( () => {
        var e = {
            77: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/rotation_axis_x_positive.svg"
            }
            ,
            493: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/empty.svg"
            }
            ,
            516: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/arrow_down.svg"
            }
            ,
            540: e => {
                "use strict";
                e.exports = function(e) {
                    var t = document.createElement("style");
                    return e.setAttributes(t, e.attributes),
                        e.insert(t, e.options),
                        t
                }
            }
            ,
            813: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/winter.svg"
            }
            ,
            853: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/icon.svg"
            }
            ,
            858: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/discord.svg"
            }
            ,
            1113: e => {
                "use strict";
                e.exports = function(e, t) {
                    if (t.styleSheet)
                        t.styleSheet.cssText = e;
                    else {
                        for (; t.firstChild; )
                            t.removeChild(t.firstChild);
                        t.appendChild(document.createTextNode(e))
                    }
                }
            }
            ,
            1312: (e, t, n) => {
                var i;
                /**
                 * [js-sha256]{@link https://github.com/emn178/js-sha256}
                 *
                 * @version 0.11.0
                 * @author Chen, Yi-Cyuan [emn178@gmail.com]
                 * @copyright Chen, Yi-Cyuan 2014-2024
                 * @license MIT
                 */
                !function() {
                    "use strict";
                    var t = "input is invalid type"
                        , r = "object" == typeof window
                        , a = r ? window : {};
                    a.JS_SHA256_NO_WINDOW && (r = !1);
                    var s = !r && "object" == typeof self
                        , o = !a.JS_SHA256_NO_NODE_JS && "object" == typeof process && process.versions && process.versions.node;
                    o ? a = n.g : s && (a = self);
                    var l = !a.JS_SHA256_NO_COMMON_JS && e.exports
                        , c = n.amdO
                        , h = !a.JS_SHA256_NO_ARRAY_BUFFER && "undefined" != typeof ArrayBuffer
                        , d = "0123456789abcdef".split("")
                        , u = [-2147483648, 8388608, 32768, 128]
                        , p = [24, 16, 8, 0]
                        , f = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]
                        , m = ["hex", "array", "digest", "arrayBuffer"]
                        , g = [];
                    !a.JS_SHA256_NO_NODE_JS && Array.isArray || (Array.isArray = function(e) {
                            return "[object Array]" === Object.prototype.toString.call(e)
                        }
                    ),
                    !h || !a.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW && ArrayBuffer.isView || (ArrayBuffer.isView = function(e) {
                            return "object" == typeof e && e.buffer && e.buffer.constructor === ArrayBuffer
                        }
                    );
                    var v = function(e, t) {
                        return function(n) {
                            return new x(t,!0).update(n)[e]()
                        }
                    }
                        , w = function(e) {
                        var t = v("hex", e);
                        o && (t = A(t, e)),
                            t.create = function() {
                                return new x(e)
                            }
                            ,
                            t.update = function(e) {
                                return t.create().update(e)
                            }
                        ;
                        for (var n = 0; n < m.length; ++n) {
                            var i = m[n];
                            t[i] = v(i, e)
                        }
                        return t
                    }
                        , A = function(e, i) {
                        var r, s = n(4394), o = n(1903).Buffer, l = i ? "sha224" : "sha256";
                        r = o.from && !a.JS_SHA256_NO_BUFFER_FROM ? o.from : function(e) {
                            return new o(e)
                        }
                        ;
                        return function(n) {
                            if ("string" == typeof n)
                                return s.createHash(l).update(n, "utf8").digest("hex");
                            if (null == n)
                                throw new Error(t);
                            return n.constructor === ArrayBuffer && (n = new Uint8Array(n)),
                                Array.isArray(n) || ArrayBuffer.isView(n) || n.constructor === o ? s.createHash(l).update(r(n)).digest("hex") : e(n)
                        }
                    }
                        , y = function(e, t) {
                        return function(n, i) {
                            return new k(n,t,!0).update(i)[e]()
                        }
                    }
                        , b = function(e) {
                        var t = y("hex", e);
                        t.create = function(t) {
                            return new k(t,e)
                        }
                            ,
                            t.update = function(e, n) {
                                return t.create(e).update(n)
                            }
                        ;
                        for (var n = 0; n < m.length; ++n) {
                            var i = m[n];
                            t[i] = y(i, e)
                        }
                        return t
                    };
                    function x(e, t) {
                        t ? (g[0] = g[16] = g[1] = g[2] = g[3] = g[4] = g[5] = g[6] = g[7] = g[8] = g[9] = g[10] = g[11] = g[12] = g[13] = g[14] = g[15] = 0,
                            this.blocks = g) : this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                            e ? (this.h0 = 3238371032,
                                this.h1 = 914150663,
                                this.h2 = 812702999,
                                this.h3 = 4144912697,
                                this.h4 = 4290775857,
                                this.h5 = 1750603025,
                                this.h6 = 1694076839,
                                this.h7 = 3204075428) : (this.h0 = 1779033703,
                                this.h1 = 3144134277,
                                this.h2 = 1013904242,
                                this.h3 = 2773480762,
                                this.h4 = 1359893119,
                                this.h5 = 2600822924,
                                this.h6 = 528734635,
                                this.h7 = 1541459225),
                            this.block = this.start = this.bytes = this.hBytes = 0,
                            this.finalized = this.hashed = !1,
                            this.first = !0,
                            this.is224 = e
                    }
                    function k(e, n, i) {
                        var r, a = typeof e;
                        if ("string" === a) {
                            var s, o = [], l = e.length, c = 0;
                            for (r = 0; r < l; ++r)
                                (s = e.charCodeAt(r)) < 128 ? o[c++] = s : s < 2048 ? (o[c++] = 192 | s >>> 6,
                                    o[c++] = 128 | 63 & s) : s < 55296 || s >= 57344 ? (o[c++] = 224 | s >>> 12,
                                    o[c++] = 128 | s >>> 6 & 63,
                                    o[c++] = 128 | 63 & s) : (s = 65536 + ((1023 & s) << 10 | 1023 & e.charCodeAt(++r)),
                                    o[c++] = 240 | s >>> 18,
                                    o[c++] = 128 | s >>> 12 & 63,
                                    o[c++] = 128 | s >>> 6 & 63,
                                    o[c++] = 128 | 63 & s);
                            e = o
                        } else {
                            if ("object" !== a)
                                throw new Error(t);
                            if (null === e)
                                throw new Error(t);
                            if (h && e.constructor === ArrayBuffer)
                                e = new Uint8Array(e);
                            else if (!(Array.isArray(e) || h && ArrayBuffer.isView(e)))
                                throw new Error(t)
                        }
                        e.length > 64 && (e = new x(n,!0).update(e).array());
                        var d = []
                            , u = [];
                        for (r = 0; r < 64; ++r) {
                            var p = e[r] || 0;
                            d[r] = 92 ^ p,
                                u[r] = 54 ^ p
                        }
                        x.call(this, n, i),
                            this.update(u),
                            this.oKeyPad = d,
                            this.inner = !0,
                            this.sharedMemory = i
                    }
                    x.prototype.update = function(e) {
                        if (!this.finalized) {
                            var n, i = typeof e;
                            if ("string" !== i) {
                                if ("object" !== i)
                                    throw new Error(t);
                                if (null === e)
                                    throw new Error(t);
                                if (h && e.constructor === ArrayBuffer)
                                    e = new Uint8Array(e);
                                else if (!(Array.isArray(e) || h && ArrayBuffer.isView(e)))
                                    throw new Error(t);
                                n = !0
                            }
                            for (var r, a, s = 0, o = e.length, l = this.blocks; s < o; ) {
                                if (this.hashed && (this.hashed = !1,
                                    l[0] = this.block,
                                    this.block = l[16] = l[1] = l[2] = l[3] = l[4] = l[5] = l[6] = l[7] = l[8] = l[9] = l[10] = l[11] = l[12] = l[13] = l[14] = l[15] = 0),
                                    n)
                                    for (a = this.start; s < o && a < 64; ++s)
                                        l[a >>> 2] |= e[s] << p[3 & a++];
                                else
                                    for (a = this.start; s < o && a < 64; ++s)
                                        (r = e.charCodeAt(s)) < 128 ? l[a >>> 2] |= r << p[3 & a++] : r < 2048 ? (l[a >>> 2] |= (192 | r >>> 6) << p[3 & a++],
                                            l[a >>> 2] |= (128 | 63 & r) << p[3 & a++]) : r < 55296 || r >= 57344 ? (l[a >>> 2] |= (224 | r >>> 12) << p[3 & a++],
                                            l[a >>> 2] |= (128 | r >>> 6 & 63) << p[3 & a++],
                                            l[a >>> 2] |= (128 | 63 & r) << p[3 & a++]) : (r = 65536 + ((1023 & r) << 10 | 1023 & e.charCodeAt(++s)),
                                            l[a >>> 2] |= (240 | r >>> 18) << p[3 & a++],
                                            l[a >>> 2] |= (128 | r >>> 12 & 63) << p[3 & a++],
                                            l[a >>> 2] |= (128 | r >>> 6 & 63) << p[3 & a++],
                                            l[a >>> 2] |= (128 | 63 & r) << p[3 & a++]);
                                this.lastByteIndex = a,
                                    this.bytes += a - this.start,
                                    a >= 64 ? (this.block = l[16],
                                        this.start = a - 64,
                                        this.hash(),
                                        this.hashed = !0) : this.start = a
                            }
                            return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 | 0,
                                this.bytes = this.bytes % 4294967296),
                                this
                        }
                    }
                        ,
                        x.prototype.finalize = function() {
                            if (!this.finalized) {
                                this.finalized = !0;
                                var e = this.blocks
                                    , t = this.lastByteIndex;
                                e[16] = this.block,
                                    e[t >>> 2] |= u[3 & t],
                                    this.block = e[16],
                                t >= 56 && (this.hashed || this.hash(),
                                    e[0] = this.block,
                                    e[16] = e[1] = e[2] = e[3] = e[4] = e[5] = e[6] = e[7] = e[8] = e[9] = e[10] = e[11] = e[12] = e[13] = e[14] = e[15] = 0),
                                    e[14] = this.hBytes << 3 | this.bytes >>> 29,
                                    e[15] = this.bytes << 3,
                                    this.hash()
                            }
                        }
                        ,
                        x.prototype.hash = function() {
                            var e, t, n, i, r, a, s, o, l, c = this.h0, h = this.h1, d = this.h2, u = this.h3, p = this.h4, m = this.h5, g = this.h6, v = this.h7, w = this.blocks;
                            for (e = 16; e < 64; ++e)
                                t = ((r = w[e - 15]) >>> 7 | r << 25) ^ (r >>> 18 | r << 14) ^ r >>> 3,
                                    n = ((r = w[e - 2]) >>> 17 | r << 15) ^ (r >>> 19 | r << 13) ^ r >>> 10,
                                    w[e] = w[e - 16] + t + w[e - 7] + n | 0;
                            for (l = h & d,
                                     e = 0; e < 64; e += 4)
                                this.first ? (this.is224 ? (a = 300032,
                                    v = (r = w[0] - 1413257819) - 150054599 | 0,
                                    u = r + 24177077 | 0) : (a = 704751109,
                                    v = (r = w[0] - 210244248) - 1521486534 | 0,
                                    u = r + 143694565 | 0),
                                    this.first = !1) : (t = (c >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10),
                                    i = (a = c & h) ^ c & d ^ l,
                                    v = u + (r = v + (n = (p >>> 6 | p << 26) ^ (p >>> 11 | p << 21) ^ (p >>> 25 | p << 7)) + (p & m ^ ~p & g) + f[e] + w[e]) | 0,
                                    u = r + (t + i) | 0),
                                    t = (u >>> 2 | u << 30) ^ (u >>> 13 | u << 19) ^ (u >>> 22 | u << 10),
                                    i = (s = u & c) ^ u & h ^ a,
                                    g = d + (r = g + (n = (v >>> 6 | v << 26) ^ (v >>> 11 | v << 21) ^ (v >>> 25 | v << 7)) + (v & p ^ ~v & m) + f[e + 1] + w[e + 1]) | 0,
                                    t = ((d = r + (t + i) | 0) >>> 2 | d << 30) ^ (d >>> 13 | d << 19) ^ (d >>> 22 | d << 10),
                                    i = (o = d & u) ^ d & c ^ s,
                                    m = h + (r = m + (n = (g >>> 6 | g << 26) ^ (g >>> 11 | g << 21) ^ (g >>> 25 | g << 7)) + (g & v ^ ~g & p) + f[e + 2] + w[e + 2]) | 0,
                                    t = ((h = r + (t + i) | 0) >>> 2 | h << 30) ^ (h >>> 13 | h << 19) ^ (h >>> 22 | h << 10),
                                    i = (l = h & d) ^ h & u ^ o,
                                    p = c + (r = p + (n = (m >>> 6 | m << 26) ^ (m >>> 11 | m << 21) ^ (m >>> 25 | m << 7)) + (m & g ^ ~m & v) + f[e + 3] + w[e + 3]) | 0,
                                    c = r + (t + i) | 0,
                                    this.chromeBugWorkAround = !0;
                            this.h0 = this.h0 + c | 0,
                                this.h1 = this.h1 + h | 0,
                                this.h2 = this.h2 + d | 0,
                                this.h3 = this.h3 + u | 0,
                                this.h4 = this.h4 + p | 0,
                                this.h5 = this.h5 + m | 0,
                                this.h6 = this.h6 + g | 0,
                                this.h7 = this.h7 + v | 0
                        }
                        ,
                        x.prototype.hex = function() {
                            this.finalize();
                            var e = this.h0
                                , t = this.h1
                                , n = this.h2
                                , i = this.h3
                                , r = this.h4
                                , a = this.h5
                                , s = this.h6
                                , o = this.h7
                                , l = d[e >>> 28 & 15] + d[e >>> 24 & 15] + d[e >>> 20 & 15] + d[e >>> 16 & 15] + d[e >>> 12 & 15] + d[e >>> 8 & 15] + d[e >>> 4 & 15] + d[15 & e] + d[t >>> 28 & 15] + d[t >>> 24 & 15] + d[t >>> 20 & 15] + d[t >>> 16 & 15] + d[t >>> 12 & 15] + d[t >>> 8 & 15] + d[t >>> 4 & 15] + d[15 & t] + d[n >>> 28 & 15] + d[n >>> 24 & 15] + d[n >>> 20 & 15] + d[n >>> 16 & 15] + d[n >>> 12 & 15] + d[n >>> 8 & 15] + d[n >>> 4 & 15] + d[15 & n] + d[i >>> 28 & 15] + d[i >>> 24 & 15] + d[i >>> 20 & 15] + d[i >>> 16 & 15] + d[i >>> 12 & 15] + d[i >>> 8 & 15] + d[i >>> 4 & 15] + d[15 & i] + d[r >>> 28 & 15] + d[r >>> 24 & 15] + d[r >>> 20 & 15] + d[r >>> 16 & 15] + d[r >>> 12 & 15] + d[r >>> 8 & 15] + d[r >>> 4 & 15] + d[15 & r] + d[a >>> 28 & 15] + d[a >>> 24 & 15] + d[a >>> 20 & 15] + d[a >>> 16 & 15] + d[a >>> 12 & 15] + d[a >>> 8 & 15] + d[a >>> 4 & 15] + d[15 & a] + d[s >>> 28 & 15] + d[s >>> 24 & 15] + d[s >>> 20 & 15] + d[s >>> 16 & 15] + d[s >>> 12 & 15] + d[s >>> 8 & 15] + d[s >>> 4 & 15] + d[15 & s];
                            return this.is224 || (l += d[o >>> 28 & 15] + d[o >>> 24 & 15] + d[o >>> 20 & 15] + d[o >>> 16 & 15] + d[o >>> 12 & 15] + d[o >>> 8 & 15] + d[o >>> 4 & 15] + d[15 & o]),
                                l
                        }
                        ,
                        x.prototype.toString = x.prototype.hex,
                        x.prototype.digest = function() {
                            this.finalize();
                            var e = this.h0
                                , t = this.h1
                                , n = this.h2
                                , i = this.h3
                                , r = this.h4
                                , a = this.h5
                                , s = this.h6
                                , o = this.h7
                                , l = [e >>> 24 & 255, e >>> 16 & 255, e >>> 8 & 255, 255 & e, t >>> 24 & 255, t >>> 16 & 255, t >>> 8 & 255, 255 & t, n >>> 24 & 255, n >>> 16 & 255, n >>> 8 & 255, 255 & n, i >>> 24 & 255, i >>> 16 & 255, i >>> 8 & 255, 255 & i, r >>> 24 & 255, r >>> 16 & 255, r >>> 8 & 255, 255 & r, a >>> 24 & 255, a >>> 16 & 255, a >>> 8 & 255, 255 & a, s >>> 24 & 255, s >>> 16 & 255, s >>> 8 & 255, 255 & s];
                            return this.is224 || l.push(o >>> 24 & 255, o >>> 16 & 255, o >>> 8 & 255, 255 & o),
                                l
                        }
                        ,
                        x.prototype.array = x.prototype.digest,
                        x.prototype.arrayBuffer = function() {
                            this.finalize();
                            var e = new ArrayBuffer(this.is224 ? 28 : 32)
                                , t = new DataView(e);
                            return t.setUint32(0, this.h0),
                                t.setUint32(4, this.h1),
                                t.setUint32(8, this.h2),
                                t.setUint32(12, this.h3),
                                t.setUint32(16, this.h4),
                                t.setUint32(20, this.h5),
                                t.setUint32(24, this.h6),
                            this.is224 || t.setUint32(28, this.h7),
                                e
                        }
                        ,
                        k.prototype = new x,
                        k.prototype.finalize = function() {
                            if (x.prototype.finalize.call(this),
                                this.inner) {
                                this.inner = !1;
                                var e = this.array();
                                x.call(this, this.is224, this.sharedMemory),
                                    this.update(this.oKeyPad),
                                    this.update(e),
                                    x.prototype.finalize.call(this)
                            }
                        }
                    ;
                    var E = w();
                    E.sha256 = E,
                        E.sha224 = w(!0),
                        E.sha256.hmac = b(),
                        E.sha224.hmac = b(!0),
                        l ? e.exports = E : (a.sha256 = E.sha256,
                            a.sha224 = E.sha224,
                        c && (void 0 === (i = function() {
                            return E
                        }
                            .call(E, n, E, e)) || (e.exports = i)))
                }()
            }
            ,
            1333: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/helmet.svg"
            }
            ,
            1465: (e, t, n) => {
                "use strict";
                n.d(t, {
                    A: () => o
                });
                var i = n(1601)
                    , r = n.n(i)
                    , a = n(6314)
                    , s = n.n(a)()(r());
                s.push([e.id, "\n.input-visualizer {\n    position: absolute;\n    left: 0;\n    bottom: 64px;\n    margin: 10px;\n    padding: 0;\n    --size: 96px;\n    width: calc(var(--size) * 3);\n    height: calc(var(--size) * 2);\n    opacity: 0.9;\n}\n\n.input-visualizer > div {\n    position: absolute;\n    margin: 0;\n    padding: 0;\n    width: var(--size);\n    height: var(--size);\n    background-color: var(--surface-color);\n}\n\n.input-visualizer > .arrow-up {\n    left: var(--size);\n    top: 0;\n}\n\n.input-visualizer > .arrow-right {\n    left: calc(var(--size) * 2);\n    top: var(--size);\n}\n\n.input-visualizer > .arrow-down {\n    left: var(--size);\n    top: var(--size);\n}\n\n.input-visualizer > .arrow-left {\n    left: 0;\n    top: var(--size);\n}\n\n.input-visualizer > div.active {\n    background-color: var(--surface-tertiary-color);\n}\n\n.input-visualizer > div > img {\n    margin: 0;\n    padding: 20px;\n    width: 100%;\n    height: 100%;\n    box-sizing: border-box;\n}\n.input-visualizer > div.active > img {\n    padding: 25px;\n}", ""]);
                const o = s
            }
            ,
            1601: e => {
                "use strict";
                e.exports = function(e) {
                    return e[1]
                }
            }
            ,
            1643: (e, t, n) => {
                "use strict";
                n.d(t, {
                    A: () => o
                });
                var i = n(1601)
                    , r = n.n(i)
                    , a = n(6314)
                    , s = n.n(a)()(r());
                s.push([e.id, '\n.settings-menu {\n\tposition: absolute;\n\tleft: calc(50% - 800px / 2);\n\ttop: 0;\n\tz-index: 2;\n\tmargin: 0;\n\tpadding: 0;\n\twidth: 800px;\n\theight: 100%;\n\ttext-align: left;\n\tdisplay: flex;\n\tflex-direction: column;\n\tbackground-color: var(--surface-color);\n}\n\n.settings-menu > h2 {\n\tmargin: 10px;\n\tpadding: 0;\n\tfont-weight: normal;\n\tfont-size: 38px;\n\ttext-align: center;\n\tcolor: var(--text-color);\n}\n\n.settings-menu > .container {\n\tmargin: 0;\n\tpadding: 0;\n\tflex-grow: 1;\n\tbackground-color: var(--surface-secondary-color);\n\toverflow-y: scroll;\n\tpointer-events: auto;\n}\n\n.settings-menu > .container > h2 {\n\tmargin: 10px;\n\tpadding: 4px;\n\tfont-weight: normal;\n\tfont-size: 24px;\n\tcolor: var(--text-color);\n\tborder-bottom: 2px solid var(--text-color);\n}\n\n.settings-menu > .container > h3 {\n\tmargin: 10px 10px 10px 15px;\n\tpadding: 4px;\n\tfont-weight: normal;\n\tfont-size: 22px;\n\tcolor: var(--text-color);\n\tborder-bottom: 2px solid var(--text-color);\n}\n\n.settings-menu > .container > .setting {\n\tmargin: 10px;\n\tdisplay: flex;\n}\n\n.settings-menu > .container > .setting > p {\n\tdisplay: inline-block;\n\tmargin: 10px;\n\tpadding: 0;\n\tmin-width: 0;\n\twhite-space: nowrap;\n\toverflow: hidden;\n\ttext-overflow: ellipsis;\n\tflex-grow: 1;\n\tfont-size: 28px;\n\ttext-align: left;\n\tcolor: var(--text-color);\n}\n\n.settings-menu > .container > .setting > .button-wrapper {\n\twhite-space: nowrap;\n}\n.settings-menu > .container > .setting.wrappable > .button-wrapper {\n\twhite-space: normal;\n}\n.settings-menu > .container > .setting.wrappable > .button-wrapper > button {\n\tmargin-bottom: 8px;\n\twidth: calc(100% / 4);\n\tfont-size: 23px;\n}\n\n.settings-menu > .container > .setting > .button-wrapper > button {\n\theight: 48px;\n\twhite-space: nowrap;\n}\n.settings-menu > .container > .setting > .button-wrapper > button.selected {\n\tbackground-color: var(--button-hover-color);\n}\n.settings-menu > .container > .setting > .button-wrapper > button.key-binding {\n\twidth: 210px;\n\tfont-size: 22px;\n\toverflow: hidden;\n\ttext-overflow: ellipsis;\n\tvertical-align: top;\n}\n\n.settings-menu > .container > .setting > input[type="range"] {\n\tmargin: 0 20px;\n\twidth: 390px;\n}\n\n.settings-menu > .button-wrapper > .button {\n\tmargin: 10px 0;\n}\n\n.settings-menu > .button-wrapper > .button:first-of-type {\n\tmargin-left: 10px;\n}\n\n.settings-menu > .button-wrapper > .button:last-of-type {\n\tmargin-right: 10px;\n}\n\n.settings-menu > .button-wrapper > .button > img {\n\tmargin-top: -3px;\n}\n\n.settings-menu > .button-wrapper > .apply {\n\tfloat: right;\n}\n', ""]);
                const o = s
            }
            ,
            1705: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/desert.svg"
            }
            ,
            1719: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/reset.svg"
            }
            ,
            1734: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/test.svg"
            }
            ,
            1758: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/desert_colored.svg"
            }
            ,
            1784: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/cancel.svg"
            }
            ,
            1903: () => {}
            ,
            1925: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/copy.svg"
            }
            ,
            1936: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/erase.svg"
            }
            ,
            1997: (e, t, n) => {
                "use strict";
                n.d(t, {
                    A: () => o
                });
                var i = n(1601)
                    , r = n.n(i)
                    , a = n(6314)
                    , s = n.n(a)()(r());
                s.push([e.id, '\n.editor-track-settings > .background {\n\tposition: absolute;\n\tleft: 0;\n\ttop: 0;\n\tz-index: 1;\n\twidth: 100%;\n\theight: 100%;\n\tbackground-color: rgba(20, 20, 30, 0.5);\n\tpointer-events: auto;\n}\n\n.editor-track-settings > .container {\n\tposition: absolute;\n\tleft: calc(50% - 600px / 2);\n\ttop: 0;\n\tz-index: 2;\n\tdisplay: flex;\n\tflex-direction: column;\n\tbox-sizing: border-box;\n\twidth: 600px;\n\theight: 100%;\n\tbackground-color: var(--surface-color);\n}\n\n.editor-track-settings > .container > h1 {\n\tmargin: 10px;\n\tpadding: 0;\n\tfont-weight: normal;\n\tfont-size: 38px;\n\ttext-align: center;\n\tcolor: var(--text-color);\n}\n\n.editor-track-settings > .container > .content {\n\tflex-grow: 1;\n\tbackground-color: var(--surface-secondary-color);\n\toverflow-y: auto;\n\tpointer-events: auto;\n}\n\n.editor-track-settings > .container > .content > .setting {\n\tmargin: 20px;\n\tpadding: 20px;\n\tbackground-color: var(--surface-color);\n\toutline: 2px solid transparent;\n\ttransition: outline 0.25s ease-in-out;\n}\n\n.editor-track-settings > .container > .content > .setting.error {\n\toutline: 2px solid #e34c4c;\n}\n\n.editor-track-settings > .container > .content > .setting > .title {\n\tdisplay: block;\n\tmargin: 0;\n\tpadding: 0;\n\tfont-size: 30px;\n\tcolor: var(--text-color);\n}\n.editor-track-settings > .container > .content > .setting > input[type="text"] {\n\twidth: calc(100% - 20px);\n\tfont-weight: normal;\n\tfont-size: 30px;\n}\n\n.editor-track-settings > .container > .content > .setting > .environment-button {\n\tdisplay: inline-block;\n\tmargin: 10px 0;\n\tpadding: 10px;\n\twidth: calc(100% / 3);\n\tcolor: var(--text-color);\n\tfont-size: 27px;\n}\n.editor-track-settings > .container > .content > .setting > .environment-button.selected {\n\tbackground-color: var(--button-hover-color);\n}\n.editor-track-settings > .container > .content > .setting > .environment-button > img {\n\tmargin: 0;\n\tpadding: 10px 30px;\n\twidth: 100%;\n\tbox-sizing: border-box;\n\tpointer-events: none;\n}\n\n.editor-track-settings > .container > .content > .setting > input[type="range"] {\n\tmargin: 0;\n\tpadding: 0;\n\twidth: 100%;\n\theight: 64px;\n\t-webkit-appearance: none;\n\tappearance: none;\n\tbackground: transparent;\n\tcursor: pointer;\n\taccent-color: var(--text-color);\n}\n.editor-track-settings > .container > .content > .setting > input[type="range"]::-webkit-slider-runnable-track {\n\tbackground-color: var(--surface-tertiary-color);\n\theight: 10px;\n}\n.editor-track-settings > .container > .content > .setting > input[type="range"]::-moz-range-track {\n\tbackground-color: var(--surface-tertiary-color);\n\theight: 10px;\n}\n.editor-track-settings > .container > .content > .setting > input[type="range"]::-webkit-slider-thumb {\n\t-webkit-appearance: none;\n\tappearance: none;\n\tborder-radius: 0;\n\tbackground: var(--text-color);\n\twidth: 32px;\n\theight: 32px;\n\tmargin: -13px 0 0 0;\n\tborder: 4px solid var(--button-color);\n\toutline: 2px solid var(--text-color);\n}\n.editor-track-settings > .container > .content > .setting > input[type="range"]::-webkit-slider-thumb:hover {\n\tborder: 4px solid var(--button-hover-color);\n}\n@media (hover: none) {\n\t.editor-track-settings > .container > .content > .setting > input[type="range"]::-webkit-slider-thumb:hover {\n\t\tborder: 4px solid var(--button-color);\n\t}\n}\n.editor-track-settings > .container > .content > .setting > input[type="range"]::-webkit-slider-thumb:active {\n\tborder: 4px solid var(--button-active-color);\n}\n.editor-track-settings > .container > .content > .setting > input[type="range"]::-moz-range-thumb {\n\t-webkit-appearance: none;\n\tappearance: none;\n\tborder-radius: 0;\n\tbackground: var(--text-color);\n\twidth: 24px;\n\theight: 24px;\n\tborder: 4px solid var(--button-color);\n\toutline: 2px solid var(--text-color);\n}\n.editor-track-settings > .container > .content > .setting > input[type="range"]::-moz-range-thumb:hover {\n\tborder: 4px solid var(--button-hover-color);\n}\n@media (hover: none) {\n\t.editor-track-settings > .container > .content > .setting > input[type="range"]::-moz-range-thumb:hover {\n\t\tborder: 4px solid var(--button-color);\n\t}\n}\n.editor-track-settings > .container > .content > .setting > input[type="range"]::-moz-range-thumb:active {\n\tborder: 4px solid var(--button-active-color);\n}\n\n\n.editor-track-settings > .container > .button-wrapper > button {\n\tmargin: 10px;\n}\n\n.editor-track-settings > .container > .button-wrapper > button:not(:first-child) {\n\tfloat: right;\n}\n', ""]);
                const o = s
            }
            ,
            2175: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/random.svg"
            }
            ,
            2207: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/arrow_up.svg"
            }
            ,
            2208: (e, t, n) => {
                "use strict";
                e.exports = n.p + "2e5b7bff10d7782e539c.woff"
            }
            ,
            2319: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/delete.svg"
            }
            ,
            2344: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/car_stripe.svg"
            }
            ,
            2346: (e, t, n) => {
                "use strict";
                n.d(t, {
                    A: () => o
                });
                var i = n(1601)
                    , r = n.n(i)
                    , a = n(6314)
                    , s = n.n(a)()(r());
                s.push([e.id, "\n.editor-side-toolbar {\n\tdisplay: flex;\n\tflex-direction: column;\n\tposition: absolute;\n\tbottom: 40px;\n\tleft: 0;\n}\n.editor-side-toolbar.touch {\n\tbottom: 176px;\n}\n\n.editor-side-toolbar > .accordion {\n\tdisplay: flex;\n\tflex-direction: row;\n\twidth: 100px;\n\toverflow: hidden; /* Use hidden if clip is not supported */\n\toverflow: clip;\n\ttransition: width 0.25s ease-out;\n}\n.editor-side-toolbar.touch > .accordion {\n\twidth: 120px;\n}\n.editor-side-toolbar > .accordion.open {\n\twidth: auto;\n}\n\n.editor-side-toolbar button {\n\tposition: relative;\n\tflex-shrink: 0;\n\tmargin: 0;\n\tpadding: 0;\n\twidth: 100px;\n\theight: 100px;\n\tbackground-color: rgba(17, 32, 82, 0.48);\n\tborder: none;\n\tpointer-events: auto;\n\tcursor: pointer;\n\ttransition: background-color 0.25s ease-out;\n}\n.editor-side-toolbar button:hover {\n\tbackground-color: rgba(37, 54, 105, 0.48);\n}\n.editor-side-toolbar > .accordion > button:not(:first-of-type) {\n\tbackground-color: rgba(17, 32, 82, 0.35);\n}\n.editor-side-toolbar > .accordion > button:not(:first-of-type):hover {\n\tbackground-color: rgba(37, 54, 105, 0.35);\n}\n.editor-side-toolbar > .accordion > button:not(:first-of-type).selected {\n\tbackground-color: rgba(17, 32, 82, 0.55);\n}\n.editor-side-toolbar > .accordion > button:not(:first-of-type):active {\n\tbackground-color: rgba(17, 32, 82, 0.6);\n}\n@media (hover: none) {\n\t.editor-side-toolbar button:hover {\n\t\tbackground-color: rgba(17, 32, 82, 0.48);\n\t}\n}\n.editor-side-toolbar button:active {\n\tbackground-color: rgba(17, 32, 82, 0.6);\n\ttransition: none;\n}\n\n.editor-side-toolbar.touch button {\n\twidth: 120px;\n\theight: 120px;\n}\n\n.editor-side-toolbar button img {\n\tmargin: 0;\n\tpadding: 20%;\n\tvertical-align: top;\n\twidth: 100%;\n    height: 100%;\n\tbox-sizing: border-box;\n\tpointer-events: none;\n\ttransition: transform 0.25s ease-out;\n\tfilter: drop-shadow(2px 2px 2px rgba(0, 0, 0, 0.5));\n}\n.editor-side-toolbar button:active img {\n\ttransition: none;\n\ttransform: scale(0.9);\n}\n\n.editor-side-toolbar button.rotate > span {\n\tdisplay: flex;\n\tjustify-content: center;\n\talign-items: center;\n\tposition: absolute;\n\ttop: 0;\n\tleft: 1px;\n\twidth: 100%;\n\theight: 100%;\n\tcolor: var(--text-color);\n\tfont-size: 16px;\n\ttext-shadow: 0 0 2px #000;\n\tpointer-events: none;\n\ttransition: transform 0.25s ease-out;\n}\n.editor-side-toolbar button.rotate:active > span {\n\ttransition: none;\n\ttransform: scale(0.9);\n}\n", ""]);
                const o = s
            }
            ,
            2493: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/overlapping_enabled.svg"
            }
            ,
            2553: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/state_invalid.svg"
            }
            ,
            2709: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/custom_tracks.jpg"
            }
            ,
            2796: (e, t, n) => {
                "use strict";
                n.d(t, {
                    A: () => o
                });
                var i = n(1601)
                    , r = n.n(i)
                    , a = n(6314)
                    , s = n.n(a)()(r());
                s.push([e.id, '\n.verifier-ui {\n\tposition: absolute;\n\tleft: 0;\n\ttop: 0;\n\tz-index: 2;\n\tmargin: 0;\n\tpadding: 16px;\n\twidth: 100%;\n\theight: 100%;\n\toverflow-y: scroll;\n\tbox-sizing: border-box;\n\tbackground-color: var(--surface-color);\n\tpointer-events: auto;\n}\n\n.verifier-ui > p {\n\tmargin: 16px 4px 0 4px;\n\tpadding: 0;\n\tfont-size: 20px;\n\tcolor: var(--text-color);\n\twhite-space: pre-wrap;\n}\n\n.verifier-ui > input[type="range"] {\n\tmargin: 16px 0;\n\twidth: 390px;\n}\n\n.verifier-ui > table {\n\tmargin: 0;\n\tpadding: 0;\n\twidth: 100%;\n\tborder-collapse: collapse;\n\ttable-layout: fixed;\n\tcolor: var(--text-color);\n}\n\n.verifier-ui > table > thead > tr > th {\n\ttext-align: left;\n\tborder-bottom: 2px solid var(--text-color);\n}\n\n.verifier-ui > table > thead > tr > th, .verifier-ui > table > tbody > tr > td {\n\tpadding: 8px 0;\n\toverflow: hidden;\n\ttext-overflow: ellipsis;\n\twhite-space: nowrap;\n}\n\n.verifier-ui > button {\n\tdisplay: inline-block;\n\tmargin: 16px 0 0 0;\n}\n', ""]);
                const o = s
            }
            ,
            2817: (e, t, n) => {
                "use strict";
                n.d(t, {
                    A: () => o
                });
                var i = n(1601)
                    , r = n.n(i)
                    , a = n(6314)
                    , s = n.n(a)()(r());
                s.push([e.id, "\n.time-announcer {\n\tposition: absolute;\n\tleft: 0;\n\ttop: 35%;\n\twidth: 100%;\n\toverflow: hidden;\n}\n\n.time-announcer > .record {\n\tmargin: 0;\n\tpadding: 0;\n\tfont-size: 48px;\n\ttext-shadow: 0 0 5px #000;\n\tcolor: #5f5;\n\ttext-align: center;\n\topacity: 0;\n\tanimation: 0.3s ease-out 0.8s 1 normal forwards running time-announcer-record-animation;\n}\n\n.time-announcer > .track-name {\n\tmargin: 0 0 10px 0;\n\tpadding: 4px 20px;\n\tbox-sizing: border-box;\n\twidth: 100%;\n\tbackground-color: var(--surface-secondary-color);\n\tfont-size: 60px;\n\tcolor: var(--text-color);\n\ttext-align: center;\n\toverflow: hidden;\n\ttext-overflow: ellipsis;\n\tanimation: 0.3s ease-out 0s 1 normal forwards running time-announcer-animation;\n}\n\n.time-announcer > .current {\n\tmargin: 0;\n\tpadding: 0;\n\twidth: 0;\n\tbackground-color: var(--surface-color);\n\tfont-size: 48px;\n\tcolor: var(--text-color);\n\ttext-align: center;\n\tanimation: 0.5s ease-out 0s 1 normal forwards running time-announcer-animation;\n}\n.time-announcer > .difference > p {\n\tmargin: 0 0 0 auto;\n\tpadding: 0;\n\twidth: 0;\n\tbackground-color: var(--surface-secondary-color);\n\tcolor: #5f5;\n\tfont-size: 30px;\n\ttext-align: center;\n\tanimation: 0.4s ease-out 0.5s 1 normal forwards running time-announcer-animation;\n}\n.time-announcer > .difference.red > p {\n\tcolor: #f55;\n}\n.time-announcer > .difference > p.title {\n\tmargin-top: 30px;\n\tbackground-color: transparent;\n\ttext-shadow: 0 0 3px #000;\n}\n\n@keyframes time-announcer-record-animation {\n\tfrom {\n\t\topacity: 0;\n\t\ttransform: translateY(10px);\n\t}\n\n\tto {\n\t\topacity: 1;\n\t}\n}\n\n@keyframes time-announcer-animation {\n\tfrom {\n\t\twidth: 0;\n\t\topacity: 0;\n\t}\n\n\tto {\n\t\twidth: 100%;\n\t\topacity: 1;\n\t}\n}\n", ""]);
                const o = s
            }
            ,
            2832: (e, t, n) => {
                "use strict";
                e.exports = n.p + "4e75ed8189c5a7b6fbf8.ttf"
            }
            ,
            2915: (e, t, n) => {
                "use strict";
                n.d(t, {
                    A: () => o
                });
                var i = n(1601)
                    , r = n.n(i)
                    , a = n(6314)
                    , s = n.n(a)()(r());
                s.push([e.id, "\n.menu {\n\tdisplay: flex;\n\tflex-direction: column;\n\tposition: absolute;\n\tleft: 0;\n\ttop: 0;\n\twidth: 100%;\n\theight: 100%;\n\tbackground-color: rgba(10, 10, 20, 0.8);\n\ttext-align: center;\n\ttransition: background-color 1s ease-out;\n}\n.menu.loading-screen {\n\tbackground-color: var(--surface-tertiary-color);\n}\n\n.menu > .logo {\n\tdisplay: block;\n\tmargin: 80px auto 0 auto;\n\tpadding: 0;\n\twidth: 1000px;\n\theight: 200px;\n\t-webkit-filter: drop-shadow(0 0 3px #000);\n\tfilter: drop-shadow(0 0 3px #000);\n}\n\n@media (max-width: 1300px) {\n\t.menu > .logo {\n\t\twidth: calc(100vw * (1000 / 1300));\n\t}\n}\n@media (max-width: 975px) {\n\t.menu > .logo {\n\t\twidth: calc(975px * (1000 / 1300));\n\t}\n}\n\n.menu > .warning-message {\n\tmargin: 16px auto 0 auto;\n\tmax-width: 900px;\n\tfont-size: 26px;\n\tcolor: #f66;\n}\n.menu > .warning-message > a {\n\tmargin: 0 auto;\n\tdisplay: block;\n\twidth: max-content;\n\tcolor: var(--text-color);\n\tpointer-events: auto;\n}\n\n.menu > .main-buttons-container {\n\tmargin: 0 0 140px 0;\n\tdisplay: flex;\n\tflex-grow: 1;\n\talign-items: center;\n\tjustify-content: center;\n}\n.menu > .main-buttons-container.hidden {\n\tdisplay: none;\n}\n\n.menu .button-image {\n\tdisplay: inline-block;\n\tmargin: 10px 0;\n\tpadding: 0;\n\twidth: 200px;\n\theight: 200px;\n\tpointer-events: auto;\n}\n.menu .button-image > img {\n\tmargin: 40px 40px 0 40px;\n\tpadding: 0;\n\twidth: 96px;\n\theight: 96px;\n\ttransition: transform 0.2s ease-in-out;\n\tpointer-events: none;\n}\n.menu .button-image:not(:disabled):hover > img {\n\ttransform: translateY(-10px);\n}\n@media (hover: none) {\n\t.menu .button-image:not(:disabled):hover > img {\n\t\ttransform: none;\n\t}\n}\n.menu .button-image > p {\n\tmargin: 0;\n\tpadding: 0;\n\tcolor: var(--text-color);\n\tfont-size: 27px;\n}\n\n.menu .button-image.button-spawn {\n\tanimation: button-spawn 0.5s ease-out forwards;\n\topacity: 0;\n}\n\n@keyframes button-spawn {\n\t0% {\n\t\ttransform: translateY(50px) scale(0.8);\n\t\topacity: 0;\n\t}\n\t70% {\n\t\ttransform: translateY(-10px) scale(1);\n\t\topacity: 1;\n\t}\n\t100% {\n\t\ttransform: translateY(0) scale(1);\n\t\topacity: 1;\n\t}\n}\n\n.menu > .bottom-buttons {\n\tmargin: 4px;\n\tpadding: 0;\n\tposition: absolute;\n\tleft: 0;\n\tbottom: 0;\n}\n\n.menu > .bottom-buttons > .small {\n\tpadding: 6px 12px;\n\tclip-path: polygon(4px 0, 100% 0, calc(100% - 4px) 100%, 0 100%);\n\tfont-size: 22px;\n}\n.menu > .bottom-buttons > .small > img {\n\tvertical-align: middle;\n\twidth: 24px;\n\theight: 24px;\n}\n\n.menu > .discord-link {\n\tdisplay: block;\n\tposition: absolute;\n\tright: 0;\n\tbottom: 0;\n\tmargin: 0;\n\tpadding: 0;\n\tpointer-events: auto;\n}\n.menu > .discord-link > img {\n\tmargin: 8px 16px;\n\tpadding: 0;\n\theight: 40px;\n}\n\n.menu > .info {\n\tposition: absolute;\n\tleft: 0;\n\tbottom: 0;\n\twidth: 100%;\n}\n.menu > .info > a {\n\tdisplay: block;\n\tmargin: 0 auto;\n\tpadding: 5px;\n\twidth: fit-content;\n\tcolor: var(--text-color);\n\ttext-decoration: none;\n\tfont-size: 20px;\n\tpointer-events: auto;\n}\n.menu > .info > a[href]:hover, .menu > .info > a[href]:focus-visible {\n\ttext-decoration: underline;\n\toutline: none;\n}\n", ""]);
                const o = s
            }
            ,
            2927: (e, t, n) => {
                "use strict";
                n.d(t, {
                    A: () => o
                });
                var i = n(1601)
                    , r = n.n(i)
                    , a = n(6314)
                    , s = n.n(a)()(r());
                s.push([e.id, "\n.loading-ui {\n\tmargin: 200px 0 0 0;\n\tpadding: 0;\n}\n.loading-ui.fade-out {\n\topacity: 0;\n\ttransition: opacity 0.25s ease-out;\n}\n\n.loading-ui > p {\n\tmargin: 5px;\n\tpadding: 0;\n\tcolor: var(--text-color);\n\tfont-size: 32px;\n}\n\n.loading-ui > div {\n\tmargin: 0 auto;\n\tpadding: 0;\n\twidth: 600px;\n\theight: 50px;\n\tbackground-color: var(--surface-color);\n\tclip-path: polygon(9px 0, 100% 0, calc(100% - 9px) 100%, 0 100%);\n\toverflow: hidden;\n}\n\n.loading-ui > div > div {\n\tmargin: 15px 20px;\n\tpadding: 0;\n\twidth: 560px;\n\theight: 20px;\n\tclip-path: polygon(3px 0, 100% 0, calc(100% - 3px) 100%, 0 100%);\n\tbackground-color: #224;\n\tbox-shadow: inset 0 0 6px #000;\n}\n\n.loading-ui > div > div > div {\n\tmargin: 0;\n\tpadding: 0;\n\twidth: 0;\n\theight: 100%;\n\tclip-path: polygon(2px 0, 100% 0, calc(100% - 2px) 100%, 0 100%);\n\tbackground-color: #fff;\n\tbox-shadow: inset 0 0 6px #000;\n\ttransition: width 0.1s ease-in-out;\n}\n", ""]);
                const o = s
            }
            ,
            3223: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/pending.svg"
            }
            ,
            3518: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/grid_large.svg"
            }
            ,
            3571: (e, t, n) => {
                "use strict";
                n.d(t, {
                    A: () => o
                });
                var i = n(1601)
                    , r = n.n(i)
                    , a = n(6314)
                    , s = n.n(a)()(r());
                s.push([e.id, "\n.touch-controls {\n\tpointer-events: none;\n}\n\n.touch-controls > button {\n\tposition: absolute;\n\ttop: calc(1.5cm + 50px);\n\tmargin: 10px;\n\tpadding: 0;\n\twidth: 160px;\n\theight: 160px;\n\tbackground-color: var(--button-color);\n\tborder: none;\n\topacity: 0.6;\n\tpointer-events: auto;\n\ttouch-action: none;\n}\n.touch-controls > button  > img {\n\tmargin: 0;\n\tpadding: 30px;\n\tvertical-align: top;\n\twidth: 100%;\n    height: 100%;\n\tbox-sizing: border-box;\n\tpointer-events: none;\n\ttransition: padding 0.25s ease-out;\n}\n.touch-controls > button.active > img {\n    padding: 40px;\n}\n\n.touch-controls > .reset {\n\tright: 1.5cm;\n}\n\n.touch-controls > .left-container {\n\tposition: absolute;\n\tleft: 1.5cm;\n\tbottom: 1.5cm;\n}\n\n.touch-controls > .right-container {\n\tposition: absolute;\n\tright: 1.5cm;\n\tbottom: 1.5cm;\n}\n.touch-controls > .right-container > div {\n\tdisplay: inline-block;\n}\n\n.touch-controls > div > div {\n\tmargin: 10px;\n\tpadding: 0;\n\twidth: 160px;\n\theight: 160px;\n\tbackground-color: var(--button-color);\n\topacity: 0.5;\n\tpointer-events: auto;\n\ttouch-action: none;\n}\n.touch-controls > div > div.active {\n\tbackground-color: var(--button-active-color);\n\topacity: 0.6;\n}\n\n.touch-controls > div > div > img {\n\tmargin: 0;\n\tpadding: 40px;\n\tvertical-align: top;\n\twidth: 100%;\n    height: 100%;\n\tbox-sizing: border-box;\n\tpointer-events: none;\n}\n.touch-controls > div > div.active > img {\n    padding: 50px;\n}\n", ""]);
                const o = s
            }
            ,
            3682: (e, t, n) => {
                "use strict";
                e.exports = n.p + "a82f15d48dbc61b6edeb.woff2"
            }
            ,
            3755: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/share.svg"
            }
            ,
            3895: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/rotation_axis_z_negative.svg"
            }
            ,
            3901: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/summer.svg"
            }
            ,
            3902: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/verified.svg"
            }
            ,
            4239: (e, t, n) => {
                "use strict";
                n.d(t, {
                    A: () => o
                });
                var i = n(1601)
                    , r = n.n(i)
                    , a = n(6314)
                    , s = n.n(a)()(r());
                s.push([e.id, ".ghost-loading-ui {\n\tposition: absolute;\n\tright: 0;\n\ttop: 0;\n\tmargin: 4px;\n\tcolor: var(--text-color);\n\tfont-size: 22px;\n\tfont-weight: normal;\n\ttext-shadow: 1px 1px 1px var(--surface-color), -1px 1px 1px var(--surface-color), -1px -1px 1px var(--surface-color), 1px -1px 1px var(--surface-color);\n\ttransition: opacity 0.25s ease-in-out;\n}\n.ghost-loading-ui.hide {\n\topacity: 0;\n\ttransform: translateX(20px);\n\ttransition: opacity 0.25s ease-in-out 0.5s, transform 0.25s ease-in-out 0.5s;\n}\n.ghost-loading-ui.down {\n\ttop: initial;\n\tbottom: 0;\n}\n\n.ghost-loading-ui > .percentage {\n\tdisplay: inline-block;\n\twidth: 60px;\n\ttext-align: center;\n}\n", ""]);
                const o = s
            }
            ,
            4309: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/save.svg"
            }
            ,
            4344: (e, t, n) => {
                "use strict";
                n.d(t, {
                    A: () => o
                });
                var i = n(1601)
                    , r = n.n(i)
                    , a = n(6314)
                    , s = n.n(a)()(r());
                s.push([e.id, "\n.debug {\n\tmargin: 0.25em;\n\tpadding: 0;\n\tposition: absolute;\n\tleft: 0;\n\tbottom: 0;\n\tfont-size: 28px;\n\ttext-shadow: 0 0 5px #000;\n\tcolor: #fff;\n\tz-index: 10;\n}\n", ""]);
                const o = s
            }
            ,
            4394: () => {}
            ,
            4411: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/rotation_axis_z_positive.svg"
            }
            ,
            4417: e => {
                "use strict";
                e.exports = function(e, t) {
                    return t || (t = {}),
                        e ? (e = String(e.__esModule ? e.default : e),
                        /^['"].*['"]$/.test(e) && (e = e.slice(1, -1)),
                        t.hash && (e += t.hash),
                            /["'() \t\n]|(%20)/.test(e) || t.needQuotes ? '"'.concat(e.replace(/"/g, '\\"').replace(/\n/g, "\\n"), '"') : e) : e
                }
            }
            ,
            4538: (e, t, n) => {
                "use strict";
                n.d(t, {
                    A: () => o
                });
                var i = n(1601)
                    , r = n.n(i)
                    , a = n(6314)
                    , s = n.n(a)()(r());
                s.push([e.id, "\n.pause-screen {\n\tposition: fixed;\n\ttop: 0;\n\tleft: 0;\n\twidth: 100%;\n\theight: 100%;\n\tbackground-color: rgba(0, 0, 0, 0.75);\n\tanimation: fade-in 0.25s forwards;\n}\n.pause-screen.fade-out {\n\topacity: 0;\n\ttransition: opacity 0.25s;\n}\n\n@keyframes fade-in {\n\tfrom {\n\t\tbackground-color: rgba(0, 0, 0, 0);\n\t}\n\tto {\n\t\tbackground-color: rgba(0, 0, 0, 0.75);\n\t}\n}\n\n\n.pause-screen > .title {\n\tposition: absolute;\n\ttop: 40%;\n\tleft: 50%;\n\ttransform: translate(-50%, -50%);\n\tfont-size: 100px;\n\tcolor: var(--text-color);\n\tanimation: slide-fade-in 0.5s 0.3s forwards;\n\topacity: 0;\n}\n\n@keyframes slide-fade-in {\n\tfrom {\n\t\ttransform: translate(-60%, -50%);\n\t\topacity: 0;\n\t}\n\tto {\n\t\ttransform: translate(-50%, -50%);\n\t\topacity: 1;\n\t}\n}\n", ""]);
                const o = s
            }
            ,
            4543: (e, t, n) => {
                "use strict";
                n.d(t, {
                    A: () => o
                });
                var i = n(1601)
                    , r = n.n(i)
                    , a = n(6314)
                    , s = n.n(a)()(r());
                s.push([e.id, "\n.time-bar {\n\tdisplay: flex;\n\tmargin: 0;\n\tpadding: 0;\n\twidth: 100%;\n\tbackground-color: var(--surface-color);\n}\n\n.time-bar > button {\n\tmargin: 6px;\n\tpadding: 4px 12px;\n}\n.time-bar > button > img {\n\tmargin: 0 0 2px 0;\n\tpadding: 0;\n\tvertical-align: middle;\n\twidth: 28px;\n\theight: 28px;\n\tpointer-events: none;\n}\n\n.time-bar > .bar {\n\tposition: relative;\n\tmargin: 6px 6px 6px -8px;\n\tpadding: 0;\n\tflex-grow: 1;\n\theight: 40px;\n\tbackground-color: var(--surface-secondary-color);\n\tclip-path: polygon(8px 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\n\ttouch-action: none;\n\tpointer-events: auto;\n}\n.time-bar > .bar > div {\n\tposition: relative;\n\twidth: calc(100% - 8px);\n\theight: 100%;\n}\n.time-bar > .bar > div > .unloaded-fill {\n\tposition: absolute;\n\tright: -8px;\n\ttop: 0;\n\tmargin: 0;\n\tpadding: 0;\n\theight: 100%;\n\tbackground-color: rgba(255, 255, 255, 0.1);\n\tclip-path: polygon(8px 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\n\twill-change: width;\n}\n.time-bar > .bar > div > .fill {\n\tposition: absolute;\n\tleft: 0;\n\ttop: 0;\n\tmargin: 0;\n\tpadding: 0;\n\theight: 100%;\n\tbackground-color: #7272c2;\n\tclip-path: polygon(8px 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\n\twill-change: width;\n}\n.time-bar > .bar > div > .dash-container {\n\tpointer-events: none;\n}\n.time-bar > .bar > div > .dash-container > .dash {\n\tposition: absolute;\n\tz-index: 1;\n\tbottom: 0;\n\tmargin: 0;\n\tpadding: 0;\n\twidth: 2px;\n\theight: 25%;\n\tbackground-color: rgba(0,0,0,0.25);\n}\n.time-bar > .bar > div > .dash-container > .dash.long {\n\theight: 50%;\n\tbackground-color: rgba(0,0,0,0.35);\n}\n", ""]);
                const o = s
            }
            ,
            4563: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/rotate.svg"
            }
            ,
            4593: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/reset_settings.svg"
            }
            ,
            4804: (e, t, n) => {
                "use strict";
                n.d(t, {
                    A: () => o
                });
                var i = n(1601)
                    , r = n.n(i)
                    , a = n(6314)
                    , s = n.n(a)()(r());
                s.push([e.id, "\n.game-toolbar {\n\tposition: absolute;\n\tleft: 0;\n\tbottom: 0;\n\tz-index: 1;\n\tpadding: 8px 10px 8px 8px;\n\tbackground-color: var(--surface-color);\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\n\topacity: 0;\n\ttransform: translateX(-10px);\n\ttransition: opacity ease-in-out 0.2s, transform ease-in-out 0.2s;\n\tpointer-events: none;\n}\n\n.game-toolbar.up {\n\tposition: absolute;\n\tbottom: auto;\n\ttop: 0;\n}\n\n.game-toolbar.touch > .button {\n\tfont-size: 24px;\n}\n.game-toolbar.touch > .button > img {\n\twidth: 24px;\n\theight: 24px;\n}\n\n.game-toolbar.visible {\n\topacity: 1;\n\ttransform: translateX(0);\n\ttransition: opacity 0.2s ease-in-out 0.5s, transform 0.2s ease-in-out 0.5s;\n\tpointer-events: auto;\n}\n", ""]);
                const o = s
            }
            ,
            4930: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/grid_small.svg"
            }
            ,
            5001: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/rotation_axis_x_negative.svg"
            }
            ,
            5007: (e, t, n) => {
                "use strict";
                n.d(t, {
                    A: () => o
                });
                var i = n(1601)
                    , r = n.n(i)
                    , a = n(6314)
                    , s = n.n(a)()(r());
                s.push([e.id, "\n.editor-height-selector {\n\tposition: absolute;\n\tleft: 0;\n\tbottom: 0;\n}\n\n.editor-height-selector > .buttons {\n\tdisplay: inline-block;\n\tvertical-align: bottom;\n}\n.editor-height-selector > .buttons > button {\n\tdisplay: block;\n\tmargin: 0;\n\tpadding: 0;\n\tborder: none;\n\tbackground-color: var(--button-color);\n\tpointer-events: auto;\n\tcursor: pointer;\n}\n.editor-height-selector > .buttons > button:hover {\n\tbackground-color: var(--button-hover-color);\n}\n@media (hover: none) {\n\t.editor-height-selector > .buttons > button:hover {\n\t\tbackground-color: var(--button-color);\n\t}\n}\n.editor-height-selector > .buttons > button:active {\n\tbackground-color: var(--button-active-color);\n}\n\n.editor-height-selector > .buttons > button > img { \n\tmargin: 0;\n\tpadding: 0 6px;\n\twidth: 20px;\n\theight: 20px;\n\tvertical-align: bottom;\n\tpointer-events: none;\n}\n.editor-height-selector.touch > .buttons > button > img {\n\tpadding: 24px;\n\twidth: 40px;\n\theight: 40px;\n}\n\n.editor-height-selector > p {\n\tmargin: 0;\n\tpadding: 0 10px;\n\tdisplay: inline-block;\n\tvertical-align: bottom;\n\tline-height: 40px;\n\tmin-width: 140px;\n\tfont-size: 26px;\n\ttext-align: center;\n\tbackground-color: var(--surface-transparent-color);\n\tcolor: var(--text-color);\n}\n.editor-height-selector.touch > p {\n\tline-height: calc((40px + 2 * 24px) * 2);\n}\n", ""]);
                const o = s
            }
            ,
            5010: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/winter_colored.svg"
            }
            ,
            5031: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/help.svg"
            }
            ,
            5056: (e, t, n) => {
                "use strict";
                e.exports = function(e) {
                    var t = n.nc;
                    t && e.setAttribute("nonce", t)
                }
            }
            ,
            5072: e => {
                "use strict";
                var t = [];
                function n(e) {
                    for (var n = -1, i = 0; i < t.length; i++)
                        if (t[i].identifier === e) {
                            n = i;
                            break
                        }
                    return n
                }
                function i(e, i) {
                    for (var a = {}, s = [], o = 0; o < e.length; o++) {
                        var l = e[o]
                            , c = i.base ? l[0] + i.base : l[0]
                            , h = a[c] || 0
                            , d = "".concat(c, " ").concat(h);
                        a[c] = h + 1;
                        var u = n(d)
                            , p = {
                            css: l[1],
                            media: l[2],
                            sourceMap: l[3],
                            supports: l[4],
                            layer: l[5]
                        };
                        if (-1 !== u)
                            t[u].references++,
                                t[u].updater(p);
                        else {
                            var f = r(p, i);
                            i.byIndex = o,
                                t.splice(o, 0, {
                                    identifier: d,
                                    updater: f,
                                    references: 1
                                })
                        }
                        s.push(d)
                    }
                    return s
                }
                function r(e, t) {
                    var n = t.domAPI(t);
                    n.update(e);
                    return function(t) {
                        if (t) {
                            if (t.css === e.css && t.media === e.media && t.sourceMap === e.sourceMap && t.supports === e.supports && t.layer === e.layer)
                                return;
                            n.update(e = t)
                        } else
                            n.remove()
                    }
                }
                e.exports = function(e, r) {
                    var a = i(e = e || [], r = r || {});
                    return function(e) {
                        e = e || [];
                        for (var s = 0; s < a.length; s++) {
                            var o = n(a[s]);
                            t[o].references--
                        }
                        for (var l = i(e, r), c = 0; c < a.length; c++) {
                            var h = n(a[c]);
                            0 === t[h].references && (t[h].updater(),
                                t.splice(h, 1))
                        }
                        a = l
                    }
                }
            }
            ,
            5086: (e, t, n) => {
                "use strict";
                n.d(t, {
                    A: () => o
                });
                var i = n(1601)
                    , r = n.n(i)
                    , a = n(6314)
                    , s = n.n(a)()(r());
                s.push([e.id, "\n.loading-spinner {\n\twidth: 40px;\n\theight: 40px;\n\tborder-radius: 50%;\n\tborder: 5px solid var(--surface-tertiary-color);\n\tborder-left-color: var(--text-color);\n\n\tanimation: 1s linear infinite forwards loading-spinner-spin;\n}\n\n@keyframes loading-spinner-spin {\n\tfrom {\n\t\ttransform: rotate(0);\n\t}\n\tto {\n\t\ttransform: rotate(360deg);\n\t}\n}\n", ""]);
                const o = s
            }
            ,
            5140: (e, t, n) => {
                "use strict";
                n.d(t, {
                    A: () => o
                });
                var i = n(1601)
                    , r = n.n(i)
                    , a = n(6314)
                    , s = n.n(a)()(r());
                s.push([e.id, "\n.profile-selection {\n\tposition: absolute;\n\tleft: calc(50% - 500px / 2);\n\ttop: 40%;\n\tz-index: 2;\n\tmargin: 0;\n\tpadding: 0;\n\twidth: 500px;\n\tbox-sizing: border-box;\n\tbackground-color: var(--surface-secondary-color);\n}\n\n.profile-selection > .top-bar {\n\tmargin: 0;\n\tpadding: 10px;\n\tbackground-color: var(--surface-color);\n}\n\n.profile-selection > .top-bar > h2 {\n\tmargin: 0;\n\tpadding: 0;\n\tfont-weight: normal;\n\tfont-size: 38px;\n\ttext-align: center;\n\tcolor: var(--text-color);\n}\n\n.profile-selection > .slot {\n\tposition: relative;\n\tmargin: 10px 10px 0 10px;\n\tpadding: 0;\n}\n\n.profile-selection > .slot > button.main {\n\tmargin: 0;\n\tpadding: 0;\n\tvertical-align: top;\n\twidth: 100%;\n\theight: 100px;\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\n\ttext-align: left;\n\twhite-space: nowrap;\n}\n\n.profile-selection > .slot > button.main.selected {\n\tbackground-color: var(--button-hover-color);\n}\n\n.profile-selection > .slot > button.main > .image-container {\n\tdisplay: inline-block;\n\tposition: relative;\n\tbackground-color: rgba(0, 0, 0, 0.1);\n\twidth: 100px;\n\theight: 100px;\n}\n\n.profile-selection > .slot > button.main > .image-container > img {\n\tposition: absolute;\n\tleft: 0;\n\ttop: 0;\n\twidth: 100%;\n\theight: 100%;\n\tpointer-events: none;\n\topacity: 0;\n\ttransition: opacity 0.5s ease-out;\n}\n.profile-selection > .slot > button.main > .image-container > img.show {\n\topacity: 1;\n}\n\n.profile-selection > .slot > button.main > .name {\n\tdisplay: inline-block;\n\tvertical-align: top;\n\tmargin: 0;\n\tpadding: 12px;\n\tfont-size: 28px;\n\tcolor: var(--text-color);\n\ttext-overflow: ellipsis;\n\toverflow: hidden;\n\twidth: 320px;\n}\n.profile-selection > .slot > button.main > .name.empty {\n\tcolor: #000;\n\topacity: 0.2;\n}\n\n.profile-selection > .bottom-bar {\n\tmargin: 10px 0 0 0;\n\tpadding: 10px;\n\tbackground-color: var(--surface-color);\n}\n\n.profile-selection > .bottom-bar > .button.right {\n\tfloat: right;\n}\n", ""]);
                const o = s
            }
            ,
            5148: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/checkpoint.svg"
            }
            ,
            5151: (e, t, n) => {
                "use strict";
                n.d(t, {
                    A: () => o
                });
                var i = n(1601)
                    , r = n.n(i)
                    , a = n(6314)
                    , s = n.n(a)()(r());
                s.push([e.id, "\n.speedometer {\n\tposition: absolute;\n\tbottom: 0;\n\tright: 0;\n\tmargin: 0;\n\tpadding: 8px 8px 8px 10px;\n\tmin-width: 140px;\n\tline-height: 0;\n\tfont-size: 40px;\n\tcolor: var(--text-color);\n\ttext-align: right;\n\topacity: 0.9;\n\tclip-path: polygon(8px 0, 100% 0, 100% 100%, 0 100%);\n\tbackground-color: var(--surface-color);\n}\n.speedometer.up {\n\tbottom: auto;\n\ttop: 0;\n\tclip-path: polygon(0 0, 100% 0, 100% 100%, 8px 100%);\n}\n.speedometer.hidden {\n\tdisplay: none;\n}\n\n.speedometer > div {\n\tmargin: 0;\n\tpadding: 0 0 0 16px;\n\tclip-path: polygon(6px 0, 100% 0, 100% 100%, 0 100%);\n\tbackground-color: var(--surface-tertiary-color);\n}\n.speedometer.up > div {\n\tclip-path: polygon(0 0, 100% 0, 100% 100%, 6px 100%);\n}\n\n.speedometer > div > span:last-of-type {\n\topacity: 0.5;\n\tmargin: 0 0.3em 0 0.25em;\n\tpadding: 0;\n\tfont-size: 0.5em;\n}\n.speedometer > div > span > span {\n\tdisplay: inline-block;\n\twidth: 0.5em;\n\ttext-align: center;\n}\n", ""]);
                const o = s
            }
            ,
            5437: (e, t, n) => {
                "use strict";
                n.d(t, {
                    A: () => o
                });
                var i = n(1601)
                    , r = n.n(i)
                    , a = n(6314)
                    , s = n.n(a)()(r());
                s.push([e.id, "\n.message-box {\n\tmargin: 0;\n\tpadding: 0;\n\tposition: absolute;\n\tleft: 0;\n\ttop: 0;\n\tz-index: 1;\n\tmax-width: unset;\n\tmax-height: unset;\n\twidth: 100%;\n\theight: 100%;\n\tbackground-color: rgba(20, 20, 30, 0.5);\n\tborder: none;\n\tpointer-events: auto;\n}\n\n.message-box > div {\n\tposition: absolute;\n\tleft: calc(50% - 500px / 2);\n\ttop: 30%;\n\tz-index: 2;\n\tmargin: 0;\n\tpadding: 16px;\n\twidth: 500px;\n\tbox-sizing: border-box;\n\tborder: none;\n\tbackground-color: var(--surface-color);\n\toutline: none;\n\ttext-align: center;\n}\n\n.message-box > div > p {\n\tmargin: 5px 0 20px 0;\n\tpadding: 0;\n\tmin-height: 50px;\n\tline-height: 0.9;\n\tfont-size: 32px;\n\toverflow-wrap: break-word;\n\twhite-space: pre-wrap;\n\tcolor: var(--text-color);\n}\n\n.message-box > div > button {\n\tmin-width: 140px;\n}\n\n.message-box.message > div > button:first-of-type {\n\tdisplay: none;\n}\n\n.message-box.confirm > div > button:first-of-type {\n\tfloat: left;\n}\n.message-box.confirm > div > button:last-of-type {\n\tfloat: right;\n}\n\n.message-box.no-buttons > div > button {\n\tdisplay: none;\n}\n", ""]);
                const o = s
            }
            ,
            5586: (e, t, n) => {
                "use strict";
                n.d(t, {
                    A: () => o
                });
                var i = n(1601)
                    , r = n.n(i)
                    , a = n(6314)
                    , s = n.n(a)()(r());
                s.push([e.id, "\n.track-info {\n\tposition: absolute;\n\tleft: calc(50% - 1050px / 2);\n\ttop: 0;\n\tz-index: 2;\n\tdisplay: flex;\n\tmargin: 0;\n\tpadding: 0;\n\twidth: 1000px;\n\theight: 100%;\n}\n.track-info.hidden {\n\tdisplay: none;\n}\n\n.track-info > .side-panel {\n\tposition: relative;\n\tdisplay: inline-block;\n\tmargin-left: 50px;\n\twidth: 400px;\n\t\n\tbackground-color: var(--surface-color);\n}\n\n.track-info > .side-panel > h2 {\n\tmargin: 10px 10px 0 10px;\n\tpadding: 0;\n\twhite-space: nowrap;\n\toverflow: hidden;\n\ttext-overflow: ellipsis;\n\tfont-weight: normal;\n\tfont-size: 38px;\n\ttext-align: center;\n\tcolor: var(--text-color);\n}\n\n\n.track-info > .side-panel > .thumbnail {\n\tposition: relative;\n\tmargin: 10px 0 0 0;\n\tpadding: 40px;\n\tbackground-color: var(--surface-secondary-color);\n}\n\n.track-info > .side-panel > .thumbnail > canvas {\n\tmargin: 0;\n\tpadding: 0;\n\twidth: 300px;\n\theight: 300px;\n\tobject-fit: contain;\n\t-webkit-filter: drop-shadow(0 0 3px #000);\n\tfilter: drop-shadow(0 0 3px #000);\n\timage-rendering: pixelated;\n}\n\n.track-info > .side-panel > .thumbnail > .share {\n\tdisplay: inline-block;\n\tposition: absolute;\n\tleft: 0;\n\tbottom: 0;\n\tmargin: 8px;\n\tpadding: 0 9px;\n\tclip-path: polygon(3px 0, 100% 0, calc(100% - 3px) 100%, 0 100%);\n}\n.track-info > .side-panel > .thumbnail > .share > img {\n\tmargin: 0;\n\tpadding: 0;\n\twidth: 16px;\n\tpointer-events: none;\n}\n\n.track-info > .side-panel > .thumbnail > .environment {\n\tposition: absolute;\n\tright: 0;\n\tbottom: 0;\n\tmargin: 8px;\n\twidth: 32px;\n\topacity: 0.2;\n\tpointer-events: none;\n}\n\n.track-info > .side-panel > .track-author {\n\tmargin: 8px 0;\n\tfont-size: 18px;\n\tcolor: var(--text-color);\n\toverflow-wrap: anywhere;\n}\n\n.track-info > .side-panel > .divider {\n\tborder-top: 1px solid var(--text-color);\n}\n\n.track-info > .side-panel > .personal-best-title, .track-info > .side-panel > .opponents-title {\n\tmargin: 16px 0 0 0;\n\tfont-size: 36px;\n\tcolor: var(--text-color);\n}\n\n.track-info > .side-panel > .personal-best {\n\tmargin: 0 0 16px 0;\n\tfont-size: 32px;\n\tcolor: var(--text-color);\n}\n.track-info > .side-panel > .personal-best.no-record {\n\topacity: 0.5;\n}\n\n.track-info > .side-panel > .opponents-container {\n\tmargin: 8px 16px 16px 16px;\n\tfont-size: 18px;\n\tcolor: var(--text-color);\n\topacity: 0.5;\n}\n\n.track-info > .side-panel > .opponents-container.no-opponents {\n\tmargin: 8px 16px 16px 16px;\n\tfont-size: 18px;\n\tcolor: var(--text-color);\n\topacity: 0.5;\n}\n\n.track-info > .side-panel > .button.play {\n\tposition: absolute;\n\tbottom: 10px;\n\tleft: 0;\n\tmargin: 10px 10px 0 10px;\n\tpadding: 0 0 0 30px;\n\tbox-sizing: border-box;\n\twidth: calc(100% - 2 * 10px);\n\theight: 100px;\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\n\ttext-align: center;\n\tfont-size: 50px;\n}\n\n.track-info > .side-panel > .button.play > img {\n\tmargin: 0 0 0 10px;\n\tpadding: 0;\n\tvertical-align: middle;\n\twidth: 48px;\n\ttransition: transform 0.2s ease-in-out;\n\tpointer-events: none;\n}\n\n.track-info > .side-panel > .button.play:hover > img {\n\ttransform: translateX(10px);\n}\n\n@media (hover: none) {\n\t.track-info > .side-panel > .button.play:hover > img {\n\t\ttransform: none;\n\t}\n}\n\n.track-info > .side-panel > .back {\n\tmargin: 10px;\n}\n\n.track-info > .side-panel > .leaderboard-button {\n\tmargin: 10px;\n\tfloat: right;\n}\n", ""]);
                const o = s
            }
            ,
            5739: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/quit.svg"
            }
            ,
            5769: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/state_pending.svg"
            }
            ,
            5798: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/rotation_axis_y_negative.svg"
            }
            ,
            5811: (e, t, n) => {
                "use strict";
                n.d(t, {
                    A: () => o
                });
                var i = n(1601)
                    , r = n.n(i)
                    , a = n(6314)
                    , s = n.n(a)()(r());
                s.push([e.id, "\n.checkpoint {\n\tposition: absolute;\n\tbottom: 0;\n\tleft: 0;\n\tmargin: 0;\n\tpadding: 8px 10px 8px 8px;\n\tline-height: 0;\n\tfont-size: 40px;\n\tcolor: var(--text-color);\n\ttext-align: left;\n\topacity: 0.9;\n\tclip-path: polygon(0 0, calc(100% - 8px) 0, 100% 100%, 0 100%);\n\tbackground-color: var(--surface-color);\n}\n.checkpoint.up {\n\tposition: absolute;\n\tbottom: auto;\n\ttop: 0;\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\n}\n.checkpoint.hidden {\n\tdisplay: none;\n}\n\n.checkpoint > div {\n\tmargin: 0;\n\tpadding: 0 16px 0 16px;\n\tclip-path: polygon(0 0, calc(100% - 6px) 0, 100% 100%, 0 100%);\n\tbackground-color: var(--surface-tertiary-color);\n}\n.checkpoint.up > div {\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 6px) 100%, 0 100%);\n}\n\n.checkpoint > div > img {\n\tmargin: 0 12px 5px 0;\n\tpadding: 0;\n\twidth: 24px;\n\theight: 24px;\n\tvertical-align: middle;\n}\n", ""]);
                const o = s
            }
            ,
            5848: (e, t, n) => {
                "use strict";
                n.d(t, {
                    A: () => o
                });
                var i = n(1601)
                    , r = n.n(i)
                    , a = n(6314)
                    , s = n.n(a)()(r());
                s.push([e.id, "\n.color-picker {\n\tmargin: 8px;\n}\n\n.color-picker > .value-saturation-picker {\n\tposition: relative;\n\tmargin: 0 0 8px 0;\n\twidth: 140px;\n\theight: 140px;\n\tbackground-color: #fff;\n\toverflow: hidden;\n}\n\n.color-picker > .value-saturation-picker > .marker {\n\tposition: absolute;\n\twidth: 12px;\n\theight: 12px;\n\tbackground-image: radial-gradient(closest-side, transparent, #000, #fff, #000, transparent);\n}\n\n.color-picker > .hue-picker {\n\tposition: relative;\n\twidth: 140px;\n\theight: 30px;\n\tbackground-image: linear-gradient(to right, \n\t\thsl(0, 100%, 50%),\n\t\thsl(60, 100%, 50%),\n\t\thsl(120, 100%, 50%),\n\t\thsl(180, 100%, 50%),\n\t\thsl(240, 100%, 50%),\n\t\thsl(300, 100%, 50%),\n\t\thsl(0, 100%, 50%)\n\t);\n\toverflow: hidden;\n}\n\n.color-picker > .hue-picker > .marker {\n\tposition: absolute;\n\ttop: 0;\n\theight: 100%;\n\twidth: 3px;\n\tbackground-image: linear-gradient(to right, #000, #fff, #000);\n}\n", ""]);
                const o = s
            }
            ,
            5918: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/load.svg"
            }
            ,
            5959: (e, t, n) => {
                "use strict";
                n.d(t, {
                    A: () => o
                });
                var i = n(1601)
                    , r = n.n(i)
                    , a = n(6314)
                    , s = n.n(a)()(r());
                s.push([e.id, "\n.customization {\n\tposition: absolute;\n\tleft: 0;\n\ttop: 0;\n\tmargin: 0;\n\tpadding: 0;\n\twidth: 100%;\n\theight: 100%;\n}\n\n.customization > .top {\n\tdisplay: block;\n\tmargin: 0;\n\tpadding: 0;\n\tbackground-color: var(--surface-color);\n}\n.customization > .top > .button {\n\tdisplay: inline-block;\n\tmargin: 8px 0;\n}\n.customization > .top > .button:first-of-type {\n\tmargin-left: 8px;\n}\n\n.customization > .save-message {\n\tmargin: 10px;\n\tpadding: 0;\n\tposition: absolute;\n\tfont-size: 30px;\n\tcolor: #96ff96;\n\ttext-shadow: 0 0 5px #000;\n\tpointer-events: none;\n\n\tleft: -10px;\n\topacity: 0;\n}\n.customization > .save-message.show {\n\tleft: 0;\n\topacity: 1;\n\ttransition: opacity 0.25s ease-in-out, left 0.25s ease-in-out;\n}\n.customization > .save-message.hide {\n\tleft: 0;\n\topacity: 0;\n\ttransition: opacity 0.25s ease-in-out, left 0.25s ease-in-out;\n}\n\n.customization > .colors {\n\tposition: absolute;\n\tleft: 0;\n\tbottom: 0;\n\twidth: 100%;\n\ttext-align: center;\n\twhite-space: nowrap;\n}\n\n.customization > .colors > div {\n\tdisplay: inline-block;\n\tmargin: 0 10px;\n\tpadding: 0;\n\ttext-align: center;\n\tbackground: var(--surface-color);\n\tpointer-events: auto;\n}\n.customization > .colors > div > h2 {\n\tmargin: 0;\n\tpadding: 2px;\n\tfont-size: 26px;\n\tfont-weight: normal;\n\tbackground-color: var(--surface-secondary-color);\n\tcolor: var(--text-color);\n}\n.customization > .colors > div > input {\n\tmargin: 8px 8px 0 8px;\n\twidth: calc(140px - 8px * 2);\n\tfont-weight: normal;\n\tclip-path: none;\n\ttext-align: center;\n}\n", ""]);
                const o = s
            }
            ,
            6027: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/pin.svg"
            }
            ,
            6057: (e, t, n) => {
                "use strict";
                n.d(t, {
                    A: () => o
                });
                var i = n(1601)
                    , r = n.n(i)
                    , a = n(6314)
                    , s = n.n(a)()(r());
                s.push([e.id, "\n.editor {\n\tmargin: 0;\n\tpadding: 0;\n\twidth: 100%;\n\theight: 100%;\n}\n\n.editor > .top {\n\tdisplay: block;\n\tmargin: 0;\n\tpadding: 0;\n}\n\n.editor > .top > .button-bar {\n\tdisplay: flex;\n\tmargin: 0;\n\tpadding: 0 8px;\n\theight: 68px;\n\tbackground-color: var(--surface-color);\n\twhite-space: nowrap;\n}\n.editor > .top > .button-bar > .button {\n\tmargin: 8px 0;\n\tmin-width: 0;\n\toverflow: hidden;\n\ttext-overflow: ellipsis;\n}\n\n.editor > .top > .track-settings-container {\n\tdisplay: inline-block;\n\tmargin: 0;\n\tpadding: 6px 7px;\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 10px) 100%, 0 100%);\n\tfont-size: 30px;\n\tcolor: var(--text-color);\n\tbackground: var(--surface-secondary-color);\n}\n.editor > .top > .track-settings-container > button {\n\ttext-align: left;\n\tmin-width: 150px;\n}\n\n.editor > .side {\n\tposition: absolute;\n\ttop: 68px;\n\tright: 0;\n\tmargin: 0;\n\tpadding: 0;\n\theight: calc(100% - 68px);\n\tdisplay: flex;\n\talign-items: end;\n}\n\n.editor > .side > .side-panel {\n\theight: 100%;\n\tbackground-color: var(--surface-secondary-color);\n\tpointer-events: auto;\n}\n\n.editor > .side > .side-panel > .category-panel, .editor > .side > .side-panel > .part-panel, .editor > .side > .side-panel > .color-panel {\n\tdisplay: inline-block;\n\tvertical-align: top;\n\tpadding: 2px 2px 0 2px;\n\theight: 100%;\n\tbox-sizing: border-box;\n\toverflow-x: hidden;\n\toverflow-y: scroll;\n\tscrollbar-width: thin;\n}\n.editor > .side > .side-panel > .category-panel > button > img {\n\twidth: 96px;\n\theight: 96px;\n}\n.editor > .side > .side-panel > .part-panel.hidden {\n\tdisplay: none;\n}\n.editor > .side > .side-panel > .color-panel.hidden {\n\tdisplay: none;\n}\n\n.editor > .side > .side-panel button {\n\tdisplay: block;\n\tmargin: 0 0 2px 0;\n\tpadding: 5px;\n\tbackground-color: var(--button-color);\n\tborder: 2px solid rgb(38, 31, 88);\n\tcursor: pointer;\n}\n.editor > .side > .side-panel button:hover {\n\tbackground-color: var(--button-hover-color);\n}\n@media (hover: none) {\n\t.editor > .side > .side-panel button:hover {\n\t\tbackground-color: var(--button-color);\n\t}\n}\n.editor > .side > .side-panel button:active {\n\tbackground-color: var(--button-active-color);\n}\n.editor > .side > .side-panel button.selected {\n\tbackground-color: var(--button-hover-color);\n\tbox-shadow: inset 0 0 5px #fff;\n\tborder: 2px solid #fff;\n}\n.editor > .side > .side-panel button > img {\n\tdisplay: block;\n\tmargin: 0;\n\tpadding: 0;\n\twidth: 64px;\n\theight: 64px;\n\t-webkit-filter: drop-shadow(0 0 2px #000);\n\tfilter: drop-shadow(0 0 2px #000);\n\tpointer-events: none;\n\ttransition: opacity 0.25s ease-out;\n}\n.editor > .side > .side-panel button > img.loading {\n\topacity: 0;\n\ttransition: none;\n}\n\n.editor > .message {\n\tmargin: 10px;\n\tpadding: 0;\n\tposition: absolute;\n\tfont-size: 30px;\n\tcolor: #ff9696;\n\ttext-shadow: 0 0 5px #000;\n\tpointer-events: none;\n\n\tleft: -10px;\n\topacity: 0;\n}\n.editor > .message.green {\n\tcolor: #96ff96;\n}\n.editor > .message.show {\n\tleft: 0;\n\topacity: 1;\n\ttransition: opacity 0.25s ease-in-out, left 0.25s ease-in-out;\n}\n.editor > .message.hide {\n\tleft: 0;\n\topacity: 0;\n\ttransition: opacity 0.25s ease-in-out, left 0.25s ease-in-out;\n}\n", ""]);
                const o = s
            }
            ,
            6099: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/arrow_left.svg"
            }
            ,
            6150: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/arrow_right.svg"
            }
            ,
            6168: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/export.svg"
            }
            ,
            6244: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/state_verified.svg"
            }
            ,
            6314: e => {
                "use strict";
                e.exports = function(e) {
                    var t = [];
                    return t.toString = function() {
                        return this.map((function(t) {
                                var n = ""
                                    , i = void 0 !== t[5];
                                return t[4] && (n += "@supports (".concat(t[4], ") {")),
                                t[2] && (n += "@media ".concat(t[2], " {")),
                                i && (n += "@layer".concat(t[5].length > 0 ? " ".concat(t[5]) : "", " {")),
                                    n += e(t),
                                i && (n += "}"),
                                t[2] && (n += "}"),
                                t[4] && (n += "}"),
                                    n
                            }
                        )).join("")
                    }
                        ,
                        t.i = function(e, n, i, r, a) {
                            "string" == typeof e && (e = [[null, e, void 0]]);
                            var s = {};
                            if (i)
                                for (var o = 0; o < this.length; o++) {
                                    var l = this[o][0];
                                    null != l && (s[l] = !0)
                                }
                            for (var c = 0; c < e.length; c++) {
                                var h = [].concat(e[c]);
                                i && s[h[0]] || (void 0 !== a && (void 0 === h[5] || (h[1] = "@layer".concat(h[5].length > 0 ? " ".concat(h[5]) : "", " {").concat(h[1], "}")),
                                    h[5] = a),
                                n && (h[2] ? (h[1] = "@media ".concat(h[2], " {").concat(h[1], "}"),
                                    h[2] = n) : h[2] = n),
                                r && (h[4] ? (h[1] = "@supports (".concat(h[4], ") {").concat(h[1], "}"),
                                    h[4] = r) : h[4] = "".concat(r)),
                                    t.push(h))
                            }
                        }
                        ,
                        t
                }
            }
            ,
            6366: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/apply.svg"
            }
            ,
            6474: (e, t, n) => {
                "use strict";
                n.d(t, {
                    A: () => o
                });
                var i = n(1601)
                    , r = n.n(i)
                    , a = n(6314)
                    , s = n.n(a)()(r());
                s.push([e.id, "\n.nickname {\n\tposition: absolute;\n\tleft: calc(50% - 500px / 2);\n\ttop: 40%;\n\tz-index: 2;\n\tmargin: 0;\n\tpadding: 16px;\n\twidth: 500px;\n\tbox-sizing: border-box;\n\tbackground-color: var(--surface-color);\n}\n\n.nickname > h1 {\n\tmargin: 0 4px 0 4px;\n\tpadding: 0;\n\tfont-size: 35px;\n\tfont-weight: normal;\n\tcolor: var(--text-color);\n}\n\n.nickname > input[type=text] {\n\tdisplay: block;\n\tmargin: 0;\n\tpadding: 0.25em;\n\tbox-sizing: border-box;\n\twidth: 100%;\n\tfont-size: 36px;\n\tfont-weight: normal;\n}\n\n.nickname > p {\n\tmargin: 16px 4px 0 4px;\n\tpadding: 0;\n\tfont-size: 20px;\n\tcolor: var(--text-color);\n}\n\n.nickname > button {\n\tdisplay: inline-block;\n\tmargin: 16px 0 0 0;\n}\n.nickname > button:last-of-type {\n\tfloat: right;\n}\n\n.nickname > button.delete {\n\tposition: absolute;\n\tright: 8px;\n\ttop: 0;\n\tfont-size: 16px;\n\tpadding: 8px 16px;\n}\n\n.nickname > button.delete > img.button-icon {\n\tmargin: -5px 0 -2px -3px;\n\twidth: 16px;\n\theight: 16px;\n}\n\nbutton.nickname-verifier-button {\n\tposition: absolute;\n\tleft: 0;\n\tbottom: 22px;\n\tmargin: 0 4px;\n}\n\n.nickname-user-token {\n\tposition: absolute;\n\tleft: 0;\n\tbottom: 0;\n\tmargin: 0 4px;\n\ttext-align: left;\n\tfont-size: 18px;\n\topacity: 0.5;\n\tcolor: var(--text-color);\n\tpointer-events: all;\n\t-webkit-user-select: all;\n\t-moz-user-select: all;\n\t-ms-user-select: all;\n\tuser-select: all;\n}\n", ""]);
                const o = s
            }
            ,
            6657: (e, t, n) => {
                "use strict";
                n.d(t, {
                    A: () => o
                });
                var i = n(1601)
                    , r = n.n(i)
                    , a = n(6314)
                    , s = n.n(a)()(r());
                s.push([e.id, "\n.leaderboard {\n\tmargin: 0;\n\tpadding: 0;\n\twidth: 600px;\n\theight: 100%;\n\ttext-align: left;\n\tdisplay: flex;\n\tflex-shrink: 0;\n\tflex-direction: column;\n\tbackground-color: var(--surface-color);\n}\n\n.leaderboard > h2 {\n\tmargin: 10px 10px 0 10px;\n\tpadding: 0;\n\tfont-weight: normal;\n\tfont-size: 38px;\n\ttext-align: center;\n\tcolor: var(--text-color);\n}\n\n.leaderboard > h3 {\n\tmargin: 0 10px 10px 10px;\n\tpadding: 0;\n\tfont-weight: normal;\n\tfont-size: 18px;\n\ttext-align: center;\n\tcolor: var(--text-color);\n\topacity: 0.5;\n}\n\n.leaderboard > .container {\n\tmargin: 0;\n\tpadding: 0;\n\tflex-grow: 1;\n\tbackground-color: var(--surface-secondary-color);\n\toverflow-x: hidden;\n\toverflow-y: scroll;\n\tpointer-events: auto;\n}\n\n.leaderboard > .container > .loading-spinner-container {\n\tdisplay: flex;\n\tjustify-content: center;\n\talign-items: center;\n\twidth: 100%;\n\theight: 100%;\n}\n\n.leaderboard > .container > .error-message {\n\tfont-size: 20px;\n\ttext-align: center;\n\tcolor: var(--text-color);\n}\n\n.leaderboard > .container > button.main {\n\tmargin: 10px 10px 0 10px;\n\tpadding: 0;\n\tvertical-align: top;\n\twidth: calc(100% - 10px * 2);\n\theight: 100px;\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\n\ttext-align: left;\n\twhite-space: nowrap;\n}\n.leaderboard > .container > button.main:last-of-type {\n\tmargin-bottom: 10px;\n}\n\n.leaderboard > .container > button.main.selected {\n\tbackground-color: var(--button-hover-color);\n}\n.leaderboard > .container > button.main.selected::after {\n\twidth: 100%;\n}\n\n.leaderboard > .container > button.main > .checkmark {\n\tdisplay: none;\n}\n\n.leaderboard > .container > button.main.selected > .checkmark {\n\tdisplay: block;\n\tposition: absolute;\n\tright: 0;\n\ttop: 0;\n\tmargin: 6px;\n\twidth: 12px;\n\tanimation: leaderboard-checkmark-spawn 0.15s ease-out;\n}\n\n@keyframes leaderboard-checkmark-spawn {\n\t0% {\n\t\ttransform: scale(0);\n\t}\n\t90% {\n\t\ttransform: scale(1.2);\n\t}\n\t100% {\n\t\ttransform: scale(1);\n\t}\n}\n\n.leaderboard > .container > button.main > .image-container {\n\tdisplay: inline-block;\n\tposition: relative;\n\tbackground-color: rgba(0, 0, 0, 0.1);\n\twidth: 100px;\n\theight: 100px;\n}\n\n.leaderboard > .container > button.main > .image-container > img {\n\tposition: absolute;\n\tleft: 0;\n\ttop: 0;\n\twidth: 100%;\n\theight: 100%;\n\tpointer-events: none;\n\topacity: 0;\n\ttransition: opacity 0.5s ease-out;\n}\n.leaderboard > .container > button.main > .image-container > img.show {\n\topacity: 1;\n}\n\n.leaderboard > .container > button.main > .left, .leaderboard > .container > button.main > .right {\n\tdisplay: inline-block;\n\tvertical-align: top;\n}\n\n.leaderboard > .container > button.main > div > p {\n\tmargin: 0;\n\tpadding: 12px;\n\tfont-size: 28px;\n\tcolor: var(--text-color);\n}\n\n.leaderboard > .container > button.main > div > .position > span {\n\tfont-size: 20px;\n\topacity: 0.3;\n}\n\n.leaderboard > .container > button.main > div > .name-container {\n\tdisplay: flex;\n\talign-items: center;\n\twidth: 336px;\n}\n\n.leaderboard > .container > button.main > div > .name-container > .name {\n\ttext-overflow: ellipsis;\n\toverflow: hidden;\n}\n.leaderboard > .container > button.main:focus-visible > div > .name-container > .name {\n\ttext-decoration: underline;\n}\n\n.leaderboard > .container > button.main > div > .name-container > .self {\n\tmargin-left: 8px;\n\topacity: 0.5;\n\tfont-size: 16px;\n\tfont-style: normal;\n}\n\n.leaderboard > .container > button.main > div > .verified-state {\n\topacity: 0.8;\n\tposition: absolute;\n\tright: 6px;\n\tmargin: 6px 0 0 0;\n\tfont-size: 18px;\n}\n.leaderboard > .container > button.main > div > .verified-state > img {\n\tmargin: 0 0 0 2px;\n\tpadding: 0;\n\theight: 12px;\n\tvertical-align: middle;\n}\n.leaderboard > .container > button.main > div > .verified-state.verified {\n\tcolor: #5f5;\n}\n.leaderboard > .container > button.main > div > .verified-state.invalid {\n\tcolor: #f55;\n}\n.leaderboard > .container > button.main > div > .verified-state.pending {\n\tcolor: #ff5;\n}\n\n.leaderboard > .pages {\n\tmargin: 10px 10px 0 10px;\n\tdisplay: flex;\n\tflex-direction: row;\n}\n.leaderboard > .pages > button.page {\n\tpadding: 0;\n\twidth: 0;\n\tflex-grow: 1;\n}\n.leaderboard > .pages > button.selected {\n\tbackground-color: var(--button-hover-color);\n}\n\n.leaderboard > .button-wrapper > .back {\n\tmargin: 10px;\n}\n\n.leaderboard > .button-wrapper > .button.only-verified {\n\tmargin: 10px 0;\n\tfloat: right;\n\tfont-size: 20px;\n\tline-height: 32px;\n}\n.leaderboard > .button-wrapper > .button.only-verified.disabled {\n\tcolor: rgba(255, 255, 255, 0.25);\n}\n\n.leaderboard > .button-wrapper > .button.only-verified > img {\n\tmargin-left: 6px;\n\tmargin-bottom: -4px;\n\twidth: 26px;\n}\n.leaderboard > .button-wrapper > .button.only-verified.disabled > img {\n\topacity: 0.25;\n}\n\n.leaderboard > .button-wrapper > .icon-button {\n\tmargin: 10px 0;\n\tfloat: right;\n}\n.leaderboard > .button-wrapper > .icon-button.first {\n\tmargin: 10px 10px 10px 0;\n}\n\n.leaderboard > .button-wrapper > .icon-button > img {\n\twidth: 28px;\n}\n.leaderboard > .button-wrapper > .icon-button.disabled > img, .leaderboard > .button-wrapper > .icon-button:disabled > img {\n\topacity: 0.25;\n}\n", ""]);
                const o = s
            }
            ,
            6838: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/smoke.png"
            }
            ,
            6925: () => {
                "use strict";
                function e(e) {
                    throw new Error(e + ": No deterministic implementation")
                }
                const t = new WebAssembly.Instance(new WebAssembly.Module(Uint8Array.from(atob("AGFzbQEAAAABJAZgAXwBfGACfHwBfGACf38AYAJ/fABgBH9/f38Bf2ACfH8BfAMcGwQDAQAAAAAAAAAAAQACBQIBAQAAAAAAAAAAAAUDAQARBgkBfwFBgIDAAAsHVQwGbWVtb3J5AgAEYWNvcwASBGFzaW4AEwRhdGFuABQFYXRhbjIAEANleHAAFQNsb2cAFgNwb3cAEQRzcXJ0ABcDdGFuABgEbG9nMgAZBWxvZzEwABoKsG4bqxsDHH8BfgR8IwBBwARrIgckACAHQQhqQaABEA8gB0GoAWpBoAEQDyAHQcgCakGgARAPIAdB6ANqQdAAEA9BhIDAACgCACIKIAFBf2oiC2ohBSADQX1qQRhtIgRBACAEQQBKGyIPIAtrIQQgD0ECdCABQQJ0a0GUgMAAaiEJQQAhAQNAIAdBCGogAUEDdGogBEEASAR8RAAAAAAAAAAABSAJKAIAtws5AwAgASAFSQRAIAlBBGohCSAEQQFqIQQgASABIAVJaiIBIAVNDQELCyADQWhqIQVBACEEA0AgBCALaiENIAQgCkkhBkQAAAAAAAAAACEhQQAhAQNAAkAgISAAIAFBA3RqKwMAIAdBCGogDSABa0EDdGorAwCioCEhIAEgC08NACABIAEgC0lqIgEgC00NAQsLIAdByAJqIARBA3RqICE5AwAgBCAKSQRAIAQgBmoiBCAKTQ0BCwtEAAAAAAAA8H9EAAAAAAAA4H8gBSAPQWhsIhdqIgZB/g9LIhIbRAAAAAAAAAAARAAAAAAAAGADIAZBuXBJIhMbRAAAAAAAAPA/IAZBgnhIIhQbIAZB/wdKIhUbIAZB/RcgBkH9F0gbQYJwaiAGQYF4aiASGyIYIAZB8GggBkHwaEobQZIPaiAGQckHaiATGyIZIAYgFBsgFRtB/wdqrUI0hr+iISMgB0HkA2oiECAKQQJ0aiENQRcgBmtBH3EhGkEYIAZrQR9xIRYgB0HAAmohGyAGQX9qIRwgCiEEAkADQCAHQcgCaiAEIgVBA3RqKwMAISECQCAFRQ0AIAdB6ANqIQggBSEBA0AgIUQAAAAAAABwPqIiIkQAAAAAAADgwWYhBCAhQQBB/////wcgIplEAAAAAAAA4EFjBH8gIqoFQYCAgIB4C0GAgICAeCAEGyAiRAAAwP///99BZBsgIiAiYhu3IiJEAAAAAAAAcMGioCIhRAAAAAAAAODBZiEEIAhBAEH/////BwJ/ICGZRAAAAAAAAOBBYwRAICGqDAELQYCAgIB4C0GAgICAeCAEGyAhRAAAwP///99BZBsgISAhYhs2AgAgGyABQQN0aisDACAioCEhIAFBAkkiBA0BIAhBBGohCEEBIAFBf2ogBBsiAQ0ACwsCfwJAIBVFBEAgFA0BIAYMAgsgIUQAAAAAAADgf6IiIUQAAAAAAADgf6IgISASGyEhIBgMAQsgIUQAAAAAAABgA6IiIUQAAAAAAABgA6IgISATGyEhIBkLIQECQCAhIAFB/wdqrUI0hr+iIiREAAAAAAAAwD+iIiFEAAAAAAAAAABhDQAgIb0iIEI0iKdB/w9xIgFBsghLDQACQAJAICBCAFkEQCAHICFEAAAAAAAAMEOgRAAAAAAAADDDoCAhoSIiOQO4BCABQf8HTw0BIAcrA7gEGkQAAAAAAAAAACEhDAMLIAcgIUQAAAAAAAAww6BEAAAAAAAAMEOgICGhIiI5A7gEIAFB/wdJDQELICEgIqAiIUQAAAAAAADwv6AgISAiRAAAAAAAAAAAZBshIQwBCyAHKwO4BBpEAAAAAAAA8L8hIQsgJCAhRAAAAAAAACDAoqAiIUQAAAAAAADgwWYhASAhQQBB/////wcCfyAhmUQAAAAAAADgQWMEQCAhqgwBC0GAgICAeAtBgICAgHggARsgIUQAAMD////fQWQbICEgIWIbIg63oSEhAn8CQAJAAkACQAJ/IAZBAEoiHUUEQCAGRQRAIBAgBUECdGooAgBBF3UMAgtBAiEMQQAgIUQAAAAAAADgP2ZFDQYaDAILIBAgBUECdGoiASABKAIAIgEgASAWdSIBIBZ0ayIENgIAIAEgDmohDiAEIBp1CyIMQQFIDQELIAUNAUEAIQgMAgsgDAwCC0EAIRFBACEIIAVBAUcEQCAFQR5xIR4gB0HoA2ohAQNAIAEoAgAhBEH///8HIQkCfwJAIAgNAEGAgIAIIQkgBA0AQQEMAQsgASAJIARrNgIAQQALIQkgAUEEaiIfKAIAIQhB////ByEEAn8CQCAJRQ0AQYCAgAghBCAIDQBBAAwBCyAfIAQgCGs2AgBBAQshCCABQQhqIQEgHiARQQJqIhFHDQALCyAFQQFxRQ0AIAdB6ANqIBFBAnRqIgkoAgAhAUH///8HIQQCQCAIDQBBgICACCEEIAENAEEAIQgMAQsgCSAEIAFrNgIAQQEhCAsCQCAdRQ0AQf///wMhAQJAAkAgHA4CAQACC0H///8BIQELIBAgBUECdGoiBCAEKAIAIAFxNgIACyAOQQFqIQ4gDCAMQQJHDQAaRAAAAAAAAPA/ICGhICNEAAAAAAAAAAAgCBuhISFBAgshDCAhRAAAAAAAAAAAYQRAIA0hASAFIQQCQCAKIAVBf2oiCEsNAEEAIQkDQAJAIAdB6ANqIAhBAnRqKAIAIAlyIQkgCiAITw0AIAogCCAKIAhJayIITQ0BCwsgBSEEIAlFDQAgBUECdCAHakHkA2ohAQNAIAVBf2ohBSAGQWhqIQYgASgCACABQXxqIQFFDQALDAMLA0AgBEEBaiEEIAEoAgAgAUF8aiEBRQ0ACyAFIARPDQEgBUEBaiEJA0AgB0EIaiAJIAtqIgVBA3RqIAkgD2pBAnRBkIDAAGooAgC3OQMAQQAhAUQAAAAAAAAAACEhA0ACQCAhIAAgAUEDdGorAwAgB0EIaiAFIAFrQQN0aisDAKKgISEgASALTw0AIAEgASALSWoiASALTQ0BCwsgB0HIAmogCUEDdGogITkDACAJIARPDQIgCSAESSAJaiIBIQkgASAETQ0ACwwBCwsCQAJAAkBBACAGayIBQf8HTARAIAFBgnhODQMgIUQAAAAAAABgA6IhISABQbhwTQ0BQckHIAZrIQEMAwsgIUQAAAAAAADgf6IhISABQf4PSw0BQYF4IAZrIQEMAgsgIUQAAAAAAABgA6IhISABQfBoIAFB8GhKG0GSD2ohAQwBCyAhRAAAAAAAAOB/oiEhIAFB/RcgAUH9F0gbQYJwaiEBCyAhIAFB/wdqrUI0hr+iIiFEAAAAAAAAcEFmBEAgIUQAAAAAAABwPqIiIkQAAAAAAADgwWYhACAhQQBB/////wcCfyAimUQAAAAAAADgQWMEQCAiqgwBC0GAgICAeAtBgICAgHggABsgIkQAAMD////fQWQbICIgImIbtyIhRAAAAAAAAHDBoqAiIkQAAAAAAADgwWYhACAHQegDaiAFQQJ0akEAQf////8HAn8gIplEAAAAAAAA4EFjBEAgIqoMAQtBgICAgHgLQYCAgIB4IAAbICJEAADA////30FkGyAiICJiGzYCACADIBdqIQYgBUEBaiEFCyAhRAAAAAAAAODBZiEAIAdB6ANqIAVBAnRqQQBB/////wcCfyAhmUQAAAAAAADgQWMEQCAhqgwBC0GAgICAeAtBgICAgHggABsgIUQAAMD////fQWQbICEgIWIbNgIACwJ8AkACQCAGQf8HTARARAAAAAAAAPA/IAZBgnhODQMaIAZBuHBNDQEgBkHJB2ohBkQAAAAAAABgAwwDCyAGQf4PSw0BIAZBgXhqIQZEAAAAAAAA4H8MAgsgBkHwaCAGQfBoShtBkg9qIQZEAAAAAAAAAAAMAQsgBkH9FyAGQf0XSBtBgnBqIQZEAAAAAAAA8H8LIAZB/wdqrUI0hr+iISEgBUEBcQR/IAUFIAdByAJqIAVBA3RqICEgB0HoA2ogBUECdGooAgC3ojkDACAhRAAAAAAAAHA+oiEhIAVBf2oLIQAgBQRAIABBA3QgB2pBwAJqIQEgAEECdCAHakHkA2ohBANAIAEgIUQAAAAAAABwPqIiIiAEKAIAt6I5AwAgAUEIaiAhIARBBGooAgC3ojkDACABQXBqIQEgBEF4aiEEICJEAAAAAAAAcD6iISEgAEEBRyAAQX5qIQANAAsLIAVBAWohBiAHQcgCaiAFQQN0aiEIIAUhAQNAAkAgCiAFIAEiAGsiAyAKIANJGyINRQRAQQAhBEQAAAAAAAAAACEhDAELIA1BAWpBfnEhCUQAAAAAAAAAACEhQQAhAUEAIQQDQCAhIAFBmILAAGorAwAgASAIaiILKwMAoqAgAUGggsAAaisDACALQQhqKwMAoqAhISABQRBqIQEgCSAEQQJqIgRHDQALCyAHQagBaiADQQN0aiANQQFxBHwgIQUgISAEQQN0QZiCwABqKwMAIAdByAJqIAAgBGpBA3RqKwMAoqALOQMAIAhBeGohCCAAQX9qIQEgAA0ACwJAIAZBA3EiAEUEQEQAAAAAAAAAACEhIAUhBAwBCyAHQagBaiAFQQN0aiEBRAAAAAAAAAAAISEgBSEEA0AgBEF/aiEEICEgASsDAKAhISABQXhqIQEgAEF/aiIADQALCyAFQQNPBEAgBEEDdCAHakGQAWohAQNAICEgAUEYaisDAKAgAUEQaisDAKAgAUEIaisDAKAgASsDAKAhISABQWBqIQEgBEEDRyAEQXxqIQQNAAsLIAIgIZogISAMGzkDACAHKwOoASAhoSEhAkAgBUUNAEEBIQEDQCAhIAdBqAFqIAFBA3RqKwMAoCEhIAEgBU8NASABIAEgBUlqIgEgBU0NAAsLIAIgIZogISAMGzkDCCAHQcAEaiQAIA5BB3ELtxIDA38BfgR8IwBBMGsiBCQAAkACQAJAAkACQCABvSIFQiCIpyIDQf////8HcSICQfvUvYAETwRAIAJBvIzxgARPBEAgBEEAQf////8HAn8CQCACQfvD5IkETwRAIAJB//+//wdLDQUgBUL/////////B4NCgICAgICAgLDBAIS/IgFEAAAAAAAA4MFmIQMgAZlEAAAAAAAA4EFjRQ0BIAGqDAILAkAgAkEUdiICIAEgAUSDyMltMF/kP6JEAAAAAAAAOEOgRAAAAAAAADjDoCIGRAAAQFT7Ifm/oqAiASAGRDFjYhphtNA9oiIJoSIIvUI0iKdB/w9xa0ERSA0AIAIgASAGRAAAYBphtNA9oiIIoSIHIAZEc3ADLooZozuiIAEgB6EgCKGhIgmhIgi9QjSIp0H/D3FrQTJIBEAgByEBDAELIAcgBkQAAAAuihmjO6IiCKEiASAGRMFJICWag3s5oiAHIAGhIAihoSIJoSEICyAAIAg5AwAgACABIAihIAmhOQMQIAZEAAAAAAAA4MFmIQMgAEEAQf////8HAn8gBplEAAAAAAAA4EFjBEAgBqoMAQtBgICAgHgLQYCAgIB4IAMbIAZEAADA////30FkGyAGIAZiGzYCCAwIC0GAgICAeAtBgICAgHggAxsgAUQAAMD////fQWQbIAEgAWIbtyIHOQMAIAEgB6FEAAAAAAAAcEGiIgFEAAAAAAAA4MFmIQMgBEEAQf////8HAn8gAZlEAAAAAAAA4EFjBEAgAaoMAQtBgICAgHgLQYCAgIB4IAMbIAFEAADA////30FkGyABIAFiGyIDtyIHOQMIIAQgASAHoUQAAAAAAABwQaIiATkDECAEQShqQgA3AwAgBEEgakIANwMAIARCADcDGCAEQQJBASADG0EDIAFEAAAAAAAAAABhGyAEQRhqIAJBFHZB6ndqEAAhAiAFQn9VBEAgACACNgIIIAAgBCsDIDkDECAAIAQrAxg5AwAMBwsgAEEAIAJrNgIIIAAgBCsDIJo5AxAgACAEKwMYmjkDAAwGCyACQb3714AETwRAIAJB+8PkgARGBEACQCABIAFEg8jJbTBf5D+iRAAAAAAAADhDoEQAAAAAAAA4w6AiBkQAAEBU+yH5v6KgIgEgBkQxY2IaYbTQPaIiCaEiCL1CgICAgICAgPj/AINC/////////4c/Vg0AIAEgBkQAAGAaYbTQPaIiCKEiByAGRHNwAy6KGaM7oiABIAehIAihoSIJoSIIvUKAgICAgICAgP8Ag0L//////////zxWBEAgByEBDAELIAcgBkQAAAAuihmjO6IiCKEiASAGRMFJICWag3s5oiAHIAGhIAihoSIJoSEICyAAIAg5AwAgACABIAihIAmhOQMQIAZEAAAAAAAA4MFmIQMgAEEAQf////8HAn8gBplEAAAAAAAA4EFjBEAgBqoMAQtBgICAgHgLQYCAgIB4IAMbIAZEAADA////30FkGyAGIAZiGzYCCAwHCyAFQgBZBEAgAEEENgIIIAAgAUQAAEBU+yEZwKAiAUQxY2IaYbTwvaAiBzkDACAAIAEgB6FEMWNiGmG08L2gOQMQDAcLIABBfDYCCCAAIAFEAABAVPshGUCgIgFEMWNiGmG08D2gIgc5AwAgACABIAehRDFjYhphtPA9oDkDEAwGCyACQfyyy4AERg0EIAVCAFkEQCAAQQM2AgggACABRAAAMH982RLAoCIBRMqUk6eRDum9oCIHOQMAIAAgASAHoUTKlJOnkQ7pvaA5AxAMBgsgAEF9NgIIIAAgAUQAADB/fNkSQKAiAUTKlJOnkQ7pPaAiBzkDACAAIAEgB6FEypSTp5EO6T2gOQMQDAULIANB//8/cUH7wyRGDQIgAkH9souABE8EQCAFQn9VBEAgAEECNgIIIAAgAUQAAEBU+yEJwKAiAUQxY2IaYbTgvaAiBzkDACAAIAEgB6FEMWNiGmG04L2gOQMQDAYLIABBfjYCCCAAIAFEAABAVPshCUCgIgFEMWNiGmG04D2gIgc5AwAgACABIAehRDFjYhphtOA9oDkDEAwFCyAFQn9VDQEgAEF/NgIIIAAgAUQAAEBU+yH5P6AiAUQxY2IaYbTQPaAiBzkDACAAIAEgB6FEMWNiGmG00D2gOQMQDAQLIABBADYCCCAAIAEgAaEiATkDECAAIAE5AwAMAwsgAEEBNgIIIAAgAUQAAEBU+yH5v6AiAUQxY2IaYbTQvaAiBzkDACAAIAEgB6FEMWNiGmG00L2gOQMQDAILAkAgAkEUdiICIAEgAUSDyMltMF/kP6JEAAAAAAAAOEOgRAAAAAAAADjDoCIGRAAAQFT7Ifm/oqAiASAGRDFjYhphtNA9oiIJoSIIvUI0iKdB/w9xa0ERSA0AIAIgASAGRAAAYBphtNA9oiIIoSIHIAZEc3ADLooZozuiIAEgB6EgCKGhIgmhIgi9QjSIp0H/D3FrQTJIBEAgByEBDAELIAcgBkQAAAAuihmjO6IiCKEiASAGRMFJICWag3s5oiAHIAGhIAihoSIJoSEICyAAIAg5AwAgACABIAihIAmhOQMQIAZEAAAAAAAA4MFmIQMgAEEAQf////8HAn8gBplEAAAAAAAA4EFjBEAgBqoMAQtBgICAgHgLQYCAgIB4IAMbIAZEAADA////30FkGyAGIAZiGzYCCAwBCwJAIAEgAUSDyMltMF/kP6JEAAAAAAAAOEOgRAAAAAAAADjDoCIGRAAAQFT7Ifm/oqAiASAGRDFjYhphtNA9oiIJoSIIvUKAgICAgICA+P8Ag0L/////////hz9WDQAgASAGRAAAYBphtNA9oiIIoSIHIAZEc3ADLooZozuiIAEgB6EgCKGhIgmhIgi9QoCAgICAgICA/wCDQv//////////PFYEQCAHIQEMAQsgByAGRAAAAC6KGaM7oiIIoSIBIAZEwUkgJZqDezmiIAcgAaEgCKGhIgmhIQgLIAAgCDkDACAAIAEgCKEgCaE5AxAgBkQAAAAAAADgwWYhAyAAQQBB/////wcCfyAGmUQAAAAAAADgQWMEQCAGqgwBC0GAgICAeAtBgICAgHggAxsgBkQAAMD////fQWQbIAYgBmIbNgIICyAEQTBqJAALzA8DCX8CfgV8RAAAAAAAAPA/IQ0CQAJAAkACQCABvSILQiCIpyIIQf////8HcSICIAunIgZyRQ0AIAC9IgxCIIinIQQgDKciCUVBACAEQYCAwP8DRhsNAAJAAkACQAJAAkACQCAEQf////8HcSIFQYCAwP8HSw0AAkAgBUGAgMD/B0YEQCAJIAJBgIDA/wdLcg0CDAELIAJBgYDA/wdPDQELIAJBgIDA/wdHDQEgBg0AIAVBgIDAgHxqIAlyRQ0GIAVB//+//wNLDQJEAAAAAAAAAAAgAZogC0J/VRsPCyAAIAGgDwsgDEIAUw0BIAYNAyACQYCAwP8DRw0CDAULIAFEAAAAAAAAAAAgC0J/VRsPC0ECIQMCQAJAIAJB////mQRLDQBBACEDIAJBgIDA/wNJDQAgAkEUdiEHIAJB////iQRNBEAgBg0EIAJBEyAHayIGdiIHIAZ0IAJHDQJBAiAHQQFxayEDDAILIAZBEyAHayIHdiIKIAd0IAZHDQBBAiAKQQFxayEDIAYNAwwBCyAGDQILIAJBgIDA/wNGDQMLIAhBgICA/wNHBEAgCEGAgICABEcNASAAIACiDwsgDEIAUw0AIAAQBA8LIACZIQ0CQAJAIAkNACAEQX9MBEAgBEGAgICAeEYgBEGAgMD/e0ZyDQIgBEGAgEBHDQEMAgsgBEUgBEGAgMD/A0ZyIARBgIDA/wdGcg0BC0QAAAAAAADwPyEPAkAgDEIAWQ0AAkACQCADDgIAAQILIAAgAKEiACAAow8LRAAAAAAAAPC/IQ8LAkAgAkGAgICPBE0EQCANRAAAAAAAAEBDoiIAIA0gBUGAgMAASSICGyENIAC9QiCIpyAFIAIbIgVB//8/cSIDQYCAwP8DciEEIAVBFHVBzHdBgXggAhtqIQVBACECAkAgA0GPsQ5JDQAgA0H67C5JBEBBASECDAELIANBgICA/wNyIQQgBUEBaiEFCyACQQN0IgNBqIPAAGorAwBEAAAAAAAA8D8gA0GYg8AAaisDACIAIA29Qv////8PgyAErUIghoS/IhCgoyINIBAgAKEiDiACQRJ0IARBAXZqQYCAoIACaq1CIIa/IhEgDiANoiIOvUKAgICAcIO/Ig2ioSAQIBEgAKGhIA2ioaIiACANIA2iIhBEAAAAAAAACECgIAAgDiANoKIgDiAOoiIAIACiIAAgACAAIAAgAETvTkVKKH7KP6JEZdvJk0qGzT+gokQBQR2pYHTRP6CiRE0mj1FVVdU/oKJE/6tv27Zt2z+gokQDMzMzMzPjP6CioCIRoL1CgICAgHCDvyIAoiAOIBEgAEQAAAAAAAAIwKAgEKGhoqAiDiAOIA0gAKIiDaC9QoCAgIBwg78iACANoaFE/QM63AnH7j+iIABE9QFbFOAvPr6ioKAiDSADQbiDwABqKwMAIg4gDSAARAAAAOAJx+4/oiINoKAgBbciEKC9QoCAgIBwg78iACAQoSAOoSANoaEhDgwBCwJAAkAgAkGAgMCfBE0EQCAFQf//v/8DSQ0CIAVBgIDA/wNLDQEgDUQAAAAAAADwv6AiAERE3134C65UPqIgACAAokQAAAAAAADgPyAAIABEAAAAAAAA0L+iRFVVVVVVVdU/oKKhokT+gitlRxX3v6KgIg0gDSAARAAAAGBHFfc/oiINoL1CgICAgHCDvyIAIA2hoSEODAMLIAVB//+//wNNBEBEAAAAAAAA8H9EAAAAAAAAAAAgC0IAUxsPC0QAAAAAAADwf0QAAAAAAAAAACAIQQBKGw8LIAhBAEwNBQwGCyALQgBZDQQMBQsgACALQoCAgIBwg78iEKIiDSAOIAGiIAEgEKEgAKKgIgCgIgG9IgunIQICQCALQiCIpyIDQf//v4QETARAIANBgPj//wdxQf+Xw4QETQ0BIANBgOi8+wNqIAJyDQUgACABIA2hZUUNAQwFCyADQYCAwPt7aiACcg0FIABE/oIrZUcVlzygIAEgDaFkRQ0ADAULQQAhAiAPAnwgA0H/////B3FBgICA/wNLBH5BAEGAgMAAIANBFHZBAmp2IANqIgNB//8/cUGAgMAAckETIANBFHYiBGt2IgJrIAIgC0IAUxshAiAAIA1BgIBAIARBAWp1IANxrUIghr+hIg2gvQUgCwtCgICAgHCDvyIBRAAAAABDLuY/oiIOIAAgASANoaFE7zn6/kIu5j+iIAFEOWyoDGFcIL6ioCINoCIAIAAgACAAIACiIgEgASABIAEgAUTQpL5yaTdmPqJE8WvSxUG9u76gokQs3iWvalYRP6CiRJO9vhZswWa/oKJEPlVVVVVVxT+goqEiAaIgAUQAAAAAAAAAwKCjIA0gACAOoaEiASAAIAGioKGhRAAAAAAAAPA/oCIAvSILQiCIpyACQRR0aiIDQYCAwABOBEAgC0L/////D4MgA61CIIaEvwwBCyAAIAIQDguiIQ0MAQtEAAAAAAAA8D8gDaMgDSALQgBTGyENIAxCf1UNACADIAVBgIDAgHxqckUEQCANIA2hIgAgAKMPCyANmiANIANBAUYbDwsgDQ8LIAtCf1UEQCAADwtEAAAAAAAA8D8gAKMPCyAPRFnz+MIfbqUBokRZ8/jCH26lAaIPCyAPRJx1AIg85Dd+okScdQCIPOQ3fqILswcDBH8BfgN8IwBBIGsiAiQAAkACQAJ8AkACQCAAvSIFQiCIp0H/////B3EiAUH8w6T/A08EQCABQf//v/8HTQRAIAJBCGogABABIAIoAhAhAyACKwMYIQggAisDCCIHvSIFQoCAgICA/////wCDQoCAgIDwhOXyP1YiBA0CDAULIAAgAKEhAAwFCyABQYCAgPIDTwRAIAVCgICAgID/////AINCgICAgPCE5fI/ViIBDQIgAAwDCyACIABEAAAAAAAAcDiiIABEAAAAAAAAcEegIAFBgIDAAEkbOQMIIAIrAwgaDAQLRBgtRFT7Iek/IAcgB5ogBUJ/VSIBG6FEB1wUMyamgTwgCCAImiABG6GgIQdEAAAAAAAAAAAhCAwCC0QYLURU+yHpPyAAmiAAIAVCAFMboUQHXBQzJqaBPKALIgcgByAHIAeiIgaiIgBEY1VVVVVV1T+iIAYgACAGIAaiIgAgACAAIAAgAERzU2Dby3XzvqJEppI3oIh+FD+gokQBZfLy2ERDP6CiRCgDVskibW0/oKJEN9YGhPRklj+gokR6/hARERHBP6AgBiAAIAAgACAAIABE1Hq/dHAq+z6iROmn8DIPuBI/oKJEaBCNGvcmMD+gokQVg+D+yNtXP6CiRJOEbunjJoI/oKJE/kGzG7qhqz+goqCiRAAAAAAAAAAAoKJEAAAAAAAAAACgoCIGoCEAIAFFDQFEAAAAAAAA8D8gByAGIAAgAKIgAEQAAAAAAADwP6CjoaAiACAAoKEiAJogACAFQgBTGyEADAELIANBAXEhASAHIAcgByAHoiIGoiIARGNVVVVVVdU/oiAIIAYgCCAAIAYgBqIiACAAIAAgACAARHNTYNvLdfO+okSmkjegiH4UP6CiRAFl8vLYREM/oKJEKANWySJtbT+gokQ31gaE9GSWP6CiRHr+EBEREcE/oCAGIAAgACAAIAAgAETUer90cCr7PqJE6afwMg+4Ej+gokRoEI0a9yYwP6CiRBWD4P7I21c/oKJEk4Ru6eMmgj+gokT+QbMbuqGrP6CioKKgoqCgIgigIQAgBEUEQCABRQ0BRAAAAAAAAPC/IACjIgYgAL1CgICAgHCDvyIAIAa9QoCAgIBwg78iBqJEAAAAAAAA8D+gIAggACAHoaEgBqKgoiAGoCEADAELRAAAAAAAAPA/IAG3IgYgBqChIgYgByAIIAAgAKIgBiAAoKOhoCIAIACgoSIAmiAAIAVCAFMbIQALIAJBIGokACAAC9UEAgl/AX4gAL0iCkIgiKciAUGAgMD/B3FBgIDA/wdGBEAgACAAoiAAoA8LIAqnIQICfwJ/AkACQAJAAkAgAUEATARAIAFB/////wdxIAJyRQ0CIApCf1cNAQsgAUEUdSABQf//P0sNBRpBASEEIAEEQCACIQMMBAsgAiEDA0AgBEFraiEEIAMiAkEVdCEDIAJBgBBJDQALDAILIAAgAKEiACAAoyEACyAADwsgAkELdiIBIAJBAEgNARoLIAFBFCABZ0Efc2siBXQLIQEgAyAFdCECIANBACAFa3YgAXIhASAEIAVrCyABQf//P3FBgIDAAHIhA0GBeGoiCUEBcQRAIANBAXQgAkEfdnIhAyACQQF0IQILIANBAXQgAkEfdnIhBCACQQF0IQNBgICAASEBQQAhAgNAIAIgASACaiIFIAFqIAUgBEoiBhshAiAEQQAgBSAGG2tBAXQgA0EfdnIhBCADQQF0IQNBACABIAYbIAdqIQcgAUEBSyABQQF2IQENAAtBgICAgHghBUEAIQYDQCAEIAJMQQAgAiAERyADIAggBSIBaiIFSXIbRQRAIAQgAmsgAyAFSWshBCACIAVBAEggASAFaiIIQX9KcWohAiABIAZqIQYgAyAFayEDCyAEQQF0IANBH3ZyIQQgAUEBdiEFIANBAXQhAyABQQJPDQALAkAgAyAEckUNACAGQX9GBEAgB0EBaiEHQQAhBgwBCyAGQQFxIAZqIQYLIAdBH3QgBkEBdnKtIAlBE3RBgIBAcSAHQQF1akGAgID/A2qtQiCGhL8LrQUDA38BfgJ8IwBBEGshASAAvSIEQj+IpyECAkACfCAAAn8CQAJAAkACQCAEQiCIp0H/////B3EiA0GrxpiEBE8EQCAAIABiBEAgAA8LIABE7zn6/kIuhkBkDQIgAETSvHrdKyOGwGNFDQEgAUQAAAAAAACgtiAAo7Y4AgQgASoCBBogAERRMC3VEEmHwGNFDQEMBwsgA0HC3Nj+A00EQCADQYCAwPEDTQ0DQQAhASAADAYLIANBscXC/wNNDQMLIABE/oIrZUcV9z+iIAJBA3RBiIPAAGorAwCgIgVEAAAAAAAA4MFmIQJBAEH/////BwJ/IAWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4C0GAgICAeCACGyAFRAAAwP///99BZBsgBSAFYhsMAwsgAEQAAAAAAADgf6IPCyABIABEAAAAAAAA4H+gOQMIIAErAwgaIABEAAAAAAAA8D+gDwsgAkEBcyACawsiAbciBUQAAOD+Qi7mv6KgIgAgBUR2PHk17znqPaIiBqELIQUgACAFIAUgBSAFoiIAIAAgACAAIABE0KS+cmk3Zj6iRPFr0sVBvbu+oKJELN4lr2pWET+gokSTvb4WbMFmv6CiRD5VVVVVVcU/oKKhIgCiRAAAAAAAAABAIAChoyAGoaBEAAAAAAAA8D+gIQUgAUUNAAJAAkACQCABQf8HTARAIAFBgnhODQMgBUQAAAAAAABgA6IhBSABQbhwTQ0BIAFByQdqIQEMAwsgBUQAAAAAAADgf6IhBSABQf4PSw0BIAFBgXhqIQEMAgsgBUQAAAAAAABgA6IhBSABQfBoIAFB8GhKG0GSD2ohAQwBCyAFRAAAAAAAAOB/oiEFIAFB/RcgAUH9F0gbQYJwaiEBCyAFIAFB/wdqrUI0hr+iIQULIAULygUDAX8BfgF8AkAgAL0iAkIgiKdB/////wdxIgFB//+//wNNBEAgAUGAgID/A08EQCACQn9VBEBEAAAAAAAA8D8gAKFEAAAAAAAA4D+iIgAgACAAIAAgACAARAn3/Q3hPQI/okSIsgF14O9JP6CiRDuPaLUogqS/oKJEVUSIDlXByT+gokR9b+sDEtbUv6CiRFVVVVVVVcU/oKIgACAAIAAgAESCki6xxbizP6JEWQGNG2wG5r+gokTIilmc5SoAQKCiREstihwnOgPAoKJEAAAAAAAA8D+goyAAEAQiA6IgACADvUKAgICAcIO/IgAgAKKhIAMgAKCjoCAAoCIAIACgDwtEGC1EVPsh+T8gAEQAAAAAAADwP6BEAAAAAAAA4D+iIgAQBCIDIAMgACAAIAAgACAAIABECff9DeE9Aj+iRIiyAXXg70k/oKJEO49otSiCpL+gokRVRIgOVcHJP6CiRH1v6wMS1tS/oKJEVVVVVVVVxT+goiAAIAAgACAARIKSLrHFuLM/okRZAY0bbAbmv6CiRMiKWZzlKgBAoKJESy2KHCc6A8CgokQAAAAAAADwP6CjokQHXBQzJqaRvKCgoSIAIACgIQMMAgtEGC1EVPsh+T8hAyABQYGAgOMDSQ0BRAdcFDMmppE8IAAgAKIiAyADIAMgAyADIANECff9DeE9Aj+iRIiyAXXg70k/oKJEO49otSiCpL+gokRVRIgOVcHJP6CiRH1v6wMS1tS/oKJEVVVVVVVVxT+goiADIAMgAyADRIKSLrHFuLM/okRZAY0bbAbmv6CiRMiKWZzlKgBAoKJESy2KHCc6A8CgokQAAAAAAADwP6CjIACioSAAoUQYLURU+yH5P6APCyACpyABQYCAwIB8anIEQEQAAAAAAAAAACAAIAChow8LRAAAAAAAAAAARBgtRFT7IQlAIAJCf1UbDwsgAwvJBAMBfwF+A3wgAL0iAkIgiKdB/////wdxIgFB//+//wNNBEACQAJ8AkAgAUGAgID/A08EQEQAAAAAAADwPyAAmaFEAAAAAAAA4D+iIgAgACAAIAAgACAARAn3/Q3hPQI/okSIsgF14O9JP6CiRDuPaLUogqS/oKJEVUSIDlXByT+gokR9b+sDEtbUv6CiRFVVVVVVVcU/oKIgACAAIAAgAESCki6xxbizP6JEWQGNG2wG5r+gokTIilmc5SoAQKCiREstihwnOgPAoKJEAAAAAAAA8D+goyEFIAAQBCEDIAFBsua8/wNLDQFEGC1EVPsh6T8gA71CgICAgHCDvyIEIASgoUQHXBQzJqaRPCAAIAQgBKKhIAMgBKCjIgAgAKChIAUgAyADoKKhoEQYLURU+yHpP6AMAgsgAUGAgEBqQYCAgPIDSQ0CIAAgAKIiAyADIAMgAyADIANECff9DeE9Aj+iRIiyAXXg70k/oKJEO49otSiCpL+gokRVRIgOVcHJP6CiRH1v6wMS1tS/oKJEVVVVVVVVxT+goiADIAMgAyADRIKSLrHFuLM/okRZAY0bbAbmv6CiRMiKWZzlKgBAoKJESy2KHCc6A8CgokQAAAAAAADwP6CjIACiIACgDwtEGC1EVPsh+T8gAyAFIAOioCIAIACgRAdcFDMmppG8oKELIgCaIAAgAkIAUxshAAsgAA8LIAKnIAFBgIDAgHxqcgRARAAAAAAAAAAAIAAgAKGjDwsgAEQYLURU+yH5P6JEAAAAAAAAcDigC48EAwJ/AX4DfCMAQRBrIQICQAJ/AkACQAJAIAC9IgNCIIinQf////8HcSIBQf//v6AETQRAIAFBgIDw/gNJDQEgAJkhACABQYCAzP8DSQ0DIAFBgICOgARJDQJEAAAAAAAA8L8gAKMhAEEDDAQLIAAgAGINBEQYLURU+yH5PyAApg8LQX8gAUGAgIDyA08NAhogAUGAgMAATw0DIAIgALY4AgwgAioCDBogAA8LIABEAAAAAAAA+L+gIABEAAAAAAAA+D+iRAAAAAAAAPA/oKMhAEECDAELIAFBgICY/wNPBEAgAEQAAAAAAADwv6AgAEQAAAAAAADwP6CjIQBBAQwBCyAAIACgRAAAAAAAAPC/oCAARAAAAAAAAABAoKMhAEEACyECIAAgAKIiBSAFoiIEIAQgBCAEIAREL2xqLES0or+iRJr93lIt3q2/oKJEbZp0r/Kws7+gokRxFiP+xnG8v6CiRMTrmJmZmcm/oKIhBiAFIAQgBCAEIAQgBEQR2iLjOq2QP6JE6w12JEt7qT+gokRRPdCgZg2xP6CiRG4gTMXNRbc/oKJE/4MAkiRJwj+gokQNVVVVVVXVP6CiIQQgAUGAgPD+A08EQCACQQN0IgFByIPAAGorAwAgACAGIASgoiABQeiDwABqKwMAoSAAoaEiAJogACADQgBTGw8LIAAgACAGIASgoqEhAAsgAAvnAwMDfwF+BnwCQAJAAkACQCAAvSIEQgBTDQAgBEIgiKciAUGAgMAASQ0AIAFB//+//wdLDQNBgIDA/wMhAkGBeCEDIAFBgIDA/wNHBEAgASECDAILIASnDQFEAAAAAAAAAAAPCyAAvUL///////////8Ag1AEQEQAAAAAAADwvyAAIACiow8LIARCAFMNASAARAAAAAAAAFBDor0iBEIgiKchAkHLdyEDCyACQeK+JWoiAUEUdiADarciB0QAYJ9QE0TTP6IiCCAEQv////8PgyABQf//P3FBnsGa/wNqrUIghoS/RAAAAAAAAPC/oCIAIAAgAEQAAAAAAADgP6KiIgWhvUKAgICAcIO/IgZEAAAgFXvL2z+iIgmgIgogCSAIIAqhoCAAIAahIAWhIAAgAEQAAAAAAAAAQKCjIgAgBSAAIACiIgUgBaIiACAAIABEn8Z40Amawz+iRK94jh3Fccw/oKJEBPqXmZmZ2T+goiAFIAAgACAARERSPt8S8cI/okTeA8uWZEbHP6CiRFmTIpQkSdI/oKJEk1VVVVVV5T+goqCgoqAiAEQAACAVe8vbP6IgB0Q2K/ER8/5ZPaIgACAGoETVrZrKOJS7PaKgoKCgDwsgACAAoUQAAAAAAAAAAKMhAAsgAAvOAwMDfwF+BXwCQAJAAkACQCAAvSIEQgBTDQAgBEIgiKciAUGAgMAASQ0AIAFB//+//wdLDQNBgIDA/wMhAkGBeCEDIAFBgIDA/wNHBEAgASECDAILIASnDQFEAAAAAAAAAAAPCyAAvUL///////////8Ag1AEQEQAAAAAAADwvyAAIACiow8LIARCAFMNASAARAAAAAAAAFBDor0iBEIgiKchAkHLdyEDCyAEQv////8PgyACQeK+JWoiAUH//z9xQZ7Bmv8Daq1CIIaEv0QAAAAAAADwv6AiACAAIABEAAAAAAAA4D+ioiIFob1CgICAgHCDvyIGRAAAIGVHFfc/oiIHIAFBFHYgA2q3IgigIgkgByAIIAmhoCAAIAahIAWhIAAgAEQAAAAAAAAAQKCjIgAgBSAAIACiIgUgBaIiACAAIABEn8Z40Amawz+iRK94jh3Fccw/oKJEBPqXmZmZ2T+goiAFIAAgACAARERSPt8S8cI/okTeA8uWZEbHP6CiRFmTIpQkSdI/oKJEk1VVVVVV5T+goqCgoqAiAEQAACBlRxX3P6IgACAGoEQAou8u/AXnPaKgoKAPCyAAIAChRAAAAAAAAAAAoyEACyAAC6UDAgV/AX4gASABYSAAIABhcUUEQCAAIAGgDwsgAb0iB0IgiKciAkGAgMCAfGogB6ciBXJFBEAgABAIDwsgAkEedkECcSIGIAC9IgdCP4inciEDAkACQAJAIAdCIIinQf////8HcSIEIAenckUEQEQYLURU+yEJwCEBAkACQCADDgMAAAEDCyAADwtEGC1EVPshCUAPCyACQf////8HcSICIAVyRQ0CAkAgAkGAgMD/B0YEQCAEQYCAwP8HRw0BRNIhM3982QLAIQEgA0EDRg0CIANBA3RB2ILAAGorAwAPCyAEQYCAwP8HRiACQYCAgCBqIARJcg0CAnwgBgRARAAAAAAAAAAAIARBgICAIGogAkkNARoLIAAgAaOZEAgLIQECQAJAAkAgAw4DBAECAAsgAUQHXBQzJqahvKBEGC1EVPshCcCgDwsgAZoPC0QYLURU+yEJQCABRAdcFDMmpqG8oKEPC0QYLURU+yEJwCEBIANBA0YNACADQQN0QfCCwABqKwMAIQELIAEPC0QYLURU+yH5PyAApg8LRBgtRFT7Ifk/IACmC54DAwN/AX4CfAJAAkACQAJAIAC9IgRCAFMNACAEQiCIpyIBQYCAwABJDQAgAUH//7//B0sNA0GAgMD/AyECQYF4IQMgAUGAgMD/A0cEQCABIQIMAgsgBKcNAUQAAAAAAAAAAA8LIAC9Qv///////////wCDUARARAAAAAAAAPC/IAAgAKKjDwsgBEIAUw0BIABEAAAAAAAAUEOivSIEQiCIpyECQct3IQMLIAJB4r4laiIBQRR2IANqtyIFRAAA4P5CLuY/oiAEQv////8PgyABQf//P3FBnsGa/wNqrUIghoS/RAAAAAAAAPC/oCIAIAVEdjx5Ne856j2iIAAgAEQAAAAAAAAAQKCjIgUgACAARAAAAAAAAOA/oqIiBiAFIAWiIgUgBaIiACAAIABEn8Z40Amawz+iRK94jh3Fccw/oKJEBPqXmZmZ2T+goiAFIAAgACAARERSPt8S8cI/okTeA8uWZEbHP6CiRFmTIpQkSdI/oKJEk1VVVVVV5T+goqCgoqAgBqGgoA8LIAAgAKFEAAAAAAAAAACjIQALIAALjgEBAn8gAUEQTwRAIABBACAAa0EDcSIDaiECIAMEQANAIABBADoAACAAQQFqIgAgAkkNAAsLIAIgASADayIBQXxxIgNqIQAgA0EBTgRAA0AgAkEANgIAIAJBBGoiAiAASQ0ACwsgAUEDcSEBCyABBEAgACABaiEBA0AgAEEAOgAAIABBAWoiACABSQ0ACwsLrAEAAkACQAJAIAFB/wdMBEAgAUGCeE4NAyAARAAAAAAAAGADoiEAIAFBuHBNDQEgAUHJB2ohAQwDCyAARAAAAAAAAOB/oiEAIAFB/g9LDQEgAUGBeGohAQwCCyAARAAAAAAAAGADoiEAIAFB8GggAUHwaEobQZIPaiEBDAELIABEAAAAAAAA4H+iIQAgAUH9FyABQf0XSBtBgnBqIQELIAAgAUH/B2qtQjSGv6ILCAAgACABEA0LCAAgACABEAsLCAAgACABEAILBgAgABAGCwYAIAAQBwsGACAAEAgLBgAgABAFCwYAIAAQDAsGACAAEAQLBgAgABADCwYAIAAQCgsGACAAEAkLC+YKBQBBgIDAAAvwAgMAAAAEAAAABAAAAAYAAACD+aIARE5uAPwpFQDRVycA3TT1AGLbwAA8mZUAQZBDAGNR/gC73qsAt2HFADpuJADSTUIASQbgAAnqLgAcktEA6x3+ACmxHADoPqcA9TWCAES7LgCc6YQAtCZwAEF+XwDWkTkAU4M5AJz0OQCLX4QAKPm9APgfOwDe/5cAD5gFABEv7wAKWosAbR9tAM9+NgAJyycARk+3AJ5mPwAt6l8Auid1AOXrxwA9e/EA9zkHAJJSigD7a+oAH7FfAAhdjQAwA1YAe/xGAPCrawAgvM8ANvSaAOOpHQBeYZEACBvmAIWZZQCgFF8AjUBoAIDY/wAnc00ABgYxAMpWFQDJqHMAe+JgAGuMwAAAAABA+yH5PwAAAAAtRHQ+AAAAgJhG+DwAAABgUcx4OwAAAICDG/A5AAAAQCAlejgAAACAIoLjNgAAAAAd82k1GC1EVPsh6T8YLURU+yHpv9IhM3982QJAAEH/gsAACymAGC1EVPshCUAAAAAAAADgPwAAAAAAAOC/AAAAAAAA8D8AAAAAAAD4PwBBsIPAAAsIBtDPQ+v9TD4AQcODwAALmQdAA7jiP0+7YQVnrN0/GC1EVPsh6T+b9oHSC3PvPxgtRFT7Ifk/4mUvIn8rejwHXBQzJqaBPL3L8HqIB3A8B1wUMyamkTxMYXp5IGluc3RhbmNlIGhhcyBwcmV2aW91c2x5IGJlZW4gcG9pc29uZWQAAAgCEAAqAAAAQzpcVXNlcnNcSm9uYXRoYW5cLmNhcmdvXHJlZ2lzdHJ5XHNyY1xpbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZlxvbmNlX2NlbGwtMS4yMC4yXHNyYy9saWIucnMAADwCEABiAAAACAMAABkAAAByZWVudHJhbnQgaW5pdAAAsAIQAA4AAAA8AhAAYgAAAHoCAAANAAAABAAAAAwAAAAEAAAABQAAAAYAAAAHAAAAL3J1c3QvZGVwcy9kbG1hbGxvYy0wLjIuNi9zcmMvZGxtYWxsb2MucnNhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA+PSBzaXplICsgbWluX292ZXJoZWFkAPACEAApAAAAqAQAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA8PSBzaXplICsgbWF4X292ZXJoZWFkAADwAhAAKQAAAK4EAAANAAAAbWVtb3J5IGFsbG9jYXRpb24gb2YgIGJ5dGVzIGZhaWxlZAAAmAMQABUAAACtAxAADQAAAGxpYnJhcnkvc3RkL3NyYy9hbGxvYy5yc8wDEAAYAAAAZAEAAAkAAAAEAAAADAAAAAQAAAAIAAAAAAAAAAgAAAAEAAAACQAAAAAAAAAIAAAABAAAAAoAAAALAAAADAAAAA0AAAAOAAAAEAAAAAQAAAAPAAAAEAAAABEAAAASAAAAY2FwYWNpdHkgb3ZlcmZsb3cAAABMBBAAEQAAAGxpYnJhcnkvYWxsb2Mvc3JjL3Jhd192ZWMucnNoBBAAHAAAABkAAAAFAAAAMDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTkAQfSKwAALAQEAfAlwcm9kdWNlcnMCCGxhbmd1YWdlAQRSdXN0AAxwcm9jZXNzZWQtYnkDBXJ1c3RjHTEuODEuMCAoZWViOTBjZGExIDIwMjQtMDktMDQpBndhbHJ1cwYwLjIzLjMMd2FzbS1iaW5kZ2VuEzAuMi4xMDAgKDI0MDVlYzJiNCkALA90YXJnZXRfZmVhdHVyZXMCKw9tdXRhYmxlLWdsb2JhbHMrCHNpZ24tZXh0"), (e => e.charCodeAt(0))))).exports;
                Math = {
                    E: 2.718281828459045,
                    LN10: 2.302585092994046,
                    LN2: .6931471805599453,
                    LOG2E: 1.4426950408889634,
                    LOG10E: .4342944819032518,
                    PI: 3.141592653589793,
                    SQRT1_2: .7071067811865476,
                    SQRT2: 1.4142135623730951,
                    abs: Math.abs,
                    acos: t.acos,
                    asin: t.asin,
                    atan: t.atan,
                    atan2: t.atan2,
                    ceil: Math.ceil,
                    cos: function(e) {
                        return Math.sin(e + Math.PI / 2)
                    },
                    exp: t.exp,
                    floor: Math.floor,
                    log: t.log,
                    max: Math.max,
                    min: Math.min,
                    pow: t.pow,
                    random: Math.random,
                    round: Math.round,
                    sin: function(e) {
                        if (!Number.isFinite(e))
                            return NaN;
                        const t = (e = function(e) {
                            return (e %= 2 * Math.PI) < 0 && (e += 2 * Math.PI),
                                e
                        }(e)) / (2 * Math.PI) * n.length
                            , i = Math.floor(t)
                            , r = (i + 1) % n.length
                            , a = t - i;
                        return n[i] * (1 - a) + n[r] * a
                    },
                    sqrt: t.sqrt,
                    tan: t.tan,
                    clz32: () => e("clz32"),
                    imul: () => e("imul"),
                    sign: Math.sign,
                    log10: t.log10,
                    log2: t.log2,
                    log1p: () => e("log1p"),
                    expm1: () => e("expm1"),
                    cosh: () => e("cosh"),
                    sinh: () => e("sinh"),
                    tanh: () => e("tanh"),
                    acosh: () => e("acosh"),
                    asinh: () => e("asinh"),
                    atanh: () => e("atanh"),
                    hypot: () => e("hypot"),
                    trunc: Math.trunc,
                    cbrt: () => e("cbrt"),
                    fround: Math.fround,
                    [Symbol.toStringTag]: "Math"
                };
                const n = [0, .01745240643728351, .03489949670250097, .05233595624294383, .0697564737441253, .08715574274765817, .10452846326765346, .12186934340514748, .13917310096006544, .15643446504023087, .17364817766693033, .1908089953765448, .20791169081775931, .22495105434386498, .24192189559966773, .25881904510252074, .27563735581699916, .2923717047227367, .3090169943749474, .3255681544571567, .3420201433256687, .35836794954530027, .374606593415912, .3907311284892737, .40673664307580015, .42261826174069944, .4383711467890774, .45399049973954675, .4694715627858908, .48480962024633706, .49999999999999994, .5150380749100542, .5299192642332049, .544639035015027, .5591929034707468, .573576436351046, .5877852522924731, .6018150231520483, .6156614753256583, .6293203910498375, .6427876096865393, .6560590289905073, .6691306063588582, .6819983600624985, .6946583704589973, .7071067811865475, .7193398003386511, .7313537016191705, .7431448254773942, .7547095802227719, .766044443118978, .7771459614569708, .7880107536067219, .7986355100472928, .8090169943749475, .8191520442889918, .8290375725550417, .8386705679454239, .848048096156426, .8571673007021122, .8660254037844386, .8746197071393957, .8829475928589269, .8910065241883678, .898794046299167, .9063077870366499, .9135454576426009, .9205048534524404, .9271838545667873, .9335804264972017, .9396926207859083, .9455185755993167, .9510565162951535, .9563047559630354, .9612616959383189, .9659258262890683, .9702957262759965, .9743700647852352, .9781476007338057, .981627183447664, .984807753012208, .9876883405951378, .9902680687415704, .992546151641322, .9945218953682733, .9961946980917455, .9975640502598242, .9986295347545738, .9993908270190958, .9998476951563913, 1, .9998476951563913, .9993908270190958, .9986295347545738, .9975640502598242, .9961946980917455, .9945218953682734, .9925461516413221, .9902680687415704, .9876883405951377, .984807753012208, .981627183447664, .9781476007338057, .9743700647852352, .9702957262759965, .9659258262890683, .9612616959383189, .9563047559630355, .9510565162951536, .9455185755993168, .9396926207859084, .9335804264972017, .9271838545667874, .9205048534524404, .913545457642601, .90630778703665, .8987940462991669, .8910065241883679, .8829475928589271, .8746197071393959, .8660254037844387, .8571673007021123, .8480480961564261, .8386705679454239, .8290375725550417, .819152044288992, .8090169943749475, .7986355100472927, .788010753606722, .777145961456971, .766044443118978, .7547095802227721, .7431448254773945, .7313537016191706, .7193398003386511, .7071067811865476, .6946583704589975, .6819983600624986, .669130606358858, .6560590289905073, .6427876096865395, .6293203910498374, .6156614753256584, .6018150231520486, .5877852522924732, .5735764363510459, .5591929034707469, .5446390350150273, .5299192642332049, .5150380749100544, .49999999999999994, .48480962024633717, .4694715627858907, .45399049973954686, .4383711467890777, .4226182617406995, .40673664307580004, .39073112848927377, .37460659341591224, .35836794954530066, .3420201433256689, .3255681544571566, .3090169943749475, .29237170472273705, .2756373558169992, .258819045102521, .24192189559966773, .2249510543438652, .20791169081775931, .19080899537654497, .1736481776669307, .15643446504023098, .13917310096006533, .12186934340514755, .10452846326765373, .0871557427476582, .06975647374412552, .05233595624294425, .03489949670250114, .01745240643728344, 12246467991473532e-32, -.017452406437283192, -.0348994967025009, -.052335956242943564, -.06975647374412483, -.08715574274765794, -.1045284632676535, -.12186934340514774, -.13917310096006552, -.15643446504023073, -.17364817766693047, -.19080899537654472, -.20791169081775907, -.22495105434386498, -.2419218955996675, -.25881904510252035, -.2756373558169986, -.29237170472273677, -.30901699437494773, -.32556815445715676, -.34202014332566866, -.35836794954530043, -.374606593415912, -.39073112848927355, -.4067366430757998, -.4226182617406993, -.43837114678907707, -.45399049973954625, -.4694715627858905, -.48480962024633734, -.5000000000000001, -.5150380749100542, -.5299192642332048, -.5446390350150271, -.5591929034707467, -.5735764363510458, -.587785252292473, -.601815023152048, -.6156614753256578, -.6293203910498372, -.6427876096865393, -.6560590289905074, -.6691306063588582, -.6819983600624984, -.6946583704589974, -.7071067811865475, -.7193398003386509, -.7313537016191705, -.743144825477394, -.7547095802227717, -.7660444431189779, -.7771459614569711, -.7880107536067221, -.7986355100472928, -.8090169943749473, -.8191520442889916, -.8290375725550414, -.838670567945424, -.848048096156426, -.8571673007021121, -.8660254037844384, -.8746197071393955, -.882947592858927, -.8910065241883678, -.8987940462991668, -.90630778703665, -.913545457642601, -.9205048534524403, -.9271838545667873, -.9335804264972016, -.9396926207859082, -.9455185755993168, -.9510565162951535, -.9563047559630353, -.961261695938319, -.9659258262890683, -.9702957262759965, -.9743700647852351, -.9781476007338056, -.981627183447664, -.984807753012208, -.9876883405951377, -.9902680687415703, -.992546151641322, -.9945218953682733, -.9961946980917455, -.9975640502598242, -.9986295347545739, -.9993908270190958, -.9998476951563913, -1, -.9998476951563913, -.9993908270190958, -.9986295347545739, -.9975640502598243, -.9961946980917455, -.9945218953682733, -.992546151641322, -.9902680687415704, -.9876883405951378, -.9848077530122081, -.9816271834476641, -.9781476007338056, -.9743700647852352, -.9702957262759966, -.9659258262890684, -.961261695938319, -.9563047559630354, -.9510565162951536, -.945518575599317, -.9396926207859083, -.9335804264972017, -.9271838545667874, -.9205048534524405, -.9135454576426011, -.9063077870366503, -.898794046299167, -.8910065241883679, -.8829475928589271, -.8746197071393956, -.8660254037844386, -.8571673007021123, -.8480480961564262, -.8386705679454243, -.8290375725550416, -.8191520442889918, -.8090169943749476, -.798635510047293, -.7880107536067223, -.7771459614569713, -.7660444431189781, -.7547095802227722, -.743144825477394, -.7313537016191703, -.7193398003386512, -.7071067811865477, -.6946583704589976, -.6819983600624989, -.6691306063588588, -.6560590289905074, -.6427876096865396, -.6293203910498372, -.6156614753256582, -.6018150231520483, -.5877852522924734, -.5735764363510465, -.5591929034707473, -.544639035015027, -.529919264233205, -.5150380749100545, -.5000000000000004, -.48480962024633767, -.4694715627858908, -.45399049973954697, -.4383711467890778, -.4226182617406992, -.40673664307580015, -.3907311284892739, -.37460659341591235, -.35836794954530077, -.34202014332566943, -.3255681544571567, -.3090169943749477, -.29237170472273716, -.27563735581699894, -.2588190451025207, -.24192189559966787, -.22495105434386534, -.20791169081775987, -.19080899537654467, -.1736481776669304, -.15643446504023112, -.13917310096006588, -.12186934340514811, -.1045284632676543, -.08715574274765832, -.06975647374412564, -.05233595624294348, -.034899496702500823, -.01745240643728356]
            }
            ,
            7173: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/windowed.svg"
            }
            ,
            7404: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/car_thumbnail_placeholder.png"
            }
            ,
            7479: (e, t, n) => {
                "use strict";
                n.d(t, {
                    A: () => o
                });
                var i = n(1601)
                    , r = n.n(i)
                    , a = n(6314)
                    , s = n.n(a)()(r());
                s.push([e.id, "\n.timer {\n\tposition: absolute;\n\tbottom: 0;\n\tleft: 0;\n\twidth: 100%;\n\ttext-align: center;\n\topacity: 0.9;\n}\n.timer.up {\n\tbottom: auto;\n\ttop: 0;\n}\n.timer.hidden {\n\tdisplay: none;\n}\n\n.timer > div {\n\tmargin: 0;\n\tpadding: 0;\n\tdisplay: inline-flex;\n\tflex-direction: column;\n\twidth: 240px;\n\tvertical-align: bottom;\n}\n.timer.up > div {\n\tflex-direction: column-reverse;\n\tvertical-align: top;\n}\n.timer > div > .title-container {\n\tposition: relative;\n\tmargin: 0 auto;\n\twidth: 220px;\n\theight: 32px;\n}\n.timer > div > .title-container > h2 {\n\tposition: absolute;\n\tmargin: 0;\n\tpadding: 0;\n\twidth: 100%;\n\toverflow: hidden;\n\ttext-overflow: ellipsis;\n\tcolor: var(--text-color);\n\tfont-size: 26px;\n\tfont-weight: normal;\n\ttext-shadow: 1px 1px 1px var(--surface-color), -1px 1px 1px var(--surface-color), -1px -1px 1px var(--surface-color), 1px -1px 1px var(--surface-color);\n}\n.timer:not(.up) > div > .title-container > .title {\n\tmargin-top: 8px;\n}\n.timer > div > .title-container > .checkpoint-time {\n\topacity: 0;\n\tfont-size: 32px;\n}\n.timer > div > .title-container > .checkpoint-time.green {\n\tcolor: #5f5;\n}\n.timer > div > .title-container > .checkpoint-time.red {\n\tcolor: #f55;\n}\n\n.timer > div > .time {\n\tmargin: 0;\n\tpadding: 0;\n\tbackground-color: var(--surface-color);\n}\n.timer > .left > .time {\n\tpadding: 8px 4px 8px 10px;\n\tclip-path: polygon(8px 0, 100% 0, 100% 100%, 0 100%);\n}\n.timer.up > .left > .time {\n\tclip-path: polygon(0 0, 100% 0, 100% 100%, 8px 100%);\n}\n.timer > .center > .time {\n\tposition: relative;\n\tz-index: 1;\n\tmargin: 0 -12px;\n\tpadding: 8px 10px;\n\tclip-path: polygon(8px 0, calc(100% - 8px) 0, 100% 100%, 0 100%);\n}\n.timer.up > .center > .time {\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 8px) 100%, 8px 100%);\n}\n.timer > .right > .time {\n\tpadding: 8px 10px 8px 4px;\n\tclip-path: polygon(0 0, calc(100% - 8px) 0, 100% 100%, 0 100%);\n}\n.timer.up > .right > .time {\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\n}\n\n.timer > div > .time > p {\n\tmargin: 0;\n\tpadding: 0;\n\tbackground-color: var(--surface-tertiary-color);\n\tcolor: var(--text-color);\n\tfont-size: 34px;\n}\n.timer > .left > .time > p {\n\tclip-path: polygon(6px 0, 100% 0, 100% 100%, 0 100%);\n}\n.timer.up > .left > .time > p {\n\tclip-path: polygon(0 0, 100% 0, 100% 100%, 6px 100%);\n}\n.timer > .center > .time > p {\n\tfont-size: 46px;\n\tclip-path: polygon(6px 0, calc(100% - 6px) 0, 100% 100%, 0 100%);\n}\n.timer.up > .center > .time > p {\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 6px) 100%, 6px 100%);\n}\n.timer > .right > .time > p {\n\tclip-path: polygon(0 0, calc(100% - 6px) 0, 100% 100%, 0 100%);\n}\n.timer.up > .right > .time > p {\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 6px) 100%, 0 100%);\n}\n\n.timer > div > .time > p.green {\n\tcolor: #5f5;\n}\n.timer > div > .time > p.red {\n\tcolor:#f55;\n}\n\n.timer > div > .time > p > span {\n\tdisplay: inline-block;\n\twidth: 0.5em;\n\ttext-align: center;\n}\n.timer > div > .time > p > span.sign {\n\tmargin-left: -4px;\n\twidth: 0.7em;\n}\n", ""]);
                const o = s
            }
            ,
            7581: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/fullscreen.svg"
            }
            ,
            7659: e => {
                "use strict";
                var t = {};
                e.exports = function(e, n) {
                    var i = function(e) {
                        if (void 0 === t[e]) {
                            var n = document.querySelector(e);
                            if (window.HTMLIFrameElement && n instanceof window.HTMLIFrameElement)
                                try {
                                    n = n.contentDocument.head
                                } catch (e) {
                                    n = null
                                }
                            t[e] = n
                        }
                        return t[e]
                    }(e);
                    if (!i)
                        throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
                    i.appendChild(n)
                }
            }
            ,
            7687: (e, t, n) => {
                "use strict";
                n.d(t, {
                    A: () => o
                });
                var i = n(1601)
                    , r = n.n(i)
                    , a = n(6314)
                    , s = n.n(a)()(r());
                s.push([e.id, "\n.track-export > .background {\n\tposition: absolute;\n\tleft: 0;\n\ttop: 0;\n\tz-index: 1;\n\twidth: 100%;\n\theight: 100%;\n\tbackground-color: rgba(20, 20, 30, 0.5);\n\tpointer-events: auto;\n}\n\n.track-export > .box {\n\tposition: absolute;\n\tleft: calc(50% - 80% / 2);\n\ttop: 20px;\n\tz-index: 2;\n\tmargin: 0;\n\tpadding: 10px;\n\tbox-sizing: border-box;\n\twidth: 80%;\n\theight: calc(100% - 20px * 2);\n\tbackground-color: var(--surface-color);\n}\n\n.track-export > .box > .bar {\n\ttext-align: left;\n\tpointer-events: auto;\n}\n.track-export > .box > .bar > .button.right {\n\tfloat: right;\n}\n\n.track-export > .box > textarea {\n\tmargin: 10px 0 0 0;\n\tpadding: 10px;\n\tbox-sizing: border-box;\n\tmin-width: 100%;\n\tmax-width: 100%;\n\tmin-height: calc(100% - 52px - 10px);\n\tmax-height: calc(100% - 52px - 10px);\n\tpointer-events: auto;\n\tbackground-color: var(--surface-tertiary-color);\n\tborder: none;\n\tresize: none;\n\tcolor: var(--text-color);\n\tword-break: break-all;\n\tfont-size: 20px;\n}\n.track-export > .box > textarea:focus-visible {\n\toutline: none;\n}\n", ""]);
                const o = s
            }
            ,
            7780: (e, t, n) => {
                var i = {
                    "./apply.svg": 6366,
                    "./arrow_down.svg": 516,
                    "./arrow_left.svg": 6099,
                    "./arrow_right.svg": 6150,
                    "./arrow_up.svg": 2207,
                    "./back.svg": 8787,
                    "./cancel.svg": 1784,
                    "./car_stripe.svg": 2344,
                    "./car_thumbnail_placeholder.png": 7404,
                    "./checkmark.svg": 9809,
                    "./checkpoint.svg": 5148,
                    "./clouds.jpg": 8875,
                    "./community_tracks.jpg": 8115,
                    "./copy.svg": 1925,
                    "./custom_tracks.jpg": 2709,
                    "./customize.svg": 9027,
                    "./delete.svg": 2319,
                    "./desert.svg": 1705,
                    "./desert_colored.svg": 1758,
                    "./discord.svg": 858,
                    "./editor.svg": 8889,
                    "./empty.svg": 493,
                    "./erase.svg": 1936,
                    "./export.svg": 6168,
                    "./fullscreen.svg": 7581,
                    "./grid_large.svg": 3518,
                    "./grid_small.svg": 4930,
                    "./helmet.svg": 1333,
                    "./help.svg": 5031,
                    "./icon.svg": 853,
                    "./import.svg": 9077,
                    "./load.svg": 5918,
                    "./logo.svg": 8903,
                    "./official_tracks.jpg": 9391,
                    "./overlapping_disabled.svg": 8358,
                    "./overlapping_enabled.svg": 2493,
                    "./pause.svg": 9708,
                    "./pending.svg": 3223,
                    "./pin.svg": 6027,
                    "./play.svg": 9236,
                    "./preview.svg": 9570,
                    "./quit.svg": 5739,
                    "./random.svg": 2175,
                    "./reset.svg": 1719,
                    "./reset_settings.svg": 4593,
                    "./rotate.svg": 4563,
                    "./rotation_axis_x_negative.svg": 5001,
                    "./rotation_axis_x_positive.svg": 77,
                    "./rotation_axis_y_negative.svg": 5798,
                    "./rotation_axis_y_positive.svg": 9062,
                    "./rotation_axis_z_negative.svg": 3895,
                    "./rotation_axis_z_positive.svg": 4411,
                    "./save.svg": 4309,
                    "./search.svg": 8718,
                    "./settings.svg": 8237,
                    "./share.svg": 3755,
                    "./smoke.png": 6838,
                    "./state_invalid.svg": 2553,
                    "./state_pending.svg": 5769,
                    "./state_verified.svg": 6244,
                    "./summer.svg": 3901,
                    "./test.svg": 1734,
                    "./verified.svg": 3902,
                    "./windowed.svg": 7173,
                    "./winter.svg": 813,
                    "./winter_colored.svg": 5010
                };
                function r(e) {
                    var t = a(e);
                    return n(t)
                }
                function a(e) {
                    if (!n.o(i, e)) {
                        var t = new Error("Cannot find module '" + e + "'");
                        throw t.code = "MODULE_NOT_FOUND",
                            t
                    }
                    return i[e]
                }
                r.keys = function() {
                    return Object.keys(i)
                }
                    ,
                    r.resolve = a,
                    e.exports = r,
                    r.id = 7780
            }
            ,
            7818: (e, t, n) => {
                "use strict";
                n.d(t, {
                    A: () => o
                });
                var i = n(1601)
                    , r = n.n(i)
                    , a = n(6314)
                    , s = n.n(a)()(r());
                s.push([e.id, "\n.user-export {\n\tposition: absolute;\n\tleft: calc(50% - 500px / 2);\n\ttop: 35%;\n\tz-index: 2;\n\tmargin: 0;\n\tpadding: 10px;\n\tbox-sizing: border-box;\n\twidth: 500px;\n\theight: 150px;\n\tbackground-color: var(--surface-color);\n}\n\n.user-export > textarea {\n\tmargin: 0;\n\tpadding: 10px;\n\tbox-sizing: border-box;\n\tmin-width: 100%;\n\tmax-width: 100%;\n\tmin-height: calc(100% - 52px - 10px);\n\tmax-height: calc(100% - 52px - 10px);\n\tpointer-events: auto;\n\tbackground-color: var(--surface-tertiary-color);\n\tborder: none;\n\tresize: none;\n\tcolor: var(--text-color);\n\tword-break: break-all;\n\tfont-size: 20px;\n}\n.user-export > textarea:focus-visible {\n\toutline: none;\n}\n\n.user-export > .bar {\n\tmargin: 8px 0 0 0;\n}\n\n.user-export > .bar > .button.right {\n\tfloat: right;\n}\n", ""]);
                const o = s
            }
            ,
            7825: e => {
                "use strict";
                e.exports = function(e) {
                    if ("undefined" == typeof document)
                        return {
                            update: function() {},
                            remove: function() {}
                        };
                    var t = e.insertStyleElement(e);
                    return {
                        update: function(n) {
                            !function(e, t, n) {
                                var i = "";
                                n.supports && (i += "@supports (".concat(n.supports, ") {")),
                                n.media && (i += "@media ".concat(n.media, " {"));
                                var r = void 0 !== n.layer;
                                r && (i += "@layer".concat(n.layer.length > 0 ? " ".concat(n.layer) : "", " {")),
                                    i += n.css,
                                r && (i += "}"),
                                n.media && (i += "}"),
                                n.supports && (i += "}");
                                var a = n.sourceMap;
                                a && "undefined" != typeof btoa && (i += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(a)))), " */")),
                                    t.styleTagTransform(i, e, t.options)
                            }(t, e, n)
                        },
                        remove: function() {
                            !function(e) {
                                if (null === e.parentNode)
                                    return !1;
                                e.parentNode.removeChild(e)
                            }(t)
                        }
                    }
                }
            }
            ,
            8115: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/community_tracks.jpg"
            }
            ,
            8229: (e, t, n) => {
                "use strict";
                n.d(t, {
                    A: () => o
                });
                var i = n(1601)
                    , r = n.n(i)
                    , a = n(6314)
                    , s = n.n(a)()(r());
                s.push([e.id, "\n.hint {\n\tpadding: 0 280px;\n\tposition: absolute;\n\tleft: 0;\n\ttop: 150px;\n\twidth: 100%;\n\tbox-sizing: border-box;\n\ttext-align: center;\n\tcolor: #fff;\n\ttext-shadow: 0 0 5px #000;\n\tpointer-events: none;\n\topacity: 0;\n}\n.hint.show {\n\ttop: 150px;\n\topacity: 1;\n\ttransition: opacity 0.25s ease-in-out, top 0.25s ease-in-out;\n}\n.hint.hide {\n\ttop: 160px;\n\topacity: 0;\n\ttransition: opacity 0.25s ease-in-out, top 0.25s ease-in-out;\n}\n\n.hint > .title {\n\tfont-size: 32px;\n}\n\n.hint > .subtitle {\n\tmargin: 16px 0 0 0;\n\tfont-size: 24px;\n}\n", ""]);
                const o = s
            }
            ,
            8237: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/settings.svg"
            }
            ,
            8353: (e, t, n) => {
                "use strict";
                n.d(t, {
                    A: () => g
                });
                var i = n(1601)
                    , r = n.n(i)
                    , a = n(6314)
                    , s = n.n(a)
                    , o = n(4417)
                    , l = n.n(o)
                    , c = new URL(n(9391),n.b)
                    , h = new URL(n(8115),n.b)
                    , d = new URL(n(2709),n.b)
                    , u = s()(r())
                    , p = l()(c)
                    , f = l()(h)
                    , m = l()(d);
                u.push([e.id, `\n.track-selection {\n\tposition: absolute;\n\tbottom: 0;\n\tdisplay: flex;\n\tflex-direction: column;\n\twidth: 100%;\n\theight: 100%;\n\ttext-align: left;\n}\n\n.track-selection > .bar {\n\tdisplay: flex;\n\tmargin: 0;\n\tpadding: 0;\n\twidth: 100%;\n\tbackground-color: var(--surface-color);\n\ttext-align: left;\n\n\tpointer-events:auto;\n}\n.track-selection > .bar > .button {\n\tmargin: 8px 12px;\n}\n\n.track-selection > .bar > .search-bar-container {\n\tposition: relative;\n\tdisplay: flex;\n\tflex-grow: 1;\n}\n.track-selection > .bar > .search-bar-container > input {\n\tmargin: 8px -10px;\n\tpadding: 0 20px;\n\tflex-grow: 1;\n\tclip-path: polygon(8px 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\n\tcolor: var(--text-color);\n\ttext-indent: 2px; /* Without this the italic text will be cut off on the left side. */\n}\n.track-selection > .bar > .search-bar-container > img {\n\tmargin: 8px -10px 8px 0;\n\tpadding: 0 16px;\n\twidth: 24px;\n\tbackground-color: var(--button-hover-color);\n\tclip-path: polygon(8px 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\n}\n\n.track-selection .category-container {\n\tdisplay: flex;\n\tbackground-color: var(--surface-secondary-color);\n}\n.track-selection .category-container > button {\n\tposition: relative;\n\tmargin: 0 -3px;\n\tpadding: 0.6em 0;\n\tflex-grow: 1;\n\tfont-size: 2.8vw;\n\ttext-shadow: 0 0 10px #000;\n\tbackground-color: transparent;\n\tclip-path: polygon(8px 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\n}\n.track-selection .category-container > button:first-of-type {\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\n}\n.track-selection .category-container > button:last-of-type {\n\tclip-path: polygon(8px 0, 100% 0, 100% 100%, 0 100%);\n}\n.track-selection .category-container > button::before {\n\tcontent: "";\n\tposition: absolute;\n\ttop: 0;\n\tleft: 0;\n\tz-index: -1;\n\twidth: 100%;\n\theight: 100%;\n\tbackground-position: center;\n\tbackground-size: cover;\n\tfilter: blur(2px);\n\ttransition: filter 0.2s ease-in-out,  0.2s ease-in-out;\n}\n.track-selection .category-container > button.official::before {\n\tbackground-image: url(${p});\n}\n.track-selection .category-container > button.community::before {\n\tbackground-image: url(${f});\n}\n.track-selection .category-container > button.custom::before {\n\tbackground-image: url(${m});\n}\n.track-selection .category-container > button:hover::before {\n\tfilter: none;\n\ttransform: scale(1.1);\n}\n@media (hover: none) {\n\t.track-selection .category-container > button:hover::before {\n\t\tfilter: blur(2px);\n\t\ttransform: none;\n\t}\n\n\t.track-selection .category-container > button:active::before {\n\t\tfilter: none;\n\t\ttransform: scale(1.1);\n\t}\n}\n.track-selection .category-container > button.selected::before {\n\tfilter: none;\n}\n.track-selection .category-container > button::after {\n\tbackground-color: transparent;\n}\n.track-selection .category-container > button.selected::after {\n\twidth: 100%;\n}\n\n.track-selection .category-container > button > .cover {\n\tposition: absolute;\n\ttop: 0;\n\tleft: 0;\n\tz-index: -1;\n\twidth: 100%;\n\theight: 100%;\n\tbackground-color: rgba(17, 32, 82, 0.75);\n\ttransition: background-color 0.2s ease-in-out;\n}\n.track-selection .category-container > button:hover > .cover {\n\tbackground-color: rgba(51, 75, 119, 0.5);\n}\n@media (hover: none) {\n\t.track-selection .category-container > button:hover > .cover {\n\t\tbackground-color: rgba(17, 32, 82, 0.75);\n\t}\n}\n.track-selection .category-container > button:active > .cover {\n\tbackground-color: rgba(21, 31, 65, 0.5);\n}\n.track-selection .category-container > button.selected > .cover {\n\tbackground-color: transparent;\n}\n\n@media (max-width: 1150px) {\n\t.track-selection .category-container > button {\n\t\tfont-size: 32.2px;\n\t}\n}\n\n.track-selection .tracks-container {\n\tmargin: 0;\n\tpadding: 20px 60px;\n\tbox-sizing: border-box;\n\twidth: 100%;\n\tflex-grow: 1;\n\toverflow-y: auto;\n\tpointer-events: auto;\n\tdisplay: none;\n}\n.track-selection .tracks-container.open {\n\tdisplay: block;\n}\n.track-selection.editor-track-selection .tracks-container {\n\tbackground-color: rgba(20, 20, 45, 0.8);\n}\n\n.track-selection .tracks-container > .empty {\n\tmargin: 100px;\n\tcolor: var(--text-color);\n\ttext-align: center;\n}\n.track-selection .tracks-container > .empty > .title {\n\tfont-size: 48px;\n}\n.track-selection .tracks-container > .empty > .description {\n\tmargin: 20px 0 0 0;\n\tfont-size: 32px;\n\topacity: 0.75;\n}\n\n.track-selection .environment-title {\n\tmargin: 0.5em 0.4em;\n\tpadding: 0;\n\tfont-size: 50px;\n\tfont-weight: normal;\n\tborder-bottom-width: 4px;\n\tborder-bottom-style: solid;\n\t\n}\n.track-selection .environment-title.summer {\n\tcolor: var(--text-color);\n\tborder-image: linear-gradient(to right, var(--text-color), transparent) 1;\n}\n.track-selection .environment-title.winter {\n\tcolor: #bed8f7;\n\tborder-image: linear-gradient(to right, #bed8f7, transparent) 1;\n}\n.track-selection .environment-title.desert {\n\tcolor: #ede2af;\n\tborder-image: linear-gradient(to right, #ede2af, transparent) 1;\n}\n\n.track-selection .environment-title > img {\n\tmargin: 6px 8px;\n\twidth: 36px;\n\theight: 36px;\n\tvertical-align: bottom;\n}\n\n.track-selection .tracks-container .track {\n\tposition: relative;\n\tdisplay: inline-block;\n}\n\n.track-selection .tracks-container .track button {\n\tmargin: 10px;\n\tpadding: 0;\n\tcolor: var(--text-color);\n\tfont-size: 32px;\n}\n.track-selection .tracks-container .track button:after {\n\tborder-bottom: none;\n}\n.track-selection .tracks-container .track button:focus-visible {\n\ttext-decoration: none;\n}\n\n.track-selection .track-title {\n\tmargin: 0;\n\tpadding: 4px;\n\tfont-size: 25px;\n\tbackground-color: var(--surface-secondary-color);\n}\n.track-selection .tracks-container .track button:focus-visible .track-title {\n\ttext-decoration: underline;\n}\n.track-selection .track-title > p {\n\tmargin: 0;\n\tpadding: 0 22px;\n\twidth: 208px;\n\tbox-sizing: border-box;\n\twhite-space: nowrap;\n\toverflow: hidden;\n\ttext-overflow: ellipsis;\n}\n\n.track-selection .track canvas {\n\tmargin: 0;\n\tpadding: 20px 40px;\n\twidth: 128px;\n\theight: 128px;\n\tobject-fit: contain;\n\t-webkit-filter: drop-shadow(0 0 3px #000);\n\tfilter: drop-shadow(0 0 3px #000);\n\timage-rendering: pixelated;\n}\n\n.track-selection .track .environment {\n\tposition: absolute;\n\tright: 14px;\n\tbottom: 40px;\n\twidth: 24px;\n\topacity: 0.2;\n\tpointer-events: none;\n}\n\n.track-selection .record {\n\tmargin: 0;\n\tpadding: 4px;\n\tfont-size: 24px;\n\tbackground-color: var(--surface-secondary-color);\n\tcolor: var(--text-color);\n}\n\n.track-selection .delete-button {\n\tposition: absolute;\n\ttop: 7px;\n\tright: 6px;\n\tmargin: 0;\n\tpadding: 0;\n\tline-height: 0;\n\tborder-radius: 2px;\n\tborder: none;\n\tbackground-color: var(--button-color);\n\n\tpointer-events: auto;\n\tcursor: pointer;\n}\n.track-selection .delete-button:hover {\n\tbackground-color: var(--button-hover-color);\n}\n@media (hover: none) {\n\t.track-selection .delete-button:hover {\n\t\tbackground-color: var(--button-color);\n\t}\n}\n.track-selection .delete-button:active {\n\tbackground-color: var(--button-active-color);\n}\n.track-selection .delete-button > img {\n\tmargin: 0;\n\tpadding: 0;\n\theight: 20px;\n\tvertical-align: top;\n\tpointer-events: none;\n}\n`, ""]);
                const g = u
            }
            ,
            8358: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/overlapping_disabled.svg"
            }
            ,
            8419: (e, t, n) => {
                "use strict";
                n.d(t, {
                    A: () => g
                });
                var i = n(1601)
                    , r = n.n(i)
                    , a = n(6314)
                    , s = n.n(a)
                    , o = n(4417)
                    , l = n.n(o)
                    , c = new URL(n(3682),n.b)
                    , h = new URL(n(2208),n.b)
                    , d = new URL(n(2832),n.b)
                    , u = s()(r())
                    , p = l()(c)
                    , f = l()(h)
                    , m = l()(d);
                u.push([e.id, `\n:root {\n\tinterpolate-size: allow-keywords; \n\n\t--text-color: #fff;\n\t--text-disabled-color: #5d6a7c;\n\t--surface-color: #28346a;\n\t--surface-secondary-color: #212b58;\n\t--surface-tertiary-color: #192042;\n\t--surface-transparent-color: rgba(40, 52, 106, 0.5);\n\t--button-color: #112052;\n\t--button-hover-color: #334b77;\n\t--button-active-color: #151f41;\n\t--button-disabled-color: #313d53;\n}\n\n@font-face {\n\tfont-family: ForcedSquare;\n\tsrc:\n\t\turl(${p}) format("woff2"),\n\t\turl(${f}) format("woff"),\n\t\turl(${m}) format("truetype");\n}\n\nhtml, body {\n\tmargin: 0;\n\tpadding: 0;\n\twidth: 100%;\n\theight: 100%;\n\toverflow: hidden;\n\toverscroll-behavior: none;\n\n\tbackground: #000;\n}\n\nbody {\n\tscrollbar-color: #7272c2 #223;\n\ttouch-action: none;\n}\n\n* {\n\tfont-style: italic;\n\tfont-family: ForcedSquare, Arial, sans-serif;\n\tline-height: 1;\n}\n\n#screen {\n\tmargin: 0;\n\tpadding: 0;\n\twidth: 100%;\n\theight: 100%;\n\t-webkit-tap-highlight-color: transparent;\n\t-webkit-touch-callout: none;\n\t-webkit-user-select: none;\n\t-moz-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none;\n\ttouch-action: none;\n}\n\n#ui {\n\tposition: absolute;\n\tleft: 0;\n\ttop: 0;\n\twidth: 100%;\n\theight: 100%;\n\ttransform-origin: 0 0;\n\tpointer-events: none;\n\t-webkit-tap-highlight-color: transparent;\n\t-webkit-user-select: none;\n\t-moz-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none;\n}\n\n::-webkit-scrollbar {\n\twidth: 8px;\n\tbackground-color: #223;\n}\n::-webkit-scrollbar-thumb {\n\tborder-radius: 4px;\n\tbackground-color: #7272c2;\n}\n\n::selection {\n\tbackground-color:  #5936d6;\n\tcolor:  #fff;\n}\n\n.hide-cursor {\n\tcursor: none;\n}\n\n.hidden {\n\tdisplay: none;\n}\n\ninput[type="text"] {\n\tmargin: 0;\n\tpadding: 4px 8px;\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\n\tfont-size: 24px;\n\tfont-weight: bold;\n\tcolor: var(--text-color);\n\tbackground-color: var(--surface-tertiary-color);\n\tborder: none;\n\tpointer-events: auto;\n}\ninput[type="text"]::placeholder {\n\tcolor: var(--text-color);\n\topacity: 0.25;\n}\ninput[type="text"]:focus-visible {\n\toutline: none;\n}\n\ninput[type="range"] {\n\tmargin: 0;\n\tpadding: 0;\n\t-webkit-appearance: none;\n\tappearance: none;\n\tbackground: transparent;\n\tcursor: pointer;\n\taccent-color: var(--text-color);\n}\ninput[type="range"]::-webkit-slider-runnable-track {\n\tbackground-color: var(--surface-tertiary-color);\n\theight: 10px;\n}\ninput[type="range"]::-moz-range-track {\n\tbackground-color: var(--surface-tertiary-color);\n\theight: 10px;\n}\ninput[type="range"]::-webkit-slider-thumb {\n\t-webkit-appearance: none;\n\tappearance: none;\n\tborder-radius: 0;\n\tbackground: var(--text-color);\n\twidth: 32px;\n\theight: 32px;\n\tmargin: -13px 0 0 0;\n\tborder: 4px solid var(--button-color);\n\toutline: 2px solid var(--text-color);\n}\ninput[type="range"]::-webkit-slider-thumb:hover {\n\tborder: 4px solid var(--button-hover-color);\n}\n@media (hover: none) {\n\tinput[type="range"]::-webkit-slider-thumb:hover {\n\t\tborder: 4px solid var(--button-color);\n\t}\n}\ninput[type="range"]::-webkit-slider-thumb:active {\n\tborder: 4px solid var(--button-active-color);\n}\ninput[type="range"]::-moz-range-thumb {\n\t-webkit-appearance: none;\n\tappearance: none;\n\tborder-radius: 0;\n\tbackground: var(--text-color);\n\twidth: 24px;\n\theight: 24px;\n\tborder: 4px solid var(--button-color);\n\toutline: 2px solid var(--text-color);\n}\ninput[type="range"]::-moz-range-thumb:hover {\n\tborder: 4px solid var(--button-hover-color);\n}\n@media (hover: none) {\n\tinput[type="range"]::-moz-range-thumb:hover {\n\t\tborder: 4px solid var(--button-color);\n\t}\n}\ninput[type="range"]::-moz-range-thumb:active {\n\tborder: 4px solid var(--button-active-color);\n}\n\n.button {\n\tposition: relative;\n\tmargin: 0;\n\tpadding: 8px 18px;\n\tbackground-color: var(--button-color);\n\tborder: none;\n\tclip-path: polygon(8px 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\n\tcolor: var(--text-color);\n\tfont-size: 32px;\n\n\tpointer-events: auto;\n\t-webkit-user-select: none;\n\t-moz-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none;\n\tcursor: pointer;\n}\n.button::after {\n\tcontent: "";\n\tposition: absolute;\n\tleft: 0;\n\tbottom: 0;\n\tz-index: -1;\n\twidth: 0;\n\theight: 100%;\n\tbackground-color: var(--button-hover-color);\n\tborder-bottom: 2px solid var(--text-color);\n\ttransition: width 0.1s ease-in-out;\n}\n.button:hover::after {\n\twidth: 100%;\n}\n@media (hover: none) {\n\t.button::after {\n\t\tbackground-color: var(--button-active-color);\n\t}\n\n\t.button:hover::after {\n\t\twidth: 0;\n\t}\n}\n.button:active::after {\n\tbackground-color: var(--button-active-color);\n\twidth: 100%;\n}\n.button:focus-visible {\n\tbackground-color: var(--button-hover-color);\n\ttext-decoration: underline;\n\toutline: none;\n}\n.button > img.button-icon {\n\tmargin: -6px -4px 0 -4px;\n\tpadding: 0;\n\twidth: 32px;\n\theight: 32px;\n\tvertical-align: middle;\n\tpointer-events: none;\n}\n.button:disabled {\n\tbackground-color: var(--button-disabled-color);\n\tcolor: var(--text-disabled-color);\n\tcursor: default;\n}\n.button:disabled:after {\n\tcontent: none;\n}\n.button:disabled > img.button-icon {\n\topacity: 0.3;\n}\n`, ""]);
                const g = u
            }
            ,
            8718: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/search.svg"
            }
            ,
            8768: (e, t, n) => {
                "use strict";
                n.d(t, {
                    A: () => o
                });
                var i = n(1601)
                    , r = n.n(i)
                    , a = n(6314)
                    , s = n.n(a)()(r());
                s.push([e.id, "\n.preview-toolbar {\n\tposition: absolute;\n\tleft: 0;\n\tbottom: 0;\n\tpadding: 8px 10px 8px 8px;\n\tbackground-color: var(--surface-color);\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\n}\n", ""]);
                const o = s
            }
            ,
            8787: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/back.svg"
            }
            ,
            8875: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/clouds.jpg"
            }
            ,
            8889: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/editor.svg"
            }
            ,
            8903: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/logo.svg"
            }
            ,
            8909: (e, t, n) => {
                "use strict";
                n.d(t, {
                    A: () => o
                });
                var i = n(1601)
                    , r = n.n(i)
                    , a = n(6314)
                    , s = n.n(a)()(r());
                s.push([e.id, "\n.editor-checkpoint-order > .buttons {\n\tdisplay: inline-block;\n\tvertical-align: bottom;\n}\n.editor-checkpoint-order > .buttons > button {\n\tdisplay: block;\n\tmargin: 0;\n\tpadding: 0;\n\tborder: none;\n\tbackground-color: var(--button-color);\n\tpointer-events: auto;\n\tcursor: pointer;\n}\n.editor-checkpoint-order > .buttons > button:hover {\n\tbackground-color: var(--button-hover-color);\n}\n@media (hover: none) {\n\t.editor-checkpoint-order > .buttons > button:hover {\n\t\tbackground-color: var(--button-color);\n\t}\n}\n.editor-checkpoint-order > .buttons > button:active {\n\tbackground-color: var(--button-active-color);\n}\n\n.editor-checkpoint-order > .buttons > button > img {\n\tmargin: 0;\n\tpadding: 0 6px;\n\twidth: 20px;\n\theight: 20px;\n\tvertical-align: bottom;\n\tpointer-events: none;\n}\n.editor-checkpoint-order.touch > .buttons > button > img {\n\tpadding: 24px;\n\twidth: 40px;\n\theight: 40px;\n}\n\n.editor-checkpoint-order > p {\n\tmargin: 0;\n\tpadding: 0 10px;\n\tdisplay: inline-block;\n\tvertical-align: bottom;\n\tline-height: 40px;\n\tmin-width: 275px;\n\tfont-size: 26px;\n\ttext-align: center;\n\tbackground-color: var(--surface-transparent-color);\n\tcolor: var(--text-color);\n}\n.editor-checkpoint-order.touch > p {\n\tline-height: calc((40px + 2 * 24px) * 2);\n}\n", ""]);
                const o = s
            }
            ,
            9027: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/customize.svg"
            }
            ,
            9062: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/rotation_axis_y_positive.svg"
            }
            ,
            9077: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/import.svg"
            }
            ,
            9207: (e, t, n) => {
                "use strict";
                n.d(t, {
                    A: () => o
                });
                var i = n(1601)
                    , r = n.n(i)
                    , a = n(6314)
                    , s = n.n(a)()(r());
                s.push([e.id, "\n#transition-layer {\n\tposition: absolute;\n\tleft: 0;\n\ttop: 0;\n\tz-index: 1;\n\twidth: 100%;\n\theight: 100%;\n\tbackground-color: #000;\n\tpointer-events: none;\n\n\topacity: 0;\n\ttransition: 0.25s ease-in-out opacity;\n}\n", ""]);
                const o = s
            }
            ,
            9236: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/play.svg"
            }
            ,
            9242: (e, t, n) => {
                "use strict";
                n.d(t, {
                    A: () => o
                });
                var i = n(1601)
                    , r = n.n(i)
                    , a = n(6314)
                    , s = n.n(a)()(r());
                s.push([e.id, "\n.editor-help > .background {\n\tposition: absolute;\n\tleft: 0;\n\ttop: 0;\n\tz-index: 1;\n\twidth: 100%;\n\theight: 100%;\n\tbackground-color: rgba(20, 20, 30, 0.5);\n\tpointer-events: auto;\n}\n\n.editor-help > .container {\n\tposition: absolute;\n\tleft: calc(50% - 80% / 2);\n\ttop: 0;\n\tz-index: 2;\n\tdisplay: flex;\n\tflex-direction: column;\n\tbox-sizing: border-box;\n\twidth: 80%;\n\theight: 100%;\n\tbackground-color: var(--surface-color);\n}\n\n.editor-help > .container > h1 {\n\tmargin: 10px;\n\tpadding: 0;\n\tfont-weight: normal;\n\tfont-size: 38px;\n\ttext-align: center;\n\tcolor: var(--text-color);\n}\n\n.editor-help > .container > .content {\n\tflex-grow: 1;\n\tpadding: 40px;\n\tbackground-color: var(--surface-secondary-color);\n\toverflow-y: auto;\n\tpointer-events: auto;\n}\n\n.editor-help > .container > .content > h2 {\n\tmargin: 32px 0 16px 0;\n\tpadding: 0;\n\tfont-weight: normal;\n\tfont-size: 30px;\n\tcolor: var(--text-color);\n\tborder-bottom: 2px solid var(--text-color);\n}\n.editor-help > .container > .content > h2:first-of-type {\n\tmargin-top: 0;\n}\n\n.editor-help > .container > .content > p {\n\tmargin: 0;\n\tpadding: 0;\n\tfont-size: 20px;\n\tcolor: var(--text-color);\n\twhite-space: pre-wrap;\n}\n\n.editor-help > .container > .content > .part-images {\n\tdisplay: flex;\n\tjustify-content: space-around;\n}\n\n.editor-help > .container > .content > .part-images > div {\n\tdisplay: flex;\n\tflex-direction: column;\n}\n\n.editor-help > .container > .content > .part-images > div > img {\n\twidth: 128px;\n\theight: 128px;\n\tfilter: drop-shadow(0 4px 5px rgba(0, 0, 0, 0.4));\n\tpointer-events: none;\n\ttransition: opacity 0.25s ease-out;\n}\n.editor-help > .container > .content > .part-images > div > img.loading {\n\topacity: 0;\n}\n\n.editor-help > .container > .content > .part-images > div > span {\n\tmargin: 0;\n\tpadding: 0;\n\tfont-size: 20px;\n\tcolor: var(--text-color);\n\ttext-align: center;\n}\n\n.editor-help > .container > .button-wrapper > button {\n\tmargin: 10px;\n}\n", ""]);
                const o = s
            }
            ,
            9391: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/official_tracks.jpg"
            }
            ,
            9570: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/preview.svg"
            }
            ,
            9708: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/pause.svg"
            }
            ,
            9809: (e, t, n) => {
                "use strict";
                e.exports = n.p + "images/checkmark.svg"
            }
        }
            , t = {};
        function n(i) {
            var r = t[i];
            if (void 0 !== r)
                return r.exports;
            var a = t[i] = {
                id: i,
                exports: {}
            };
            return e[i](a, a.exports, n),
                a.exports
        }
        n.m = e,
            n.amdO = {},
            n.n = e => {
                var t = e && e.__esModule ? () => e.default : () => e;
                return n.d(t, {
                    a: t
                }),
                    t
            }
            ,
            n.d = (e, t) => {
                for (var i in t)
                    n.o(t, i) && !n.o(e, i) && Object.defineProperty(e, i, {
                        enumerable: !0,
                        get: t[i]
                    })
            }
            ,
            n.g = function() {
                if ("object" == typeof globalThis)
                    return globalThis;
                try {
                    return this || new Function("return this")()
                } catch (e) {
                    if ("object" == typeof window)
                        return window
                }
            }(),
            n.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t),
            ( () => {
                    var e;
                    n.g.importScripts && (e = n.g.location + "");
                    var t = n.g.document;
                    if (!e && t && (t.currentScript && "SCRIPT" === t.currentScript.tagName.toUpperCase() && (e = t.currentScript.src),
                        !e)) {
                        var i = t.getElementsByTagName("script");
                        if (i.length)
                            for (var r = i.length - 1; r > -1 && (!e || !/^http(s?):/.test(e)); )
                                e = i[r--].src
                    }
                    if (!e)
                        throw new Error("Automatic publicPath is not supported in this browser");
                    e = e.replace(/^blob:/, "").replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/"),
                        n.p = e
                }
            )(),
            n.b = document.baseURI || self.location.href,
            n.nc = void 0,
            ( () => {
                    "use strict";
                    n(6925);
                    var e = n(5072)
                        , t = n.n(e)
                        , i = n(7825)
                        , r = n.n(i)
                        , a = n(7659)
                        , s = n.n(a)
                        , o = n(5056)
                        , l = n.n(o)
                        , c = n(540)
                        , h = n.n(c)
                        , d = n(1113)
                        , u = n.n(d)
                        , p = n(8419)
                        , f = {};
                    f.styleTagTransform = u(),
                        f.setAttributes = l(),
                        f.insert = s().bind(null, "head"),
                        f.domAPI = r(),
                        f.insertStyleElement = h();
                    t()(p.A, f);
                    p.A && p.A.locals && p.A.locals;
                    const m = "174"
                        , g = 0
                        , v = 1
                        , w = 2
                        , A = 0
                        , y = 1
                        , b = 2
                        , x = 3
                        , k = 0
                        , E = 1
                        , S = 2
                        , M = 100
                        , T = 101
                        , C = 102
                        , _ = 200
                        , I = 201
                        , P = 202
                        , R = 203
                        , L = 204
                        , N = 205
                        , D = 206
                        , B = 207
                        , U = 208
                        , z = 209
                        , O = 210
                        , F = 211
                        , W = 212
                        , H = 213
                        , V = 214
                        , G = 0
                        , j = 1
                        , Q = 2
                        , Y = 3
                        , q = 4
                        , K = 5
                        , X = 6
                        , Z = 7
                        , J = "attached"
                        , $ = 301
                        , ee = 302
                        , te = 303
                        , ne = 304
                        , ie = 306
                        , re = 1e3
                        , ae = 1001
                        , se = 1002
                        , oe = 1003
                        , le = 1004
                        , ce = 1005
                        , he = 1006
                        , de = 1007
                        , ue = 1008
                        , pe = 1009
                        , fe = 1010
                        , me = 1011
                        , ge = 1012
                        , ve = 1013
                        , we = 1014
                        , Ae = 1015
                        , ye = 1016
                        , be = 1017
                        , xe = 1018
                        , ke = 1020
                        , Ee = 35902
                        , Se = 1023
                        , Me = 1026
                        , Te = 1027
                        , Ce = 1028
                        , _e = 1029
                        , Ie = 1031
                        , Pe = 1033
                        , Re = 33776
                        , Le = 33777
                        , Ne = 33778
                        , De = 33779
                        , Be = 35840
                        , Ue = 35841
                        , ze = 35842
                        , Oe = 35843
                        , Fe = 36196
                        , We = 37492
                        , He = 37496
                        , Ve = 37808
                        , Ge = 37809
                        , je = 37810
                        , Qe = 37811
                        , Ye = 37812
                        , qe = 37813
                        , Ke = 37814
                        , Xe = 37815
                        , Ze = 37816
                        , Je = 37817
                        , $e = 37818
                        , et = 37819
                        , tt = 37820
                        , nt = 37821
                        , it = 36492
                        , rt = 36494
                        , at = 36495
                        , st = 36284
                        , ot = 36285
                        , lt = 36286
                        , ct = 2300
                        , ht = 2301
                        , dt = 2302
                        , ut = 2400
                        , pt = 2401
                        , ft = 2402
                        , mt = ""
                        , gt = "srgb"
                        , vt = "srgb-linear"
                        , wt = "linear"
                        , At = "srgb"
                        , yt = 7680
                        , bt = 512
                        , xt = 513
                        , kt = 514
                        , Et = 515
                        , St = 516
                        , Mt = 517
                        , Tt = 518
                        , Ct = 519
                        , _t = 35044
                        , It = "300 es"
                        , Pt = 2e3
                        , Rt = 2001;
                    class Lt {
                        addEventListener(e, t) {
                            void 0 === this._listeners && (this._listeners = {});
                            const n = this._listeners;
                            void 0 === n[e] && (n[e] = []),
                            -1 === n[e].indexOf(t) && n[e].push(t)
                        }
                        hasEventListener(e, t) {
                            const n = this._listeners;
                            return void 0 !== n && (void 0 !== n[e] && -1 !== n[e].indexOf(t))
                        }
                        removeEventListener(e, t) {
                            const n = this._listeners;
                            if (void 0 === n)
                                return;
                            const i = n[e];
                            if (void 0 !== i) {
                                const e = i.indexOf(t);
                                -1 !== e && i.splice(e, 1)
                            }
                        }
                        dispatchEvent(e) {
                            const t = this._listeners;
                            if (void 0 === t)
                                return;
                            const n = t[e.type];
                            if (void 0 !== n) {
                                e.target = this;
                                const t = n.slice(0);
                                for (let n = 0, i = t.length; n < i; n++)
                                    t[n].call(this, e);
                                e.target = null
                            }
                        }
                    }
                    const Nt = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
                    let Dt = 1234567;
                    const Bt = Math.PI / 180
                        , Ut = 180 / Math.PI;
                    function zt() {
                        const e = 4294967295 * Math.random() | 0
                            , t = 4294967295 * Math.random() | 0
                            , n = 4294967295 * Math.random() | 0
                            , i = 4294967295 * Math.random() | 0;
                        return (Nt[255 & e] + Nt[e >> 8 & 255] + Nt[e >> 16 & 255] + Nt[e >> 24 & 255] + "-" + Nt[255 & t] + Nt[t >> 8 & 255] + "-" + Nt[t >> 16 & 15 | 64] + Nt[t >> 24 & 255] + "-" + Nt[63 & n | 128] + Nt[n >> 8 & 255] + "-" + Nt[n >> 16 & 255] + Nt[n >> 24 & 255] + Nt[255 & i] + Nt[i >> 8 & 255] + Nt[i >> 16 & 255] + Nt[i >> 24 & 255]).toLowerCase()
                    }
                    function Ot(e, t, n) {
                        return Math.max(t, Math.min(n, e))
                    }
                    function Ft(e, t) {
                        return (e % t + t) % t
                    }
                    function Wt(e, t, n) {
                        return (1 - n) * e + n * t
                    }
                    function Ht(e, t) {
                        switch (t.constructor) {
                            case Float32Array:
                                return e;
                            case Uint32Array:
                                return e / 4294967295;
                            case Uint16Array:
                                return e / 65535;
                            case Uint8Array:
                                return e / 255;
                            case Int32Array:
                                return Math.max(e / 2147483647, -1);
                            case Int16Array:
                                return Math.max(e / 32767, -1);
                            case Int8Array:
                                return Math.max(e / 127, -1);
                            default:
                                throw new Error("Invalid component type.")
                        }
                    }
                    function Vt(e, t) {
                        switch (t.constructor) {
                            case Float32Array:
                                return e;
                            case Uint32Array:
                                return Math.round(4294967295 * e);
                            case Uint16Array:
                                return Math.round(65535 * e);
                            case Uint8Array:
                                return Math.round(255 * e);
                            case Int32Array:
                                return Math.round(2147483647 * e);
                            case Int16Array:
                                return Math.round(32767 * e);
                            case Int8Array:
                                return Math.round(127 * e);
                            default:
                                throw new Error("Invalid component type.")
                        }
                    }
                    const Gt = {
                        DEG2RAD: Bt,
                        RAD2DEG: Ut,
                        generateUUID: zt,
                        clamp: Ot,
                        euclideanModulo: Ft,
                        mapLinear: function(e, t, n, i, r) {
                            return i + (e - t) * (r - i) / (n - t)
                        },
                        inverseLerp: function(e, t, n) {
                            return e !== t ? (n - e) / (t - e) : 0
                        },
                        lerp: Wt,
                        damp: function(e, t, n, i) {
                            return Wt(e, t, 1 - Math.exp(-n * i))
                        },
                        pingpong: function(e, t=1) {
                            return t - Math.abs(Ft(e, 2 * t) - t)
                        },
                        smoothstep: function(e, t, n) {
                            return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e)
                        },
                        smootherstep: function(e, t, n) {
                            return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10)
                        },
                        randInt: function(e, t) {
                            return e + Math.floor(Math.random() * (t - e + 1))
                        },
                        randFloat: function(e, t) {
                            return e + Math.random() * (t - e)
                        },
                        randFloatSpread: function(e) {
                            return e * (.5 - Math.random())
                        },
                        seededRandom: function(e) {
                            void 0 !== e && (Dt = e);
                            let t = Dt += 1831565813;
                            return t = Math.imul(t ^ t >>> 15, 1 | t),
                                t ^= t + Math.imul(t ^ t >>> 7, 61 | t),
                            ((t ^ t >>> 14) >>> 0) / 4294967296
                        },
                        degToRad: function(e) {
                            return e * Bt
                        },
                        radToDeg: function(e) {
                            return e * Ut
                        },
                        isPowerOfTwo: function(e) {
                            return !(e & e - 1) && 0 !== e
                        },
                        ceilPowerOfTwo: function(e) {
                            return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
                        },
                        floorPowerOfTwo: function(e) {
                            return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
                        },
                        setQuaternionFromProperEuler: function(e, t, n, i, r) {
                            const a = Math.cos
                                , s = Math.sin
                                , o = a(n / 2)
                                , l = s(n / 2)
                                , c = a((t + i) / 2)
                                , h = s((t + i) / 2)
                                , d = a((t - i) / 2)
                                , u = s((t - i) / 2)
                                , p = a((i - t) / 2)
                                , f = s((i - t) / 2);
                            switch (r) {
                                case "XYX":
                                    e.set(o * h, l * d, l * u, o * c);
                                    break;
                                case "YZY":
                                    e.set(l * u, o * h, l * d, o * c);
                                    break;
                                case "ZXZ":
                                    e.set(l * d, l * u, o * h, o * c);
                                    break;
                                case "XZX":
                                    e.set(o * h, l * f, l * p, o * c);
                                    break;
                                case "YXY":
                                    e.set(l * p, o * h, l * f, o * c);
                                    break;
                                case "ZYZ":
                                    e.set(l * f, l * p, o * h, o * c);
                                    break;
                                default:
                                    console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
                            }
                        },
                        normalize: Vt,
                        denormalize: Ht
                    };
                    class jt {
                        constructor(e=0, t=0) {
                            jt.prototype.isVector2 = !0,
                                this.x = e,
                                this.y = t
                        }
                        get width() {
                            return this.x
                        }
                        set width(e) {
                            this.x = e
                        }
                        get height() {
                            return this.y
                        }
                        set height(e) {
                            this.y = e
                        }
                        set(e, t) {
                            return this.x = e,
                                this.y = t,
                                this
                        }
                        setScalar(e) {
                            return this.x = e,
                                this.y = e,
                                this
                        }
                        setX(e) {
                            return this.x = e,
                                this
                        }
                        setY(e) {
                            return this.y = e,
                                this
                        }
                        setComponent(e, t) {
                            switch (e) {
                                case 0:
                                    this.x = t;
                                    break;
                                case 1:
                                    this.y = t;
                                    break;
                                default:
                                    throw new Error("index is out of range: " + e)
                            }
                            return this
                        }
                        getComponent(e) {
                            switch (e) {
                                case 0:
                                    return this.x;
                                case 1:
                                    return this.y;
                                default:
                                    throw new Error("index is out of range: " + e)
                            }
                        }
                        clone() {
                            return new this.constructor(this.x,this.y)
                        }
                        copy(e) {
                            return this.x = e.x,
                                this.y = e.y,
                                this
                        }
                        add(e) {
                            return this.x += e.x,
                                this.y += e.y,
                                this
                        }
                        addScalar(e) {
                            return this.x += e,
                                this.y += e,
                                this
                        }
                        addVectors(e, t) {
                            return this.x = e.x + t.x,
                                this.y = e.y + t.y,
                                this
                        }
                        addScaledVector(e, t) {
                            return this.x += e.x * t,
                                this.y += e.y * t,
                                this
                        }
                        sub(e) {
                            return this.x -= e.x,
                                this.y -= e.y,
                                this
                        }
                        subScalar(e) {
                            return this.x -= e,
                                this.y -= e,
                                this
                        }
                        subVectors(e, t) {
                            return this.x = e.x - t.x,
                                this.y = e.y - t.y,
                                this
                        }
                        multiply(e) {
                            return this.x *= e.x,
                                this.y *= e.y,
                                this
                        }
                        multiplyScalar(e) {
                            return this.x *= e,
                                this.y *= e,
                                this
                        }
                        divide(e) {
                            return this.x /= e.x,
                                this.y /= e.y,
                                this
                        }
                        divideScalar(e) {
                            return this.multiplyScalar(1 / e)
                        }
                        applyMatrix3(e) {
                            const t = this.x
                                , n = this.y
                                , i = e.elements;
                            return this.x = i[0] * t + i[3] * n + i[6],
                                this.y = i[1] * t + i[4] * n + i[7],
                                this
                        }
                        min(e) {
                            return this.x = Math.min(this.x, e.x),
                                this.y = Math.min(this.y, e.y),
                                this
                        }
                        max(e) {
                            return this.x = Math.max(this.x, e.x),
                                this.y = Math.max(this.y, e.y),
                                this
                        }
                        clamp(e, t) {
                            return this.x = Ot(this.x, e.x, t.x),
                                this.y = Ot(this.y, e.y, t.y),
                                this
                        }
                        clampScalar(e, t) {
                            return this.x = Ot(this.x, e, t),
                                this.y = Ot(this.y, e, t),
                                this
                        }
                        clampLength(e, t) {
                            const n = this.length();
                            return this.divideScalar(n || 1).multiplyScalar(Ot(n, e, t))
                        }
                        floor() {
                            return this.x = Math.floor(this.x),
                                this.y = Math.floor(this.y),
                                this
                        }
                        ceil() {
                            return this.x = Math.ceil(this.x),
                                this.y = Math.ceil(this.y),
                                this
                        }
                        round() {
                            return this.x = Math.round(this.x),
                                this.y = Math.round(this.y),
                                this
                        }
                        roundToZero() {
                            return this.x = Math.trunc(this.x),
                                this.y = Math.trunc(this.y),
                                this
                        }
                        negate() {
                            return this.x = -this.x,
                                this.y = -this.y,
                                this
                        }
                        dot(e) {
                            return this.x * e.x + this.y * e.y
                        }
                        cross(e) {
                            return this.x * e.y - this.y * e.x
                        }
                        lengthSq() {
                            return this.x * this.x + this.y * this.y
                        }
                        length() {
                            return Math.sqrt(this.x * this.x + this.y * this.y)
                        }
                        manhattanLength() {
                            return Math.abs(this.x) + Math.abs(this.y)
                        }
                        normalize() {
                            return this.divideScalar(this.length() || 1)
                        }
                        angle() {
                            return Math.atan2(-this.y, -this.x) + Math.PI
                        }
                        angleTo(e) {
                            const t = Math.sqrt(this.lengthSq() * e.lengthSq());
                            if (0 === t)
                                return Math.PI / 2;
                            const n = this.dot(e) / t;
                            return Math.acos(Ot(n, -1, 1))
                        }
                        distanceTo(e) {
                            return Math.sqrt(this.distanceToSquared(e))
                        }
                        distanceToSquared(e) {
                            const t = this.x - e.x
                                , n = this.y - e.y;
                            return t * t + n * n
                        }
                        manhattanDistanceTo(e) {
                            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
                        }
                        setLength(e) {
                            return this.normalize().multiplyScalar(e)
                        }
                        lerp(e, t) {
                            return this.x += (e.x - this.x) * t,
                                this.y += (e.y - this.y) * t,
                                this
                        }
                        lerpVectors(e, t, n) {
                            return this.x = e.x + (t.x - e.x) * n,
                                this.y = e.y + (t.y - e.y) * n,
                                this
                        }
                        equals(e) {
                            return e.x === this.x && e.y === this.y
                        }
                        fromArray(e, t=0) {
                            return this.x = e[t],
                                this.y = e[t + 1],
                                this
                        }
                        toArray(e=[], t=0) {
                            return e[t] = this.x,
                                e[t + 1] = this.y,
                                e
                        }
                        fromBufferAttribute(e, t) {
                            return this.x = e.getX(t),
                                this.y = e.getY(t),
                                this
                        }
                        rotateAround(e, t) {
                            const n = Math.cos(t)
                                , i = Math.sin(t)
                                , r = this.x - e.x
                                , a = this.y - e.y;
                            return this.x = r * n - a * i + e.x,
                                this.y = r * i + a * n + e.y,
                                this
                        }
                        random() {
                            return this.x = Math.random(),
                                this.y = Math.random(),
                                this
                        }
                        *[Symbol.iterator]() {
                            yield this.x,
                                yield this.y
                        }
                    }
                    class Qt {
                        constructor(e, t, n, i, r, a, s, o, l) {
                            Qt.prototype.isMatrix3 = !0,
                                this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
                            void 0 !== e && this.set(e, t, n, i, r, a, s, o, l)
                        }
                        set(e, t, n, i, r, a, s, o, l) {
                            const c = this.elements;
                            return c[0] = e,
                                c[1] = i,
                                c[2] = s,
                                c[3] = t,
                                c[4] = r,
                                c[5] = o,
                                c[6] = n,
                                c[7] = a,
                                c[8] = l,
                                this
                        }
                        identity() {
                            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
                                this
                        }
                        copy(e) {
                            const t = this.elements
                                , n = e.elements;
                            return t[0] = n[0],
                                t[1] = n[1],
                                t[2] = n[2],
                                t[3] = n[3],
                                t[4] = n[4],
                                t[5] = n[5],
                                t[6] = n[6],
                                t[7] = n[7],
                                t[8] = n[8],
                                this
                        }
                        extractBasis(e, t, n) {
                            return e.setFromMatrix3Column(this, 0),
                                t.setFromMatrix3Column(this, 1),
                                n.setFromMatrix3Column(this, 2),
                                this
                        }
                        setFromMatrix4(e) {
                            const t = e.elements;
                            return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
                                this
                        }
                        multiply(e) {
                            return this.multiplyMatrices(this, e)
                        }
                        premultiply(e) {
                            return this.multiplyMatrices(e, this)
                        }
                        multiplyMatrices(e, t) {
                            const n = e.elements
                                , i = t.elements
                                , r = this.elements
                                , a = n[0]
                                , s = n[3]
                                , o = n[6]
                                , l = n[1]
                                , c = n[4]
                                , h = n[7]
                                , d = n[2]
                                , u = n[5]
                                , p = n[8]
                                , f = i[0]
                                , m = i[3]
                                , g = i[6]
                                , v = i[1]
                                , w = i[4]
                                , A = i[7]
                                , y = i[2]
                                , b = i[5]
                                , x = i[8];
                            return r[0] = a * f + s * v + o * y,
                                r[3] = a * m + s * w + o * b,
                                r[6] = a * g + s * A + o * x,
                                r[1] = l * f + c * v + h * y,
                                r[4] = l * m + c * w + h * b,
                                r[7] = l * g + c * A + h * x,
                                r[2] = d * f + u * v + p * y,
                                r[5] = d * m + u * w + p * b,
                                r[8] = d * g + u * A + p * x,
                                this
                        }
                        multiplyScalar(e) {
                            const t = this.elements;
                            return t[0] *= e,
                                t[3] *= e,
                                t[6] *= e,
                                t[1] *= e,
                                t[4] *= e,
                                t[7] *= e,
                                t[2] *= e,
                                t[5] *= e,
                                t[8] *= e,
                                this
                        }
                        determinant() {
                            const e = this.elements
                                , t = e[0]
                                , n = e[1]
                                , i = e[2]
                                , r = e[3]
                                , a = e[4]
                                , s = e[5]
                                , o = e[6]
                                , l = e[7]
                                , c = e[8];
                            return t * a * c - t * s * l - n * r * c + n * s * o + i * r * l - i * a * o
                        }
                        invert() {
                            const e = this.elements
                                , t = e[0]
                                , n = e[1]
                                , i = e[2]
                                , r = e[3]
                                , a = e[4]
                                , s = e[5]
                                , o = e[6]
                                , l = e[7]
                                , c = e[8]
                                , h = c * a - s * l
                                , d = s * o - c * r
                                , u = l * r - a * o
                                , p = t * h + n * d + i * u;
                            if (0 === p)
                                return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                            const f = 1 / p;
                            return e[0] = h * f,
                                e[1] = (i * l - c * n) * f,
                                e[2] = (s * n - i * a) * f,
                                e[3] = d * f,
                                e[4] = (c * t - i * o) * f,
                                e[5] = (i * r - s * t) * f,
                                e[6] = u * f,
                                e[7] = (n * o - l * t) * f,
                                e[8] = (a * t - n * r) * f,
                                this
                        }
                        transpose() {
                            let e;
                            const t = this.elements;
                            return e = t[1],
                                t[1] = t[3],
                                t[3] = e,
                                e = t[2],
                                t[2] = t[6],
                                t[6] = e,
                                e = t[5],
                                t[5] = t[7],
                                t[7] = e,
                                this
                        }
                        getNormalMatrix(e) {
                            return this.setFromMatrix4(e).invert().transpose()
                        }
                        transposeIntoArray(e) {
                            const t = this.elements;
                            return e[0] = t[0],
                                e[1] = t[3],
                                e[2] = t[6],
                                e[3] = t[1],
                                e[4] = t[4],
                                e[5] = t[7],
                                e[6] = t[2],
                                e[7] = t[5],
                                e[8] = t[8],
                                this
                        }
                        setUvTransform(e, t, n, i, r, a, s) {
                            const o = Math.cos(r)
                                , l = Math.sin(r);
                            return this.set(n * o, n * l, -n * (o * a + l * s) + a + e, -i * l, i * o, -i * (-l * a + o * s) + s + t, 0, 0, 1),
                                this
                        }
                        scale(e, t) {
                            return this.premultiply(Yt.makeScale(e, t)),
                                this
                        }
                        rotate(e) {
                            return this.premultiply(Yt.makeRotation(-e)),
                                this
                        }
                        translate(e, t) {
                            return this.premultiply(Yt.makeTranslation(e, t)),
                                this
                        }
                        makeTranslation(e, t) {
                            return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
                                this
                        }
                        makeRotation(e) {
                            const t = Math.cos(e)
                                , n = Math.sin(e);
                            return this.set(t, -n, 0, n, t, 0, 0, 0, 1),
                                this
                        }
                        makeScale(e, t) {
                            return this.set(e, 0, 0, 0, t, 0, 0, 0, 1),
                                this
                        }
                        equals(e) {
                            const t = this.elements
                                , n = e.elements;
                            for (let e = 0; e < 9; e++)
                                if (t[e] !== n[e])
                                    return !1;
                            return !0
                        }
                        fromArray(e, t=0) {
                            for (let n = 0; n < 9; n++)
                                this.elements[n] = e[n + t];
                            return this
                        }
                        toArray(e=[], t=0) {
                            const n = this.elements;
                            return e[t] = n[0],
                                e[t + 1] = n[1],
                                e[t + 2] = n[2],
                                e[t + 3] = n[3],
                                e[t + 4] = n[4],
                                e[t + 5] = n[5],
                                e[t + 6] = n[6],
                                e[t + 7] = n[7],
                                e[t + 8] = n[8],
                                e
                        }
                        clone() {
                            return (new this.constructor).fromArray(this.elements)
                        }
                    }
                    const Yt = new Qt;
                    function qt(e) {
                        for (let t = e.length - 1; t >= 0; --t)
                            if (e[t] >= 65535)
                                return !0;
                        return !1
                    }
                    Int8Array,
                        Uint8Array,
                        Uint8ClampedArray,
                        Int16Array,
                        Uint16Array,
                        Int32Array,
                        Uint32Array,
                        Float32Array,
                        Float64Array;
                    function Kt(e) {
                        return document.createElementNS("http://www.w3.org/1999/xhtml", e)
                    }
                    function Xt() {
                        const e = Kt("canvas");
                        return e.style.display = "block",
                            e
                    }
                    const Zt = {};
                    function Jt(e) {
                        e in Zt || (Zt[e] = !0,
                            console.warn(e))
                    }
                    const $t = (new Qt).set(.4123908, .3575843, .1804808, .212639, .7151687, .0721923, .0193308, .1191948, .9505322)
                        , en = (new Qt).set(3.2409699, -1.5373832, -.4986108, -.9692436, 1.8759675, .0415551, .0556301, -.203977, 1.0569715);
                    function tn() {
                        const e = {
                            enabled: !0,
                            workingColorSpace: vt,
                            spaces: {},
                            convert: function(e, t, n) {
                                return !1 !== this.enabled && t !== n && t && n ? (this.spaces[t].transfer === At && (e.r = rn(e.r),
                                    e.g = rn(e.g),
                                    e.b = rn(e.b)),
                                this.spaces[t].primaries !== this.spaces[n].primaries && (e.applyMatrix3(this.spaces[t].toXYZ),
                                    e.applyMatrix3(this.spaces[n].fromXYZ)),
                                this.spaces[n].transfer === At && (e.r = an(e.r),
                                    e.g = an(e.g),
                                    e.b = an(e.b)),
                                    e) : e
                            },
                            fromWorkingColorSpace: function(e, t) {
                                return this.convert(e, this.workingColorSpace, t)
                            },
                            toWorkingColorSpace: function(e, t) {
                                return this.convert(e, t, this.workingColorSpace)
                            },
                            getPrimaries: function(e) {
                                return this.spaces[e].primaries
                            },
                            getTransfer: function(e) {
                                return e === mt ? wt : this.spaces[e].transfer
                            },
                            getLuminanceCoefficients: function(e, t=this.workingColorSpace) {
                                return e.fromArray(this.spaces[t].luminanceCoefficients)
                            },
                            define: function(e) {
                                Object.assign(this.spaces, e)
                            },
                            _getMatrix: function(e, t, n) {
                                return e.copy(this.spaces[t].toXYZ).multiply(this.spaces[n].fromXYZ)
                            },
                            _getDrawingBufferColorSpace: function(e) {
                                return this.spaces[e].outputColorSpaceConfig.drawingBufferColorSpace
                            },
                            _getUnpackColorSpace: function(e=this.workingColorSpace) {
                                return this.spaces[e].workingColorSpaceConfig.unpackColorSpace
                            }
                        }
                            , t = [.64, .33, .3, .6, .15, .06]
                            , n = [.2126, .7152, .0722]
                            , i = [.3127, .329];
                        return e.define({
                            [vt]: {
                                primaries: t,
                                whitePoint: i,
                                transfer: wt,
                                toXYZ: $t,
                                fromXYZ: en,
                                luminanceCoefficients: n,
                                workingColorSpaceConfig: {
                                    unpackColorSpace: gt
                                },
                                outputColorSpaceConfig: {
                                    drawingBufferColorSpace: gt
                                }
                            },
                            [gt]: {
                                primaries: t,
                                whitePoint: i,
                                transfer: At,
                                toXYZ: $t,
                                fromXYZ: en,
                                luminanceCoefficients: n,
                                outputColorSpaceConfig: {
                                    drawingBufferColorSpace: gt
                                }
                            }
                        }),
                            e
                    }
                    const nn = tn();
                    function rn(e) {
                        return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
                    }
                    function an(e) {
                        return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
                    }
                    let sn;
                    class on {
                        static getDataURL(e) {
                            if (/^data:/i.test(e.src))
                                return e.src;
                            if ("undefined" == typeof HTMLCanvasElement)
                                return e.src;
                            let t;
                            if (e instanceof HTMLCanvasElement)
                                t = e;
                            else {
                                void 0 === sn && (sn = Kt("canvas")),
                                    sn.width = e.width,
                                    sn.height = e.height;
                                const n = sn.getContext("2d");
                                e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height),
                                    t = sn
                            }
                            return t.toDataURL("image/png")
                        }
                        static sRGBToLinear(e) {
                            if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                                const t = Kt("canvas");
                                t.width = e.width,
                                    t.height = e.height;
                                const n = t.getContext("2d");
                                n.drawImage(e, 0, 0, e.width, e.height);
                                const i = n.getImageData(0, 0, e.width, e.height)
                                    , r = i.data;
                                for (let e = 0; e < r.length; e++)
                                    r[e] = 255 * rn(r[e] / 255);
                                return n.putImageData(i, 0, 0),
                                    t
                            }
                            if (e.data) {
                                const t = e.data.slice(0);
                                for (let e = 0; e < t.length; e++)
                                    t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[e] = Math.floor(255 * rn(t[e] / 255)) : t[e] = rn(t[e]);
                                return {
                                    data: t,
                                    width: e.width,
                                    height: e.height
                                }
                            }
                            return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
                                e
                        }
                    }
                    let ln = 0;
                    class cn {
                        constructor(e=null) {
                            this.isSource = !0,
                                Object.defineProperty(this, "id", {
                                    value: ln++
                                }),
                                this.uuid = zt(),
                                this.data = e,
                                this.dataReady = !0,
                                this.version = 0
                        }
                        set needsUpdate(e) {
                            !0 === e && this.version++
                        }
                        toJSON(e) {
                            const t = void 0 === e || "string" == typeof e;
                            if (!t && void 0 !== e.images[this.uuid])
                                return e.images[this.uuid];
                            const n = {
                                uuid: this.uuid,
                                url: ""
                            }
                                , i = this.data;
                            if (null !== i) {
                                let e;
                                if (Array.isArray(i)) {
                                    e = [];
                                    for (let t = 0, n = i.length; t < n; t++)
                                        i[t].isDataTexture ? e.push(hn(i[t].image)) : e.push(hn(i[t]))
                                } else
                                    e = hn(i);
                                n.url = e
                            }
                            return t || (e.images[this.uuid] = n),
                                n
                        }
                    }
                    function hn(e) {
                        return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? on.getDataURL(e) : e.data ? {
                            data: Array.from(e.data),
                            width: e.width,
                            height: e.height,
                            type: e.data.constructor.name
                        } : (console.warn("THREE.Texture: Unable to serialize Texture."),
                            {})
                    }
                    let dn = 0;
                    class un extends Lt {
                        constructor(e=un.DEFAULT_IMAGE, t=un.DEFAULT_MAPPING, n=1001, i=1001, r=1006, a=1008, s=1023, o=1009, l=un.DEFAULT_ANISOTROPY, c="") {
                            super(),
                                this.isTexture = !0,
                                Object.defineProperty(this, "id", {
                                    value: dn++
                                }),
                                this.uuid = zt(),
                                this.name = "",
                                this.source = new cn(e),
                                this.mipmaps = [],
                                this.mapping = t,
                                this.channel = 0,
                                this.wrapS = n,
                                this.wrapT = i,
                                this.magFilter = r,
                                this.minFilter = a,
                                this.anisotropy = l,
                                this.format = s,
                                this.internalFormat = null,
                                this.type = o,
                                this.offset = new jt(0,0),
                                this.repeat = new jt(1,1),
                                this.center = new jt(0,0),
                                this.rotation = 0,
                                this.matrixAutoUpdate = !0,
                                this.matrix = new Qt,
                                this.generateMipmaps = !0,
                                this.premultiplyAlpha = !1,
                                this.flipY = !0,
                                this.unpackAlignment = 4,
                                this.colorSpace = c,
                                this.userData = {},
                                this.version = 0,
                                this.onUpdate = null,
                                this.renderTarget = null,
                                this.isRenderTargetTexture = !1,
                                this.pmremVersion = 0
                        }
                        get image() {
                            return this.source.data
                        }
                        set image(e=null) {
                            this.source.data = e
                        }
                        updateMatrix() {
                            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                        }
                        clone() {
                            return (new this.constructor).copy(this)
                        }
                        copy(e) {
                            return this.name = e.name,
                                this.source = e.source,
                                this.mipmaps = e.mipmaps.slice(0),
                                this.mapping = e.mapping,
                                this.channel = e.channel,
                                this.wrapS = e.wrapS,
                                this.wrapT = e.wrapT,
                                this.magFilter = e.magFilter,
                                this.minFilter = e.minFilter,
                                this.anisotropy = e.anisotropy,
                                this.format = e.format,
                                this.internalFormat = e.internalFormat,
                                this.type = e.type,
                                this.offset.copy(e.offset),
                                this.repeat.copy(e.repeat),
                                this.center.copy(e.center),
                                this.rotation = e.rotation,
                                this.matrixAutoUpdate = e.matrixAutoUpdate,
                                this.matrix.copy(e.matrix),
                                this.generateMipmaps = e.generateMipmaps,
                                this.premultiplyAlpha = e.premultiplyAlpha,
                                this.flipY = e.flipY,
                                this.unpackAlignment = e.unpackAlignment,
                                this.colorSpace = e.colorSpace,
                                this.renderTarget = e.renderTarget,
                                this.isRenderTargetTexture = e.isRenderTargetTexture,
                                this.userData = JSON.parse(JSON.stringify(e.userData)),
                                this.needsUpdate = !0,
                                this
                        }
                        toJSON(e) {
                            const t = void 0 === e || "string" == typeof e;
                            if (!t && void 0 !== e.textures[this.uuid])
                                return e.textures[this.uuid];
                            const n = {
                                metadata: {
                                    version: 4.6,
                                    type: "Texture",
                                    generator: "Texture.toJSON"
                                },
                                uuid: this.uuid,
                                name: this.name,
                                image: this.source.toJSON(e).uuid,
                                mapping: this.mapping,
                                channel: this.channel,
                                repeat: [this.repeat.x, this.repeat.y],
                                offset: [this.offset.x, this.offset.y],
                                center: [this.center.x, this.center.y],
                                rotation: this.rotation,
                                wrap: [this.wrapS, this.wrapT],
                                format: this.format,
                                internalFormat: this.internalFormat,
                                type: this.type,
                                colorSpace: this.colorSpace,
                                minFilter: this.minFilter,
                                magFilter: this.magFilter,
                                anisotropy: this.anisotropy,
                                flipY: this.flipY,
                                generateMipmaps: this.generateMipmaps,
                                premultiplyAlpha: this.premultiplyAlpha,
                                unpackAlignment: this.unpackAlignment
                            };
                            return Object.keys(this.userData).length > 0 && (n.userData = this.userData),
                            t || (e.textures[this.uuid] = n),
                                n
                        }
                        dispose() {
                            this.dispatchEvent({
                                type: "dispose"
                            })
                        }
                        transformUv(e) {
                            if (300 !== this.mapping)
                                return e;
                            if (e.applyMatrix3(this.matrix),
                            e.x < 0 || e.x > 1)
                                switch (this.wrapS) {
                                    case re:
                                        e.x = e.x - Math.floor(e.x);
                                        break;
                                    case ae:
                                        e.x = e.x < 0 ? 0 : 1;
                                        break;
                                    case se:
                                        1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
                                }
                            if (e.y < 0 || e.y > 1)
                                switch (this.wrapT) {
                                    case re:
                                        e.y = e.y - Math.floor(e.y);
                                        break;
                                    case ae:
                                        e.y = e.y < 0 ? 0 : 1;
                                        break;
                                    case se:
                                        1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
                                }
                            return this.flipY && (e.y = 1 - e.y),
                                e
                        }
                        set needsUpdate(e) {
                            !0 === e && (this.version++,
                                this.source.needsUpdate = !0)
                        }
                        set needsPMREMUpdate(e) {
                            !0 === e && this.pmremVersion++
                        }
                    }
                    un.DEFAULT_IMAGE = null,
                        un.DEFAULT_MAPPING = 300,
                        un.DEFAULT_ANISOTROPY = 1;
                    class pn {
                        constructor(e=0, t=0, n=0, i=1) {
                            pn.prototype.isVector4 = !0,
                                this.x = e,
                                this.y = t,
                                this.z = n,
                                this.w = i
                        }
                        get width() {
                            return this.z
                        }
                        set width(e) {
                            this.z = e
                        }
                        get height() {
                            return this.w
                        }
                        set height(e) {
                            this.w = e
                        }
                        set(e, t, n, i) {
                            return this.x = e,
                                this.y = t,
                                this.z = n,
                                this.w = i,
                                this
                        }
                        setScalar(e) {
                            return this.x = e,
                                this.y = e,
                                this.z = e,
                                this.w = e,
                                this
                        }
                        setX(e) {
                            return this.x = e,
                                this
                        }
                        setY(e) {
                            return this.y = e,
                                this
                        }
                        setZ(e) {
                            return this.z = e,
                                this
                        }
                        setW(e) {
                            return this.w = e,
                                this
                        }
                        setComponent(e, t) {
                            switch (e) {
                                case 0:
                                    this.x = t;
                                    break;
                                case 1:
                                    this.y = t;
                                    break;
                                case 2:
                                    this.z = t;
                                    break;
                                case 3:
                                    this.w = t;
                                    break;
                                default:
                                    throw new Error("index is out of range: " + e)
                            }
                            return this
                        }
                        getComponent(e) {
                            switch (e) {
                                case 0:
                                    return this.x;
                                case 1:
                                    return this.y;
                                case 2:
                                    return this.z;
                                case 3:
                                    return this.w;
                                default:
                                    throw new Error("index is out of range: " + e)
                            }
                        }
                        clone() {
                            return new this.constructor(this.x,this.y,this.z,this.w)
                        }
                        copy(e) {
                            return this.x = e.x,
                                this.y = e.y,
                                this.z = e.z,
                                this.w = void 0 !== e.w ? e.w : 1,
                                this
                        }
                        add(e) {
                            return this.x += e.x,
                                this.y += e.y,
                                this.z += e.z,
                                this.w += e.w,
                                this
                        }
                        addScalar(e) {
                            return this.x += e,
                                this.y += e,
                                this.z += e,
                                this.w += e,
                                this
                        }
                        addVectors(e, t) {
                            return this.x = e.x + t.x,
                                this.y = e.y + t.y,
                                this.z = e.z + t.z,
                                this.w = e.w + t.w,
                                this
                        }
                        addScaledVector(e, t) {
                            return this.x += e.x * t,
                                this.y += e.y * t,
                                this.z += e.z * t,
                                this.w += e.w * t,
                                this
                        }
                        sub(e) {
                            return this.x -= e.x,
                                this.y -= e.y,
                                this.z -= e.z,
                                this.w -= e.w,
                                this
                        }
                        subScalar(e) {
                            return this.x -= e,
                                this.y -= e,
                                this.z -= e,
                                this.w -= e,
                                this
                        }
                        subVectors(e, t) {
                            return this.x = e.x - t.x,
                                this.y = e.y - t.y,
                                this.z = e.z - t.z,
                                this.w = e.w - t.w,
                                this
                        }
                        multiply(e) {
                            return this.x *= e.x,
                                this.y *= e.y,
                                this.z *= e.z,
                                this.w *= e.w,
                                this
                        }
                        multiplyScalar(e) {
                            return this.x *= e,
                                this.y *= e,
                                this.z *= e,
                                this.w *= e,
                                this
                        }
                        applyMatrix4(e) {
                            const t = this.x
                                , n = this.y
                                , i = this.z
                                , r = this.w
                                , a = e.elements;
                            return this.x = a[0] * t + a[4] * n + a[8] * i + a[12] * r,
                                this.y = a[1] * t + a[5] * n + a[9] * i + a[13] * r,
                                this.z = a[2] * t + a[6] * n + a[10] * i + a[14] * r,
                                this.w = a[3] * t + a[7] * n + a[11] * i + a[15] * r,
                                this
                        }
                        divide(e) {
                            return this.x /= e.x,
                                this.y /= e.y,
                                this.z /= e.z,
                                this.w /= e.w,
                                this
                        }
                        divideScalar(e) {
                            return this.multiplyScalar(1 / e)
                        }
                        setAxisAngleFromQuaternion(e) {
                            this.w = 2 * Math.acos(e.w);
                            const t = Math.sqrt(1 - e.w * e.w);
                            return t < 1e-4 ? (this.x = 1,
                                this.y = 0,
                                this.z = 0) : (this.x = e.x / t,
                                this.y = e.y / t,
                                this.z = e.z / t),
                                this
                        }
                        setAxisAngleFromRotationMatrix(e) {
                            let t, n, i, r;
                            const a = .01
                                , s = .1
                                , o = e.elements
                                , l = o[0]
                                , c = o[4]
                                , h = o[8]
                                , d = o[1]
                                , u = o[5]
                                , p = o[9]
                                , f = o[2]
                                , m = o[6]
                                , g = o[10];
                            if (Math.abs(c - d) < a && Math.abs(h - f) < a && Math.abs(p - m) < a) {
                                if (Math.abs(c + d) < s && Math.abs(h + f) < s && Math.abs(p + m) < s && Math.abs(l + u + g - 3) < s)
                                    return this.set(1, 0, 0, 0),
                                        this;
                                t = Math.PI;
                                const e = (l + 1) / 2
                                    , o = (u + 1) / 2
                                    , v = (g + 1) / 2
                                    , w = (c + d) / 4
                                    , A = (h + f) / 4
                                    , y = (p + m) / 4;
                                return e > o && e > v ? e < a ? (n = 0,
                                    i = .707106781,
                                    r = .707106781) : (n = Math.sqrt(e),
                                    i = w / n,
                                    r = A / n) : o > v ? o < a ? (n = .707106781,
                                    i = 0,
                                    r = .707106781) : (i = Math.sqrt(o),
                                    n = w / i,
                                    r = y / i) : v < a ? (n = .707106781,
                                    i = .707106781,
                                    r = 0) : (r = Math.sqrt(v),
                                    n = A / r,
                                    i = y / r),
                                    this.set(n, i, r, t),
                                    this
                            }
                            let v = Math.sqrt((m - p) * (m - p) + (h - f) * (h - f) + (d - c) * (d - c));
                            return Math.abs(v) < .001 && (v = 1),
                                this.x = (m - p) / v,
                                this.y = (h - f) / v,
                                this.z = (d - c) / v,
                                this.w = Math.acos((l + u + g - 1) / 2),
                                this
                        }
                        setFromMatrixPosition(e) {
                            const t = e.elements;
                            return this.x = t[12],
                                this.y = t[13],
                                this.z = t[14],
                                this.w = t[15],
                                this
                        }
                        min(e) {
                            return this.x = Math.min(this.x, e.x),
                                this.y = Math.min(this.y, e.y),
                                this.z = Math.min(this.z, e.z),
                                this.w = Math.min(this.w, e.w),
                                this
                        }
                        max(e) {
                            return this.x = Math.max(this.x, e.x),
                                this.y = Math.max(this.y, e.y),
                                this.z = Math.max(this.z, e.z),
                                this.w = Math.max(this.w, e.w),
                                this
                        }
                        clamp(e, t) {
                            return this.x = Ot(this.x, e.x, t.x),
                                this.y = Ot(this.y, e.y, t.y),
                                this.z = Ot(this.z, e.z, t.z),
                                this.w = Ot(this.w, e.w, t.w),
                                this
                        }
                        clampScalar(e, t) {
                            return this.x = Ot(this.x, e, t),
                                this.y = Ot(this.y, e, t),
                                this.z = Ot(this.z, e, t),
                                this.w = Ot(this.w, e, t),
                                this
                        }
                        clampLength(e, t) {
                            const n = this.length();
                            return this.divideScalar(n || 1).multiplyScalar(Ot(n, e, t))
                        }
                        floor() {
                            return this.x = Math.floor(this.x),
                                this.y = Math.floor(this.y),
                                this.z = Math.floor(this.z),
                                this.w = Math.floor(this.w),
                                this
                        }
                        ceil() {
                            return this.x = Math.ceil(this.x),
                                this.y = Math.ceil(this.y),
                                this.z = Math.ceil(this.z),
                                this.w = Math.ceil(this.w),
                                this
                        }
                        round() {
                            return this.x = Math.round(this.x),
                                this.y = Math.round(this.y),
                                this.z = Math.round(this.z),
                                this.w = Math.round(this.w),
                                this
                        }
                        roundToZero() {
                            return this.x = Math.trunc(this.x),
                                this.y = Math.trunc(this.y),
                                this.z = Math.trunc(this.z),
                                this.w = Math.trunc(this.w),
                                this
                        }
                        negate() {
                            return this.x = -this.x,
                                this.y = -this.y,
                                this.z = -this.z,
                                this.w = -this.w,
                                this
                        }
                        dot(e) {
                            return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
                        }
                        lengthSq() {
                            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                        }
                        length() {
                            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                        }
                        manhattanLength() {
                            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                        }
                        normalize() {
                            return this.divideScalar(this.length() || 1)
                        }
                        setLength(e) {
                            return this.normalize().multiplyScalar(e)
                        }
                        lerp(e, t) {
                            return this.x += (e.x - this.x) * t,
                                this.y += (e.y - this.y) * t,
                                this.z += (e.z - this.z) * t,
                                this.w += (e.w - this.w) * t,
                                this
                        }
                        lerpVectors(e, t, n) {
                            return this.x = e.x + (t.x - e.x) * n,
                                this.y = e.y + (t.y - e.y) * n,
                                this.z = e.z + (t.z - e.z) * n,
                                this.w = e.w + (t.w - e.w) * n,
                                this
                        }
                        equals(e) {
                            return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
                        }
                        fromArray(e, t=0) {
                            return this.x = e[t],
                                this.y = e[t + 1],
                                this.z = e[t + 2],
                                this.w = e[t + 3],
                                this
                        }
                        toArray(e=[], t=0) {
                            return e[t] = this.x,
                                e[t + 1] = this.y,
                                e[t + 2] = this.z,
                                e[t + 3] = this.w,
                                e
                        }
                        fromBufferAttribute(e, t) {
                            return this.x = e.getX(t),
                                this.y = e.getY(t),
                                this.z = e.getZ(t),
                                this.w = e.getW(t),
                                this
                        }
                        random() {
                            return this.x = Math.random(),
                                this.y = Math.random(),
                                this.z = Math.random(),
                                this.w = Math.random(),
                                this
                        }
                        *[Symbol.iterator]() {
                            yield this.x,
                                yield this.y,
                                yield this.z,
                                yield this.w
                        }
                    }
                    class fn extends Lt {
                        constructor(e=1, t=1, n={}) {
                            super(),
                                this.isRenderTarget = !0,
                                this.width = e,
                                this.height = t,
                                this.depth = 1,
                                this.scissor = new pn(0,0,e,t),
                                this.scissorTest = !1,
                                this.viewport = new pn(0,0,e,t);
                            const i = {
                                width: e,
                                height: t,
                                depth: 1
                            };
                            n = Object.assign({
                                generateMipmaps: !1,
                                internalFormat: null,
                                minFilter: he,
                                depthBuffer: !0,
                                stencilBuffer: !1,
                                resolveDepthBuffer: !0,
                                resolveStencilBuffer: !0,
                                depthTexture: null,
                                samples: 0,
                                count: 1
                            }, n);
                            const r = new un(i,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.colorSpace);
                            r.flipY = !1,
                                r.generateMipmaps = n.generateMipmaps,
                                r.internalFormat = n.internalFormat,
                                this.textures = [];
                            const a = n.count;
                            for (let e = 0; e < a; e++)
                                this.textures[e] = r.clone(),
                                    this.textures[e].isRenderTargetTexture = !0,
                                    this.textures[e].renderTarget = this;
                            this.depthBuffer = n.depthBuffer,
                                this.stencilBuffer = n.stencilBuffer,
                                this.resolveDepthBuffer = n.resolveDepthBuffer,
                                this.resolveStencilBuffer = n.resolveStencilBuffer,
                                this._depthTexture = null,
                                this.depthTexture = n.depthTexture,
                                this.samples = n.samples
                        }
                        get texture() {
                            return this.textures[0]
                        }
                        set texture(e) {
                            this.textures[0] = e
                        }
                        set depthTexture(e) {
                            null !== this._depthTexture && (this._depthTexture.renderTarget = null),
                            null !== e && (e.renderTarget = this),
                                this._depthTexture = e
                        }
                        get depthTexture() {
                            return this._depthTexture
                        }
                        setSize(e, t, n=1) {
                            if (this.width !== e || this.height !== t || this.depth !== n) {
                                this.width = e,
                                    this.height = t,
                                    this.depth = n;
                                for (let i = 0, r = this.textures.length; i < r; i++)
                                    this.textures[i].image.width = e,
                                        this.textures[i].image.height = t,
                                        this.textures[i].image.depth = n;
                                this.dispose()
                            }
                            this.viewport.set(0, 0, e, t),
                                this.scissor.set(0, 0, e, t)
                        }
                        clone() {
                            return (new this.constructor).copy(this)
                        }
                        copy(e) {
                            this.width = e.width,
                                this.height = e.height,
                                this.depth = e.depth,
                                this.scissor.copy(e.scissor),
                                this.scissorTest = e.scissorTest,
                                this.viewport.copy(e.viewport),
                                this.textures.length = 0;
                            for (let t = 0, n = e.textures.length; t < n; t++) {
                                this.textures[t] = e.textures[t].clone(),
                                    this.textures[t].isRenderTargetTexture = !0,
                                    this.textures[t].renderTarget = this;
                                const n = Object.assign({}, e.textures[t].image);
                                this.textures[t].source = new cn(n)
                            }
                            return this.depthBuffer = e.depthBuffer,
                                this.stencilBuffer = e.stencilBuffer,
                                this.resolveDepthBuffer = e.resolveDepthBuffer,
                                this.resolveStencilBuffer = e.resolveStencilBuffer,
                            null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()),
                                this.samples = e.samples,
                                this
                        }
                        dispose() {
                            this.dispatchEvent({
                                type: "dispose"
                            })
                        }
                    }
                    class mn extends fn {
                        constructor(e=1, t=1, n={}) {
                            super(e, t, n),
                                this.isWebGLRenderTarget = !0
                        }
                    }
                    class gn extends un {
                        constructor(e=null, t=1, n=1, i=1) {
                            super(null),
                                this.isDataArrayTexture = !0,
                                this.image = {
                                    data: e,
                                    width: t,
                                    height: n,
                                    depth: i
                                },
                                this.magFilter = oe,
                                this.minFilter = oe,
                                this.wrapR = ae,
                                this.generateMipmaps = !1,
                                this.flipY = !1,
                                this.unpackAlignment = 1,
                                this.layerUpdates = new Set
                        }
                        addLayerUpdate(e) {
                            this.layerUpdates.add(e)
                        }
                        clearLayerUpdates() {
                            this.layerUpdates.clear()
                        }
                    }
                    class vn extends un {
                        constructor(e=null, t=1, n=1, i=1) {
                            super(null),
                                this.isData3DTexture = !0,
                                this.image = {
                                    data: e,
                                    width: t,
                                    height: n,
                                    depth: i
                                },
                                this.magFilter = oe,
                                this.minFilter = oe,
                                this.wrapR = ae,
                                this.generateMipmaps = !1,
                                this.flipY = !1,
                                this.unpackAlignment = 1
                        }
                    }
                    class wn {
                        constructor(e=0, t=0, n=0, i=1) {
                            this.isQuaternion = !0,
                                this._x = e,
                                this._y = t,
                                this._z = n,
                                this._w = i
                        }
                        static slerpFlat(e, t, n, i, r, a, s) {
                            let o = n[i + 0]
                                , l = n[i + 1]
                                , c = n[i + 2]
                                , h = n[i + 3];
                            const d = r[a + 0]
                                , u = r[a + 1]
                                , p = r[a + 2]
                                , f = r[a + 3];
                            if (0 === s)
                                return e[t + 0] = o,
                                    e[t + 1] = l,
                                    e[t + 2] = c,
                                    void (e[t + 3] = h);
                            if (1 === s)
                                return e[t + 0] = d,
                                    e[t + 1] = u,
                                    e[t + 2] = p,
                                    void (e[t + 3] = f);
                            if (h !== f || o !== d || l !== u || c !== p) {
                                let e = 1 - s;
                                const t = o * d + l * u + c * p + h * f
                                    , n = t >= 0 ? 1 : -1
                                    , i = 1 - t * t;
                                if (i > Number.EPSILON) {
                                    const r = Math.sqrt(i)
                                        , a = Math.atan2(r, t * n);
                                    e = Math.sin(e * a) / r,
                                        s = Math.sin(s * a) / r
                                }
                                const r = s * n;
                                if (o = o * e + d * r,
                                    l = l * e + u * r,
                                    c = c * e + p * r,
                                    h = h * e + f * r,
                                e === 1 - s) {
                                    const e = 1 / Math.sqrt(o * o + l * l + c * c + h * h);
                                    o *= e,
                                        l *= e,
                                        c *= e,
                                        h *= e
                                }
                            }
                            e[t] = o,
                                e[t + 1] = l,
                                e[t + 2] = c,
                                e[t + 3] = h
                        }
                        static multiplyQuaternionsFlat(e, t, n, i, r, a) {
                            const s = n[i]
                                , o = n[i + 1]
                                , l = n[i + 2]
                                , c = n[i + 3]
                                , h = r[a]
                                , d = r[a + 1]
                                , u = r[a + 2]
                                , p = r[a + 3];
                            return e[t] = s * p + c * h + o * u - l * d,
                                e[t + 1] = o * p + c * d + l * h - s * u,
                                e[t + 2] = l * p + c * u + s * d - o * h,
                                e[t + 3] = c * p - s * h - o * d - l * u,
                                e
                        }
                        get x() {
                            return this._x
                        }
                        set x(e) {
                            this._x = e,
                                this._onChangeCallback()
                        }
                        get y() {
                            return this._y
                        }
                        set y(e) {
                            this._y = e,
                                this._onChangeCallback()
                        }
                        get z() {
                            return this._z
                        }
                        set z(e) {
                            this._z = e,
                                this._onChangeCallback()
                        }
                        get w() {
                            return this._w
                        }
                        set w(e) {
                            this._w = e,
                                this._onChangeCallback()
                        }
                        set(e, t, n, i) {
                            return this._x = e,
                                this._y = t,
                                this._z = n,
                                this._w = i,
                                this._onChangeCallback(),
                                this
                        }
                        clone() {
                            return new this.constructor(this._x,this._y,this._z,this._w)
                        }
                        copy(e) {
                            return this._x = e.x,
                                this._y = e.y,
                                this._z = e.z,
                                this._w = e.w,
                                this._onChangeCallback(),
                                this
                        }
                        setFromEuler(e, t=!0) {
                            const n = e._x
                                , i = e._y
                                , r = e._z
                                , a = e._order
                                , s = Math.cos
                                , o = Math.sin
                                , l = s(n / 2)
                                , c = s(i / 2)
                                , h = s(r / 2)
                                , d = o(n / 2)
                                , u = o(i / 2)
                                , p = o(r / 2);
                            switch (a) {
                                case "XYZ":
                                    this._x = d * c * h + l * u * p,
                                        this._y = l * u * h - d * c * p,
                                        this._z = l * c * p + d * u * h,
                                        this._w = l * c * h - d * u * p;
                                    break;
                                case "YXZ":
                                    this._x = d * c * h + l * u * p,
                                        this._y = l * u * h - d * c * p,
                                        this._z = l * c * p - d * u * h,
                                        this._w = l * c * h + d * u * p;
                                    break;
                                case "ZXY":
                                    this._x = d * c * h - l * u * p,
                                        this._y = l * u * h + d * c * p,
                                        this._z = l * c * p + d * u * h,
                                        this._w = l * c * h - d * u * p;
                                    break;
                                case "ZYX":
                                    this._x = d * c * h - l * u * p,
                                        this._y = l * u * h + d * c * p,
                                        this._z = l * c * p - d * u * h,
                                        this._w = l * c * h + d * u * p;
                                    break;
                                case "YZX":
                                    this._x = d * c * h + l * u * p,
                                        this._y = l * u * h + d * c * p,
                                        this._z = l * c * p - d * u * h,
                                        this._w = l * c * h - d * u * p;
                                    break;
                                case "XZY":
                                    this._x = d * c * h - l * u * p,
                                        this._y = l * u * h - d * c * p,
                                        this._z = l * c * p + d * u * h,
                                        this._w = l * c * h + d * u * p;
                                    break;
                                default:
                                    console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a)
                            }
                            return !0 === t && this._onChangeCallback(),
                                this
                        }
                        setFromAxisAngle(e, t) {
                            const n = t / 2
                                , i = Math.sin(n);
                            return this._x = e.x * i,
                                this._y = e.y * i,
                                this._z = e.z * i,
                                this._w = Math.cos(n),
                                this._onChangeCallback(),
                                this
                        }
                        setFromRotationMatrix(e) {
                            const t = e.elements
                                , n = t[0]
                                , i = t[4]
                                , r = t[8]
                                , a = t[1]
                                , s = t[5]
                                , o = t[9]
                                , l = t[2]
                                , c = t[6]
                                , h = t[10]
                                , d = n + s + h;
                            if (d > 0) {
                                const e = .5 / Math.sqrt(d + 1);
                                this._w = .25 / e,
                                    this._x = (c - o) * e,
                                    this._y = (r - l) * e,
                                    this._z = (a - i) * e
                            } else if (n > s && n > h) {
                                const e = 2 * Math.sqrt(1 + n - s - h);
                                this._w = (c - o) / e,
                                    this._x = .25 * e,
                                    this._y = (i + a) / e,
                                    this._z = (r + l) / e
                            } else if (s > h) {
                                const e = 2 * Math.sqrt(1 + s - n - h);
                                this._w = (r - l) / e,
                                    this._x = (i + a) / e,
                                    this._y = .25 * e,
                                    this._z = (o + c) / e
                            } else {
                                const e = 2 * Math.sqrt(1 + h - n - s);
                                this._w = (a - i) / e,
                                    this._x = (r + l) / e,
                                    this._y = (o + c) / e,
                                    this._z = .25 * e
                            }
                            return this._onChangeCallback(),
                                this
                        }
                        setFromUnitVectors(e, t) {
                            let n = e.dot(t) + 1;
                            return n < Number.EPSILON ? (n = 0,
                                Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
                                    this._y = e.x,
                                    this._z = 0,
                                    this._w = n) : (this._x = 0,
                                    this._y = -e.z,
                                    this._z = e.y,
                                    this._w = n)) : (this._x = e.y * t.z - e.z * t.y,
                                this._y = e.z * t.x - e.x * t.z,
                                this._z = e.x * t.y - e.y * t.x,
                                this._w = n),
                                this.normalize()
                        }
                        angleTo(e) {
                            return 2 * Math.acos(Math.abs(Ot(this.dot(e), -1, 1)))
                        }
                        rotateTowards(e, t) {
                            const n = this.angleTo(e);
                            if (0 === n)
                                return this;
                            const i = Math.min(1, t / n);
                            return this.slerp(e, i),
                                this
                        }
                        identity() {
                            return this.set(0, 0, 0, 1)
                        }
                        invert() {
                            return this.conjugate()
                        }
                        conjugate() {
                            return this._x *= -1,
                                this._y *= -1,
                                this._z *= -1,
                                this._onChangeCallback(),
                                this
                        }
                        dot(e) {
                            return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
                        }
                        lengthSq() {
                            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                        }
                        length() {
                            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                        }
                        normalize() {
                            let e = this.length();
                            return 0 === e ? (this._x = 0,
                                this._y = 0,
                                this._z = 0,
                                this._w = 1) : (e = 1 / e,
                                this._x = this._x * e,
                                this._y = this._y * e,
                                this._z = this._z * e,
                                this._w = this._w * e),
                                this._onChangeCallback(),
                                this
                        }
                        multiply(e) {
                            return this.multiplyQuaternions(this, e)
                        }
                        premultiply(e) {
                            return this.multiplyQuaternions(e, this)
                        }
                        multiplyQuaternions(e, t) {
                            const n = e._x
                                , i = e._y
                                , r = e._z
                                , a = e._w
                                , s = t._x
                                , o = t._y
                                , l = t._z
                                , c = t._w;
                            return this._x = n * c + a * s + i * l - r * o,
                                this._y = i * c + a * o + r * s - n * l,
                                this._z = r * c + a * l + n * o - i * s,
                                this._w = a * c - n * s - i * o - r * l,
                                this._onChangeCallback(),
                                this
                        }
                        slerp(e, t) {
                            if (0 === t)
                                return this;
                            if (1 === t)
                                return this.copy(e);
                            const n = this._x
                                , i = this._y
                                , r = this._z
                                , a = this._w;
                            let s = a * e._w + n * e._x + i * e._y + r * e._z;
                            if (s < 0 ? (this._w = -e._w,
                                this._x = -e._x,
                                this._y = -e._y,
                                this._z = -e._z,
                                s = -s) : this.copy(e),
                            s >= 1)
                                return this._w = a,
                                    this._x = n,
                                    this._y = i,
                                    this._z = r,
                                    this;
                            const o = 1 - s * s;
                            if (o <= Number.EPSILON) {
                                const e = 1 - t;
                                return this._w = e * a + t * this._w,
                                    this._x = e * n + t * this._x,
                                    this._y = e * i + t * this._y,
                                    this._z = e * r + t * this._z,
                                    this.normalize(),
                                    this
                            }
                            const l = Math.sqrt(o)
                                , c = Math.atan2(l, s)
                                , h = Math.sin((1 - t) * c) / l
                                , d = Math.sin(t * c) / l;
                            return this._w = a * h + this._w * d,
                                this._x = n * h + this._x * d,
                                this._y = i * h + this._y * d,
                                this._z = r * h + this._z * d,
                                this._onChangeCallback(),
                                this
                        }
                        slerpQuaternions(e, t, n) {
                            return this.copy(e).slerp(t, n)
                        }
                        random() {
                            const e = 2 * Math.PI * Math.random()
                                , t = 2 * Math.PI * Math.random()
                                , n = Math.random()
                                , i = Math.sqrt(1 - n)
                                , r = Math.sqrt(n);
                            return this.set(i * Math.sin(e), i * Math.cos(e), r * Math.sin(t), r * Math.cos(t))
                        }
                        equals(e) {
                            return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
                        }
                        fromArray(e, t=0) {
                            return this._x = e[t],
                                this._y = e[t + 1],
                                this._z = e[t + 2],
                                this._w = e[t + 3],
                                this._onChangeCallback(),
                                this
                        }
                        toArray(e=[], t=0) {
                            return e[t] = this._x,
                                e[t + 1] = this._y,
                                e[t + 2] = this._z,
                                e[t + 3] = this._w,
                                e
                        }
                        fromBufferAttribute(e, t) {
                            return this._x = e.getX(t),
                                this._y = e.getY(t),
                                this._z = e.getZ(t),
                                this._w = e.getW(t),
                                this._onChangeCallback(),
                                this
                        }
                        toJSON() {
                            return this.toArray()
                        }
                        _onChange(e) {
                            return this._onChangeCallback = e,
                                this
                        }
                        _onChangeCallback() {}
                        *[Symbol.iterator]() {
                            yield this._x,
                                yield this._y,
                                yield this._z,
                                yield this._w
                        }
                    }
                    class An {
                        constructor(e=0, t=0, n=0) {
                            An.prototype.isVector3 = !0,
                                this.x = e,
                                this.y = t,
                                this.z = n
                        }
                        set(e, t, n) {
                            return void 0 === n && (n = this.z),
                                this.x = e,
                                this.y = t,
                                this.z = n,
                                this
                        }
                        setScalar(e) {
                            return this.x = e,
                                this.y = e,
                                this.z = e,
                                this
                        }
                        setX(e) {
                            return this.x = e,
                                this
                        }
                        setY(e) {
                            return this.y = e,
                                this
                        }
                        setZ(e) {
                            return this.z = e,
                                this
                        }
                        setComponent(e, t) {
                            switch (e) {
                                case 0:
                                    this.x = t;
                                    break;
                                case 1:
                                    this.y = t;
                                    break;
                                case 2:
                                    this.z = t;
                                    break;
                                default:
                                    throw new Error("index is out of range: " + e)
                            }
                            return this
                        }
                        getComponent(e) {
                            switch (e) {
                                case 0:
                                    return this.x;
                                case 1:
                                    return this.y;
                                case 2:
                                    return this.z;
                                default:
                                    throw new Error("index is out of range: " + e)
                            }
                        }
                        clone() {
                            return new this.constructor(this.x,this.y,this.z)
                        }
                        copy(e) {
                            return this.x = e.x,
                                this.y = e.y,
                                this.z = e.z,
                                this
                        }
                        add(e) {
                            return this.x += e.x,
                                this.y += e.y,
                                this.z += e.z,
                                this
                        }
                        addScalar(e) {
                            return this.x += e,
                                this.y += e,
                                this.z += e,
                                this
                        }
                        addVectors(e, t) {
                            return this.x = e.x + t.x,
                                this.y = e.y + t.y,
                                this.z = e.z + t.z,
                                this
                        }
                        addScaledVector(e, t) {
                            return this.x += e.x * t,
                                this.y += e.y * t,
                                this.z += e.z * t,
                                this
                        }
                        sub(e) {
                            return this.x -= e.x,
                                this.y -= e.y,
                                this.z -= e.z,
                                this
                        }
                        subScalar(e) {
                            return this.x -= e,
                                this.y -= e,
                                this.z -= e,
                                this
                        }
                        subVectors(e, t) {
                            return this.x = e.x - t.x,
                                this.y = e.y - t.y,
                                this.z = e.z - t.z,
                                this
                        }
                        multiply(e) {
                            return this.x *= e.x,
                                this.y *= e.y,
                                this.z *= e.z,
                                this
                        }
                        multiplyScalar(e) {
                            return this.x *= e,
                                this.y *= e,
                                this.z *= e,
                                this
                        }
                        multiplyVectors(e, t) {
                            return this.x = e.x * t.x,
                                this.y = e.y * t.y,
                                this.z = e.z * t.z,
                                this
                        }
                        applyEuler(e) {
                            return this.applyQuaternion(bn.setFromEuler(e))
                        }
                        applyAxisAngle(e, t) {
                            return this.applyQuaternion(bn.setFromAxisAngle(e, t))
                        }
                        applyMatrix3(e) {
                            const t = this.x
                                , n = this.y
                                , i = this.z
                                , r = e.elements;
                            return this.x = r[0] * t + r[3] * n + r[6] * i,
                                this.y = r[1] * t + r[4] * n + r[7] * i,
                                this.z = r[2] * t + r[5] * n + r[8] * i,
                                this
                        }
                        applyNormalMatrix(e) {
                            return this.applyMatrix3(e).normalize()
                        }
                        applyMatrix4(e) {
                            const t = this.x
                                , n = this.y
                                , i = this.z
                                , r = e.elements
                                , a = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
                            return this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * a,
                                this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * a,
                                this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * a,
                                this
                        }
                        applyQuaternion(e) {
                            const t = this.x
                                , n = this.y
                                , i = this.z
                                , r = e.x
                                , a = e.y
                                , s = e.z
                                , o = e.w
                                , l = 2 * (a * i - s * n)
                                , c = 2 * (s * t - r * i)
                                , h = 2 * (r * n - a * t);
                            return this.x = t + o * l + a * h - s * c,
                                this.y = n + o * c + s * l - r * h,
                                this.z = i + o * h + r * c - a * l,
                                this
                        }
                        project(e) {
                            return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
                        }
                        unproject(e) {
                            return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
                        }
                        transformDirection(e) {
                            const t = this.x
                                , n = this.y
                                , i = this.z
                                , r = e.elements;
                            return this.x = r[0] * t + r[4] * n + r[8] * i,
                                this.y = r[1] * t + r[5] * n + r[9] * i,
                                this.z = r[2] * t + r[6] * n + r[10] * i,
                                this.normalize()
                        }
                        divide(e) {
                            return this.x /= e.x,
                                this.y /= e.y,
                                this.z /= e.z,
                                this
                        }
                        divideScalar(e) {
                            return this.multiplyScalar(1 / e)
                        }
                        min(e) {
                            return this.x = Math.min(this.x, e.x),
                                this.y = Math.min(this.y, e.y),
                                this.z = Math.min(this.z, e.z),
                                this
                        }
                        max(e) {
                            return this.x = Math.max(this.x, e.x),
                                this.y = Math.max(this.y, e.y),
                                this.z = Math.max(this.z, e.z),
                                this
                        }
                        clamp(e, t) {
                            return this.x = Ot(this.x, e.x, t.x),
                                this.y = Ot(this.y, e.y, t.y),
                                this.z = Ot(this.z, e.z, t.z),
                                this
                        }
                        clampScalar(e, t) {
                            return this.x = Ot(this.x, e, t),
                                this.y = Ot(this.y, e, t),
                                this.z = Ot(this.z, e, t),
                                this
                        }
                        clampLength(e, t) {
                            const n = this.length();
                            return this.divideScalar(n || 1).multiplyScalar(Ot(n, e, t))
                        }
                        floor() {
                            return this.x = Math.floor(this.x),
                                this.y = Math.floor(this.y),
                                this.z = Math.floor(this.z),
                                this
                        }
                        ceil() {
                            return this.x = Math.ceil(this.x),
                                this.y = Math.ceil(this.y),
                                this.z = Math.ceil(this.z),
                                this
                        }
                        round() {
                            return this.x = Math.round(this.x),
                                this.y = Math.round(this.y),
                                this.z = Math.round(this.z),
                                this
                        }
                        roundToZero() {
                            return this.x = Math.trunc(this.x),
                                this.y = Math.trunc(this.y),
                                this.z = Math.trunc(this.z),
                                this
                        }
                        negate() {
                            return this.x = -this.x,
                                this.y = -this.y,
                                this.z = -this.z,
                                this
                        }
                        dot(e) {
                            return this.x * e.x + this.y * e.y + this.z * e.z
                        }
                        lengthSq() {
                            return this.x * this.x + this.y * this.y + this.z * this.z
                        }
                        length() {
                            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                        }
                        manhattanLength() {
                            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                        }
                        normalize() {
                            return this.divideScalar(this.length() || 1)
                        }
                        setLength(e) {
                            return this.normalize().multiplyScalar(e)
                        }
                        lerp(e, t) {
                            return this.x += (e.x - this.x) * t,
                                this.y += (e.y - this.y) * t,
                                this.z += (e.z - this.z) * t,
                                this
                        }
                        lerpVectors(e, t, n) {
                            return this.x = e.x + (t.x - e.x) * n,
                                this.y = e.y + (t.y - e.y) * n,
                                this.z = e.z + (t.z - e.z) * n,
                                this
                        }
                        cross(e) {
                            return this.crossVectors(this, e)
                        }
                        crossVectors(e, t) {
                            const n = e.x
                                , i = e.y
                                , r = e.z
                                , a = t.x
                                , s = t.y
                                , o = t.z;
                            return this.x = i * o - r * s,
                                this.y = r * a - n * o,
                                this.z = n * s - i * a,
                                this
                        }
                        projectOnVector(e) {
                            const t = e.lengthSq();
                            if (0 === t)
                                return this.set(0, 0, 0);
                            const n = e.dot(this) / t;
                            return this.copy(e).multiplyScalar(n)
                        }
                        projectOnPlane(e) {
                            return yn.copy(this).projectOnVector(e),
                                this.sub(yn)
                        }
                        reflect(e) {
                            return this.sub(yn.copy(e).multiplyScalar(2 * this.dot(e)))
                        }
                        angleTo(e) {
                            const t = Math.sqrt(this.lengthSq() * e.lengthSq());
                            if (0 === t)
                                return Math.PI / 2;
                            const n = this.dot(e) / t;
                            return Math.acos(Ot(n, -1, 1))
                        }
                        distanceTo(e) {
                            return Math.sqrt(this.distanceToSquared(e))
                        }
                        distanceToSquared(e) {
                            const t = this.x - e.x
                                , n = this.y - e.y
                                , i = this.z - e.z;
                            return t * t + n * n + i * i
                        }
                        manhattanDistanceTo(e) {
                            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
                        }
                        setFromSpherical(e) {
                            return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
                        }
                        setFromSphericalCoords(e, t, n) {
                            const i = Math.sin(t) * e;
                            return this.x = i * Math.sin(n),
                                this.y = Math.cos(t) * e,
                                this.z = i * Math.cos(n),
                                this
                        }
                        setFromCylindrical(e) {
                            return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
                        }
                        setFromCylindricalCoords(e, t, n) {
                            return this.x = e * Math.sin(t),
                                this.y = n,
                                this.z = e * Math.cos(t),
                                this
                        }
                        setFromMatrixPosition(e) {
                            const t = e.elements;
                            return this.x = t[12],
                                this.y = t[13],
                                this.z = t[14],
                                this
                        }
                        setFromMatrixScale(e) {
                            const t = this.setFromMatrixColumn(e, 0).length()
                                , n = this.setFromMatrixColumn(e, 1).length()
                                , i = this.setFromMatrixColumn(e, 2).length();
                            return this.x = t,
                                this.y = n,
                                this.z = i,
                                this
                        }
                        setFromMatrixColumn(e, t) {
                            return this.fromArray(e.elements, 4 * t)
                        }
                        setFromMatrix3Column(e, t) {
                            return this.fromArray(e.elements, 3 * t)
                        }
                        setFromEuler(e) {
                            return this.x = e._x,
                                this.y = e._y,
                                this.z = e._z,
                                this
                        }
                        setFromColor(e) {
                            return this.x = e.r,
                                this.y = e.g,
                                this.z = e.b,
                                this
                        }
                        equals(e) {
                            return e.x === this.x && e.y === this.y && e.z === this.z
                        }
                        fromArray(e, t=0) {
                            return this.x = e[t],
                                this.y = e[t + 1],
                                this.z = e[t + 2],
                                this
                        }
                        toArray(e=[], t=0) {
                            return e[t] = this.x,
                                e[t + 1] = this.y,
                                e[t + 2] = this.z,
                                e
                        }
                        fromBufferAttribute(e, t) {
                            return this.x = e.getX(t),
                                this.y = e.getY(t),
                                this.z = e.getZ(t),
                                this
                        }
                        random() {
                            return this.x = Math.random(),
                                this.y = Math.random(),
                                this.z = Math.random(),
                                this
                        }
                        randomDirection() {
                            const e = Math.random() * Math.PI * 2
                                , t = 2 * Math.random() - 1
                                , n = Math.sqrt(1 - t * t);
                            return this.x = n * Math.cos(e),
                                this.y = t,
                                this.z = n * Math.sin(e),
                                this
                        }
                        *[Symbol.iterator]() {
                            yield this.x,
                                yield this.y,
                                yield this.z
                        }
                    }
                    const yn = new An
                        , bn = new wn;
                    class xn {
                        constructor(e=new An(1 / 0,1 / 0,1 / 0), t=new An(-1 / 0,-1 / 0,-1 / 0)) {
                            this.isBox3 = !0,
                                this.min = e,
                                this.max = t
                        }
                        set(e, t) {
                            return this.min.copy(e),
                                this.max.copy(t),
                                this
                        }
                        setFromArray(e) {
                            this.makeEmpty();
                            for (let t = 0, n = e.length; t < n; t += 3)
                                this.expandByPoint(En.fromArray(e, t));
                            return this
                        }
                        setFromBufferAttribute(e) {
                            this.makeEmpty();
                            for (let t = 0, n = e.count; t < n; t++)
                                this.expandByPoint(En.fromBufferAttribute(e, t));
                            return this
                        }
                        setFromPoints(e) {
                            this.makeEmpty();
                            for (let t = 0, n = e.length; t < n; t++)
                                this.expandByPoint(e[t]);
                            return this
                        }
                        setFromCenterAndSize(e, t) {
                            const n = En.copy(t).multiplyScalar(.5);
                            return this.min.copy(e).sub(n),
                                this.max.copy(e).add(n),
                                this
                        }
                        setFromObject(e, t=!1) {
                            return this.makeEmpty(),
                                this.expandByObject(e, t)
                        }
                        clone() {
                            return (new this.constructor).copy(this)
                        }
                        copy(e) {
                            return this.min.copy(e.min),
                                this.max.copy(e.max),
                                this
                        }
                        makeEmpty() {
                            return this.min.x = this.min.y = this.min.z = 1 / 0,
                                this.max.x = this.max.y = this.max.z = -1 / 0,
                                this
                        }
                        isEmpty() {
                            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                        }
                        getCenter(e) {
                            return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
                        }
                        getSize(e) {
                            return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
                        }
                        expandByPoint(e) {
                            return this.min.min(e),
                                this.max.max(e),
                                this
                        }
                        expandByVector(e) {
                            return this.min.sub(e),
                                this.max.add(e),
                                this
                        }
                        expandByScalar(e) {
                            return this.min.addScalar(-e),
                                this.max.addScalar(e),
                                this
                        }
                        expandByObject(e, t=!1) {
                            e.updateWorldMatrix(!1, !1);
                            const n = e.geometry;
                            if (void 0 !== n) {
                                const i = n.getAttribute("position");
                                if (!0 === t && void 0 !== i && !0 !== e.isInstancedMesh)
                                    for (let t = 0, n = i.count; t < n; t++)
                                        !0 === e.isMesh ? e.getVertexPosition(t, En) : En.fromBufferAttribute(i, t),
                                            En.applyMatrix4(e.matrixWorld),
                                            this.expandByPoint(En);
                                else
                                    void 0 !== e.boundingBox ? (null === e.boundingBox && e.computeBoundingBox(),
                                        Sn.copy(e.boundingBox)) : (null === n.boundingBox && n.computeBoundingBox(),
                                        Sn.copy(n.boundingBox)),
                                        Sn.applyMatrix4(e.matrixWorld),
                                        this.union(Sn)
                            }
                            const i = e.children;
                            for (let e = 0, n = i.length; e < n; e++)
                                this.expandByObject(i[e], t);
                            return this
                        }
                        containsPoint(e) {
                            return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z
                        }
                        containsBox(e) {
                            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
                        }
                        getParameter(e, t) {
                            return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
                        }
                        intersectsBox(e) {
                            return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z
                        }
                        intersectsSphere(e) {
                            return this.clampPoint(e.center, En),
                            En.distanceToSquared(e.center) <= e.radius * e.radius
                        }
                        intersectsPlane(e) {
                            let t, n;
                            return e.normal.x > 0 ? (t = e.normal.x * this.min.x,
                                n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
                                n = e.normal.x * this.min.x),
                                e.normal.y > 0 ? (t += e.normal.y * this.min.y,
                                    n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
                                    n += e.normal.y * this.min.y),
                                e.normal.z > 0 ? (t += e.normal.z * this.min.z,
                                    n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
                                    n += e.normal.z * this.min.z),
                            t <= -e.constant && n >= -e.constant
                        }
                        intersectsTriangle(e) {
                            if (this.isEmpty())
                                return !1;
                            this.getCenter(Rn),
                                Ln.subVectors(this.max, Rn),
                                Mn.subVectors(e.a, Rn),
                                Tn.subVectors(e.b, Rn),
                                Cn.subVectors(e.c, Rn),
                                _n.subVectors(Tn, Mn),
                                In.subVectors(Cn, Tn),
                                Pn.subVectors(Mn, Cn);
                            let t = [0, -_n.z, _n.y, 0, -In.z, In.y, 0, -Pn.z, Pn.y, _n.z, 0, -_n.x, In.z, 0, -In.x, Pn.z, 0, -Pn.x, -_n.y, _n.x, 0, -In.y, In.x, 0, -Pn.y, Pn.x, 0];
                            return !!Bn(t, Mn, Tn, Cn, Ln) && (t = [1, 0, 0, 0, 1, 0, 0, 0, 1],
                            !!Bn(t, Mn, Tn, Cn, Ln) && (Nn.crossVectors(_n, In),
                                t = [Nn.x, Nn.y, Nn.z],
                                Bn(t, Mn, Tn, Cn, Ln)))
                        }
                        clampPoint(e, t) {
                            return t.copy(e).clamp(this.min, this.max)
                        }
                        distanceToPoint(e) {
                            return this.clampPoint(e, En).distanceTo(e)
                        }
                        getBoundingSphere(e) {
                            return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center),
                                e.radius = .5 * this.getSize(En).length()),
                                e
                        }
                        intersect(e) {
                            return this.min.max(e.min),
                                this.max.min(e.max),
                            this.isEmpty() && this.makeEmpty(),
                                this
                        }
                        union(e) {
                            return this.min.min(e.min),
                                this.max.max(e.max),
                                this
                        }
                        applyMatrix4(e) {
                            return this.isEmpty() || (kn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
                                kn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
                                kn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
                                kn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
                                kn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
                                kn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
                                kn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
                                kn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
                                this.setFromPoints(kn)),
                                this
                        }
                        translate(e) {
                            return this.min.add(e),
                                this.max.add(e),
                                this
                        }
                        equals(e) {
                            return e.min.equals(this.min) && e.max.equals(this.max)
                        }
                    }
                    const kn = [new An, new An, new An, new An, new An, new An, new An, new An]
                        , En = new An
                        , Sn = new xn
                        , Mn = new An
                        , Tn = new An
                        , Cn = new An
                        , _n = new An
                        , In = new An
                        , Pn = new An
                        , Rn = new An
                        , Ln = new An
                        , Nn = new An
                        , Dn = new An;
                    function Bn(e, t, n, i, r) {
                        for (let a = 0, s = e.length - 3; a <= s; a += 3) {
                            Dn.fromArray(e, a);
                            const s = r.x * Math.abs(Dn.x) + r.y * Math.abs(Dn.y) + r.z * Math.abs(Dn.z)
                                , o = t.dot(Dn)
                                , l = n.dot(Dn)
                                , c = i.dot(Dn);
                            if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > s)
                                return !1
                        }
                        return !0
                    }
                    const Un = new xn
                        , zn = new An
                        , On = new An;
                    class Fn {
                        constructor(e=new An, t=-1) {
                            this.isSphere = !0,
                                this.center = e,
                                this.radius = t
                        }
                        set(e, t) {
                            return this.center.copy(e),
                                this.radius = t,
                                this
                        }
                        setFromPoints(e, t) {
                            const n = this.center;
                            void 0 !== t ? n.copy(t) : Un.setFromPoints(e).getCenter(n);
                            let i = 0;
                            for (let t = 0, r = e.length; t < r; t++)
                                i = Math.max(i, n.distanceToSquared(e[t]));
                            return this.radius = Math.sqrt(i),
                                this
                        }
                        copy(e) {
                            return this.center.copy(e.center),
                                this.radius = e.radius,
                                this
                        }
                        isEmpty() {
                            return this.radius < 0
                        }
                        makeEmpty() {
                            return this.center.set(0, 0, 0),
                                this.radius = -1,
                                this
                        }
                        containsPoint(e) {
                            return e.distanceToSquared(this.center) <= this.radius * this.radius
                        }
                        distanceToPoint(e) {
                            return e.distanceTo(this.center) - this.radius
                        }
                        intersectsSphere(e) {
                            const t = this.radius + e.radius;
                            return e.center.distanceToSquared(this.center) <= t * t
                        }
                        intersectsBox(e) {
                            return e.intersectsSphere(this)
                        }
                        intersectsPlane(e) {
                            return Math.abs(e.distanceToPoint(this.center)) <= this.radius
                        }
                        clampPoint(e, t) {
                            const n = this.center.distanceToSquared(e);
                            return t.copy(e),
                            n > this.radius * this.radius && (t.sub(this.center).normalize(),
                                t.multiplyScalar(this.radius).add(this.center)),
                                t
                        }
                        getBoundingBox(e) {
                            return this.isEmpty() ? (e.makeEmpty(),
                                e) : (e.set(this.center, this.center),
                                e.expandByScalar(this.radius),
                                e)
                        }
                        applyMatrix4(e) {
                            return this.center.applyMatrix4(e),
                                this.radius = this.radius * e.getMaxScaleOnAxis(),
                                this
                        }
                        translate(e) {
                            return this.center.add(e),
                                this
                        }
                        expandByPoint(e) {
                            if (this.isEmpty())
                                return this.center.copy(e),
                                    this.radius = 0,
                                    this;
                            zn.subVectors(e, this.center);
                            const t = zn.lengthSq();
                            if (t > this.radius * this.radius) {
                                const e = Math.sqrt(t)
                                    , n = .5 * (e - this.radius);
                                this.center.addScaledVector(zn, n / e),
                                    this.radius += n
                            }
                            return this
                        }
                        union(e) {
                            return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e),
                                this) : (!0 === this.center.equals(e.center) ? this.radius = Math.max(this.radius, e.radius) : (On.subVectors(e.center, this.center).setLength(e.radius),
                                this.expandByPoint(zn.copy(e.center).add(On)),
                                this.expandByPoint(zn.copy(e.center).sub(On))),
                                this)
                        }
                        equals(e) {
                            return e.center.equals(this.center) && e.radius === this.radius
                        }
                        clone() {
                            return (new this.constructor).copy(this)
                        }
                    }
                    const Wn = new An
                        , Hn = new An
                        , Vn = new An
                        , Gn = new An
                        , jn = new An
                        , Qn = new An
                        , Yn = new An;
                    class qn {
                        constructor(e=new An, t=new An(0,0,-1)) {
                            this.origin = e,
                                this.direction = t
                        }
                        set(e, t) {
                            return this.origin.copy(e),
                                this.direction.copy(t),
                                this
                        }
                        copy(e) {
                            return this.origin.copy(e.origin),
                                this.direction.copy(e.direction),
                                this
                        }
                        at(e, t) {
                            return t.copy(this.origin).addScaledVector(this.direction, e)
                        }
                        lookAt(e) {
                            return this.direction.copy(e).sub(this.origin).normalize(),
                                this
                        }
                        recast(e) {
                            return this.origin.copy(this.at(e, Wn)),
                                this
                        }
                        closestPointToPoint(e, t) {
                            t.subVectors(e, this.origin);
                            const n = t.dot(this.direction);
                            return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n)
                        }
                        distanceToPoint(e) {
                            return Math.sqrt(this.distanceSqToPoint(e))
                        }
                        distanceSqToPoint(e) {
                            const t = Wn.subVectors(e, this.origin).dot(this.direction);
                            return t < 0 ? this.origin.distanceToSquared(e) : (Wn.copy(this.origin).addScaledVector(this.direction, t),
                                Wn.distanceToSquared(e))
                        }
                        distanceSqToSegment(e, t, n, i) {
                            Hn.copy(e).add(t).multiplyScalar(.5),
                                Vn.copy(t).sub(e).normalize(),
                                Gn.copy(this.origin).sub(Hn);
                            const r = .5 * e.distanceTo(t)
                                , a = -this.direction.dot(Vn)
                                , s = Gn.dot(this.direction)
                                , o = -Gn.dot(Vn)
                                , l = Gn.lengthSq()
                                , c = Math.abs(1 - a * a);
                            let h, d, u, p;
                            if (c > 0)
                                if (h = a * o - s,
                                    d = a * s - o,
                                    p = r * c,
                                h >= 0)
                                    if (d >= -p)
                                        if (d <= p) {
                                            const e = 1 / c;
                                            h *= e,
                                                d *= e,
                                                u = h * (h + a * d + 2 * s) + d * (a * h + d + 2 * o) + l
                                        } else
                                            d = r,
                                                h = Math.max(0, -(a * d + s)),
                                                u = -h * h + d * (d + 2 * o) + l;
                                    else
                                        d = -r,
                                            h = Math.max(0, -(a * d + s)),
                                            u = -h * h + d * (d + 2 * o) + l;
                                else
                                    d <= -p ? (h = Math.max(0, -(-a * r + s)),
                                        d = h > 0 ? -r : Math.min(Math.max(-r, -o), r),
                                        u = -h * h + d * (d + 2 * o) + l) : d <= p ? (h = 0,
                                        d = Math.min(Math.max(-r, -o), r),
                                        u = d * (d + 2 * o) + l) : (h = Math.max(0, -(a * r + s)),
                                        d = h > 0 ? r : Math.min(Math.max(-r, -o), r),
                                        u = -h * h + d * (d + 2 * o) + l);
                            else
                                d = a > 0 ? -r : r,
                                    h = Math.max(0, -(a * d + s)),
                                    u = -h * h + d * (d + 2 * o) + l;
                            return n && n.copy(this.origin).addScaledVector(this.direction, h),
                            i && i.copy(Hn).addScaledVector(Vn, d),
                                u
                        }
                        intersectSphere(e, t) {
                            Wn.subVectors(e.center, this.origin);
                            const n = Wn.dot(this.direction)
                                , i = Wn.dot(Wn) - n * n
                                , r = e.radius * e.radius;
                            if (i > r)
                                return null;
                            const a = Math.sqrt(r - i)
                                , s = n - a
                                , o = n + a;
                            return o < 0 ? null : s < 0 ? this.at(o, t) : this.at(s, t)
                        }
                        intersectsSphere(e) {
                            return this.distanceSqToPoint(e.center) <= e.radius * e.radius
                        }
                        distanceToPlane(e) {
                            const t = e.normal.dot(this.direction);
                            if (0 === t)
                                return 0 === e.distanceToPoint(this.origin) ? 0 : null;
                            const n = -(this.origin.dot(e.normal) + e.constant) / t;
                            return n >= 0 ? n : null
                        }
                        intersectPlane(e, t) {
                            const n = this.distanceToPlane(e);
                            return null === n ? null : this.at(n, t)
                        }
                        intersectsPlane(e) {
                            const t = e.distanceToPoint(this.origin);
                            if (0 === t)
                                return !0;
                            return e.normal.dot(this.direction) * t < 0
                        }
                        intersectBox(e, t) {
                            let n, i, r, a, s, o;
                            const l = 1 / this.direction.x
                                , c = 1 / this.direction.y
                                , h = 1 / this.direction.z
                                , d = this.origin;
                            return l >= 0 ? (n = (e.min.x - d.x) * l,
                                i = (e.max.x - d.x) * l) : (n = (e.max.x - d.x) * l,
                                i = (e.min.x - d.x) * l),
                                c >= 0 ? (r = (e.min.y - d.y) * c,
                                    a = (e.max.y - d.y) * c) : (r = (e.max.y - d.y) * c,
                                    a = (e.min.y - d.y) * c),
                                n > a || r > i ? null : ((r > n || isNaN(n)) && (n = r),
                                (a < i || isNaN(i)) && (i = a),
                                    h >= 0 ? (s = (e.min.z - d.z) * h,
                                        o = (e.max.z - d.z) * h) : (s = (e.max.z - d.z) * h,
                                        o = (e.min.z - d.z) * h),
                                    n > o || s > i ? null : ((s > n || n != n) && (n = s),
                                    (o < i || i != i) && (i = o),
                                        i < 0 ? null : this.at(n >= 0 ? n : i, t)))
                        }
                        intersectsBox(e) {
                            return null !== this.intersectBox(e, Wn)
                        }
                        intersectTriangle(e, t, n, i, r) {
                            jn.subVectors(t, e),
                                Qn.subVectors(n, e),
                                Yn.crossVectors(jn, Qn);
                            let a, s = this.direction.dot(Yn);
                            if (s > 0) {
                                if (i)
                                    return null;
                                a = 1
                            } else {
                                if (!(s < 0))
                                    return null;
                                a = -1,
                                    s = -s
                            }
                            Gn.subVectors(this.origin, e);
                            const o = a * this.direction.dot(Qn.crossVectors(Gn, Qn));
                            if (o < 0)
                                return null;
                            const l = a * this.direction.dot(jn.cross(Gn));
                            if (l < 0)
                                return null;
                            if (o + l > s)
                                return null;
                            const c = -a * Gn.dot(Yn);
                            return c < 0 ? null : this.at(c / s, r)
                        }
                        applyMatrix4(e) {
                            return this.origin.applyMatrix4(e),
                                this.direction.transformDirection(e),
                                this
                        }
                        equals(e) {
                            return e.origin.equals(this.origin) && e.direction.equals(this.direction)
                        }
                        clone() {
                            return (new this.constructor).copy(this)
                        }
                    }
                    class Kn {
                        constructor(e, t, n, i, r, a, s, o, l, c, h, d, u, p, f, m) {
                            Kn.prototype.isMatrix4 = !0,
                                this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
                            void 0 !== e && this.set(e, t, n, i, r, a, s, o, l, c, h, d, u, p, f, m)
                        }
                        set(e, t, n, i, r, a, s, o, l, c, h, d, u, p, f, m) {
                            const g = this.elements;
                            return g[0] = e,
                                g[4] = t,
                                g[8] = n,
                                g[12] = i,
                                g[1] = r,
                                g[5] = a,
                                g[9] = s,
                                g[13] = o,
                                g[2] = l,
                                g[6] = c,
                                g[10] = h,
                                g[14] = d,
                                g[3] = u,
                                g[7] = p,
                                g[11] = f,
                                g[15] = m,
                                this
                        }
                        identity() {
                            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                                this
                        }
                        clone() {
                            return (new Kn).fromArray(this.elements)
                        }
                        copy(e) {
                            const t = this.elements
                                , n = e.elements;
                            return t[0] = n[0],
                                t[1] = n[1],
                                t[2] = n[2],
                                t[3] = n[3],
                                t[4] = n[4],
                                t[5] = n[5],
                                t[6] = n[6],
                                t[7] = n[7],
                                t[8] = n[8],
                                t[9] = n[9],
                                t[10] = n[10],
                                t[11] = n[11],
                                t[12] = n[12],
                                t[13] = n[13],
                                t[14] = n[14],
                                t[15] = n[15],
                                this
                        }
                        copyPosition(e) {
                            const t = this.elements
                                , n = e.elements;
                            return t[12] = n[12],
                                t[13] = n[13],
                                t[14] = n[14],
                                this
                        }
                        setFromMatrix3(e) {
                            const t = e.elements;
                            return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1),
                                this
                        }
                        extractBasis(e, t, n) {
                            return e.setFromMatrixColumn(this, 0),
                                t.setFromMatrixColumn(this, 1),
                                n.setFromMatrixColumn(this, 2),
                                this
                        }
                        makeBasis(e, t, n) {
                            return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1),
                                this
                        }
                        extractRotation(e) {
                            const t = this.elements
                                , n = e.elements
                                , i = 1 / Xn.setFromMatrixColumn(e, 0).length()
                                , r = 1 / Xn.setFromMatrixColumn(e, 1).length()
                                , a = 1 / Xn.setFromMatrixColumn(e, 2).length();
                            return t[0] = n[0] * i,
                                t[1] = n[1] * i,
                                t[2] = n[2] * i,
                                t[3] = 0,
                                t[4] = n[4] * r,
                                t[5] = n[5] * r,
                                t[6] = n[6] * r,
                                t[7] = 0,
                                t[8] = n[8] * a,
                                t[9] = n[9] * a,
                                t[10] = n[10] * a,
                                t[11] = 0,
                                t[12] = 0,
                                t[13] = 0,
                                t[14] = 0,
                                t[15] = 1,
                                this
                        }
                        makeRotationFromEuler(e) {
                            const t = this.elements
                                , n = e.x
                                , i = e.y
                                , r = e.z
                                , a = Math.cos(n)
                                , s = Math.sin(n)
                                , o = Math.cos(i)
                                , l = Math.sin(i)
                                , c = Math.cos(r)
                                , h = Math.sin(r);
                            if ("XYZ" === e.order) {
                                const e = a * c
                                    , n = a * h
                                    , i = s * c
                                    , r = s * h;
                                t[0] = o * c,
                                    t[4] = -o * h,
                                    t[8] = l,
                                    t[1] = n + i * l,
                                    t[5] = e - r * l,
                                    t[9] = -s * o,
                                    t[2] = r - e * l,
                                    t[6] = i + n * l,
                                    t[10] = a * o
                            } else if ("YXZ" === e.order) {
                                const e = o * c
                                    , n = o * h
                                    , i = l * c
                                    , r = l * h;
                                t[0] = e + r * s,
                                    t[4] = i * s - n,
                                    t[8] = a * l,
                                    t[1] = a * h,
                                    t[5] = a * c,
                                    t[9] = -s,
                                    t[2] = n * s - i,
                                    t[6] = r + e * s,
                                    t[10] = a * o
                            } else if ("ZXY" === e.order) {
                                const e = o * c
                                    , n = o * h
                                    , i = l * c
                                    , r = l * h;
                                t[0] = e - r * s,
                                    t[4] = -a * h,
                                    t[8] = i + n * s,
                                    t[1] = n + i * s,
                                    t[5] = a * c,
                                    t[9] = r - e * s,
                                    t[2] = -a * l,
                                    t[6] = s,
                                    t[10] = a * o
                            } else if ("ZYX" === e.order) {
                                const e = a * c
                                    , n = a * h
                                    , i = s * c
                                    , r = s * h;
                                t[0] = o * c,
                                    t[4] = i * l - n,
                                    t[8] = e * l + r,
                                    t[1] = o * h,
                                    t[5] = r * l + e,
                                    t[9] = n * l - i,
                                    t[2] = -l,
                                    t[6] = s * o,
                                    t[10] = a * o
                            } else if ("YZX" === e.order) {
                                const e = a * o
                                    , n = a * l
                                    , i = s * o
                                    , r = s * l;
                                t[0] = o * c,
                                    t[4] = r - e * h,
                                    t[8] = i * h + n,
                                    t[1] = h,
                                    t[5] = a * c,
                                    t[9] = -s * c,
                                    t[2] = -l * c,
                                    t[6] = n * h + i,
                                    t[10] = e - r * h
                            } else if ("XZY" === e.order) {
                                const e = a * o
                                    , n = a * l
                                    , i = s * o
                                    , r = s * l;
                                t[0] = o * c,
                                    t[4] = -h,
                                    t[8] = l * c,
                                    t[1] = e * h + r,
                                    t[5] = a * c,
                                    t[9] = n * h - i,
                                    t[2] = i * h - n,
                                    t[6] = s * c,
                                    t[10] = r * h + e
                            }
                            return t[3] = 0,
                                t[7] = 0,
                                t[11] = 0,
                                t[12] = 0,
                                t[13] = 0,
                                t[14] = 0,
                                t[15] = 1,
                                this
                        }
                        makeRotationFromQuaternion(e) {
                            return this.compose(Jn, e, $n)
                        }
                        lookAt(e, t, n) {
                            const i = this.elements;
                            return ni.subVectors(e, t),
                            0 === ni.lengthSq() && (ni.z = 1),
                                ni.normalize(),
                                ei.crossVectors(n, ni),
                            0 === ei.lengthSq() && (1 === Math.abs(n.z) ? ni.x += 1e-4 : ni.z += 1e-4,
                                ni.normalize(),
                                ei.crossVectors(n, ni)),
                                ei.normalize(),
                                ti.crossVectors(ni, ei),
                                i[0] = ei.x,
                                i[4] = ti.x,
                                i[8] = ni.x,
                                i[1] = ei.y,
                                i[5] = ti.y,
                                i[9] = ni.y,
                                i[2] = ei.z,
                                i[6] = ti.z,
                                i[10] = ni.z,
                                this
                        }
                        multiply(e) {
                            return this.multiplyMatrices(this, e)
                        }
                        premultiply(e) {
                            return this.multiplyMatrices(e, this)
                        }
                        multiplyMatrices(e, t) {
                            const n = e.elements
                                , i = t.elements
                                , r = this.elements
                                , a = n[0]
                                , s = n[4]
                                , o = n[8]
                                , l = n[12]
                                , c = n[1]
                                , h = n[5]
                                , d = n[9]
                                , u = n[13]
                                , p = n[2]
                                , f = n[6]
                                , m = n[10]
                                , g = n[14]
                                , v = n[3]
                                , w = n[7]
                                , A = n[11]
                                , y = n[15]
                                , b = i[0]
                                , x = i[4]
                                , k = i[8]
                                , E = i[12]
                                , S = i[1]
                                , M = i[5]
                                , T = i[9]
                                , C = i[13]
                                , _ = i[2]
                                , I = i[6]
                                , P = i[10]
                                , R = i[14]
                                , L = i[3]
                                , N = i[7]
                                , D = i[11]
                                , B = i[15];
                            return r[0] = a * b + s * S + o * _ + l * L,
                                r[4] = a * x + s * M + o * I + l * N,
                                r[8] = a * k + s * T + o * P + l * D,
                                r[12] = a * E + s * C + o * R + l * B,
                                r[1] = c * b + h * S + d * _ + u * L,
                                r[5] = c * x + h * M + d * I + u * N,
                                r[9] = c * k + h * T + d * P + u * D,
                                r[13] = c * E + h * C + d * R + u * B,
                                r[2] = p * b + f * S + m * _ + g * L,
                                r[6] = p * x + f * M + m * I + g * N,
                                r[10] = p * k + f * T + m * P + g * D,
                                r[14] = p * E + f * C + m * R + g * B,
                                r[3] = v * b + w * S + A * _ + y * L,
                                r[7] = v * x + w * M + A * I + y * N,
                                r[11] = v * k + w * T + A * P + y * D,
                                r[15] = v * E + w * C + A * R + y * B,
                                this
                        }
                        multiplyScalar(e) {
                            const t = this.elements;
                            return t[0] *= e,
                                t[4] *= e,
                                t[8] *= e,
                                t[12] *= e,
                                t[1] *= e,
                                t[5] *= e,
                                t[9] *= e,
                                t[13] *= e,
                                t[2] *= e,
                                t[6] *= e,
                                t[10] *= e,
                                t[14] *= e,
                                t[3] *= e,
                                t[7] *= e,
                                t[11] *= e,
                                t[15] *= e,
                                this
                        }
                        determinant() {
                            const e = this.elements
                                , t = e[0]
                                , n = e[4]
                                , i = e[8]
                                , r = e[12]
                                , a = e[1]
                                , s = e[5]
                                , o = e[9]
                                , l = e[13]
                                , c = e[2]
                                , h = e[6]
                                , d = e[10]
                                , u = e[14];
                            return e[3] * (+r * o * h - i * l * h - r * s * d + n * l * d + i * s * u - n * o * u) + e[7] * (+t * o * u - t * l * d + r * a * d - i * a * u + i * l * c - r * o * c) + e[11] * (+t * l * h - t * s * u - r * a * h + n * a * u + r * s * c - n * l * c) + e[15] * (-i * s * c - t * o * h + t * s * d + i * a * h - n * a * d + n * o * c)
                        }
                        transpose() {
                            const e = this.elements;
                            let t;
                            return t = e[1],
                                e[1] = e[4],
                                e[4] = t,
                                t = e[2],
                                e[2] = e[8],
                                e[8] = t,
                                t = e[6],
                                e[6] = e[9],
                                e[9] = t,
                                t = e[3],
                                e[3] = e[12],
                                e[12] = t,
                                t = e[7],
                                e[7] = e[13],
                                e[13] = t,
                                t = e[11],
                                e[11] = e[14],
                                e[14] = t,
                                this
                        }
                        setPosition(e, t, n) {
                            const i = this.elements;
                            return e.isVector3 ? (i[12] = e.x,
                                i[13] = e.y,
                                i[14] = e.z) : (i[12] = e,
                                i[13] = t,
                                i[14] = n),
                                this
                        }
                        invert() {
                            const e = this.elements
                                , t = e[0]
                                , n = e[1]
                                , i = e[2]
                                , r = e[3]
                                , a = e[4]
                                , s = e[5]
                                , o = e[6]
                                , l = e[7]
                                , c = e[8]
                                , h = e[9]
                                , d = e[10]
                                , u = e[11]
                                , p = e[12]
                                , f = e[13]
                                , m = e[14]
                                , g = e[15]
                                , v = h * m * l - f * d * l + f * o * u - s * m * u - h * o * g + s * d * g
                                , w = p * d * l - c * m * l - p * o * u + a * m * u + c * o * g - a * d * g
                                , A = c * f * l - p * h * l + p * s * u - a * f * u - c * s * g + a * h * g
                                , y = p * h * o - c * f * o - p * s * d + a * f * d + c * s * m - a * h * m
                                , b = t * v + n * w + i * A + r * y;
                            if (0 === b)
                                return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                            const x = 1 / b;
                            return e[0] = v * x,
                                e[1] = (f * d * r - h * m * r - f * i * u + n * m * u + h * i * g - n * d * g) * x,
                                e[2] = (s * m * r - f * o * r + f * i * l - n * m * l - s * i * g + n * o * g) * x,
                                e[3] = (h * o * r - s * d * r - h * i * l + n * d * l + s * i * u - n * o * u) * x,
                                e[4] = w * x,
                                e[5] = (c * m * r - p * d * r + p * i * u - t * m * u - c * i * g + t * d * g) * x,
                                e[6] = (p * o * r - a * m * r - p * i * l + t * m * l + a * i * g - t * o * g) * x,
                                e[7] = (a * d * r - c * o * r + c * i * l - t * d * l - a * i * u + t * o * u) * x,
                                e[8] = A * x,
                                e[9] = (p * h * r - c * f * r - p * n * u + t * f * u + c * n * g - t * h * g) * x,
                                e[10] = (a * f * r - p * s * r + p * n * l - t * f * l - a * n * g + t * s * g) * x,
                                e[11] = (c * s * r - a * h * r - c * n * l + t * h * l + a * n * u - t * s * u) * x,
                                e[12] = y * x,
                                e[13] = (c * f * i - p * h * i + p * n * d - t * f * d - c * n * m + t * h * m) * x,
                                e[14] = (p * s * i - a * f * i - p * n * o + t * f * o + a * n * m - t * s * m) * x,
                                e[15] = (a * h * i - c * s * i + c * n * o - t * h * o - a * n * d + t * s * d) * x,
                                this
                        }
                        scale(e) {
                            const t = this.elements
                                , n = e.x
                                , i = e.y
                                , r = e.z;
                            return t[0] *= n,
                                t[4] *= i,
                                t[8] *= r,
                                t[1] *= n,
                                t[5] *= i,
                                t[9] *= r,
                                t[2] *= n,
                                t[6] *= i,
                                t[10] *= r,
                                t[3] *= n,
                                t[7] *= i,
                                t[11] *= r,
                                this
                        }
                        getMaxScaleOnAxis() {
                            const e = this.elements
                                , t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
                                , n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
                                , i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
                            return Math.sqrt(Math.max(t, n, i))
                        }
                        makeTranslation(e, t, n) {
                            return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1),
                                this
                        }
                        makeRotationX(e) {
                            const t = Math.cos(e)
                                , n = Math.sin(e);
                            return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1),
                                this
                        }
                        makeRotationY(e) {
                            const t = Math.cos(e)
                                , n = Math.sin(e);
                            return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1),
                                this
                        }
                        makeRotationZ(e) {
                            const t = Math.cos(e)
                                , n = Math.sin(e);
                            return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                                this
                        }
                        makeRotationAxis(e, t) {
                            const n = Math.cos(t)
                                , i = Math.sin(t)
                                , r = 1 - n
                                , a = e.x
                                , s = e.y
                                , o = e.z
                                , l = r * a
                                , c = r * s;
                            return this.set(l * a + n, l * s - i * o, l * o + i * s, 0, l * s + i * o, c * s + n, c * o - i * a, 0, l * o - i * s, c * o + i * a, r * o * o + n, 0, 0, 0, 0, 1),
                                this
                        }
                        makeScale(e, t, n) {
                            return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1),
                                this
                        }
                        makeShear(e, t, n, i, r, a) {
                            return this.set(1, n, r, 0, e, 1, a, 0, t, i, 1, 0, 0, 0, 0, 1),
                                this
                        }
                        compose(e, t, n) {
                            const i = this.elements
                                , r = t._x
                                , a = t._y
                                , s = t._z
                                , o = t._w
                                , l = r + r
                                , c = a + a
                                , h = s + s
                                , d = r * l
                                , u = r * c
                                , p = r * h
                                , f = a * c
                                , m = a * h
                                , g = s * h
                                , v = o * l
                                , w = o * c
                                , A = o * h
                                , y = n.x
                                , b = n.y
                                , x = n.z;
                            return i[0] = (1 - (f + g)) * y,
                                i[1] = (u + A) * y,
                                i[2] = (p - w) * y,
                                i[3] = 0,
                                i[4] = (u - A) * b,
                                i[5] = (1 - (d + g)) * b,
                                i[6] = (m + v) * b,
                                i[7] = 0,
                                i[8] = (p + w) * x,
                                i[9] = (m - v) * x,
                                i[10] = (1 - (d + f)) * x,
                                i[11] = 0,
                                i[12] = e.x,
                                i[13] = e.y,
                                i[14] = e.z,
                                i[15] = 1,
                                this
                        }
                        decompose(e, t, n) {
                            const i = this.elements;
                            let r = Xn.set(i[0], i[1], i[2]).length();
                            const a = Xn.set(i[4], i[5], i[6]).length()
                                , s = Xn.set(i[8], i[9], i[10]).length();
                            this.determinant() < 0 && (r = -r),
                                e.x = i[12],
                                e.y = i[13],
                                e.z = i[14],
                                Zn.copy(this);
                            const o = 1 / r
                                , l = 1 / a
                                , c = 1 / s;
                            return Zn.elements[0] *= o,
                                Zn.elements[1] *= o,
                                Zn.elements[2] *= o,
                                Zn.elements[4] *= l,
                                Zn.elements[5] *= l,
                                Zn.elements[6] *= l,
                                Zn.elements[8] *= c,
                                Zn.elements[9] *= c,
                                Zn.elements[10] *= c,
                                t.setFromRotationMatrix(Zn),
                                n.x = r,
                                n.y = a,
                                n.z = s,
                                this
                        }
                        makePerspective(e, t, n, i, r, a, s=2e3) {
                            const o = this.elements
                                , l = 2 * r / (t - e)
                                , c = 2 * r / (n - i)
                                , h = (t + e) / (t - e)
                                , d = (n + i) / (n - i);
                            let u, p;
                            if (s === Pt)
                                u = -(a + r) / (a - r),
                                    p = -2 * a * r / (a - r);
                            else {
                                if (s !== Rt)
                                    throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + s);
                                u = -a / (a - r),
                                    p = -a * r / (a - r)
                            }
                            return o[0] = l,
                                o[4] = 0,
                                o[8] = h,
                                o[12] = 0,
                                o[1] = 0,
                                o[5] = c,
                                o[9] = d,
                                o[13] = 0,
                                o[2] = 0,
                                o[6] = 0,
                                o[10] = u,
                                o[14] = p,
                                o[3] = 0,
                                o[7] = 0,
                                o[11] = -1,
                                o[15] = 0,
                                this
                        }
                        makeOrthographic(e, t, n, i, r, a, s=2e3) {
                            const o = this.elements
                                , l = 1 / (t - e)
                                , c = 1 / (n - i)
                                , h = 1 / (a - r)
                                , d = (t + e) * l
                                , u = (n + i) * c;
                            let p, f;
                            if (s === Pt)
                                p = (a + r) * h,
                                    f = -2 * h;
                            else {
                                if (s !== Rt)
                                    throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + s);
                                p = r * h,
                                    f = -1 * h
                            }
                            return o[0] = 2 * l,
                                o[4] = 0,
                                o[8] = 0,
                                o[12] = -d,
                                o[1] = 0,
                                o[5] = 2 * c,
                                o[9] = 0,
                                o[13] = -u,
                                o[2] = 0,
                                o[6] = 0,
                                o[10] = f,
                                o[14] = -p,
                                o[3] = 0,
                                o[7] = 0,
                                o[11] = 0,
                                o[15] = 1,
                                this
                        }
                        equals(e) {
                            const t = this.elements
                                , n = e.elements;
                            for (let e = 0; e < 16; e++)
                                if (t[e] !== n[e])
                                    return !1;
                            return !0
                        }
                        fromArray(e, t=0) {
                            for (let n = 0; n < 16; n++)
                                this.elements[n] = e[n + t];
                            return this
                        }
                        toArray(e=[], t=0) {
                            const n = this.elements;
                            return e[t] = n[0],
                                e[t + 1] = n[1],
                                e[t + 2] = n[2],
                                e[t + 3] = n[3],
                                e[t + 4] = n[4],
                                e[t + 5] = n[5],
                                e[t + 6] = n[6],
                                e[t + 7] = n[7],
                                e[t + 8] = n[8],
                                e[t + 9] = n[9],
                                e[t + 10] = n[10],
                                e[t + 11] = n[11],
                                e[t + 12] = n[12],
                                e[t + 13] = n[13],
                                e[t + 14] = n[14],
                                e[t + 15] = n[15],
                                e
                        }
                    }
                    const Xn = new An
                        , Zn = new Kn
                        , Jn = new An(0,0,0)
                        , $n = new An(1,1,1)
                        , ei = new An
                        , ti = new An
                        , ni = new An
                        , ii = new Kn
                        , ri = new wn;
                    class ai {
                        constructor(e=0, t=0, n=0, i=ai.DEFAULT_ORDER) {
                            this.isEuler = !0,
                                this._x = e,
                                this._y = t,
                                this._z = n,
                                this._order = i
                        }
                        get x() {
                            return this._x
                        }
                        set x(e) {
                            this._x = e,
                                this._onChangeCallback()
                        }
                        get y() {
                            return this._y
                        }
                        set y(e) {
                            this._y = e,
                                this._onChangeCallback()
                        }
                        get z() {
                            return this._z
                        }
                        set z(e) {
                            this._z = e,
                                this._onChangeCallback()
                        }
                        get order() {
                            return this._order
                        }
                        set order(e) {
                            this._order = e,
                                this._onChangeCallback()
                        }
                        set(e, t, n, i=this._order) {
                            return this._x = e,
                                this._y = t,
                                this._z = n,
                                this._order = i,
                                this._onChangeCallback(),
                                this
                        }
                        clone() {
                            return new this.constructor(this._x,this._y,this._z,this._order)
                        }
                        copy(e) {
                            return this._x = e._x,
                                this._y = e._y,
                                this._z = e._z,
                                this._order = e._order,
                                this._onChangeCallback(),
                                this
                        }
                        setFromRotationMatrix(e, t=this._order, n=!0) {
                            const i = e.elements
                                , r = i[0]
                                , a = i[4]
                                , s = i[8]
                                , o = i[1]
                                , l = i[5]
                                , c = i[9]
                                , h = i[2]
                                , d = i[6]
                                , u = i[10];
                            switch (t) {
                                case "XYZ":
                                    this._y = Math.asin(Ot(s, -1, 1)),
                                        Math.abs(s) < .9999999 ? (this._x = Math.atan2(-c, u),
                                            this._z = Math.atan2(-a, r)) : (this._x = Math.atan2(d, l),
                                            this._z = 0);
                                    break;
                                case "YXZ":
                                    this._x = Math.asin(-Ot(c, -1, 1)),
                                        Math.abs(c) < .9999999 ? (this._y = Math.atan2(s, u),
                                            this._z = Math.atan2(o, l)) : (this._y = Math.atan2(-h, r),
                                            this._z = 0);
                                    break;
                                case "ZXY":
                                    this._x = Math.asin(Ot(d, -1, 1)),
                                        Math.abs(d) < .9999999 ? (this._y = Math.atan2(-h, u),
                                            this._z = Math.atan2(-a, l)) : (this._y = 0,
                                            this._z = Math.atan2(o, r));
                                    break;
                                case "ZYX":
                                    this._y = Math.asin(-Ot(h, -1, 1)),
                                        Math.abs(h) < .9999999 ? (this._x = Math.atan2(d, u),
                                            this._z = Math.atan2(o, r)) : (this._x = 0,
                                            this._z = Math.atan2(-a, l));
                                    break;
                                case "YZX":
                                    this._z = Math.asin(Ot(o, -1, 1)),
                                        Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, l),
                                            this._y = Math.atan2(-h, r)) : (this._x = 0,
                                            this._y = Math.atan2(s, u));
                                    break;
                                case "XZY":
                                    this._z = Math.asin(-Ot(a, -1, 1)),
                                        Math.abs(a) < .9999999 ? (this._x = Math.atan2(d, l),
                                            this._y = Math.atan2(s, r)) : (this._x = Math.atan2(-c, u),
                                            this._y = 0);
                                    break;
                                default:
                                    console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
                            }
                            return this._order = t,
                            !0 === n && this._onChangeCallback(),
                                this
                        }
                        setFromQuaternion(e, t, n) {
                            return ii.makeRotationFromQuaternion(e),
                                this.setFromRotationMatrix(ii, t, n)
                        }
                        setFromVector3(e, t=this._order) {
                            return this.set(e.x, e.y, e.z, t)
                        }
                        reorder(e) {
                            return ri.setFromEuler(this),
                                this.setFromQuaternion(ri, e)
                        }
                        equals(e) {
                            return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
                        }
                        fromArray(e) {
                            return this._x = e[0],
                                this._y = e[1],
                                this._z = e[2],
                            void 0 !== e[3] && (this._order = e[3]),
                                this._onChangeCallback(),
                                this
                        }
                        toArray(e=[], t=0) {
                            return e[t] = this._x,
                                e[t + 1] = this._y,
                                e[t + 2] = this._z,
                                e[t + 3] = this._order,
                                e
                        }
                        _onChange(e) {
                            return this._onChangeCallback = e,
                                this
                        }
                        _onChangeCallback() {}
                        *[Symbol.iterator]() {
                            yield this._x,
                                yield this._y,
                                yield this._z,
                                yield this._order
                        }
                    }
                    ai.DEFAULT_ORDER = "XYZ";
                    class si {
                        constructor() {
                            this.mask = 1
                        }
                        set(e) {
                            this.mask = 1 << e >>> 0
                        }
                        enable(e) {
                            this.mask |= 1 << e
                        }
                        enableAll() {
                            this.mask = -1
                        }
                        toggle(e) {
                            this.mask ^= 1 << e
                        }
                        disable(e) {
                            this.mask &= ~(1 << e)
                        }
                        disableAll() {
                            this.mask = 0
                        }
                        test(e) {
                            return !!(this.mask & e.mask)
                        }
                        isEnabled(e) {
                            return !!(this.mask & 1 << e)
                        }
                    }
                    let oi = 0;
                    const li = new An
                        , ci = new wn
                        , hi = new Kn
                        , di = new An
                        , ui = new An
                        , pi = new An
                        , fi = new wn
                        , mi = new An(1,0,0)
                        , gi = new An(0,1,0)
                        , vi = new An(0,0,1)
                        , wi = {
                        type: "added"
                    }
                        , Ai = {
                        type: "removed"
                    }
                        , yi = {
                        type: "childadded",
                        child: null
                    }
                        , bi = {
                        type: "childremoved",
                        child: null
                    };
                    class xi extends Lt {
                        constructor() {
                            super(),
                                this.isObject3D = !0,
                                Object.defineProperty(this, "id", {
                                    value: oi++
                                }),
                                this.uuid = zt(),
                                this.name = "",
                                this.type = "Object3D",
                                this.parent = null,
                                this.children = [],
                                this.up = xi.DEFAULT_UP.clone();
                            const e = new An
                                , t = new ai
                                , n = new wn
                                , i = new An(1,1,1);
                            t._onChange((function() {
                                    n.setFromEuler(t, !1)
                                }
                            )),
                                n._onChange((function() {
                                        t.setFromQuaternion(n, void 0, !1)
                                    }
                                )),
                                Object.defineProperties(this, {
                                    position: {
                                        configurable: !0,
                                        enumerable: !0,
                                        value: e
                                    },
                                    rotation: {
                                        configurable: !0,
                                        enumerable: !0,
                                        value: t
                                    },
                                    quaternion: {
                                        configurable: !0,
                                        enumerable: !0,
                                        value: n
                                    },
                                    scale: {
                                        configurable: !0,
                                        enumerable: !0,
                                        value: i
                                    },
                                    modelViewMatrix: {
                                        value: new Kn
                                    },
                                    normalMatrix: {
                                        value: new Qt
                                    }
                                }),
                                this.matrix = new Kn,
                                this.matrixWorld = new Kn,
                                this.matrixAutoUpdate = xi.DEFAULT_MATRIX_AUTO_UPDATE,
                                this.matrixWorldAutoUpdate = xi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
                                this.matrixWorldNeedsUpdate = !1,
                                this.layers = new si,
                                this.visible = !0,
                                this.castShadow = !1,
                                this.receiveShadow = !1,
                                this.frustumCulled = !0,
                                this.renderOrder = 0,
                                this.animations = [],
                                this.userData = {}
                        }
                        onBeforeShadow() {}
                        onAfterShadow() {}
                        onBeforeRender() {}
                        onAfterRender() {}
                        applyMatrix4(e) {
                            this.matrixAutoUpdate && this.updateMatrix(),
                                this.matrix.premultiply(e),
                                this.matrix.decompose(this.position, this.quaternion, this.scale)
                        }
                        applyQuaternion(e) {
                            return this.quaternion.premultiply(e),
                                this
                        }
                        setRotationFromAxisAngle(e, t) {
                            this.quaternion.setFromAxisAngle(e, t)
                        }
                        setRotationFromEuler(e) {
                            this.quaternion.setFromEuler(e, !0)
                        }
                        setRotationFromMatrix(e) {
                            this.quaternion.setFromRotationMatrix(e)
                        }
                        setRotationFromQuaternion(e) {
                            this.quaternion.copy(e)
                        }
                        rotateOnAxis(e, t) {
                            return ci.setFromAxisAngle(e, t),
                                this.quaternion.multiply(ci),
                                this
                        }
                        rotateOnWorldAxis(e, t) {
                            return ci.setFromAxisAngle(e, t),
                                this.quaternion.premultiply(ci),
                                this
                        }
                        rotateX(e) {
                            return this.rotateOnAxis(mi, e)
                        }
                        rotateY(e) {
                            return this.rotateOnAxis(gi, e)
                        }
                        rotateZ(e) {
                            return this.rotateOnAxis(vi, e)
                        }
                        translateOnAxis(e, t) {
                            return li.copy(e).applyQuaternion(this.quaternion),
                                this.position.add(li.multiplyScalar(t)),
                                this
                        }
                        translateX(e) {
                            return this.translateOnAxis(mi, e)
                        }
                        translateY(e) {
                            return this.translateOnAxis(gi, e)
                        }
                        translateZ(e) {
                            return this.translateOnAxis(vi, e)
                        }
                        localToWorld(e) {
                            return this.updateWorldMatrix(!0, !1),
                                e.applyMatrix4(this.matrixWorld)
                        }
                        worldToLocal(e) {
                            return this.updateWorldMatrix(!0, !1),
                                e.applyMatrix4(hi.copy(this.matrixWorld).invert())
                        }
                        lookAt(e, t, n) {
                            e.isVector3 ? di.copy(e) : di.set(e, t, n);
                            const i = this.parent;
                            this.updateWorldMatrix(!0, !1),
                                ui.setFromMatrixPosition(this.matrixWorld),
                                this.isCamera || this.isLight ? hi.lookAt(ui, di, this.up) : hi.lookAt(di, ui, this.up),
                                this.quaternion.setFromRotationMatrix(hi),
                            i && (hi.extractRotation(i.matrixWorld),
                                ci.setFromRotationMatrix(hi),
                                this.quaternion.premultiply(ci.invert()))
                        }
                        add(e) {
                            if (arguments.length > 1) {
                                for (let e = 0; e < arguments.length; e++)
                                    this.add(arguments[e]);
                                return this
                            }
                            return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e),
                                this) : (e && e.isObject3D ? (e.removeFromParent(),
                                e.parent = this,
                                this.children.push(e),
                                e.dispatchEvent(wi),
                                yi.child = e,
                                this.dispatchEvent(yi),
                                yi.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
                                this)
                        }
                        remove(e) {
                            if (arguments.length > 1) {
                                for (let e = 0; e < arguments.length; e++)
                                    this.remove(arguments[e]);
                                return this
                            }
                            const t = this.children.indexOf(e);
                            return -1 !== t && (e.parent = null,
                                this.children.splice(t, 1),
                                e.dispatchEvent(Ai),
                                bi.child = e,
                                this.dispatchEvent(bi),
                                bi.child = null),
                                this
                        }
                        removeFromParent() {
                            const e = this.parent;
                            return null !== e && e.remove(this),
                                this
                        }
                        clear() {
                            return this.remove(...this.children)
                        }
                        attach(e) {
                            return this.updateWorldMatrix(!0, !1),
                                hi.copy(this.matrixWorld).invert(),
                            null !== e.parent && (e.parent.updateWorldMatrix(!0, !1),
                                hi.multiply(e.parent.matrixWorld)),
                                e.applyMatrix4(hi),
                                e.removeFromParent(),
                                e.parent = this,
                                this.children.push(e),
                                e.updateWorldMatrix(!1, !0),
                                e.dispatchEvent(wi),
                                yi.child = e,
                                this.dispatchEvent(yi),
                                yi.child = null,
                                this
                        }
                        getObjectById(e) {
                            return this.getObjectByProperty("id", e)
                        }
                        getObjectByName(e) {
                            return this.getObjectByProperty("name", e)
                        }
                        getObjectByProperty(e, t) {
                            if (this[e] === t)
                                return this;
                            for (let n = 0, i = this.children.length; n < i; n++) {
                                const i = this.children[n].getObjectByProperty(e, t);
                                if (void 0 !== i)
                                    return i
                            }
                        }
                        getObjectsByProperty(e, t, n=[]) {
                            this[e] === t && n.push(this);
                            const i = this.children;
                            for (let r = 0, a = i.length; r < a; r++)
                                i[r].getObjectsByProperty(e, t, n);
                            return n
                        }
                        getWorldPosition(e) {
                            return this.updateWorldMatrix(!0, !1),
                                e.setFromMatrixPosition(this.matrixWorld)
                        }
                        getWorldQuaternion(e) {
                            return this.updateWorldMatrix(!0, !1),
                                this.matrixWorld.decompose(ui, e, pi),
                                e
                        }
                        getWorldScale(e) {
                            return this.updateWorldMatrix(!0, !1),
                                this.matrixWorld.decompose(ui, fi, e),
                                e
                        }
                        getWorldDirection(e) {
                            this.updateWorldMatrix(!0, !1);
                            const t = this.matrixWorld.elements;
                            return e.set(t[8], t[9], t[10]).normalize()
                        }
                        raycast() {}
                        traverse(e) {
                            e(this);
                            const t = this.children;
                            for (let n = 0, i = t.length; n < i; n++)
                                t[n].traverse(e)
                        }
                        traverseVisible(e) {
                            if (!1 === this.visible)
                                return;
                            e(this);
                            const t = this.children;
                            for (let n = 0, i = t.length; n < i; n++)
                                t[n].traverseVisible(e)
                        }
                        traverseAncestors(e) {
                            const t = this.parent;
                            null !== t && (e(t),
                                t.traverseAncestors(e))
                        }
                        updateMatrix() {
                            this.matrix.compose(this.position, this.quaternion, this.scale),
                                this.matrixWorldNeedsUpdate = !0
                        }
                        updateMatrixWorld(e) {
                            this.matrixAutoUpdate && this.updateMatrix(),
                            (this.matrixWorldNeedsUpdate || e) && (!0 === this.matrixWorldAutoUpdate && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
                                this.matrixWorldNeedsUpdate = !1,
                                e = !0);
                            const t = this.children;
                            for (let n = 0, i = t.length; n < i; n++) {
                                t[n].updateMatrixWorld(e)
                            }
                        }
                        updateWorldMatrix(e, t) {
                            const n = this.parent;
                            if (!0 === e && null !== n && n.updateWorldMatrix(!0, !1),
                            this.matrixAutoUpdate && this.updateMatrix(),
                            !0 === this.matrixWorldAutoUpdate && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
                            !0 === t) {
                                const e = this.children;
                                for (let t = 0, n = e.length; t < n; t++) {
                                    e[t].updateWorldMatrix(!1, !0)
                                }
                            }
                        }
                        toJSON(e) {
                            const t = void 0 === e || "string" == typeof e
                                , n = {};
                            t && (e = {
                                geometries: {},
                                materials: {},
                                textures: {},
                                images: {},
                                shapes: {},
                                skeletons: {},
                                animations: {},
                                nodes: {}
                            },
                                n.metadata = {
                                    version: 4.6,
                                    type: "Object",
                                    generator: "Object3D.toJSON"
                                });
                            const i = {};
                            function r(t, n) {
                                return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)),
                                    n.uuid
                            }
                            if (i.uuid = this.uuid,
                                i.type = this.type,
                            "" !== this.name && (i.name = this.name),
                            !0 === this.castShadow && (i.castShadow = !0),
                            !0 === this.receiveShadow && (i.receiveShadow = !0),
                            !1 === this.visible && (i.visible = !1),
                            !1 === this.frustumCulled && (i.frustumCulled = !1),
                            0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
                            Object.keys(this.userData).length > 0 && (i.userData = this.userData),
                                i.layers = this.layers.mask,
                                i.matrix = this.matrix.toArray(),
                                i.up = this.up.toArray(),
                            !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
                            this.isInstancedMesh && (i.type = "InstancedMesh",
                                i.count = this.count,
                                i.instanceMatrix = this.instanceMatrix.toJSON(),
                            null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())),
                            this.isBatchedMesh && (i.type = "BatchedMesh",
                                i.perObjectFrustumCulled = this.perObjectFrustumCulled,
                                i.sortObjects = this.sortObjects,
                                i.drawRanges = this._drawRanges,
                                i.reservedRanges = this._reservedRanges,
                                i.visibility = this._visibility,
                                i.active = this._active,
                                i.bounds = this._bounds.map((e => ({
                                    boxInitialized: e.boxInitialized,
                                    boxMin: e.box.min.toArray(),
                                    boxMax: e.box.max.toArray(),
                                    sphereInitialized: e.sphereInitialized,
                                    sphereRadius: e.sphere.radius,
                                    sphereCenter: e.sphere.center.toArray()
                                }))),
                                i.maxInstanceCount = this._maxInstanceCount,
                                i.maxVertexCount = this._maxVertexCount,
                                i.maxIndexCount = this._maxIndexCount,
                                i.geometryInitialized = this._geometryInitialized,
                                i.geometryCount = this._geometryCount,
                                i.matricesTexture = this._matricesTexture.toJSON(e),
                            null !== this._colorsTexture && (i.colorsTexture = this._colorsTexture.toJSON(e)),
                            null !== this.boundingSphere && (i.boundingSphere = {
                                center: i.boundingSphere.center.toArray(),
                                radius: i.boundingSphere.radius
                            }),
                            null !== this.boundingBox && (i.boundingBox = {
                                min: i.boundingBox.min.toArray(),
                                max: i.boundingBox.max.toArray()
                            })),
                                this.isScene)
                                this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)),
                                this.environment && this.environment.isTexture && !0 !== this.environment.isRenderTargetTexture && (i.environment = this.environment.toJSON(e).uuid);
                            else if (this.isMesh || this.isLine || this.isPoints) {
                                i.geometry = r(e.geometries, this.geometry);
                                const t = this.geometry.parameters;
                                if (void 0 !== t && void 0 !== t.shapes) {
                                    const n = t.shapes;
                                    if (Array.isArray(n))
                                        for (let t = 0, i = n.length; t < i; t++) {
                                            const i = n[t];
                                            r(e.shapes, i)
                                        }
                                    else
                                        r(e.shapes, n)
                                }
                            }
                            if (this.isSkinnedMesh && (i.bindMode = this.bindMode,
                                i.bindMatrix = this.bindMatrix.toArray(),
                            void 0 !== this.skeleton && (r(e.skeletons, this.skeleton),
                                i.skeleton = this.skeleton.uuid)),
                            void 0 !== this.material)
                                if (Array.isArray(this.material)) {
                                    const t = [];
                                    for (let n = 0, i = this.material.length; n < i; n++)
                                        t.push(r(e.materials, this.material[n]));
                                    i.material = t
                                } else
                                    i.material = r(e.materials, this.material);
                            if (this.children.length > 0) {
                                i.children = [];
                                for (let t = 0; t < this.children.length; t++)
                                    i.children.push(this.children[t].toJSON(e).object)
                            }
                            if (this.animations.length > 0) {
                                i.animations = [];
                                for (let t = 0; t < this.animations.length; t++) {
                                    const n = this.animations[t];
                                    i.animations.push(r(e.animations, n))
                                }
                            }
                            if (t) {
                                const t = a(e.geometries)
                                    , i = a(e.materials)
                                    , r = a(e.textures)
                                    , s = a(e.images)
                                    , o = a(e.shapes)
                                    , l = a(e.skeletons)
                                    , c = a(e.animations)
                                    , h = a(e.nodes);
                                t.length > 0 && (n.geometries = t),
                                i.length > 0 && (n.materials = i),
                                r.length > 0 && (n.textures = r),
                                s.length > 0 && (n.images = s),
                                o.length > 0 && (n.shapes = o),
                                l.length > 0 && (n.skeletons = l),
                                c.length > 0 && (n.animations = c),
                                h.length > 0 && (n.nodes = h)
                            }
                            return n.object = i,
                                n;
                            function a(e) {
                                const t = [];
                                for (const n in e) {
                                    const i = e[n];
                                    delete i.metadata,
                                        t.push(i)
                                }
                                return t
                            }
                        }
                        clone(e) {
                            return (new this.constructor).copy(this, e)
                        }
                        copy(e, t=!0) {
                            if (this.name = e.name,
                                this.up.copy(e.up),
                                this.position.copy(e.position),
                                this.rotation.order = e.rotation.order,
                                this.quaternion.copy(e.quaternion),
                                this.scale.copy(e.scale),
                                this.matrix.copy(e.matrix),
                                this.matrixWorld.copy(e.matrixWorld),
                                this.matrixAutoUpdate = e.matrixAutoUpdate,
                                this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate,
                                this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
                                this.layers.mask = e.layers.mask,
                                this.visible = e.visible,
                                this.castShadow = e.castShadow,
                                this.receiveShadow = e.receiveShadow,
                                this.frustumCulled = e.frustumCulled,
                                this.renderOrder = e.renderOrder,
                                this.animations = e.animations.slice(),
                                this.userData = JSON.parse(JSON.stringify(e.userData)),
                            !0 === t)
                                for (let t = 0; t < e.children.length; t++) {
                                    const n = e.children[t];
                                    this.add(n.clone())
                                }
                            return this
                        }
                    }
                    xi.DEFAULT_UP = new An(0,1,0),
                        xi.DEFAULT_MATRIX_AUTO_UPDATE = !0,
                        xi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
                    const ki = new An
                        , Ei = new An
                        , Si = new An
                        , Mi = new An
                        , Ti = new An
                        , Ci = new An
                        , _i = new An
                        , Ii = new An
                        , Pi = new An
                        , Ri = new An
                        , Li = new pn
                        , Ni = new pn
                        , Di = new pn;
                    class Bi {
                        constructor(e=new An, t=new An, n=new An) {
                            this.a = e,
                                this.b = t,
                                this.c = n
                        }
                        static getNormal(e, t, n, i) {
                            i.subVectors(n, t),
                                ki.subVectors(e, t),
                                i.cross(ki);
                            const r = i.lengthSq();
                            return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
                        }
                        static getBarycoord(e, t, n, i, r) {
                            ki.subVectors(i, t),
                                Ei.subVectors(n, t),
                                Si.subVectors(e, t);
                            const a = ki.dot(ki)
                                , s = ki.dot(Ei)
                                , o = ki.dot(Si)
                                , l = Ei.dot(Ei)
                                , c = Ei.dot(Si)
                                , h = a * l - s * s;
                            if (0 === h)
                                return r.set(0, 0, 0),
                                    null;
                            const d = 1 / h
                                , u = (l * o - s * c) * d
                                , p = (a * c - s * o) * d;
                            return r.set(1 - u - p, p, u)
                        }
                        static containsPoint(e, t, n, i) {
                            return null !== this.getBarycoord(e, t, n, i, Mi) && (Mi.x >= 0 && Mi.y >= 0 && Mi.x + Mi.y <= 1)
                        }
                        static getInterpolation(e, t, n, i, r, a, s, o) {
                            return null === this.getBarycoord(e, t, n, i, Mi) ? (o.x = 0,
                                o.y = 0,
                            "z"in o && (o.z = 0),
                            "w"in o && (o.w = 0),
                                null) : (o.setScalar(0),
                                o.addScaledVector(r, Mi.x),
                                o.addScaledVector(a, Mi.y),
                                o.addScaledVector(s, Mi.z),
                                o)
                        }
                        static getInterpolatedAttribute(e, t, n, i, r, a) {
                            return Li.setScalar(0),
                                Ni.setScalar(0),
                                Di.setScalar(0),
                                Li.fromBufferAttribute(e, t),
                                Ni.fromBufferAttribute(e, n),
                                Di.fromBufferAttribute(e, i),
                                a.setScalar(0),
                                a.addScaledVector(Li, r.x),
                                a.addScaledVector(Ni, r.y),
                                a.addScaledVector(Di, r.z),
                                a
                        }
                        static isFrontFacing(e, t, n, i) {
                            return ki.subVectors(n, t),
                                Ei.subVectors(e, t),
                            ki.cross(Ei).dot(i) < 0
                        }
                        set(e, t, n) {
                            return this.a.copy(e),
                                this.b.copy(t),
                                this.c.copy(n),
                                this
                        }
                        setFromPointsAndIndices(e, t, n, i) {
                            return this.a.copy(e[t]),
                                this.b.copy(e[n]),
                                this.c.copy(e[i]),
                                this
                        }
                        setFromAttributeAndIndices(e, t, n, i) {
                            return this.a.fromBufferAttribute(e, t),
                                this.b.fromBufferAttribute(e, n),
                                this.c.fromBufferAttribute(e, i),
                                this
                        }
                        clone() {
                            return (new this.constructor).copy(this)
                        }
                        copy(e) {
                            return this.a.copy(e.a),
                                this.b.copy(e.b),
                                this.c.copy(e.c),
                                this
                        }
                        getArea() {
                            return ki.subVectors(this.c, this.b),
                                Ei.subVectors(this.a, this.b),
                            .5 * ki.cross(Ei).length()
                        }
                        getMidpoint(e) {
                            return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                        }
                        getNormal(e) {
                            return Bi.getNormal(this.a, this.b, this.c, e)
                        }
                        getPlane(e) {
                            return e.setFromCoplanarPoints(this.a, this.b, this.c)
                        }
                        getBarycoord(e, t) {
                            return Bi.getBarycoord(e, this.a, this.b, this.c, t)
                        }
                        getInterpolation(e, t, n, i, r) {
                            return Bi.getInterpolation(e, this.a, this.b, this.c, t, n, i, r)
                        }
                        containsPoint(e) {
                            return Bi.containsPoint(e, this.a, this.b, this.c)
                        }
                        isFrontFacing(e) {
                            return Bi.isFrontFacing(this.a, this.b, this.c, e)
                        }
                        intersectsBox(e) {
                            return e.intersectsTriangle(this)
                        }
                        closestPointToPoint(e, t) {
                            const n = this.a
                                , i = this.b
                                , r = this.c;
                            let a, s;
                            Ti.subVectors(i, n),
                                Ci.subVectors(r, n),
                                Ii.subVectors(e, n);
                            const o = Ti.dot(Ii)
                                , l = Ci.dot(Ii);
                            if (o <= 0 && l <= 0)
                                return t.copy(n);
                            Pi.subVectors(e, i);
                            const c = Ti.dot(Pi)
                                , h = Ci.dot(Pi);
                            if (c >= 0 && h <= c)
                                return t.copy(i);
                            const d = o * h - c * l;
                            if (d <= 0 && o >= 0 && c <= 0)
                                return a = o / (o - c),
                                    t.copy(n).addScaledVector(Ti, a);
                            Ri.subVectors(e, r);
                            const u = Ti.dot(Ri)
                                , p = Ci.dot(Ri);
                            if (p >= 0 && u <= p)
                                return t.copy(r);
                            const f = u * l - o * p;
                            if (f <= 0 && l >= 0 && p <= 0)
                                return s = l / (l - p),
                                    t.copy(n).addScaledVector(Ci, s);
                            const m = c * p - u * h;
                            if (m <= 0 && h - c >= 0 && u - p >= 0)
                                return _i.subVectors(r, i),
                                    s = (h - c) / (h - c + (u - p)),
                                    t.copy(i).addScaledVector(_i, s);
                            const g = 1 / (m + f + d);
                            return a = f * g,
                                s = d * g,
                                t.copy(n).addScaledVector(Ti, a).addScaledVector(Ci, s)
                        }
                        equals(e) {
                            return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
                        }
                    }
                    const Ui = {
                        aliceblue: 15792383,
                        antiquewhite: 16444375,
                        aqua: 65535,
                        aquamarine: 8388564,
                        azure: 15794175,
                        beige: 16119260,
                        bisque: 16770244,
                        black: 0,
                        blanchedalmond: 16772045,
                        blue: 255,
                        blueviolet: 9055202,
                        brown: 10824234,
                        burlywood: 14596231,
                        cadetblue: 6266528,
                        chartreuse: 8388352,
                        chocolate: 13789470,
                        coral: 16744272,
                        cornflowerblue: 6591981,
                        cornsilk: 16775388,
                        crimson: 14423100,
                        cyan: 65535,
                        darkblue: 139,
                        darkcyan: 35723,
                        darkgoldenrod: 12092939,
                        darkgray: 11119017,
                        darkgreen: 25600,
                        darkgrey: 11119017,
                        darkkhaki: 12433259,
                        darkmagenta: 9109643,
                        darkolivegreen: 5597999,
                        darkorange: 16747520,
                        darkorchid: 10040012,
                        darkred: 9109504,
                        darksalmon: 15308410,
                        darkseagreen: 9419919,
                        darkslateblue: 4734347,
                        darkslategray: 3100495,
                        darkslategrey: 3100495,
                        darkturquoise: 52945,
                        darkviolet: 9699539,
                        deeppink: 16716947,
                        deepskyblue: 49151,
                        dimgray: 6908265,
                        dimgrey: 6908265,
                        dodgerblue: 2003199,
                        firebrick: 11674146,
                        floralwhite: 16775920,
                        forestgreen: 2263842,
                        fuchsia: 16711935,
                        gainsboro: 14474460,
                        ghostwhite: 16316671,
                        gold: 16766720,
                        goldenrod: 14329120,
                        gray: 8421504,
                        green: 32768,
                        greenyellow: 11403055,
                        grey: 8421504,
                        honeydew: 15794160,
                        hotpink: 16738740,
                        indianred: 13458524,
                        indigo: 4915330,
                        ivory: 16777200,
                        khaki: 15787660,
                        lavender: 15132410,
                        lavenderblush: 16773365,
                        lawngreen: 8190976,
                        lemonchiffon: 16775885,
                        lightblue: 11393254,
                        lightcoral: 15761536,
                        lightcyan: 14745599,
                        lightgoldenrodyellow: 16448210,
                        lightgray: 13882323,
                        lightgreen: 9498256,
                        lightgrey: 13882323,
                        lightpink: 16758465,
                        lightsalmon: 16752762,
                        lightseagreen: 2142890,
                        lightskyblue: 8900346,
                        lightslategray: 7833753,
                        lightslategrey: 7833753,
                        lightsteelblue: 11584734,
                        lightyellow: 16777184,
                        lime: 65280,
                        limegreen: 3329330,
                        linen: 16445670,
                        magenta: 16711935,
                        maroon: 8388608,
                        mediumaquamarine: 6737322,
                        mediumblue: 205,
                        mediumorchid: 12211667,
                        mediumpurple: 9662683,
                        mediumseagreen: 3978097,
                        mediumslateblue: 8087790,
                        mediumspringgreen: 64154,
                        mediumturquoise: 4772300,
                        mediumvioletred: 13047173,
                        midnightblue: 1644912,
                        mintcream: 16121850,
                        mistyrose: 16770273,
                        moccasin: 16770229,
                        navajowhite: 16768685,
                        navy: 128,
                        oldlace: 16643558,
                        olive: 8421376,
                        olivedrab: 7048739,
                        orange: 16753920,
                        orangered: 16729344,
                        orchid: 14315734,
                        palegoldenrod: 15657130,
                        palegreen: 10025880,
                        paleturquoise: 11529966,
                        palevioletred: 14381203,
                        papayawhip: 16773077,
                        peachpuff: 16767673,
                        peru: 13468991,
                        pink: 16761035,
                        plum: 14524637,
                        powderblue: 11591910,
                        purple: 8388736,
                        rebeccapurple: 6697881,
                        red: 16711680,
                        rosybrown: 12357519,
                        royalblue: 4286945,
                        saddlebrown: 9127187,
                        salmon: 16416882,
                        sandybrown: 16032864,
                        seagreen: 3050327,
                        seashell: 16774638,
                        sienna: 10506797,
                        silver: 12632256,
                        skyblue: 8900331,
                        slateblue: 6970061,
                        slategray: 7372944,
                        slategrey: 7372944,
                        snow: 16775930,
                        springgreen: 65407,
                        steelblue: 4620980,
                        tan: 13808780,
                        teal: 32896,
                        thistle: 14204888,
                        tomato: 16737095,
                        turquoise: 4251856,
                        violet: 15631086,
                        wheat: 16113331,
                        white: 16777215,
                        whitesmoke: 16119285,
                        yellow: 16776960,
                        yellowgreen: 10145074
                    }
                        , zi = {
                        h: 0,
                        s: 0,
                        l: 0
                    }
                        , Oi = {
                        h: 0,
                        s: 0,
                        l: 0
                    };
                    function Fi(e, t, n) {
                        return n < 0 && (n += 1),
                        n > 1 && (n -= 1),
                            n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e
                    }
                    class Wi {
                        constructor(e, t, n) {
                            return this.isColor = !0,
                                this.r = 1,
                                this.g = 1,
                                this.b = 1,
                                this.set(e, t, n)
                        }
                        set(e, t, n) {
                            if (void 0 === t && void 0 === n) {
                                const t = e;
                                t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t)
                            } else
                                this.setRGB(e, t, n);
                            return this
                        }
                        setScalar(e) {
                            return this.r = e,
                                this.g = e,
                                this.b = e,
                                this
                        }
                        setHex(e, t=gt) {
                            return e = Math.floor(e),
                                this.r = (e >> 16 & 255) / 255,
                                this.g = (e >> 8 & 255) / 255,
                                this.b = (255 & e) / 255,
                                nn.toWorkingColorSpace(this, t),
                                this
                        }
                        setRGB(e, t, n, i=nn.workingColorSpace) {
                            return this.r = e,
                                this.g = t,
                                this.b = n,
                                nn.toWorkingColorSpace(this, i),
                                this
                        }
                        setHSL(e, t, n, i=nn.workingColorSpace) {
                            if (e = Ft(e, 1),
                                t = Ot(t, 0, 1),
                                n = Ot(n, 0, 1),
                            0 === t)
                                this.r = this.g = this.b = n;
                            else {
                                const i = n <= .5 ? n * (1 + t) : n + t - n * t
                                    , r = 2 * n - i;
                                this.r = Fi(r, i, e + 1 / 3),
                                    this.g = Fi(r, i, e),
                                    this.b = Fi(r, i, e - 1 / 3)
                            }
                            return nn.toWorkingColorSpace(this, i),
                                this
                        }
                        setStyle(e, t=gt) {
                            function n(t) {
                                void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
                            }
                            let i;
                            if (i = /^(\w+)\(([^\)]*)\)/.exec(e)) {
                                let r;
                                const a = i[1]
                                    , s = i[2];
                                switch (a) {
                                    case "rgb":
                                    case "rgba":
                                        if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))
                                            return n(r[4]),
                                                this.setRGB(Math.min(255, parseInt(r[1], 10)) / 255, Math.min(255, parseInt(r[2], 10)) / 255, Math.min(255, parseInt(r[3], 10)) / 255, t);
                                        if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))
                                            return n(r[4]),
                                                this.setRGB(Math.min(100, parseInt(r[1], 10)) / 100, Math.min(100, parseInt(r[2], 10)) / 100, Math.min(100, parseInt(r[3], 10)) / 100, t);
                                        break;
                                    case "hsl":
                                    case "hsla":
                                        if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))
                                            return n(r[4]),
                                                this.setHSL(parseFloat(r[1]) / 360, parseFloat(r[2]) / 100, parseFloat(r[3]) / 100, t);
                                        break;
                                    default:
                                        console.warn("THREE.Color: Unknown color model " + e)
                                }
                            } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
                                const n = i[1]
                                    , r = n.length;
                                if (3 === r)
                                    return this.setRGB(parseInt(n.charAt(0), 16) / 15, parseInt(n.charAt(1), 16) / 15, parseInt(n.charAt(2), 16) / 15, t);
                                if (6 === r)
                                    return this.setHex(parseInt(n, 16), t);
                                console.warn("THREE.Color: Invalid hex color " + e)
                            } else if (e && e.length > 0)
                                return this.setColorName(e, t);
                            return this
                        }
                        setColorName(e, t=gt) {
                            const n = Ui[e.toLowerCase()];
                            return void 0 !== n ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e),
                                this
                        }
                        clone() {
                            return new this.constructor(this.r,this.g,this.b)
                        }
                        copy(e) {
                            return this.r = e.r,
                                this.g = e.g,
                                this.b = e.b,
                                this
                        }
                        copySRGBToLinear(e) {
                            return this.r = rn(e.r),
                                this.g = rn(e.g),
                                this.b = rn(e.b),
                                this
                        }
                        copyLinearToSRGB(e) {
                            return this.r = an(e.r),
                                this.g = an(e.g),
                                this.b = an(e.b),
                                this
                        }
                        convertSRGBToLinear() {
                            return this.copySRGBToLinear(this),
                                this
                        }
                        convertLinearToSRGB() {
                            return this.copyLinearToSRGB(this),
                                this
                        }
                        getHex(e=gt) {
                            return nn.fromWorkingColorSpace(Hi.copy(this), e),
                            65536 * Math.round(Ot(255 * Hi.r, 0, 255)) + 256 * Math.round(Ot(255 * Hi.g, 0, 255)) + Math.round(Ot(255 * Hi.b, 0, 255))
                        }
                        getHexString(e=gt) {
                            return ("000000" + this.getHex(e).toString(16)).slice(-6)
                        }
                        getHSL(e, t=nn.workingColorSpace) {
                            nn.fromWorkingColorSpace(Hi.copy(this), t);
                            const n = Hi.r
                                , i = Hi.g
                                , r = Hi.b
                                , a = Math.max(n, i, r)
                                , s = Math.min(n, i, r);
                            let o, l;
                            const c = (s + a) / 2;
                            if (s === a)
                                o = 0,
                                    l = 0;
                            else {
                                const e = a - s;
                                switch (l = c <= .5 ? e / (a + s) : e / (2 - a - s),
                                    a) {
                                    case n:
                                        o = (i - r) / e + (i < r ? 6 : 0);
                                        break;
                                    case i:
                                        o = (r - n) / e + 2;
                                        break;
                                    case r:
                                        o = (n - i) / e + 4
                                }
                                o /= 6
                            }
                            return e.h = o,
                                e.s = l,
                                e.l = c,
                                e
                        }
                        getRGB(e, t=nn.workingColorSpace) {
                            return nn.fromWorkingColorSpace(Hi.copy(this), t),
                                e.r = Hi.r,
                                e.g = Hi.g,
                                e.b = Hi.b,
                                e
                        }
                        getStyle(e=gt) {
                            nn.fromWorkingColorSpace(Hi.copy(this), e);
                            const t = Hi.r
                                , n = Hi.g
                                , i = Hi.b;
                            return e !== gt ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(255 * t)},${Math.round(255 * n)},${Math.round(255 * i)})`
                        }
                        offsetHSL(e, t, n) {
                            return this.getHSL(zi),
                                this.setHSL(zi.h + e, zi.s + t, zi.l + n)
                        }
                        add(e) {
                            return this.r += e.r,
                                this.g += e.g,
                                this.b += e.b,
                                this
                        }
                        addColors(e, t) {
                            return this.r = e.r + t.r,
                                this.g = e.g + t.g,
                                this.b = e.b + t.b,
                                this
                        }
                        addScalar(e) {
                            return this.r += e,
                                this.g += e,
                                this.b += e,
                                this
                        }
                        sub(e) {
                            return this.r = Math.max(0, this.r - e.r),
                                this.g = Math.max(0, this.g - e.g),
                                this.b = Math.max(0, this.b - e.b),
                                this
                        }
                        multiply(e) {
                            return this.r *= e.r,
                                this.g *= e.g,
                                this.b *= e.b,
                                this
                        }
                        multiplyScalar(e) {
                            return this.r *= e,
                                this.g *= e,
                                this.b *= e,
                                this
                        }
                        lerp(e, t) {
                            return this.r += (e.r - this.r) * t,
                                this.g += (e.g - this.g) * t,
                                this.b += (e.b - this.b) * t,
                                this
                        }
                        lerpColors(e, t, n) {
                            return this.r = e.r + (t.r - e.r) * n,
                                this.g = e.g + (t.g - e.g) * n,
                                this.b = e.b + (t.b - e.b) * n,
                                this
                        }
                        lerpHSL(e, t) {
                            this.getHSL(zi),
                                e.getHSL(Oi);
                            const n = Wt(zi.h, Oi.h, t)
                                , i = Wt(zi.s, Oi.s, t)
                                , r = Wt(zi.l, Oi.l, t);
                            return this.setHSL(n, i, r),
                                this
                        }
                        setFromVector3(e) {
                            return this.r = e.x,
                                this.g = e.y,
                                this.b = e.z,
                                this
                        }
                        applyMatrix3(e) {
                            const t = this.r
                                , n = this.g
                                , i = this.b
                                , r = e.elements;
                            return this.r = r[0] * t + r[3] * n + r[6] * i,
                                this.g = r[1] * t + r[4] * n + r[7] * i,
                                this.b = r[2] * t + r[5] * n + r[8] * i,
                                this
                        }
                        equals(e) {
                            return e.r === this.r && e.g === this.g && e.b === this.b
                        }
                        fromArray(e, t=0) {
                            return this.r = e[t],
                                this.g = e[t + 1],
                                this.b = e[t + 2],
                                this
                        }
                        toArray(e=[], t=0) {
                            return e[t] = this.r,
                                e[t + 1] = this.g,
                                e[t + 2] = this.b,
                                e
                        }
                        fromBufferAttribute(e, t) {
                            return this.r = e.getX(t),
                                this.g = e.getY(t),
                                this.b = e.getZ(t),
                                this
                        }
                        toJSON() {
                            return this.getHex()
                        }
                        *[Symbol.iterator]() {
                            yield this.r,
                                yield this.g,
                                yield this.b
                        }
                    }
                    const Hi = new Wi;
                    Wi.NAMES = Ui;
                    let Vi = 0;
                    class Gi extends Lt {
                        constructor() {
                            super(),
                                this.isMaterial = !0,
                                Object.defineProperty(this, "id", {
                                    value: Vi++
                                }),
                                this.uuid = zt(),
                                this.name = "",
                                this.type = "Material",
                                this.blending = 1,
                                this.side = 0,
                                this.vertexColors = !1,
                                this.opacity = 1,
                                this.transparent = !1,
                                this.alphaHash = !1,
                                this.blendSrc = 204,
                                this.blendDst = 205,
                                this.blendEquation = M,
                                this.blendSrcAlpha = null,
                                this.blendDstAlpha = null,
                                this.blendEquationAlpha = null,
                                this.blendColor = new Wi(0,0,0),
                                this.blendAlpha = 0,
                                this.depthFunc = 3,
                                this.depthTest = !0,
                                this.depthWrite = !0,
                                this.stencilWriteMask = 255,
                                this.stencilFunc = 519,
                                this.stencilRef = 0,
                                this.stencilFuncMask = 255,
                                this.stencilFail = yt,
                                this.stencilZFail = yt,
                                this.stencilZPass = yt,
                                this.stencilWrite = !1,
                                this.clippingPlanes = null,
                                this.clipIntersection = !1,
                                this.clipShadows = !1,
                                this.shadowSide = null,
                                this.colorWrite = !0,
                                this.precision = null,
                                this.polygonOffset = !1,
                                this.polygonOffsetFactor = 0,
                                this.polygonOffsetUnits = 0,
                                this.dithering = !1,
                                this.alphaToCoverage = !1,
                                this.premultipliedAlpha = !1,
                                this.forceSinglePass = !1,
                                this.visible = !0,
                                this.toneMapped = !0,
                                this.userData = {},
                                this.version = 0,
                                this._alphaTest = 0
                        }
                        get alphaTest() {
                            return this._alphaTest
                        }
                        set alphaTest(e) {
                            this._alphaTest > 0 != e > 0 && this.version++,
                                this._alphaTest = e
                        }
                        onBeforeRender() {}
                        onBeforeCompile() {}
                        customProgramCacheKey() {
                            return this.onBeforeCompile.toString()
                        }
                        setValues(e) {
                            if (void 0 !== e)
                                for (const t in e) {
                                    const n = e[t];
                                    if (void 0 === n) {
                                        console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
                                        continue
                                    }
                                    const i = this[t];
                                    void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n : console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`)
                                }
                        }
                        toJSON(e) {
                            const t = void 0 === e || "string" == typeof e;
                            t && (e = {
                                textures: {},
                                images: {}
                            });
                            const n = {
                                metadata: {
                                    version: 4.6,
                                    type: "Material",
                                    generator: "Material.toJSON"
                                }
                            };
                            function i(e) {
                                const t = [];
                                for (const n in e) {
                                    const i = e[n];
                                    delete i.metadata,
                                        t.push(i)
                                }
                                return t
                            }
                            if (n.uuid = this.uuid,
                                n.type = this.type,
                            "" !== this.name && (n.name = this.name),
                            this.color && this.color.isColor && (n.color = this.color.getHex()),
                            void 0 !== this.roughness && (n.roughness = this.roughness),
                            void 0 !== this.metalness && (n.metalness = this.metalness),
                            void 0 !== this.sheen && (n.sheen = this.sheen),
                            this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()),
                            void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness),
                            this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
                            void 0 !== this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity),
                            this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
                            void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity),
                            this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()),
                            void 0 !== this.shininess && (n.shininess = this.shininess),
                            void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
                            void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness),
                            this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
                            this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
                            this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
                                n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
                            void 0 !== this.dispersion && (n.dispersion = this.dispersion),
                            void 0 !== this.iridescence && (n.iridescence = this.iridescence),
                            void 0 !== this.iridescenceIOR && (n.iridescenceIOR = this.iridescenceIOR),
                            void 0 !== this.iridescenceThicknessRange && (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
                            this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
                            this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
                            void 0 !== this.anisotropy && (n.anisotropy = this.anisotropy),
                            void 0 !== this.anisotropyRotation && (n.anisotropyRotation = this.anisotropyRotation),
                            this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
                            this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
                            this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid),
                            this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid),
                            this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid,
                                n.lightMapIntensity = this.lightMapIntensity),
                            this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid,
                                n.aoMapIntensity = this.aoMapIntensity),
                            this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid,
                                n.bumpScale = this.bumpScale),
                            this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid,
                                n.normalMapType = this.normalMapType,
                                n.normalScale = this.normalScale.toArray()),
                            this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid,
                                n.displacementScale = this.displacementScale,
                                n.displacementBias = this.displacementBias),
                            this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
                            this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
                            this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
                            this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid),
                            this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
                            this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid),
                            this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid,
                            void 0 !== this.combine && (n.combine = this.combine)),
                            void 0 !== this.envMapRotation && (n.envMapRotation = this.envMapRotation.toArray()),
                            void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity),
                            void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity),
                            void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio),
                            this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid),
                            void 0 !== this.transmission && (n.transmission = this.transmission),
                            this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
                            void 0 !== this.thickness && (n.thickness = this.thickness),
                            this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
                            void 0 !== this.attenuationDistance && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance),
                            void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()),
                            void 0 !== this.size && (n.size = this.size),
                            null !== this.shadowSide && (n.shadowSide = this.shadowSide),
                            void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation),
                            1 !== this.blending && (n.blending = this.blending),
                            0 !== this.side && (n.side = this.side),
                            !0 === this.vertexColors && (n.vertexColors = !0),
                            this.opacity < 1 && (n.opacity = this.opacity),
                            !0 === this.transparent && (n.transparent = !0),
                            204 !== this.blendSrc && (n.blendSrc = this.blendSrc),
                            205 !== this.blendDst && (n.blendDst = this.blendDst),
                            this.blendEquation !== M && (n.blendEquation = this.blendEquation),
                            null !== this.blendSrcAlpha && (n.blendSrcAlpha = this.blendSrcAlpha),
                            null !== this.blendDstAlpha && (n.blendDstAlpha = this.blendDstAlpha),
                            null !== this.blendEquationAlpha && (n.blendEquationAlpha = this.blendEquationAlpha),
                            this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()),
                            0 !== this.blendAlpha && (n.blendAlpha = this.blendAlpha),
                            3 !== this.depthFunc && (n.depthFunc = this.depthFunc),
                            !1 === this.depthTest && (n.depthTest = this.depthTest),
                            !1 === this.depthWrite && (n.depthWrite = this.depthWrite),
                            !1 === this.colorWrite && (n.colorWrite = this.colorWrite),
                            255 !== this.stencilWriteMask && (n.stencilWriteMask = this.stencilWriteMask),
                            519 !== this.stencilFunc && (n.stencilFunc = this.stencilFunc),
                            0 !== this.stencilRef && (n.stencilRef = this.stencilRef),
                            255 !== this.stencilFuncMask && (n.stencilFuncMask = this.stencilFuncMask),
                            this.stencilFail !== yt && (n.stencilFail = this.stencilFail),
                            this.stencilZFail !== yt && (n.stencilZFail = this.stencilZFail),
                            this.stencilZPass !== yt && (n.stencilZPass = this.stencilZPass),
                            !0 === this.stencilWrite && (n.stencilWrite = this.stencilWrite),
                            void 0 !== this.rotation && 0 !== this.rotation && (n.rotation = this.rotation),
                            !0 === this.polygonOffset && (n.polygonOffset = !0),
                            0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor),
                            0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits),
                            void 0 !== this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth),
                            void 0 !== this.dashSize && (n.dashSize = this.dashSize),
                            void 0 !== this.gapSize && (n.gapSize = this.gapSize),
                            void 0 !== this.scale && (n.scale = this.scale),
                            !0 === this.dithering && (n.dithering = !0),
                            this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
                            !0 === this.alphaHash && (n.alphaHash = !0),
                            !0 === this.alphaToCoverage && (n.alphaToCoverage = !0),
                            !0 === this.premultipliedAlpha && (n.premultipliedAlpha = !0),
                            !0 === this.forceSinglePass && (n.forceSinglePass = !0),
                            !0 === this.wireframe && (n.wireframe = !0),
                            this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
                            "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap),
                            "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin),
                                !0 === this.flatShading && (n.flatShading = !0),
                                !1 === this.visible && (n.visible = !1),
                                !1 === this.toneMapped && (n.toneMapped = !1),
                                !1 === this.fog && (n.fog = !1),
                                Object.keys(this.userData).length > 0 && (n.userData = this.userData),
                                t) {
                                const t = i(e.textures)
                                    , r = i(e.images);
                                t.length > 0 && (n.textures = t),
                                r.length > 0 && (n.images = r)
                            }
                            return n
                        }
                        clone() {
                            return (new this.constructor).copy(this)
                        }
                        copy(e) {
                            this.name = e.name,
                                this.blending = e.blending,
                                this.side = e.side,
                                this.vertexColors = e.vertexColors,
                                this.opacity = e.opacity,
                                this.transparent = e.transparent,
                                this.blendSrc = e.blendSrc,
                                this.blendDst = e.blendDst,
                                this.blendEquation = e.blendEquation,
                                this.blendSrcAlpha = e.blendSrcAlpha,
                                this.blendDstAlpha = e.blendDstAlpha,
                                this.blendEquationAlpha = e.blendEquationAlpha,
                                this.blendColor.copy(e.blendColor),
                                this.blendAlpha = e.blendAlpha,
                                this.depthFunc = e.depthFunc,
                                this.depthTest = e.depthTest,
                                this.depthWrite = e.depthWrite,
                                this.stencilWriteMask = e.stencilWriteMask,
                                this.stencilFunc = e.stencilFunc,
                                this.stencilRef = e.stencilRef,
                                this.stencilFuncMask = e.stencilFuncMask,
                                this.stencilFail = e.stencilFail,
                                this.stencilZFail = e.stencilZFail,
                                this.stencilZPass = e.stencilZPass,
                                this.stencilWrite = e.stencilWrite;
                            const t = e.clippingPlanes;
                            let n = null;
                            if (null !== t) {
                                const e = t.length;
                                n = new Array(e);
                                for (let i = 0; i !== e; ++i)
                                    n[i] = t[i].clone()
                            }
                            return this.clippingPlanes = n,
                                this.clipIntersection = e.clipIntersection,
                                this.clipShadows = e.clipShadows,
                                this.shadowSide = e.shadowSide,
                                this.colorWrite = e.colorWrite,
                                this.precision = e.precision,
                                this.polygonOffset = e.polygonOffset,
                                this.polygonOffsetFactor = e.polygonOffsetFactor,
                                this.polygonOffsetUnits = e.polygonOffsetUnits,
                                this.dithering = e.dithering,
                                this.alphaTest = e.alphaTest,
                                this.alphaHash = e.alphaHash,
                                this.alphaToCoverage = e.alphaToCoverage,
                                this.premultipliedAlpha = e.premultipliedAlpha,
                                this.forceSinglePass = e.forceSinglePass,
                                this.visible = e.visible,
                                this.toneMapped = e.toneMapped,
                                this.userData = JSON.parse(JSON.stringify(e.userData)),
                                this
                        }
                        dispose() {
                            this.dispatchEvent({
                                type: "dispose"
                            })
                        }
                        set needsUpdate(e) {
                            !0 === e && this.version++
                        }
                        onBuild() {
                            console.warn("Material: onBuild() has been removed.")
                        }
                    }
                    class ji extends Gi {
                        constructor(e) {
                            super(),
                                this.isMeshBasicMaterial = !0,
                                this.type = "MeshBasicMaterial",
                                this.color = new Wi(16777215),
                                this.map = null,
                                this.lightMap = null,
                                this.lightMapIntensity = 1,
                                this.aoMap = null,
                                this.aoMapIntensity = 1,
                                this.specularMap = null,
                                this.alphaMap = null,
                                this.envMap = null,
                                this.envMapRotation = new ai,
                                this.combine = 0,
                                this.reflectivity = 1,
                                this.refractionRatio = .98,
                                this.wireframe = !1,
                                this.wireframeLinewidth = 1,
                                this.wireframeLinecap = "round",
                                this.wireframeLinejoin = "round",
                                this.fog = !0,
                                this.setValues(e)
                        }
                        copy(e) {
                            return super.copy(e),
                                this.color.copy(e.color),
                                this.map = e.map,
                                this.lightMap = e.lightMap,
                                this.lightMapIntensity = e.lightMapIntensity,
                                this.aoMap = e.aoMap,
                                this.aoMapIntensity = e.aoMapIntensity,
                                this.specularMap = e.specularMap,
                                this.alphaMap = e.alphaMap,
                                this.envMap = e.envMap,
                                this.envMapRotation.copy(e.envMapRotation),
                                this.combine = e.combine,
                                this.reflectivity = e.reflectivity,
                                this.refractionRatio = e.refractionRatio,
                                this.wireframe = e.wireframe,
                                this.wireframeLinewidth = e.wireframeLinewidth,
                                this.wireframeLinecap = e.wireframeLinecap,
                                this.wireframeLinejoin = e.wireframeLinejoin,
                                this.fog = e.fog,
                                this
                        }
                    }
                    const Qi = new An
                        , Yi = new jt;
                    let qi = 0;
                    class Ki {
                        constructor(e, t, n=!1) {
                            if (Array.isArray(e))
                                throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                            this.isBufferAttribute = !0,
                                Object.defineProperty(this, "id", {
                                    value: qi++
                                }),
                                this.name = "",
                                this.array = e,
                                this.itemSize = t,
                                this.count = void 0 !== e ? e.length / t : 0,
                                this.normalized = n,
                                this.usage = _t,
                                this.updateRanges = [],
                                this.gpuType = Ae,
                                this.version = 0
                        }
                        onUploadCallback() {}
                        set needsUpdate(e) {
                            !0 === e && this.version++
                        }
                        setUsage(e) {
                            return this.usage = e,
                                this
                        }
                        addUpdateRange(e, t) {
                            this.updateRanges.push({
                                start: e,
                                count: t
                            })
                        }
                        clearUpdateRanges() {
                            this.updateRanges.length = 0
                        }
                        copy(e) {
                            return this.name = e.name,
                                this.array = new e.array.constructor(e.array),
                                this.itemSize = e.itemSize,
                                this.count = e.count,
                                this.normalized = e.normalized,
                                this.usage = e.usage,
                                this.gpuType = e.gpuType,
                                this
                        }
                        copyAt(e, t, n) {
                            e *= this.itemSize,
                                n *= t.itemSize;
                            for (let i = 0, r = this.itemSize; i < r; i++)
                                this.array[e + i] = t.array[n + i];
                            return this
                        }
                        copyArray(e) {
                            return this.array.set(e),
                                this
                        }
                        applyMatrix3(e) {
                            if (2 === this.itemSize)
                                for (let t = 0, n = this.count; t < n; t++)
                                    Yi.fromBufferAttribute(this, t),
                                        Yi.applyMatrix3(e),
                                        this.setXY(t, Yi.x, Yi.y);
                            else if (3 === this.itemSize)
                                for (let t = 0, n = this.count; t < n; t++)
                                    Qi.fromBufferAttribute(this, t),
                                        Qi.applyMatrix3(e),
                                        this.setXYZ(t, Qi.x, Qi.y, Qi.z);
                            return this
                        }
                        applyMatrix4(e) {
                            for (let t = 0, n = this.count; t < n; t++)
                                Qi.fromBufferAttribute(this, t),
                                    Qi.applyMatrix4(e),
                                    this.setXYZ(t, Qi.x, Qi.y, Qi.z);
                            return this
                        }
                        applyNormalMatrix(e) {
                            for (let t = 0, n = this.count; t < n; t++)
                                Qi.fromBufferAttribute(this, t),
                                    Qi.applyNormalMatrix(e),
                                    this.setXYZ(t, Qi.x, Qi.y, Qi.z);
                            return this
                        }
                        transformDirection(e) {
                            for (let t = 0, n = this.count; t < n; t++)
                                Qi.fromBufferAttribute(this, t),
                                    Qi.transformDirection(e),
                                    this.setXYZ(t, Qi.x, Qi.y, Qi.z);
                            return this
                        }
                        set(e, t=0) {
                            return this.array.set(e, t),
                                this
                        }
                        getComponent(e, t) {
                            let n = this.array[e * this.itemSize + t];
                            return this.normalized && (n = Ht(n, this.array)),
                                n
                        }
                        setComponent(e, t, n) {
                            return this.normalized && (n = Vt(n, this.array)),
                                this.array[e * this.itemSize + t] = n,
                                this
                        }
                        getX(e) {
                            let t = this.array[e * this.itemSize];
                            return this.normalized && (t = Ht(t, this.array)),
                                t
                        }
                        setX(e, t) {
                            return this.normalized && (t = Vt(t, this.array)),
                                this.array[e * this.itemSize] = t,
                                this
                        }
                        getY(e) {
                            let t = this.array[e * this.itemSize + 1];
                            return this.normalized && (t = Ht(t, this.array)),
                                t
                        }
                        setY(e, t) {
                            return this.normalized && (t = Vt(t, this.array)),
                                this.array[e * this.itemSize + 1] = t,
                                this
                        }
                        getZ(e) {
                            let t = this.array[e * this.itemSize + 2];
                            return this.normalized && (t = Ht(t, this.array)),
                                t
                        }
                        setZ(e, t) {
                            return this.normalized && (t = Vt(t, this.array)),
                                this.array[e * this.itemSize + 2] = t,
                                this
                        }
                        getW(e) {
                            let t = this.array[e * this.itemSize + 3];
                            return this.normalized && (t = Ht(t, this.array)),
                                t
                        }
                        setW(e, t) {
                            return this.normalized && (t = Vt(t, this.array)),
                                this.array[e * this.itemSize + 3] = t,
                                this
                        }
                        setXY(e, t, n) {
                            return e *= this.itemSize,
                            this.normalized && (t = Vt(t, this.array),
                                n = Vt(n, this.array)),
                                this.array[e + 0] = t,
                                this.array[e + 1] = n,
                                this
                        }
                        setXYZ(e, t, n, i) {
                            return e *= this.itemSize,
                            this.normalized && (t = Vt(t, this.array),
                                n = Vt(n, this.array),
                                i = Vt(i, this.array)),
                                this.array[e + 0] = t,
                                this.array[e + 1] = n,
                                this.array[e + 2] = i,
                                this
                        }
                        setXYZW(e, t, n, i, r) {
                            return e *= this.itemSize,
                            this.normalized && (t = Vt(t, this.array),
                                n = Vt(n, this.array),
                                i = Vt(i, this.array),
                                r = Vt(r, this.array)),
                                this.array[e + 0] = t,
                                this.array[e + 1] = n,
                                this.array[e + 2] = i,
                                this.array[e + 3] = r,
                                this
                        }
                        onUpload(e) {
                            return this.onUploadCallback = e,
                                this
                        }
                        clone() {
                            return new this.constructor(this.array,this.itemSize).copy(this)
                        }
                        toJSON() {
                            const e = {
                                itemSize: this.itemSize,
                                type: this.array.constructor.name,
                                array: Array.from(this.array),
                                normalized: this.normalized
                            };
                            return "" !== this.name && (e.name = this.name),
                            this.usage !== _t && (e.usage = this.usage),
                                e
                        }
                    }
                    class Xi extends Ki {
                        constructor(e, t, n) {
                            super(new Uint16Array(e), t, n)
                        }
                    }
                    class Zi extends Ki {
                        constructor(e, t, n) {
                            super(new Uint32Array(e), t, n)
                        }
                    }
                    class Ji extends Ki {
                        constructor(e, t, n) {
                            super(new Float32Array(e), t, n)
                        }
                    }
                    let $i = 0;
                    const er = new Kn
                        , tr = new xi
                        , nr = new An
                        , ir = new xn
                        , rr = new xn
                        , ar = new An;
                    class sr extends Lt {
                        constructor() {
                            super(),
                                this.isBufferGeometry = !0,
                                Object.defineProperty(this, "id", {
                                    value: $i++
                                }),
                                this.uuid = zt(),
                                this.name = "",
                                this.type = "BufferGeometry",
                                this.index = null,
                                this.indirect = null,
                                this.attributes = {},
                                this.morphAttributes = {},
                                this.morphTargetsRelative = !1,
                                this.groups = [],
                                this.boundingBox = null,
                                this.boundingSphere = null,
                                this.drawRange = {
                                    start: 0,
                                    count: 1 / 0
                                },
                                this.userData = {}
                        }
                        getIndex() {
                            return this.index
                        }
                        setIndex(e) {
                            return Array.isArray(e) ? this.index = new (qt(e) ? Zi : Xi)(e,1) : this.index = e,
                                this
                        }
                        setIndirect(e) {
                            return this.indirect = e,
                                this
                        }
                        getIndirect() {
                            return this.indirect
                        }
                        getAttribute(e) {
                            return this.attributes[e]
                        }
                        setAttribute(e, t) {
                            return this.attributes[e] = t,
                                this
                        }
                        deleteAttribute(e) {
                            return delete this.attributes[e],
                                this
                        }
                        hasAttribute(e) {
                            return void 0 !== this.attributes[e]
                        }
                        addGroup(e, t, n=0) {
                            this.groups.push({
                                start: e,
                                count: t,
                                materialIndex: n
                            })
                        }
                        clearGroups() {
                            this.groups = []
                        }
                        setDrawRange(e, t) {
                            this.drawRange.start = e,
                                this.drawRange.count = t
                        }
                        applyMatrix4(e) {
                            const t = this.attributes.position;
                            void 0 !== t && (t.applyMatrix4(e),
                                t.needsUpdate = !0);
                            const n = this.attributes.normal;
                            if (void 0 !== n) {
                                const t = (new Qt).getNormalMatrix(e);
                                n.applyNormalMatrix(t),
                                    n.needsUpdate = !0
                            }
                            const i = this.attributes.tangent;
                            return void 0 !== i && (i.transformDirection(e),
                                i.needsUpdate = !0),
                            null !== this.boundingBox && this.computeBoundingBox(),
                            null !== this.boundingSphere && this.computeBoundingSphere(),
                                this
                        }
                        applyQuaternion(e) {
                            return er.makeRotationFromQuaternion(e),
                                this.applyMatrix4(er),
                                this
                        }
                        rotateX(e) {
                            return er.makeRotationX(e),
                                this.applyMatrix4(er),
                                this
                        }
                        rotateY(e) {
                            return er.makeRotationY(e),
                                this.applyMatrix4(er),
                                this
                        }
                        rotateZ(e) {
                            return er.makeRotationZ(e),
                                this.applyMatrix4(er),
                                this
                        }
                        translate(e, t, n) {
                            return er.makeTranslation(e, t, n),
                                this.applyMatrix4(er),
                                this
                        }
                        scale(e, t, n) {
                            return er.makeScale(e, t, n),
                                this.applyMatrix4(er),
                                this
                        }
                        lookAt(e) {
                            return tr.lookAt(e),
                                tr.updateMatrix(),
                                this.applyMatrix4(tr.matrix),
                                this
                        }
                        center() {
                            return this.computeBoundingBox(),
                                this.boundingBox.getCenter(nr).negate(),
                                this.translate(nr.x, nr.y, nr.z),
                                this
                        }
                        setFromPoints(e) {
                            const t = this.getAttribute("position");
                            if (void 0 === t) {
                                const t = [];
                                for (let n = 0, i = e.length; n < i; n++) {
                                    const i = e[n];
                                    t.push(i.x, i.y, i.z || 0)
                                }
                                this.setAttribute("position", new Ji(t,3))
                            } else {
                                const n = Math.min(e.length, t.count);
                                for (let i = 0; i < n; i++) {
                                    const n = e[i];
                                    t.setXYZ(i, n.x, n.y, n.z || 0)
                                }
                                e.length > t.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),
                                    t.needsUpdate = !0
                            }
                            return this
                        }
                        computeBoundingBox() {
                            null === this.boundingBox && (this.boundingBox = new xn);
                            const e = this.attributes.position
                                , t = this.morphAttributes.position;
                            if (e && e.isGLBufferAttribute)
                                return console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this),
                                    void this.boundingBox.set(new An(-1 / 0,-1 / 0,-1 / 0), new An(1 / 0,1 / 0,1 / 0));
                            if (void 0 !== e) {
                                if (this.boundingBox.setFromBufferAttribute(e),
                                    t)
                                    for (let e = 0, n = t.length; e < n; e++) {
                                        const n = t[e];
                                        ir.setFromBufferAttribute(n),
                                            this.morphTargetsRelative ? (ar.addVectors(this.boundingBox.min, ir.min),
                                                this.boundingBox.expandByPoint(ar),
                                                ar.addVectors(this.boundingBox.max, ir.max),
                                                this.boundingBox.expandByPoint(ar)) : (this.boundingBox.expandByPoint(ir.min),
                                                this.boundingBox.expandByPoint(ir.max))
                                    }
                            } else
                                this.boundingBox.makeEmpty();
                            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                        }
                        computeBoundingSphere() {
                            null === this.boundingSphere && (this.boundingSphere = new Fn);
                            const e = this.attributes.position
                                , t = this.morphAttributes.position;
                            if (e && e.isGLBufferAttribute)
                                return console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this),
                                    void this.boundingSphere.set(new An, 1 / 0);
                            if (e) {
                                const n = this.boundingSphere.center;
                                if (ir.setFromBufferAttribute(e),
                                    t)
                                    for (let e = 0, n = t.length; e < n; e++) {
                                        const n = t[e];
                                        rr.setFromBufferAttribute(n),
                                            this.morphTargetsRelative ? (ar.addVectors(ir.min, rr.min),
                                                ir.expandByPoint(ar),
                                                ar.addVectors(ir.max, rr.max),
                                                ir.expandByPoint(ar)) : (ir.expandByPoint(rr.min),
                                                ir.expandByPoint(rr.max))
                                    }
                                ir.getCenter(n);
                                let i = 0;
                                for (let t = 0, r = e.count; t < r; t++)
                                    ar.fromBufferAttribute(e, t),
                                        i = Math.max(i, n.distanceToSquared(ar));
                                if (t)
                                    for (let r = 0, a = t.length; r < a; r++) {
                                        const a = t[r]
                                            , s = this.morphTargetsRelative;
                                        for (let t = 0, r = a.count; t < r; t++)
                                            ar.fromBufferAttribute(a, t),
                                            s && (nr.fromBufferAttribute(e, t),
                                                ar.add(nr)),
                                                i = Math.max(i, n.distanceToSquared(ar))
                                    }
                                this.boundingSphere.radius = Math.sqrt(i),
                                isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                            }
                        }
                        computeTangents() {
                            const e = this.index
                                , t = this.attributes;
                            if (null === e || void 0 === t.position || void 0 === t.normal || void 0 === t.uv)
                                return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                            const n = t.position
                                , i = t.normal
                                , r = t.uv;
                            !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new Ki(new Float32Array(4 * n.count),4));
                            const a = this.getAttribute("tangent")
                                , s = []
                                , o = [];
                            for (let e = 0; e < n.count; e++)
                                s[e] = new An,
                                    o[e] = new An;
                            const l = new An
                                , c = new An
                                , h = new An
                                , d = new jt
                                , u = new jt
                                , p = new jt
                                , f = new An
                                , m = new An;
                            function g(e, t, i) {
                                l.fromBufferAttribute(n, e),
                                    c.fromBufferAttribute(n, t),
                                    h.fromBufferAttribute(n, i),
                                    d.fromBufferAttribute(r, e),
                                    u.fromBufferAttribute(r, t),
                                    p.fromBufferAttribute(r, i),
                                    c.sub(l),
                                    h.sub(l),
                                    u.sub(d),
                                    p.sub(d);
                                const a = 1 / (u.x * p.y - p.x * u.y);
                                isFinite(a) && (f.copy(c).multiplyScalar(p.y).addScaledVector(h, -u.y).multiplyScalar(a),
                                    m.copy(h).multiplyScalar(u.x).addScaledVector(c, -p.x).multiplyScalar(a),
                                    s[e].add(f),
                                    s[t].add(f),
                                    s[i].add(f),
                                    o[e].add(m),
                                    o[t].add(m),
                                    o[i].add(m))
                            }
                            let v = this.groups;
                            0 === v.length && (v = [{
                                start: 0,
                                count: e.count
                            }]);
                            for (let t = 0, n = v.length; t < n; ++t) {
                                const n = v[t]
                                    , i = n.start;
                                for (let t = i, r = i + n.count; t < r; t += 3)
                                    g(e.getX(t + 0), e.getX(t + 1), e.getX(t + 2))
                            }
                            const w = new An
                                , A = new An
                                , y = new An
                                , b = new An;
                            function x(e) {
                                y.fromBufferAttribute(i, e),
                                    b.copy(y);
                                const t = s[e];
                                w.copy(t),
                                    w.sub(y.multiplyScalar(y.dot(t))).normalize(),
                                    A.crossVectors(b, t);
                                const n = A.dot(o[e]) < 0 ? -1 : 1;
                                a.setXYZW(e, w.x, w.y, w.z, n)
                            }
                            for (let t = 0, n = v.length; t < n; ++t) {
                                const n = v[t]
                                    , i = n.start;
                                for (let t = i, r = i + n.count; t < r; t += 3)
                                    x(e.getX(t + 0)),
                                        x(e.getX(t + 1)),
                                        x(e.getX(t + 2))
                            }
                        }
                        computeVertexNormals() {
                            const e = this.index
                                , t = this.getAttribute("position");
                            if (void 0 !== t) {
                                let n = this.getAttribute("normal");
                                if (void 0 === n)
                                    n = new Ki(new Float32Array(3 * t.count),3),
                                        this.setAttribute("normal", n);
                                else
                                    for (let e = 0, t = n.count; e < t; e++)
                                        n.setXYZ(e, 0, 0, 0);
                                const i = new An
                                    , r = new An
                                    , a = new An
                                    , s = new An
                                    , o = new An
                                    , l = new An
                                    , c = new An
                                    , h = new An;
                                if (e)
                                    for (let d = 0, u = e.count; d < u; d += 3) {
                                        const u = e.getX(d + 0)
                                            , p = e.getX(d + 1)
                                            , f = e.getX(d + 2);
                                        i.fromBufferAttribute(t, u),
                                            r.fromBufferAttribute(t, p),
                                            a.fromBufferAttribute(t, f),
                                            c.subVectors(a, r),
                                            h.subVectors(i, r),
                                            c.cross(h),
                                            s.fromBufferAttribute(n, u),
                                            o.fromBufferAttribute(n, p),
                                            l.fromBufferAttribute(n, f),
                                            s.add(c),
                                            o.add(c),
                                            l.add(c),
                                            n.setXYZ(u, s.x, s.y, s.z),
                                            n.setXYZ(p, o.x, o.y, o.z),
                                            n.setXYZ(f, l.x, l.y, l.z)
                                    }
                                else
                                    for (let e = 0, s = t.count; e < s; e += 3)
                                        i.fromBufferAttribute(t, e + 0),
                                            r.fromBufferAttribute(t, e + 1),
                                            a.fromBufferAttribute(t, e + 2),
                                            c.subVectors(a, r),
                                            h.subVectors(i, r),
                                            c.cross(h),
                                            n.setXYZ(e + 0, c.x, c.y, c.z),
                                            n.setXYZ(e + 1, c.x, c.y, c.z),
                                            n.setXYZ(e + 2, c.x, c.y, c.z);
                                this.normalizeNormals(),
                                    n.needsUpdate = !0
                            }
                        }
                        normalizeNormals() {
                            const e = this.attributes.normal;
                            for (let t = 0, n = e.count; t < n; t++)
                                ar.fromBufferAttribute(e, t),
                                    ar.normalize(),
                                    e.setXYZ(t, ar.x, ar.y, ar.z)
                        }
                        toNonIndexed() {
                            function e(e, t) {
                                const n = e.array
                                    , i = e.itemSize
                                    , r = e.normalized
                                    , a = new n.constructor(t.length * i);
                                let s = 0
                                    , o = 0;
                                for (let r = 0, l = t.length; r < l; r++) {
                                    s = e.isInterleavedBufferAttribute ? t[r] * e.data.stride + e.offset : t[r] * i;
                                    for (let e = 0; e < i; e++)
                                        a[o++] = n[s++]
                                }
                                return new Ki(a,i,r)
                            }
                            if (null === this.index)
                                return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
                                    this;
                            const t = new sr
                                , n = this.index.array
                                , i = this.attributes;
                            for (const r in i) {
                                const a = e(i[r], n);
                                t.setAttribute(r, a)
                            }
                            const r = this.morphAttributes;
                            for (const i in r) {
                                const a = []
                                    , s = r[i];
                                for (let t = 0, i = s.length; t < i; t++) {
                                    const i = e(s[t], n);
                                    a.push(i)
                                }
                                t.morphAttributes[i] = a
                            }
                            t.morphTargetsRelative = this.morphTargetsRelative;
                            const a = this.groups;
                            for (let e = 0, n = a.length; e < n; e++) {
                                const n = a[e];
                                t.addGroup(n.start, n.count, n.materialIndex)
                            }
                            return t
                        }
                        toJSON() {
                            const e = {
                                metadata: {
                                    version: 4.6,
                                    type: "BufferGeometry",
                                    generator: "BufferGeometry.toJSON"
                                }
                            };
                            if (e.uuid = this.uuid,
                                e.type = this.type,
                            "" !== this.name && (e.name = this.name),
                            Object.keys(this.userData).length > 0 && (e.userData = this.userData),
                            void 0 !== this.parameters) {
                                const t = this.parameters;
                                for (const n in t)
                                    void 0 !== t[n] && (e[n] = t[n]);
                                return e
                            }
                            e.data = {
                                attributes: {}
                            };
                            const t = this.index;
                            null !== t && (e.data.index = {
                                type: t.array.constructor.name,
                                array: Array.prototype.slice.call(t.array)
                            });
                            const n = this.attributes;
                            for (const t in n) {
                                const i = n[t];
                                e.data.attributes[t] = i.toJSON(e.data)
                            }
                            const i = {};
                            let r = !1;
                            for (const t in this.morphAttributes) {
                                const n = this.morphAttributes[t]
                                    , a = [];
                                for (let t = 0, i = n.length; t < i; t++) {
                                    const i = n[t];
                                    a.push(i.toJSON(e.data))
                                }
                                a.length > 0 && (i[t] = a,
                                    r = !0)
                            }
                            r && (e.data.morphAttributes = i,
                                e.data.morphTargetsRelative = this.morphTargetsRelative);
                            const a = this.groups;
                            a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
                            const s = this.boundingSphere;
                            return null !== s && (e.data.boundingSphere = {
                                center: s.center.toArray(),
                                radius: s.radius
                            }),
                                e
                        }
                        clone() {
                            return (new this.constructor).copy(this)
                        }
                        copy(e) {
                            this.index = null,
                                this.attributes = {},
                                this.morphAttributes = {},
                                this.groups = [],
                                this.boundingBox = null,
                                this.boundingSphere = null;
                            const t = {};
                            this.name = e.name;
                            const n = e.index;
                            null !== n && this.setIndex(n.clone(t));
                            const i = e.attributes;
                            for (const e in i) {
                                const n = i[e];
                                this.setAttribute(e, n.clone(t))
                            }
                            const r = e.morphAttributes;
                            for (const e in r) {
                                const n = []
                                    , i = r[e];
                                for (let e = 0, r = i.length; e < r; e++)
                                    n.push(i[e].clone(t));
                                this.morphAttributes[e] = n
                            }
                            this.morphTargetsRelative = e.morphTargetsRelative;
                            const a = e.groups;
                            for (let e = 0, t = a.length; e < t; e++) {
                                const t = a[e];
                                this.addGroup(t.start, t.count, t.materialIndex)
                            }
                            const s = e.boundingBox;
                            null !== s && (this.boundingBox = s.clone());
                            const o = e.boundingSphere;
                            return null !== o && (this.boundingSphere = o.clone()),
                                this.drawRange.start = e.drawRange.start,
                                this.drawRange.count = e.drawRange.count,
                                this.userData = e.userData,
                                this
                        }
                        dispose() {
                            this.dispatchEvent({
                                type: "dispose"
                            })
                        }
                    }
                    const or = new Kn
                        , lr = new qn
                        , cr = new Fn
                        , hr = new An
                        , dr = new An
                        , ur = new An
                        , pr = new An
                        , fr = new An
                        , mr = new An
                        , gr = new An
                        , vr = new An;
                    class wr extends xi {
                        constructor(e=new sr, t=new ji) {
                            super(),
                                this.isMesh = !0,
                                this.type = "Mesh",
                                this.geometry = e,
                                this.material = t,
                                this.morphTargetDictionary = void 0,
                                this.morphTargetInfluences = void 0,
                                this.updateMorphTargets()
                        }
                        copy(e, t) {
                            return super.copy(e, t),
                            void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
                            void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
                                this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
                                this.geometry = e.geometry,
                                this
                        }
                        updateMorphTargets() {
                            const e = this.geometry.morphAttributes
                                , t = Object.keys(e);
                            if (t.length > 0) {
                                const n = e[t[0]];
                                if (void 0 !== n) {
                                    this.morphTargetInfluences = [],
                                        this.morphTargetDictionary = {};
                                    for (let e = 0, t = n.length; e < t; e++) {
                                        const t = n[e].name || String(e);
                                        this.morphTargetInfluences.push(0),
                                            this.morphTargetDictionary[t] = e
                                    }
                                }
                            }
                        }
                        getVertexPosition(e, t) {
                            const n = this.geometry
                                , i = n.attributes.position
                                , r = n.morphAttributes.position
                                , a = n.morphTargetsRelative;
                            t.fromBufferAttribute(i, e);
                            const s = this.morphTargetInfluences;
                            if (r && s) {
                                mr.set(0, 0, 0);
                                for (let n = 0, i = r.length; n < i; n++) {
                                    const i = s[n]
                                        , o = r[n];
                                    0 !== i && (fr.fromBufferAttribute(o, e),
                                        a ? mr.addScaledVector(fr, i) : mr.addScaledVector(fr.sub(t), i))
                                }
                                t.add(mr)
                            }
                            return t
                        }
                        raycast(e, t) {
                            const n = this.geometry
                                , i = this.material
                                , r = this.matrixWorld;
                            if (void 0 !== i) {
                                if (null === n.boundingSphere && n.computeBoundingSphere(),
                                    cr.copy(n.boundingSphere),
                                    cr.applyMatrix4(r),
                                    lr.copy(e.ray).recast(e.near),
                                !1 === cr.containsPoint(lr.origin)) {
                                    if (null === lr.intersectSphere(cr, hr))
                                        return;
                                    if (lr.origin.distanceToSquared(hr) > (e.far - e.near) ** 2)
                                        return
                                }
                                or.copy(r).invert(),
                                    lr.copy(e.ray).applyMatrix4(or),
                                null !== n.boundingBox && !1 === lr.intersectsBox(n.boundingBox) || this._computeIntersections(e, t, lr)
                            }
                        }
                        _computeIntersections(e, t, n) {
                            let i;
                            const r = this.geometry
                                , a = this.material
                                , s = r.index
                                , o = r.attributes.position
                                , l = r.attributes.uv
                                , c = r.attributes.uv1
                                , h = r.attributes.normal
                                , d = r.groups
                                , u = r.drawRange;
                            if (null !== s)
                                if (Array.isArray(a))
                                    for (let r = 0, o = d.length; r < o; r++) {
                                        const o = d[r]
                                            , p = a[o.materialIndex];
                                        for (let r = Math.max(o.start, u.start), a = Math.min(s.count, Math.min(o.start + o.count, u.start + u.count)); r < a; r += 3) {
                                            i = Ar(this, p, e, n, l, c, h, s.getX(r), s.getX(r + 1), s.getX(r + 2)),
                                            i && (i.faceIndex = Math.floor(r / 3),
                                                i.face.materialIndex = o.materialIndex,
                                                t.push(i))
                                        }
                                    }
                                else {
                                    for (let r = Math.max(0, u.start), o = Math.min(s.count, u.start + u.count); r < o; r += 3) {
                                        i = Ar(this, a, e, n, l, c, h, s.getX(r), s.getX(r + 1), s.getX(r + 2)),
                                        i && (i.faceIndex = Math.floor(r / 3),
                                            t.push(i))
                                    }
                                }
                            else if (void 0 !== o)
                                if (Array.isArray(a))
                                    for (let r = 0, s = d.length; r < s; r++) {
                                        const s = d[r]
                                            , p = a[s.materialIndex];
                                        for (let r = Math.max(s.start, u.start), a = Math.min(o.count, Math.min(s.start + s.count, u.start + u.count)); r < a; r += 3) {
                                            i = Ar(this, p, e, n, l, c, h, r, r + 1, r + 2),
                                            i && (i.faceIndex = Math.floor(r / 3),
                                                i.face.materialIndex = s.materialIndex,
                                                t.push(i))
                                        }
                                    }
                                else {
                                    for (let r = Math.max(0, u.start), s = Math.min(o.count, u.start + u.count); r < s; r += 3) {
                                        i = Ar(this, a, e, n, l, c, h, r, r + 1, r + 2),
                                        i && (i.faceIndex = Math.floor(r / 3),
                                            t.push(i))
                                    }
                                }
                        }
                    }
                    function Ar(e, t, n, i, r, a, s, o, l, c) {
                        e.getVertexPosition(o, dr),
                            e.getVertexPosition(l, ur),
                            e.getVertexPosition(c, pr);
                        const h = function(e, t, n, i, r, a, s, o) {
                            let l;
                            if (l = 1 === t.side ? i.intersectTriangle(s, a, r, !0, o) : i.intersectTriangle(r, a, s, 0 === t.side, o),
                            null === l)
                                return null;
                            vr.copy(o),
                                vr.applyMatrix4(e.matrixWorld);
                            const c = n.ray.origin.distanceTo(vr);
                            return c < n.near || c > n.far ? null : {
                                distance: c,
                                point: vr.clone(),
                                object: e
                            }
                        }(e, t, n, i, dr, ur, pr, gr);
                        if (h) {
                            const e = new An;
                            Bi.getBarycoord(gr, dr, ur, pr, e),
                            r && (h.uv = Bi.getInterpolatedAttribute(r, o, l, c, e, new jt)),
                            a && (h.uv1 = Bi.getInterpolatedAttribute(a, o, l, c, e, new jt)),
                            s && (h.normal = Bi.getInterpolatedAttribute(s, o, l, c, e, new An),
                            h.normal.dot(i.direction) > 0 && h.normal.multiplyScalar(-1));
                            const t = {
                                a: o,
                                b: l,
                                c,
                                normal: new An,
                                materialIndex: 0
                            };
                            Bi.getNormal(dr, ur, pr, t.normal),
                                h.face = t,
                                h.barycoord = e
                        }
                        return h
                    }
                    class yr extends sr {
                        constructor(e=1, t=1, n=1, i=1, r=1, a=1) {
                            super(),
                                this.type = "BoxGeometry",
                                this.parameters = {
                                    width: e,
                                    height: t,
                                    depth: n,
                                    widthSegments: i,
                                    heightSegments: r,
                                    depthSegments: a
                                };
                            const s = this;
                            i = Math.floor(i),
                                r = Math.floor(r),
                                a = Math.floor(a);
                            const o = []
                                , l = []
                                , c = []
                                , h = [];
                            let d = 0
                                , u = 0;
                            function p(e, t, n, i, r, a, p, f, m, g, v) {
                                const w = a / m
                                    , A = p / g
                                    , y = a / 2
                                    , b = p / 2
                                    , x = f / 2
                                    , k = m + 1
                                    , E = g + 1;
                                let S = 0
                                    , M = 0;
                                const T = new An;
                                for (let a = 0; a < E; a++) {
                                    const s = a * A - b;
                                    for (let o = 0; o < k; o++) {
                                        const d = o * w - y;
                                        T[e] = d * i,
                                            T[t] = s * r,
                                            T[n] = x,
                                            l.push(T.x, T.y, T.z),
                                            T[e] = 0,
                                            T[t] = 0,
                                            T[n] = f > 0 ? 1 : -1,
                                            c.push(T.x, T.y, T.z),
                                            h.push(o / m),
                                            h.push(1 - a / g),
                                            S += 1
                                    }
                                }
                                for (let e = 0; e < g; e++)
                                    for (let t = 0; t < m; t++) {
                                        const n = d + t + k * e
                                            , i = d + t + k * (e + 1)
                                            , r = d + (t + 1) + k * (e + 1)
                                            , a = d + (t + 1) + k * e;
                                        o.push(n, i, a),
                                            o.push(i, r, a),
                                            M += 6
                                    }
                                s.addGroup(u, M, v),
                                    u += M,
                                    d += S
                            }
                            p("z", "y", "x", -1, -1, n, t, e, a, r, 0),
                                p("z", "y", "x", 1, -1, n, t, -e, a, r, 1),
                                p("x", "z", "y", 1, 1, e, n, t, i, a, 2),
                                p("x", "z", "y", 1, -1, e, n, -t, i, a, 3),
                                p("x", "y", "z", 1, -1, e, t, n, i, r, 4),
                                p("x", "y", "z", -1, -1, e, t, -n, i, r, 5),
                                this.setIndex(o),
                                this.setAttribute("position", new Ji(l,3)),
                                this.setAttribute("normal", new Ji(c,3)),
                                this.setAttribute("uv", new Ji(h,2))
                        }
                        copy(e) {
                            return super.copy(e),
                                this.parameters = Object.assign({}, e.parameters),
                                this
                        }
                        static fromJSON(e) {
                            return new yr(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)
                        }
                    }
                    function br(e) {
                        const t = {};
                        for (const n in e) {
                            t[n] = {};
                            for (const i in e[n]) {
                                const r = e[n][i];
                                r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),
                                    t[n][i] = null) : t[n][i] = r.clone() : Array.isArray(r) ? t[n][i] = r.slice() : t[n][i] = r
                            }
                        }
                        return t
                    }
                    function xr(e) {
                        const t = {};
                        for (let n = 0; n < e.length; n++) {
                            const i = br(e[n]);
                            for (const e in i)
                                t[e] = i[e]
                        }
                        return t
                    }
                    function kr(e) {
                        const t = e.getRenderTarget();
                        return null === t ? e.outputColorSpace : !0 === t.isXRRenderTarget ? t.texture.colorSpace : nn.workingColorSpace
                    }
                    const Er = {
                        clone: br,
                        merge: xr
                    };
                    class Sr extends Gi {
                        constructor(e) {
                            super(),
                                this.isShaderMaterial = !0,
                                this.type = "ShaderMaterial",
                                this.defines = {},
                                this.uniforms = {},
                                this.uniformsGroups = [],
                                this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
                                this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",
                                this.linewidth = 1,
                                this.wireframe = !1,
                                this.wireframeLinewidth = 1,
                                this.fog = !1,
                                this.lights = !1,
                                this.clipping = !1,
                                this.forceSinglePass = !0,
                                this.extensions = {
                                    clipCullDistance: !1,
                                    multiDraw: !1
                                },
                                this.defaultAttributeValues = {
                                    color: [1, 1, 1],
                                    uv: [0, 0],
                                    uv1: [0, 0]
                                },
                                this.index0AttributeName = void 0,
                                this.uniformsNeedUpdate = !1,
                                this.glslVersion = null,
                            void 0 !== e && this.setValues(e)
                        }
                        copy(e) {
                            return super.copy(e),
                                this.fragmentShader = e.fragmentShader,
                                this.vertexShader = e.vertexShader,
                                this.uniforms = br(e.uniforms),
                                this.uniformsGroups = function(e) {
                                    const t = [];
                                    for (let n = 0; n < e.length; n++)
                                        t.push(e[n].clone());
                                    return t
                                }(e.uniformsGroups),
                                this.defines = Object.assign({}, e.defines),
                                this.wireframe = e.wireframe,
                                this.wireframeLinewidth = e.wireframeLinewidth,
                                this.fog = e.fog,
                                this.lights = e.lights,
                                this.clipping = e.clipping,
                                this.extensions = Object.assign({}, e.extensions),
                                this.glslVersion = e.glslVersion,
                                this
                        }
                        toJSON(e) {
                            const t = super.toJSON(e);
                            t.glslVersion = this.glslVersion,
                                t.uniforms = {};
                            for (const n in this.uniforms) {
                                const i = this.uniforms[n].value;
                                i && i.isTexture ? t.uniforms[n] = {
                                    type: "t",
                                    value: i.toJSON(e).uuid
                                } : i && i.isColor ? t.uniforms[n] = {
                                    type: "c",
                                    value: i.getHex()
                                } : i && i.isVector2 ? t.uniforms[n] = {
                                    type: "v2",
                                    value: i.toArray()
                                } : i && i.isVector3 ? t.uniforms[n] = {
                                    type: "v3",
                                    value: i.toArray()
                                } : i && i.isVector4 ? t.uniforms[n] = {
                                    type: "v4",
                                    value: i.toArray()
                                } : i && i.isMatrix3 ? t.uniforms[n] = {
                                    type: "m3",
                                    value: i.toArray()
                                } : i && i.isMatrix4 ? t.uniforms[n] = {
                                    type: "m4",
                                    value: i.toArray()
                                } : t.uniforms[n] = {
                                    value: i
                                }
                            }
                            Object.keys(this.defines).length > 0 && (t.defines = this.defines),
                                t.vertexShader = this.vertexShader,
                                t.fragmentShader = this.fragmentShader,
                                t.lights = this.lights,
                                t.clipping = this.clipping;
                            const n = {};
                            for (const e in this.extensions)
                                !0 === this.extensions[e] && (n[e] = !0);
                            return Object.keys(n).length > 0 && (t.extensions = n),
                                t
                        }
                    }
                    class Mr extends xi {
                        constructor() {
                            super(),
                                this.isCamera = !0,
                                this.type = "Camera",
                                this.matrixWorldInverse = new Kn,
                                this.projectionMatrix = new Kn,
                                this.projectionMatrixInverse = new Kn,
                                this.coordinateSystem = Pt
                        }
                        copy(e, t) {
                            return super.copy(e, t),
                                this.matrixWorldInverse.copy(e.matrixWorldInverse),
                                this.projectionMatrix.copy(e.projectionMatrix),
                                this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
                                this.coordinateSystem = e.coordinateSystem,
                                this
                        }
                        getWorldDirection(e) {
                            return super.getWorldDirection(e).negate()
                        }
                        updateMatrixWorld(e) {
                            super.updateMatrixWorld(e),
                                this.matrixWorldInverse.copy(this.matrixWorld).invert()
                        }
                        updateWorldMatrix(e, t) {
                            super.updateWorldMatrix(e, t),
                                this.matrixWorldInverse.copy(this.matrixWorld).invert()
                        }
                        clone() {
                            return (new this.constructor).copy(this)
                        }
                    }
                    const Tr = new An
                        , Cr = new jt
                        , _r = new jt;
                    class Ir extends Mr {
                        constructor(e=50, t=1, n=.1, i=2e3) {
                            super(),
                                this.isPerspectiveCamera = !0,
                                this.type = "PerspectiveCamera",
                                this.fov = e,
                                this.zoom = 1,
                                this.near = n,
                                this.far = i,
                                this.focus = 10,
                                this.aspect = t,
                                this.view = null,
                                this.filmGauge = 35,
                                this.filmOffset = 0,
                                this.updateProjectionMatrix()
                        }
                        copy(e, t) {
                            return super.copy(e, t),
                                this.fov = e.fov,
                                this.zoom = e.zoom,
                                this.near = e.near,
                                this.far = e.far,
                                this.focus = e.focus,
                                this.aspect = e.aspect,
                                this.view = null === e.view ? null : Object.assign({}, e.view),
                                this.filmGauge = e.filmGauge,
                                this.filmOffset = e.filmOffset,
                                this
                        }
                        setFocalLength(e) {
                            const t = .5 * this.getFilmHeight() / e;
                            this.fov = 2 * Ut * Math.atan(t),
                                this.updateProjectionMatrix()
                        }
                        getFocalLength() {
                            const e = Math.tan(.5 * Bt * this.fov);
                            return .5 * this.getFilmHeight() / e
                        }
                        getEffectiveFOV() {
                            return 2 * Ut * Math.atan(Math.tan(.5 * Bt * this.fov) / this.zoom)
                        }
                        getFilmWidth() {
                            return this.filmGauge * Math.min(this.aspect, 1)
                        }
                        getFilmHeight() {
                            return this.filmGauge / Math.max(this.aspect, 1)
                        }
                        getViewBounds(e, t, n) {
                            Tr.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse),
                                t.set(Tr.x, Tr.y).multiplyScalar(-e / Tr.z),
                                Tr.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse),
                                n.set(Tr.x, Tr.y).multiplyScalar(-e / Tr.z)
                        }
                        getViewSize(e, t) {
                            return this.getViewBounds(e, Cr, _r),
                                t.subVectors(_r, Cr)
                        }
                        setViewOffset(e, t, n, i, r, a) {
                            this.aspect = e / t,
                            null === this.view && (this.view = {
                                enabled: !0,
                                fullWidth: 1,
                                fullHeight: 1,
                                offsetX: 0,
                                offsetY: 0,
                                width: 1,
                                height: 1
                            }),
                                this.view.enabled = !0,
                                this.view.fullWidth = e,
                                this.view.fullHeight = t,
                                this.view.offsetX = n,
                                this.view.offsetY = i,
                                this.view.width = r,
                                this.view.height = a,
                                this.updateProjectionMatrix()
                        }
                        clearViewOffset() {
                            null !== this.view && (this.view.enabled = !1),
                                this.updateProjectionMatrix()
                        }
                        updateProjectionMatrix() {
                            const e = this.near;
                            let t = e * Math.tan(.5 * Bt * this.fov) / this.zoom
                                , n = 2 * t
                                , i = this.aspect * n
                                , r = -.5 * i;
                            const a = this.view;
                            if (null !== this.view && this.view.enabled) {
                                const e = a.fullWidth
                                    , s = a.fullHeight;
                                r += a.offsetX * i / e,
                                    t -= a.offsetY * n / s,
                                    i *= a.width / e,
                                    n *= a.height / s
                            }
                            const s = this.filmOffset;
                            0 !== s && (r += e * s / this.getFilmWidth()),
                                this.projectionMatrix.makePerspective(r, r + i, t, t - n, e, this.far, this.coordinateSystem),
                                this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                        }
                        toJSON(e) {
                            const t = super.toJSON(e);
                            return t.object.fov = this.fov,
                                t.object.zoom = this.zoom,
                                t.object.near = this.near,
                                t.object.far = this.far,
                                t.object.focus = this.focus,
                                t.object.aspect = this.aspect,
                            null !== this.view && (t.object.view = Object.assign({}, this.view)),
                                t.object.filmGauge = this.filmGauge,
                                t.object.filmOffset = this.filmOffset,
                                t
                        }
                    }
                    const Pr = -90;
                    class Rr extends xi {
                        constructor(e, t, n) {
                            super(),
                                this.type = "CubeCamera",
                                this.renderTarget = n,
                                this.coordinateSystem = null,
                                this.activeMipmapLevel = 0;
                            const i = new Ir(Pr,1,e,t);
                            i.layers = this.layers,
                                this.add(i);
                            const r = new Ir(Pr,1,e,t);
                            r.layers = this.layers,
                                this.add(r);
                            const a = new Ir(Pr,1,e,t);
                            a.layers = this.layers,
                                this.add(a);
                            const s = new Ir(Pr,1,e,t);
                            s.layers = this.layers,
                                this.add(s);
                            const o = new Ir(Pr,1,e,t);
                            o.layers = this.layers,
                                this.add(o);
                            const l = new Ir(Pr,1,e,t);
                            l.layers = this.layers,
                                this.add(l)
                        }
                        updateCoordinateSystem() {
                            const e = this.coordinateSystem
                                , t = this.children.concat()
                                , [n,i,r,a,s,o] = t;
                            for (const e of t)
                                this.remove(e);
                            if (e === Pt)
                                n.up.set(0, 1, 0),
                                    n.lookAt(1, 0, 0),
                                    i.up.set(0, 1, 0),
                                    i.lookAt(-1, 0, 0),
                                    r.up.set(0, 0, -1),
                                    r.lookAt(0, 1, 0),
                                    a.up.set(0, 0, 1),
                                    a.lookAt(0, -1, 0),
                                    s.up.set(0, 1, 0),
                                    s.lookAt(0, 0, 1),
                                    o.up.set(0, 1, 0),
                                    o.lookAt(0, 0, -1);
                            else {
                                if (e !== Rt)
                                    throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
                                n.up.set(0, -1, 0),
                                    n.lookAt(-1, 0, 0),
                                    i.up.set(0, -1, 0),
                                    i.lookAt(1, 0, 0),
                                    r.up.set(0, 0, 1),
                                    r.lookAt(0, 1, 0),
                                    a.up.set(0, 0, -1),
                                    a.lookAt(0, -1, 0),
                                    s.up.set(0, -1, 0),
                                    s.lookAt(0, 0, 1),
                                    o.up.set(0, -1, 0),
                                    o.lookAt(0, 0, -1)
                            }
                            for (const e of t)
                                this.add(e),
                                    e.updateMatrixWorld()
                        }
                        update(e, t) {
                            null === this.parent && this.updateMatrixWorld();
                            const {renderTarget: n, activeMipmapLevel: i} = this;
                            this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem,
                                this.updateCoordinateSystem());
                            const [r,a,s,o,l,c] = this.children
                                , h = e.getRenderTarget()
                                , d = e.getActiveCubeFace()
                                , u = e.getActiveMipmapLevel()
                                , p = e.xr.enabled;
                            e.xr.enabled = !1;
                            const f = n.texture.generateMipmaps;
                            n.texture.generateMipmaps = !1,
                                e.setRenderTarget(n, 0, i),
                                e.render(t, r),
                                e.setRenderTarget(n, 1, i),
                                e.render(t, a),
                                e.setRenderTarget(n, 2, i),
                                e.render(t, s),
                                e.setRenderTarget(n, 3, i),
                                e.render(t, o),
                                e.setRenderTarget(n, 4, i),
                                e.render(t, l),
                                n.texture.generateMipmaps = f,
                                e.setRenderTarget(n, 5, i),
                                e.render(t, c),
                                e.setRenderTarget(h, d, u),
                                e.xr.enabled = p,
                                n.texture.needsPMREMUpdate = !0
                        }
                    }
                    class Lr extends un {
                        constructor(e, t, n, i, r, a, s, o, l, c) {
                            super(e = void 0 !== e ? e : [], t = void 0 !== t ? t : $, n, i, r, a, s, o, l, c),
                                this.isCubeTexture = !0,
                                this.flipY = !1
                        }
                        get images() {
                            return this.image
                        }
                        set images(e) {
                            this.image = e
                        }
                    }
                    class Nr extends mn {
                        constructor(e=1, t={}) {
                            super(e, e, t),
                                this.isWebGLCubeRenderTarget = !0;
                            const n = {
                                width: e,
                                height: e,
                                depth: 1
                            }
                                , i = [n, n, n, n, n, n];
                            this.texture = new Lr(i,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.colorSpace),
                                this.texture.isRenderTargetTexture = !0,
                                this.texture.generateMipmaps = void 0 !== t.generateMipmaps && t.generateMipmaps,
                                this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : he
                        }
                        fromEquirectangularTexture(e, t) {
                            this.texture.type = t.type,
                                this.texture.colorSpace = t.colorSpace,
                                this.texture.generateMipmaps = t.generateMipmaps,
                                this.texture.minFilter = t.minFilter,
                                this.texture.magFilter = t.magFilter;
                            const n = {
                                uniforms: {
                                    tEquirect: {
                                        value: null
                                    }
                                },
                                vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                                fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
                            }
                                , i = new yr(5,5,5)
                                , r = new Sr({
                                name: "CubemapFromEquirect",
                                uniforms: br(n.uniforms),
                                vertexShader: n.vertexShader,
                                fragmentShader: n.fragmentShader,
                                side: 1,
                                blending: 0
                            });
                            r.uniforms.tEquirect.value = t;
                            const a = new wr(i,r)
                                , s = t.minFilter;
                            t.minFilter === ue && (t.minFilter = he);
                            return new Rr(1,10,this).update(e, a),
                                t.minFilter = s,
                                a.geometry.dispose(),
                                a.material.dispose(),
                                this
                        }
                        clear(e, t, n, i) {
                            const r = e.getRenderTarget();
                            for (let r = 0; r < 6; r++)
                                e.setRenderTarget(this, r),
                                    e.clear(t, n, i);
                            e.setRenderTarget(r)
                        }
                    }
                    class Dr extends xi {
                        constructor() {
                            super(),
                                this.isGroup = !0,
                                this.type = "Group"
                        }
                    }
                    const Br = {
                        type: "move"
                    };
                    class Ur {
                        constructor() {
                            this._targetRay = null,
                                this._grip = null,
                                this._hand = null
                        }
                        getHandSpace() {
                            return null === this._hand && (this._hand = new Dr,
                                this._hand.matrixAutoUpdate = !1,
                                this._hand.visible = !1,
                                this._hand.joints = {},
                                this._hand.inputState = {
                                    pinching: !1
                                }),
                                this._hand
                        }
                        getTargetRaySpace() {
                            return null === this._targetRay && (this._targetRay = new Dr,
                                this._targetRay.matrixAutoUpdate = !1,
                                this._targetRay.visible = !1,
                                this._targetRay.hasLinearVelocity = !1,
                                this._targetRay.linearVelocity = new An,
                                this._targetRay.hasAngularVelocity = !1,
                                this._targetRay.angularVelocity = new An),
                                this._targetRay
                        }
                        getGripSpace() {
                            return null === this._grip && (this._grip = new Dr,
                                this._grip.matrixAutoUpdate = !1,
                                this._grip.visible = !1,
                                this._grip.hasLinearVelocity = !1,
                                this._grip.linearVelocity = new An,
                                this._grip.hasAngularVelocity = !1,
                                this._grip.angularVelocity = new An),
                                this._grip
                        }
                        dispatchEvent(e) {
                            return null !== this._targetRay && this._targetRay.dispatchEvent(e),
                            null !== this._grip && this._grip.dispatchEvent(e),
                            null !== this._hand && this._hand.dispatchEvent(e),
                                this
                        }
                        connect(e) {
                            if (e && e.hand) {
                                const t = this._hand;
                                if (t)
                                    for (const n of e.hand.values())
                                        this._getHandJoint(t, n)
                            }
                            return this.dispatchEvent({
                                type: "connected",
                                data: e
                            }),
                                this
                        }
                        disconnect(e) {
                            return this.dispatchEvent({
                                type: "disconnected",
                                data: e
                            }),
                            null !== this._targetRay && (this._targetRay.visible = !1),
                            null !== this._grip && (this._grip.visible = !1),
                            null !== this._hand && (this._hand.visible = !1),
                                this
                        }
                        update(e, t, n) {
                            let i = null
                                , r = null
                                , a = null;
                            const s = this._targetRay
                                , o = this._grip
                                , l = this._hand;
                            if (e && "visible-blurred" !== t.session.visibilityState) {
                                if (l && e.hand) {
                                    a = !0;
                                    for (const i of e.hand.values()) {
                                        const e = t.getJointPose(i, n)
                                            , r = this._getHandJoint(l, i);
                                        null !== e && (r.matrix.fromArray(e.transform.matrix),
                                            r.matrix.decompose(r.position, r.rotation, r.scale),
                                            r.matrixWorldNeedsUpdate = !0,
                                            r.jointRadius = e.radius),
                                            r.visible = null !== e
                                    }
                                    const i = l.joints["index-finger-tip"]
                                        , r = l.joints["thumb-tip"]
                                        , s = i.position.distanceTo(r.position)
                                        , o = .02
                                        , c = .005;
                                    l.inputState.pinching && s > o + c ? (l.inputState.pinching = !1,
                                        this.dispatchEvent({
                                            type: "pinchend",
                                            handedness: e.handedness,
                                            target: this
                                        })) : !l.inputState.pinching && s <= o - c && (l.inputState.pinching = !0,
                                        this.dispatchEvent({
                                            type: "pinchstart",
                                            handedness: e.handedness,
                                            target: this
                                        }))
                                } else
                                    null !== o && e.gripSpace && (r = t.getPose(e.gripSpace, n),
                                    null !== r && (o.matrix.fromArray(r.transform.matrix),
                                        o.matrix.decompose(o.position, o.rotation, o.scale),
                                        o.matrixWorldNeedsUpdate = !0,
                                        r.linearVelocity ? (o.hasLinearVelocity = !0,
                                            o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1,
                                        r.angularVelocity ? (o.hasAngularVelocity = !0,
                                            o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1));
                                null !== s && (i = t.getPose(e.targetRaySpace, n),
                                null === i && null !== r && (i = r),
                                null !== i && (s.matrix.fromArray(i.transform.matrix),
                                    s.matrix.decompose(s.position, s.rotation, s.scale),
                                    s.matrixWorldNeedsUpdate = !0,
                                    i.linearVelocity ? (s.hasLinearVelocity = !0,
                                        s.linearVelocity.copy(i.linearVelocity)) : s.hasLinearVelocity = !1,
                                    i.angularVelocity ? (s.hasAngularVelocity = !0,
                                        s.angularVelocity.copy(i.angularVelocity)) : s.hasAngularVelocity = !1,
                                    this.dispatchEvent(Br)))
                            }
                            return null !== s && (s.visible = null !== i),
                            null !== o && (o.visible = null !== r),
                            null !== l && (l.visible = null !== a),
                                this
                        }
                        _getHandJoint(e, t) {
                            if (void 0 === e.joints[t.jointName]) {
                                const n = new Dr;
                                n.matrixAutoUpdate = !1,
                                    n.visible = !1,
                                    e.joints[t.jointName] = n,
                                    e.add(n)
                            }
                            return e.joints[t.jointName]
                        }
                    }
                    class zr {
                        constructor(e, t=1, n=1e3) {
                            this.isFog = !0,
                                this.name = "",
                                this.color = new Wi(e),
                                this.near = t,
                                this.far = n
                        }
                        clone() {
                            return new zr(this.color,this.near,this.far)
                        }
                        toJSON() {
                            return {
                                type: "Fog",
                                name: this.name,
                                color: this.color.getHex(),
                                near: this.near,
                                far: this.far
                            }
                        }
                    }
                    class Or extends xi {
                        constructor() {
                            super(),
                                this.isScene = !0,
                                this.type = "Scene",
                                this.background = null,
                                this.environment = null,
                                this.fog = null,
                                this.backgroundBlurriness = 0,
                                this.backgroundIntensity = 1,
                                this.backgroundRotation = new ai,
                                this.environmentIntensity = 1,
                                this.environmentRotation = new ai,
                                this.overrideMaterial = null,
                            "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                                detail: this
                            }))
                        }
                        copy(e, t) {
                            return super.copy(e, t),
                            null !== e.background && (this.background = e.background.clone()),
                            null !== e.environment && (this.environment = e.environment.clone()),
                            null !== e.fog && (this.fog = e.fog.clone()),
                                this.backgroundBlurriness = e.backgroundBlurriness,
                                this.backgroundIntensity = e.backgroundIntensity,
                                this.backgroundRotation.copy(e.backgroundRotation),
                                this.environmentIntensity = e.environmentIntensity,
                                this.environmentRotation.copy(e.environmentRotation),
                            null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()),
                                this.matrixAutoUpdate = e.matrixAutoUpdate,
                                this
                        }
                        toJSON(e) {
                            const t = super.toJSON(e);
                            return null !== this.fog && (t.object.fog = this.fog.toJSON()),
                            this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness),
                            1 !== this.backgroundIntensity && (t.object.backgroundIntensity = this.backgroundIntensity),
                                t.object.backgroundRotation = this.backgroundRotation.toArray(),
                            1 !== this.environmentIntensity && (t.object.environmentIntensity = this.environmentIntensity),
                                t.object.environmentRotation = this.environmentRotation.toArray(),
                                t
                        }
                    }
                    class Fr {
                        constructor(e, t) {
                            this.isInterleavedBuffer = !0,
                                this.array = e,
                                this.stride = t,
                                this.count = void 0 !== e ? e.length / t : 0,
                                this.usage = _t,
                                this.updateRanges = [],
                                this.version = 0,
                                this.uuid = zt()
                        }
                        onUploadCallback() {}
                        set needsUpdate(e) {
                            !0 === e && this.version++
                        }
                        setUsage(e) {
                            return this.usage = e,
                                this
                        }
                        addUpdateRange(e, t) {
                            this.updateRanges.push({
                                start: e,
                                count: t
                            })
                        }
                        clearUpdateRanges() {
                            this.updateRanges.length = 0
                        }
                        copy(e) {
                            return this.array = new e.array.constructor(e.array),
                                this.count = e.count,
                                this.stride = e.stride,
                                this.usage = e.usage,
                                this
                        }
                        copyAt(e, t, n) {
                            e *= this.stride,
                                n *= t.stride;
                            for (let i = 0, r = this.stride; i < r; i++)
                                this.array[e + i] = t.array[n + i];
                            return this
                        }
                        set(e, t=0) {
                            return this.array.set(e, t),
                                this
                        }
                        clone(e) {
                            void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
                            void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = zt()),
                            void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                            const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid])
                                , n = new this.constructor(t,this.stride);
                            return n.setUsage(this.usage),
                                n
                        }
                        onUpload(e) {
                            return this.onUploadCallback = e,
                                this
                        }
                        toJSON(e) {
                            return void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
                            void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = zt()),
                            void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))),
                                {
                                    uuid: this.uuid,
                                    buffer: this.array.buffer._uuid,
                                    type: this.array.constructor.name,
                                    stride: this.stride
                                }
                        }
                    }
                    const Wr = new An;
                    class Hr {
                        constructor(e, t, n, i=!1) {
                            this.isInterleavedBufferAttribute = !0,
                                this.name = "",
                                this.data = e,
                                this.itemSize = t,
                                this.offset = n,
                                this.normalized = i
                        }
                        get count() {
                            return this.data.count
                        }
                        get array() {
                            return this.data.array
                        }
                        set needsUpdate(e) {
                            this.data.needsUpdate = e
                        }
                        applyMatrix4(e) {
                            for (let t = 0, n = this.data.count; t < n; t++)
                                Wr.fromBufferAttribute(this, t),
                                    Wr.applyMatrix4(e),
                                    this.setXYZ(t, Wr.x, Wr.y, Wr.z);
                            return this
                        }
                        applyNormalMatrix(e) {
                            for (let t = 0, n = this.count; t < n; t++)
                                Wr.fromBufferAttribute(this, t),
                                    Wr.applyNormalMatrix(e),
                                    this.setXYZ(t, Wr.x, Wr.y, Wr.z);
                            return this
                        }
                        transformDirection(e) {
                            for (let t = 0, n = this.count; t < n; t++)
                                Wr.fromBufferAttribute(this, t),
                                    Wr.transformDirection(e),
                                    this.setXYZ(t, Wr.x, Wr.y, Wr.z);
                            return this
                        }
                        getComponent(e, t) {
                            let n = this.array[e * this.data.stride + this.offset + t];
                            return this.normalized && (n = Ht(n, this.array)),
                                n
                        }
                        setComponent(e, t, n) {
                            return this.normalized && (n = Vt(n, this.array)),
                                this.data.array[e * this.data.stride + this.offset + t] = n,
                                this
                        }
                        setX(e, t) {
                            return this.normalized && (t = Vt(t, this.array)),
                                this.data.array[e * this.data.stride + this.offset] = t,
                                this
                        }
                        setY(e, t) {
                            return this.normalized && (t = Vt(t, this.array)),
                                this.data.array[e * this.data.stride + this.offset + 1] = t,
                                this
                        }
                        setZ(e, t) {
                            return this.normalized && (t = Vt(t, this.array)),
                                this.data.array[e * this.data.stride + this.offset + 2] = t,
                                this
                        }
                        setW(e, t) {
                            return this.normalized && (t = Vt(t, this.array)),
                                this.data.array[e * this.data.stride + this.offset + 3] = t,
                                this
                        }
                        getX(e) {
                            let t = this.data.array[e * this.data.stride + this.offset];
                            return this.normalized && (t = Ht(t, this.array)),
                                t
                        }
                        getY(e) {
                            let t = this.data.array[e * this.data.stride + this.offset + 1];
                            return this.normalized && (t = Ht(t, this.array)),
                                t
                        }
                        getZ(e) {
                            let t = this.data.array[e * this.data.stride + this.offset + 2];
                            return this.normalized && (t = Ht(t, this.array)),
                                t
                        }
                        getW(e) {
                            let t = this.data.array[e * this.data.stride + this.offset + 3];
                            return this.normalized && (t = Ht(t, this.array)),
                                t
                        }
                        setXY(e, t, n) {
                            return e = e * this.data.stride + this.offset,
                            this.normalized && (t = Vt(t, this.array),
                                n = Vt(n, this.array)),
                                this.data.array[e + 0] = t,
                                this.data.array[e + 1] = n,
                                this
                        }
                        setXYZ(e, t, n, i) {
                            return e = e * this.data.stride + this.offset,
                            this.normalized && (t = Vt(t, this.array),
                                n = Vt(n, this.array),
                                i = Vt(i, this.array)),
                                this.data.array[e + 0] = t,
                                this.data.array[e + 1] = n,
                                this.data.array[e + 2] = i,
                                this
                        }
                        setXYZW(e, t, n, i, r) {
                            return e = e * this.data.stride + this.offset,
                            this.normalized && (t = Vt(t, this.array),
                                n = Vt(n, this.array),
                                i = Vt(i, this.array),
                                r = Vt(r, this.array)),
                                this.data.array[e + 0] = t,
                                this.data.array[e + 1] = n,
                                this.data.array[e + 2] = i,
                                this.data.array[e + 3] = r,
                                this
                        }
                        clone(e) {
                            if (void 0 === e) {
                                console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
                                const e = [];
                                for (let t = 0; t < this.count; t++) {
                                    const n = t * this.data.stride + this.offset;
                                    for (let t = 0; t < this.itemSize; t++)
                                        e.push(this.data.array[n + t])
                                }
                                return new Ki(new this.array.constructor(e),this.itemSize,this.normalized)
                            }
                            return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
                            void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
                                new Hr(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
                        }
                        toJSON(e) {
                            if (void 0 === e) {
                                console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
                                const e = [];
                                for (let t = 0; t < this.count; t++) {
                                    const n = t * this.data.stride + this.offset;
                                    for (let t = 0; t < this.itemSize; t++)
                                        e.push(this.data.array[n + t])
                                }
                                return {
                                    itemSize: this.itemSize,
                                    type: this.array.constructor.name,
                                    array: e,
                                    normalized: this.normalized
                                }
                            }
                            return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
                            void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
                                {
                                    isInterleavedBufferAttribute: !0,
                                    itemSize: this.itemSize,
                                    data: this.data.uuid,
                                    offset: this.offset,
                                    normalized: this.normalized
                                }
                        }
                    }
                    const Vr = new An
                        , Gr = new pn
                        , jr = new pn
                        , Qr = new An
                        , Yr = new Kn
                        , qr = new An
                        , Kr = new Fn
                        , Xr = new Kn
                        , Zr = new qn;
                    class Jr extends wr {
                        constructor(e, t) {
                            super(e, t),
                                this.isSkinnedMesh = !0,
                                this.type = "SkinnedMesh",
                                this.bindMode = J,
                                this.bindMatrix = new Kn,
                                this.bindMatrixInverse = new Kn,
                                this.boundingBox = null,
                                this.boundingSphere = null
                        }
                        computeBoundingBox() {
                            const e = this.geometry;
                            null === this.boundingBox && (this.boundingBox = new xn),
                                this.boundingBox.makeEmpty();
                            const t = e.getAttribute("position");
                            for (let e = 0; e < t.count; e++)
                                this.getVertexPosition(e, qr),
                                    this.boundingBox.expandByPoint(qr)
                        }
                        computeBoundingSphere() {
                            const e = this.geometry;
                            null === this.boundingSphere && (this.boundingSphere = new Fn),
                                this.boundingSphere.makeEmpty();
                            const t = e.getAttribute("position");
                            for (let e = 0; e < t.count; e++)
                                this.getVertexPosition(e, qr),
                                    this.boundingSphere.expandByPoint(qr)
                        }
                        copy(e, t) {
                            return super.copy(e, t),
                                this.bindMode = e.bindMode,
                                this.bindMatrix.copy(e.bindMatrix),
                                this.bindMatrixInverse.copy(e.bindMatrixInverse),
                                this.skeleton = e.skeleton,
                            null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()),
                            null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()),
                                this
                        }
                        raycast(e, t) {
                            const n = this.material
                                , i = this.matrixWorld;
                            void 0 !== n && (null === this.boundingSphere && this.computeBoundingSphere(),
                                Kr.copy(this.boundingSphere),
                                Kr.applyMatrix4(i),
                            !1 !== e.ray.intersectsSphere(Kr) && (Xr.copy(i).invert(),
                                Zr.copy(e.ray).applyMatrix4(Xr),
                            null !== this.boundingBox && !1 === Zr.intersectsBox(this.boundingBox) || this._computeIntersections(e, t, Zr)))
                        }
                        getVertexPosition(e, t) {
                            return super.getVertexPosition(e, t),
                                this.applyBoneTransform(e, t),
                                t
                        }
                        bind(e, t) {
                            this.skeleton = e,
                            void 0 === t && (this.updateMatrixWorld(!0),
                                this.skeleton.calculateInverses(),
                                t = this.matrixWorld),
                                this.bindMatrix.copy(t),
                                this.bindMatrixInverse.copy(t).invert()
                        }
                        pose() {
                            this.skeleton.pose()
                        }
                        normalizeSkinWeights() {
                            const e = new pn
                                , t = this.geometry.attributes.skinWeight;
                            for (let n = 0, i = t.count; n < i; n++) {
                                e.fromBufferAttribute(t, n);
                                const i = 1 / e.manhattanLength();
                                i !== 1 / 0 ? e.multiplyScalar(i) : e.set(1, 0, 0, 0),
                                    t.setXYZW(n, e.x, e.y, e.z, e.w)
                            }
                        }
                        updateMatrixWorld(e) {
                            super.updateMatrixWorld(e),
                                this.bindMode === J ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                        }
                        applyBoneTransform(e, t) {
                            const n = this.skeleton
                                , i = this.geometry;
                            Gr.fromBufferAttribute(i.attributes.skinIndex, e),
                                jr.fromBufferAttribute(i.attributes.skinWeight, e),
                                Vr.copy(t).applyMatrix4(this.bindMatrix),
                                t.set(0, 0, 0);
                            for (let e = 0; e < 4; e++) {
                                const i = jr.getComponent(e);
                                if (0 !== i) {
                                    const r = Gr.getComponent(e);
                                    Yr.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]),
                                        t.addScaledVector(Qr.copy(Vr).applyMatrix4(Yr), i)
                                }
                            }
                            return t.applyMatrix4(this.bindMatrixInverse)
                        }
                    }
                    class $r extends xi {
                        constructor() {
                            super(),
                                this.isBone = !0,
                                this.type = "Bone"
                        }
                    }
                    class ea extends un {
                        constructor(e=null, t=1, n=1, i, r, a, s, o, l=1003, c=1003, h, d) {
                            super(null, a, s, o, l, c, i, r, h, d),
                                this.isDataTexture = !0,
                                this.image = {
                                    data: e,
                                    width: t,
                                    height: n
                                },
                                this.generateMipmaps = !1,
                                this.flipY = !1,
                                this.unpackAlignment = 1
                        }
                    }
                    const ta = new Kn
                        , na = new Kn;
                    class ia {
                        constructor(e=[], t=[]) {
                            this.uuid = zt(),
                                this.bones = e.slice(0),
                                this.boneInverses = t,
                                this.boneMatrices = null,
                                this.boneTexture = null,
                                this.init()
                        }
                        init() {
                            const e = this.bones
                                , t = this.boneInverses;
                            if (this.boneMatrices = new Float32Array(16 * e.length),
                            0 === t.length)
                                this.calculateInverses();
                            else if (e.length !== t.length) {
                                console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),
                                    this.boneInverses = [];
                                for (let e = 0, t = this.bones.length; e < t; e++)
                                    this.boneInverses.push(new Kn)
                            }
                        }
                        calculateInverses() {
                            this.boneInverses.length = 0;
                            for (let e = 0, t = this.bones.length; e < t; e++) {
                                const t = new Kn;
                                this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(),
                                    this.boneInverses.push(t)
                            }
                        }
                        pose() {
                            for (let e = 0, t = this.bones.length; e < t; e++) {
                                const t = this.bones[e];
                                t && t.matrixWorld.copy(this.boneInverses[e]).invert()
                            }
                            for (let e = 0, t = this.bones.length; e < t; e++) {
                                const t = this.bones[e];
                                t && (t.parent && t.parent.isBone ? (t.matrix.copy(t.parent.matrixWorld).invert(),
                                    t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld),
                                    t.matrix.decompose(t.position, t.quaternion, t.scale))
                            }
                        }
                        update() {
                            const e = this.bones
                                , t = this.boneInverses
                                , n = this.boneMatrices
                                , i = this.boneTexture;
                            for (let i = 0, r = e.length; i < r; i++) {
                                const r = e[i] ? e[i].matrixWorld : na;
                                ta.multiplyMatrices(r, t[i]),
                                    ta.toArray(n, 16 * i)
                            }
                            null !== i && (i.needsUpdate = !0)
                        }
                        clone() {
                            return new ia(this.bones,this.boneInverses)
                        }
                        computeBoneTexture() {
                            let e = Math.sqrt(4 * this.bones.length);
                            e = 4 * Math.ceil(e / 4),
                                e = Math.max(e, 4);
                            const t = new Float32Array(e * e * 4);
                            t.set(this.boneMatrices);
                            const n = new ea(t,e,e,Se,Ae);
                            return n.needsUpdate = !0,
                                this.boneMatrices = t,
                                this.boneTexture = n,
                                this
                        }
                        getBoneByName(e) {
                            for (let t = 0, n = this.bones.length; t < n; t++) {
                                const n = this.bones[t];
                                if (n.name === e)
                                    return n
                            }
                        }
                        dispose() {
                            null !== this.boneTexture && (this.boneTexture.dispose(),
                                this.boneTexture = null)
                        }
                        fromJSON(e, t) {
                            this.uuid = e.uuid;
                            for (let n = 0, i = e.bones.length; n < i; n++) {
                                const i = e.bones[n];
                                let r = t[i];
                                void 0 === r && (console.warn("THREE.Skeleton: No bone found with UUID:", i),
                                    r = new $r),
                                    this.bones.push(r),
                                    this.boneInverses.push((new Kn).fromArray(e.boneInverses[n]))
                            }
                            return this.init(),
                                this
                        }
                        toJSON() {
                            const e = {
                                metadata: {
                                    version: 4.6,
                                    type: "Skeleton",
                                    generator: "Skeleton.toJSON"
                                },
                                bones: [],
                                boneInverses: []
                            };
                            e.uuid = this.uuid;
                            const t = this.bones
                                , n = this.boneInverses;
                            for (let i = 0, r = t.length; i < r; i++) {
                                const r = t[i];
                                e.bones.push(r.uuid);
                                const a = n[i];
                                e.boneInverses.push(a.toArray())
                            }
                            return e
                        }
                    }
                    class ra extends Ki {
                        constructor(e, t, n, i=1) {
                            super(e, t, n),
                                this.isInstancedBufferAttribute = !0,
                                this.meshPerAttribute = i
                        }
                        copy(e) {
                            return super.copy(e),
                                this.meshPerAttribute = e.meshPerAttribute,
                                this
                        }
                        toJSON() {
                            const e = super.toJSON();
                            return e.meshPerAttribute = this.meshPerAttribute,
                                e.isInstancedBufferAttribute = !0,
                                e
                        }
                    }
                    const aa = new Kn
                        , sa = new Kn
                        , oa = []
                        , la = new xn
                        , ca = new Kn
                        , ha = new wr
                        , da = new Fn;
                    class ua extends wr {
                        constructor(e, t, n) {
                            super(e, t),
                                this.isInstancedMesh = !0,
                                this.instanceMatrix = new ra(new Float32Array(16 * n),16),
                                this.instanceColor = null,
                                this.morphTexture = null,
                                this.count = n,
                                this.boundingBox = null,
                                this.boundingSphere = null;
                            for (let e = 0; e < n; e++)
                                this.setMatrixAt(e, ca)
                        }
                        computeBoundingBox() {
                            const e = this.geometry
                                , t = this.count;
                            null === this.boundingBox && (this.boundingBox = new xn),
                            null === e.boundingBox && e.computeBoundingBox(),
                                this.boundingBox.makeEmpty();
                            for (let n = 0; n < t; n++)
                                this.getMatrixAt(n, aa),
                                    la.copy(e.boundingBox).applyMatrix4(aa),
                                    this.boundingBox.union(la)
                        }
                        computeBoundingSphere() {
                            const e = this.geometry
                                , t = this.count;
                            null === this.boundingSphere && (this.boundingSphere = new Fn),
                            null === e.boundingSphere && e.computeBoundingSphere(),
                                this.boundingSphere.makeEmpty();
                            for (let n = 0; n < t; n++)
                                this.getMatrixAt(n, aa),
                                    da.copy(e.boundingSphere).applyMatrix4(aa),
                                    this.boundingSphere.union(da)
                        }
                        copy(e, t) {
                            return super.copy(e, t),
                                this.instanceMatrix.copy(e.instanceMatrix),
                            null !== e.morphTexture && (this.morphTexture = e.morphTexture.clone()),
                            null !== e.instanceColor && (this.instanceColor = e.instanceColor.clone()),
                                this.count = e.count,
                            null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()),
                            null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()),
                                this
                        }
                        getColorAt(e, t) {
                            t.fromArray(this.instanceColor.array, 3 * e)
                        }
                        getMatrixAt(e, t) {
                            t.fromArray(this.instanceMatrix.array, 16 * e)
                        }
                        getMorphAt(e, t) {
                            const n = t.morphTargetInfluences
                                , i = this.morphTexture.source.data.data
                                , r = e * (n.length + 1) + 1;
                            for (let e = 0; e < n.length; e++)
                                n[e] = i[r + e]
                        }
                        raycast(e, t) {
                            const n = this.matrixWorld
                                , i = this.count;
                            if (ha.geometry = this.geometry,
                                ha.material = this.material,
                            void 0 !== ha.material && (null === this.boundingSphere && this.computeBoundingSphere(),
                                da.copy(this.boundingSphere),
                                da.applyMatrix4(n),
                            !1 !== e.ray.intersectsSphere(da)))
                                for (let r = 0; r < i; r++) {
                                    this.getMatrixAt(r, aa),
                                        sa.multiplyMatrices(n, aa),
                                        ha.matrixWorld = sa,
                                        ha.raycast(e, oa);
                                    for (let e = 0, n = oa.length; e < n; e++) {
                                        const n = oa[e];
                                        n.instanceId = r,
                                            n.object = this,
                                            t.push(n)
                                    }
                                    oa.length = 0
                                }
                        }
                        setColorAt(e, t) {
                            null === this.instanceColor && (this.instanceColor = new ra(new Float32Array(3 * this.instanceMatrix.count).fill(1),3)),
                                t.toArray(this.instanceColor.array, 3 * e)
                        }
                        setMatrixAt(e, t) {
                            t.toArray(this.instanceMatrix.array, 16 * e)
                        }
                        setMorphAt(e, t) {
                            const n = t.morphTargetInfluences
                                , i = n.length + 1;
                            null === this.morphTexture && (this.morphTexture = new ea(new Float32Array(i * this.count),i,this.count,Ce,Ae));
                            const r = this.morphTexture.source.data.data;
                            let a = 0;
                            for (let e = 0; e < n.length; e++)
                                a += n[e];
                            const s = this.geometry.morphTargetsRelative ? 1 : 1 - a
                                , o = i * e;
                            r[o] = s,
                                r.set(n, o + 1)
                        }
                        updateMorphTargets() {}
                        dispose() {
                            this.dispatchEvent({
                                type: "dispose"
                            }),
                            null !== this.morphTexture && (this.morphTexture.dispose(),
                                this.morphTexture = null)
                        }
                    }
                    const pa = new An
                        , fa = new An
                        , ma = new Qt;
                    class ga {
                        constructor(e=new An(1,0,0), t=0) {
                            this.isPlane = !0,
                                this.normal = e,
                                this.constant = t
                        }
                        set(e, t) {
                            return this.normal.copy(e),
                                this.constant = t,
                                this
                        }
                        setComponents(e, t, n, i) {
                            return this.normal.set(e, t, n),
                                this.constant = i,
                                this
                        }
                        setFromNormalAndCoplanarPoint(e, t) {
                            return this.normal.copy(e),
                                this.constant = -t.dot(this.normal),
                                this
                        }
                        setFromCoplanarPoints(e, t, n) {
                            const i = pa.subVectors(n, t).cross(fa.subVectors(e, t)).normalize();
                            return this.setFromNormalAndCoplanarPoint(i, e),
                                this
                        }
                        copy(e) {
                            return this.normal.copy(e.normal),
                                this.constant = e.constant,
                                this
                        }
                        normalize() {
                            const e = 1 / this.normal.length();
                            return this.normal.multiplyScalar(e),
                                this.constant *= e,
                                this
                        }
                        negate() {
                            return this.constant *= -1,
                                this.normal.negate(),
                                this
                        }
                        distanceToPoint(e) {
                            return this.normal.dot(e) + this.constant
                        }
                        distanceToSphere(e) {
                            return this.distanceToPoint(e.center) - e.radius
                        }
                        projectPoint(e, t) {
                            return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
                        }
                        intersectLine(e, t) {
                            const n = e.delta(pa)
                                , i = this.normal.dot(n);
                            if (0 === i)
                                return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
                            const r = -(e.start.dot(this.normal) + this.constant) / i;
                            return r < 0 || r > 1 ? null : t.copy(e.start).addScaledVector(n, r)
                        }
                        intersectsLine(e) {
                            const t = this.distanceToPoint(e.start)
                                , n = this.distanceToPoint(e.end);
                            return t < 0 && n > 0 || n < 0 && t > 0
                        }
                        intersectsBox(e) {
                            return e.intersectsPlane(this)
                        }
                        intersectsSphere(e) {
                            return e.intersectsPlane(this)
                        }
                        coplanarPoint(e) {
                            return e.copy(this.normal).multiplyScalar(-this.constant)
                        }
                        applyMatrix4(e, t) {
                            const n = t || ma.getNormalMatrix(e)
                                , i = this.coplanarPoint(pa).applyMatrix4(e)
                                , r = this.normal.applyMatrix3(n).normalize();
                            return this.constant = -i.dot(r),
                                this
                        }
                        translate(e) {
                            return this.constant -= e.dot(this.normal),
                                this
                        }
                        equals(e) {
                            return e.normal.equals(this.normal) && e.constant === this.constant
                        }
                        clone() {
                            return (new this.constructor).copy(this)
                        }
                    }
                    const va = new Fn
                        , wa = new An;
                    class Aa {
                        constructor(e=new ga, t=new ga, n=new ga, i=new ga, r=new ga, a=new ga) {
                            this.planes = [e, t, n, i, r, a]
                        }
                        set(e, t, n, i, r, a) {
                            const s = this.planes;
                            return s[0].copy(e),
                                s[1].copy(t),
                                s[2].copy(n),
                                s[3].copy(i),
                                s[4].copy(r),
                                s[5].copy(a),
                                this
                        }
                        copy(e) {
                            const t = this.planes;
                            for (let n = 0; n < 6; n++)
                                t[n].copy(e.planes[n]);
                            return this
                        }
                        setFromProjectionMatrix(e, t=2e3) {
                            const n = this.planes
                                , i = e.elements
                                , r = i[0]
                                , a = i[1]
                                , s = i[2]
                                , o = i[3]
                                , l = i[4]
                                , c = i[5]
                                , h = i[6]
                                , d = i[7]
                                , u = i[8]
                                , p = i[9]
                                , f = i[10]
                                , m = i[11]
                                , g = i[12]
                                , v = i[13]
                                , w = i[14]
                                , A = i[15];
                            if (n[0].setComponents(o - r, d - l, m - u, A - g).normalize(),
                                n[1].setComponents(o + r, d + l, m + u, A + g).normalize(),
                                n[2].setComponents(o + a, d + c, m + p, A + v).normalize(),
                                n[3].setComponents(o - a, d - c, m - p, A - v).normalize(),
                                n[4].setComponents(o - s, d - h, m - f, A - w).normalize(),
                            t === Pt)
                                n[5].setComponents(o + s, d + h, m + f, A + w).normalize();
                            else {
                                if (t !== Rt)
                                    throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
                                n[5].setComponents(s, h, f, w).normalize()
                            }
                            return this
                        }
                        intersectsObject(e) {
                            if (void 0 !== e.boundingSphere)
                                null === e.boundingSphere && e.computeBoundingSphere(),
                                    va.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
                            else {
                                const t = e.geometry;
                                null === t.boundingSphere && t.computeBoundingSphere(),
                                    va.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
                            }
                            return this.intersectsSphere(va)
                        }
                        intersectsSprite(e) {
                            return va.center.set(0, 0, 0),
                                va.radius = .7071067811865476,
                                va.applyMatrix4(e.matrixWorld),
                                this.intersectsSphere(va)
                        }
                        intersectsSphere(e) {
                            const t = this.planes
                                , n = e.center
                                , i = -e.radius;
                            for (let e = 0; e < 6; e++) {
                                if (t[e].distanceToPoint(n) < i)
                                    return !1
                            }
                            return !0
                        }
                        intersectsBox(e) {
                            const t = this.planes;
                            for (let n = 0; n < 6; n++) {
                                const i = t[n];
                                if (wa.x = i.normal.x > 0 ? e.max.x : e.min.x,
                                    wa.y = i.normal.y > 0 ? e.max.y : e.min.y,
                                    wa.z = i.normal.z > 0 ? e.max.z : e.min.z,
                                i.distanceToPoint(wa) < 0)
                                    return !1
                            }
                            return !0
                        }
                        containsPoint(e) {
                            const t = this.planes;
                            for (let n = 0; n < 6; n++)
                                if (t[n].distanceToPoint(e) < 0)
                                    return !1;
                            return !0
                        }
                        clone() {
                            return (new this.constructor).copy(this)
                        }
                    }
                    class ya extends Gi {
                        constructor(e) {
                            super(),
                                this.isLineBasicMaterial = !0,
                                this.type = "LineBasicMaterial",
                                this.color = new Wi(16777215),
                                this.map = null,
                                this.linewidth = 1,
                                this.linecap = "round",
                                this.linejoin = "round",
                                this.fog = !0,
                                this.setValues(e)
                        }
                        copy(e) {
                            return super.copy(e),
                                this.color.copy(e.color),
                                this.map = e.map,
                                this.linewidth = e.linewidth,
                                this.linecap = e.linecap,
                                this.linejoin = e.linejoin,
                                this.fog = e.fog,
                                this
                        }
                    }
                    const ba = new An
                        , xa = new An
                        , ka = new Kn
                        , Ea = new qn
                        , Sa = new Fn
                        , Ma = new An
                        , Ta = new An;
                    class Ca extends xi {
                        constructor(e=new sr, t=new ya) {
                            super(),
                                this.isLine = !0,
                                this.type = "Line",
                                this.geometry = e,
                                this.material = t,
                                this.morphTargetDictionary = void 0,
                                this.morphTargetInfluences = void 0,
                                this.updateMorphTargets()
                        }
                        copy(e, t) {
                            return super.copy(e, t),
                                this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
                                this.geometry = e.geometry,
                                this
                        }
                        computeLineDistances() {
                            const e = this.geometry;
                            if (null === e.index) {
                                const t = e.attributes.position
                                    , n = [0];
                                for (let e = 1, i = t.count; e < i; e++)
                                    ba.fromBufferAttribute(t, e - 1),
                                        xa.fromBufferAttribute(t, e),
                                        n[e] = n[e - 1],
                                        n[e] += ba.distanceTo(xa);
                                e.setAttribute("lineDistance", new Ji(n,1))
                            } else
                                console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                            return this
                        }
                        raycast(e, t) {
                            const n = this.geometry
                                , i = this.matrixWorld
                                , r = e.params.Line.threshold
                                , a = n.drawRange;
                            if (null === n.boundingSphere && n.computeBoundingSphere(),
                                Sa.copy(n.boundingSphere),
                                Sa.applyMatrix4(i),
                                Sa.radius += r,
                            !1 === e.ray.intersectsSphere(Sa))
                                return;
                            ka.copy(i).invert(),
                                Ea.copy(e.ray).applyMatrix4(ka);
                            const s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                                , o = s * s
                                , l = this.isLineSegments ? 2 : 1
                                , c = n.index
                                , h = n.attributes.position;
                            if (null !== c) {
                                const n = Math.max(0, a.start)
                                    , i = Math.min(c.count, a.start + a.count);
                                for (let r = n, a = i - 1; r < a; r += l) {
                                    const n = c.getX(r)
                                        , i = c.getX(r + 1)
                                        , a = _a(this, e, Ea, o, n, i, r);
                                    a && t.push(a)
                                }
                                if (this.isLineLoop) {
                                    const r = c.getX(i - 1)
                                        , a = c.getX(n)
                                        , s = _a(this, e, Ea, o, r, a, i - 1);
                                    s && t.push(s)
                                }
                            } else {
                                const n = Math.max(0, a.start)
                                    , i = Math.min(h.count, a.start + a.count);
                                for (let r = n, a = i - 1; r < a; r += l) {
                                    const n = _a(this, e, Ea, o, r, r + 1, r);
                                    n && t.push(n)
                                }
                                if (this.isLineLoop) {
                                    const r = _a(this, e, Ea, o, i - 1, n, i - 1);
                                    r && t.push(r)
                                }
                            }
                        }
                        updateMorphTargets() {
                            const e = this.geometry.morphAttributes
                                , t = Object.keys(e);
                            if (t.length > 0) {
                                const n = e[t[0]];
                                if (void 0 !== n) {
                                    this.morphTargetInfluences = [],
                                        this.morphTargetDictionary = {};
                                    for (let e = 0, t = n.length; e < t; e++) {
                                        const t = n[e].name || String(e);
                                        this.morphTargetInfluences.push(0),
                                            this.morphTargetDictionary[t] = e
                                    }
                                }
                            }
                        }
                    }
                    function _a(e, t, n, i, r, a, s) {
                        const o = e.geometry.attributes.position;
                        ba.fromBufferAttribute(o, r),
                            xa.fromBufferAttribute(o, a);
                        if (n.distanceSqToSegment(ba, xa, Ma, Ta) > i)
                            return;
                        Ma.applyMatrix4(e.matrixWorld);
                        const l = t.ray.origin.distanceTo(Ma);
                        return l < t.near || l > t.far ? void 0 : {
                            distance: l,
                            point: Ta.clone().applyMatrix4(e.matrixWorld),
                            index: s,
                            face: null,
                            faceIndex: null,
                            barycoord: null,
                            object: e
                        }
                    }
                    const Ia = new An
                        , Pa = new An;
                    class Ra extends Ca {
                        constructor(e, t) {
                            super(e, t),
                                this.isLineSegments = !0,
                                this.type = "LineSegments"
                        }
                        computeLineDistances() {
                            const e = this.geometry;
                            if (null === e.index) {
                                const t = e.attributes.position
                                    , n = [];
                                for (let e = 0, i = t.count; e < i; e += 2)
                                    Ia.fromBufferAttribute(t, e),
                                        Pa.fromBufferAttribute(t, e + 1),
                                        n[e] = 0 === e ? 0 : n[e - 1],
                                        n[e + 1] = n[e] + Ia.distanceTo(Pa);
                                e.setAttribute("lineDistance", new Ji(n,1))
                            } else
                                console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                            return this
                        }
                    }
                    class La extends Ca {
                        constructor(e, t) {
                            super(e, t),
                                this.isLineLoop = !0,
                                this.type = "LineLoop"
                        }
                    }
                    class Na extends Gi {
                        constructor(e) {
                            super(),
                                this.isPointsMaterial = !0,
                                this.type = "PointsMaterial",
                                this.color = new Wi(16777215),
                                this.map = null,
                                this.alphaMap = null,
                                this.size = 1,
                                this.sizeAttenuation = !0,
                                this.fog = !0,
                                this.setValues(e)
                        }
                        copy(e) {
                            return super.copy(e),
                                this.color.copy(e.color),
                                this.map = e.map,
                                this.alphaMap = e.alphaMap,
                                this.size = e.size,
                                this.sizeAttenuation = e.sizeAttenuation,
                                this.fog = e.fog,
                                this
                        }
                    }
                    const Da = new Kn
                        , Ba = new qn
                        , Ua = new Fn
                        , za = new An;
                    class Oa extends xi {
                        constructor(e=new sr, t=new Na) {
                            super(),
                                this.isPoints = !0,
                                this.type = "Points",
                                this.geometry = e,
                                this.material = t,
                                this.morphTargetDictionary = void 0,
                                this.morphTargetInfluences = void 0,
                                this.updateMorphTargets()
                        }
                        copy(e, t) {
                            return super.copy(e, t),
                                this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
                                this.geometry = e.geometry,
                                this
                        }
                        raycast(e, t) {
                            const n = this.geometry
                                , i = this.matrixWorld
                                , r = e.params.Points.threshold
                                , a = n.drawRange;
                            if (null === n.boundingSphere && n.computeBoundingSphere(),
                                Ua.copy(n.boundingSphere),
                                Ua.applyMatrix4(i),
                                Ua.radius += r,
                            !1 === e.ray.intersectsSphere(Ua))
                                return;
                            Da.copy(i).invert(),
                                Ba.copy(e.ray).applyMatrix4(Da);
                            const s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                                , o = s * s
                                , l = n.index
                                , c = n.attributes.position;
                            if (null !== l) {
                                for (let n = Math.max(0, a.start), r = Math.min(l.count, a.start + a.count); n < r; n++) {
                                    const r = l.getX(n);
                                    za.fromBufferAttribute(c, r),
                                        Fa(za, r, o, i, e, t, this)
                                }
                            } else {
                                for (let n = Math.max(0, a.start), r = Math.min(c.count, a.start + a.count); n < r; n++)
                                    za.fromBufferAttribute(c, n),
                                        Fa(za, n, o, i, e, t, this)
                            }
                        }
                        updateMorphTargets() {
                            const e = this.geometry.morphAttributes
                                , t = Object.keys(e);
                            if (t.length > 0) {
                                const n = e[t[0]];
                                if (void 0 !== n) {
                                    this.morphTargetInfluences = [],
                                        this.morphTargetDictionary = {};
                                    for (let e = 0, t = n.length; e < t; e++) {
                                        const t = n[e].name || String(e);
                                        this.morphTargetInfluences.push(0),
                                            this.morphTargetDictionary[t] = e
                                    }
                                }
                            }
                        }
                    }
                    function Fa(e, t, n, i, r, a, s) {
                        const o = Ba.distanceSqToPoint(e);
                        if (o < n) {
                            const n = new An;
                            Ba.closestPointToPoint(e, n),
                                n.applyMatrix4(i);
                            const l = r.ray.origin.distanceTo(n);
                            if (l < r.near || l > r.far)
                                return;
                            a.push({
                                distance: l,
                                distanceToRay: Math.sqrt(o),
                                point: n,
                                index: t,
                                face: null,
                                faceIndex: null,
                                barycoord: null,
                                object: s
                            })
                        }
                    }
                    class Wa extends un {
                        constructor(e, t, n, i, r, a, s, o, l, c=1026) {
                            if (c !== Me && c !== Te)
                                throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                            void 0 === n && c === Me && (n = we),
                            void 0 === n && c === Te && (n = ke),
                                super(null, i, r, a, s, o, c, n, l),
                                this.isDepthTexture = !0,
                                this.image = {
                                    width: e,
                                    height: t
                                },
                                this.magFilter = void 0 !== s ? s : oe,
                                this.minFilter = void 0 !== o ? o : oe,
                                this.flipY = !1,
                                this.generateMipmaps = !1,
                                this.compareFunction = null
                        }
                        copy(e) {
                            return super.copy(e),
                                this.source = new cn(Object.assign({}, e.image)),
                                this.compareFunction = e.compareFunction,
                                this
                        }
                        toJSON(e) {
                            const t = super.toJSON(e);
                            return null !== this.compareFunction && (t.compareFunction = this.compareFunction),
                                t
                        }
                    }
                    class Ha {
                        constructor() {
                            this.type = "Curve",
                                this.arcLengthDivisions = 200,
                                this.needsUpdate = !1,
                                this.cacheArcLengths = null
                        }
                        getPoint() {
                            console.warn("THREE.Curve: .getPoint() not implemented.")
                        }
                        getPointAt(e, t) {
                            const n = this.getUtoTmapping(e);
                            return this.getPoint(n, t)
                        }
                        getPoints(e=5) {
                            const t = [];
                            for (let n = 0; n <= e; n++)
                                t.push(this.getPoint(n / e));
                            return t
                        }
                        getSpacedPoints(e=5) {
                            const t = [];
                            for (let n = 0; n <= e; n++)
                                t.push(this.getPointAt(n / e));
                            return t
                        }
                        getLength() {
                            const e = this.getLengths();
                            return e[e.length - 1]
                        }
                        getLengths(e=this.arcLengthDivisions) {
                            if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
                                return this.cacheArcLengths;
                            this.needsUpdate = !1;
                            const t = [];
                            let n, i = this.getPoint(0), r = 0;
                            t.push(0);
                            for (let a = 1; a <= e; a++)
                                n = this.getPoint(a / e),
                                    r += n.distanceTo(i),
                                    t.push(r),
                                    i = n;
                            return this.cacheArcLengths = t,
                                t
                        }
                        updateArcLengths() {
                            this.needsUpdate = !0,
                                this.getLengths()
                        }
                        getUtoTmapping(e, t=null) {
                            const n = this.getLengths();
                            let i = 0;
                            const r = n.length;
                            let a;
                            a = t || e * n[r - 1];
                            let s, o = 0, l = r - 1;
                            for (; o <= l; )
                                if (i = Math.floor(o + (l - o) / 2),
                                    s = n[i] - a,
                                s < 0)
                                    o = i + 1;
                                else {
                                    if (!(s > 0)) {
                                        l = i;
                                        break
                                    }
                                    l = i - 1
                                }
                            if (i = l,
                            n[i] === a)
                                return i / (r - 1);
                            const c = n[i];
                            return (i + (a - c) / (n[i + 1] - c)) / (r - 1)
                        }
                        getTangent(e, t) {
                            const n = 1e-4;
                            let i = e - n
                                , r = e + n;
                            i < 0 && (i = 0),
                            r > 1 && (r = 1);
                            const a = this.getPoint(i)
                                , s = this.getPoint(r)
                                , o = t || (a.isVector2 ? new jt : new An);
                            return o.copy(s).sub(a).normalize(),
                                o
                        }
                        getTangentAt(e, t) {
                            const n = this.getUtoTmapping(e);
                            return this.getTangent(n, t)
                        }
                        computeFrenetFrames(e, t=!1) {
                            const n = new An
                                , i = []
                                , r = []
                                , a = []
                                , s = new An
                                , o = new Kn;
                            for (let t = 0; t <= e; t++) {
                                const n = t / e;
                                i[t] = this.getTangentAt(n, new An)
                            }
                            r[0] = new An,
                                a[0] = new An;
                            let l = Number.MAX_VALUE;
                            const c = Math.abs(i[0].x)
                                , h = Math.abs(i[0].y)
                                , d = Math.abs(i[0].z);
                            c <= l && (l = c,
                                n.set(1, 0, 0)),
                            h <= l && (l = h,
                                n.set(0, 1, 0)),
                            d <= l && n.set(0, 0, 1),
                                s.crossVectors(i[0], n).normalize(),
                                r[0].crossVectors(i[0], s),
                                a[0].crossVectors(i[0], r[0]);
                            for (let t = 1; t <= e; t++) {
                                if (r[t] = r[t - 1].clone(),
                                    a[t] = a[t - 1].clone(),
                                    s.crossVectors(i[t - 1], i[t]),
                                s.length() > Number.EPSILON) {
                                    s.normalize();
                                    const e = Math.acos(Ot(i[t - 1].dot(i[t]), -1, 1));
                                    r[t].applyMatrix4(o.makeRotationAxis(s, e))
                                }
                                a[t].crossVectors(i[t], r[t])
                            }
                            if (!0 === t) {
                                let t = Math.acos(Ot(r[0].dot(r[e]), -1, 1));
                                t /= e,
                                i[0].dot(s.crossVectors(r[0], r[e])) > 0 && (t = -t);
                                for (let n = 1; n <= e; n++)
                                    r[n].applyMatrix4(o.makeRotationAxis(i[n], t * n)),
                                        a[n].crossVectors(i[n], r[n])
                            }
                            return {
                                tangents: i,
                                normals: r,
                                binormals: a
                            }
                        }
                        clone() {
                            return (new this.constructor).copy(this)
                        }
                        copy(e) {
                            return this.arcLengthDivisions = e.arcLengthDivisions,
                                this
                        }
                        toJSON() {
                            const e = {
                                metadata: {
                                    version: 4.6,
                                    type: "Curve",
                                    generator: "Curve.toJSON"
                                }
                            };
                            return e.arcLengthDivisions = this.arcLengthDivisions,
                                e.type = this.type,
                                e
                        }
                        fromJSON(e) {
                            return this.arcLengthDivisions = e.arcLengthDivisions,
                                this
                        }
                    }
                    class Va extends Ha {
                        constructor(e=0, t=0, n=1, i=1, r=0, a=2 * Math.PI, s=!1, o=0) {
                            super(),
                                this.isEllipseCurve = !0,
                                this.type = "EllipseCurve",
                                this.aX = e,
                                this.aY = t,
                                this.xRadius = n,
                                this.yRadius = i,
                                this.aStartAngle = r,
                                this.aEndAngle = a,
                                this.aClockwise = s,
                                this.aRotation = o
                        }
                        getPoint(e, t=new jt) {
                            const n = t
                                , i = 2 * Math.PI;
                            let r = this.aEndAngle - this.aStartAngle;
                            const a = Math.abs(r) < Number.EPSILON;
                            for (; r < 0; )
                                r += i;
                            for (; r > i; )
                                r -= i;
                            r < Number.EPSILON && (r = a ? 0 : i),
                            !0 !== this.aClockwise || a || (r === i ? r = -i : r -= i);
                            const s = this.aStartAngle + e * r;
                            let o = this.aX + this.xRadius * Math.cos(s)
                                , l = this.aY + this.yRadius * Math.sin(s);
                            if (0 !== this.aRotation) {
                                const e = Math.cos(this.aRotation)
                                    , t = Math.sin(this.aRotation)
                                    , n = o - this.aX
                                    , i = l - this.aY;
                                o = n * e - i * t + this.aX,
                                    l = n * t + i * e + this.aY
                            }
                            return n.set(o, l)
                        }
                        copy(e) {
                            return super.copy(e),
                                this.aX = e.aX,
                                this.aY = e.aY,
                                this.xRadius = e.xRadius,
                                this.yRadius = e.yRadius,
                                this.aStartAngle = e.aStartAngle,
                                this.aEndAngle = e.aEndAngle,
                                this.aClockwise = e.aClockwise,
                                this.aRotation = e.aRotation,
                                this
                        }
                        toJSON() {
                            const e = super.toJSON();
                            return e.aX = this.aX,
                                e.aY = this.aY,
                                e.xRadius = this.xRadius,
                                e.yRadius = this.yRadius,
                                e.aStartAngle = this.aStartAngle,
                                e.aEndAngle = this.aEndAngle,
                                e.aClockwise = this.aClockwise,
                                e.aRotation = this.aRotation,
                                e
                        }
                        fromJSON(e) {
                            return super.fromJSON(e),
                                this.aX = e.aX,
                                this.aY = e.aY,
                                this.xRadius = e.xRadius,
                                this.yRadius = e.yRadius,
                                this.aStartAngle = e.aStartAngle,
                                this.aEndAngle = e.aEndAngle,
                                this.aClockwise = e.aClockwise,
                                this.aRotation = e.aRotation,
                                this
                        }
                    }
                    function Ga() {
                        let e = 0
                            , t = 0
                            , n = 0
                            , i = 0;
                        function r(r, a, s, o) {
                            e = r,
                                t = s,
                                n = -3 * r + 3 * a - 2 * s - o,
                                i = 2 * r - 2 * a + s + o
                        }
                        return {
                            initCatmullRom: function(e, t, n, i, a) {
                                r(t, n, a * (n - e), a * (i - t))
                            },
                            initNonuniformCatmullRom: function(e, t, n, i, a, s, o) {
                                let l = (t - e) / a - (n - e) / (a + s) + (n - t) / s
                                    , c = (n - t) / s - (i - t) / (s + o) + (i - n) / o;
                                l *= s,
                                    c *= s,
                                    r(t, n, l, c)
                            },
                            calc: function(r) {
                                const a = r * r;
                                return e + t * r + n * a + i * (a * r)
                            }
                        }
                    }
                    const ja = new An
                        , Qa = new Ga
                        , Ya = new Ga
                        , qa = new Ga;
                    function Ka(e, t, n, i, r) {
                        const a = .5 * (i - t)
                            , s = .5 * (r - n)
                            , o = e * e;
                        return (2 * n - 2 * i + a + s) * (e * o) + (-3 * n + 3 * i - 2 * a - s) * o + a * e + n
                    }
                    function Xa(e, t, n, i) {
                        return function(e, t) {
                            const n = 1 - e;
                            return n * n * t
                        }(e, t) + function(e, t) {
                            return 2 * (1 - e) * e * t
                        }(e, n) + function(e, t) {
                            return e * e * t
                        }(e, i)
                    }
                    function Za(e, t, n, i, r) {
                        return function(e, t) {
                            const n = 1 - e;
                            return n * n * n * t
                        }(e, t) + function(e, t) {
                            const n = 1 - e;
                            return 3 * n * n * e * t
                        }(e, n) + function(e, t) {
                            return 3 * (1 - e) * e * e * t
                        }(e, i) + function(e, t) {
                            return e * e * e * t
                        }(e, r)
                    }
                    class Ja extends Ha {
                        constructor(e=new jt, t=new jt, n=new jt, i=new jt) {
                            super(),
                                this.isCubicBezierCurve = !0,
                                this.type = "CubicBezierCurve",
                                this.v0 = e,
                                this.v1 = t,
                                this.v2 = n,
                                this.v3 = i
                        }
                        getPoint(e, t=new jt) {
                            const n = t
                                , i = this.v0
                                , r = this.v1
                                , a = this.v2
                                , s = this.v3;
                            return n.set(Za(e, i.x, r.x, a.x, s.x), Za(e, i.y, r.y, a.y, s.y)),
                                n
                        }
                        copy(e) {
                            return super.copy(e),
                                this.v0.copy(e.v0),
                                this.v1.copy(e.v1),
                                this.v2.copy(e.v2),
                                this.v3.copy(e.v3),
                                this
                        }
                        toJSON() {
                            const e = super.toJSON();
                            return e.v0 = this.v0.toArray(),
                                e.v1 = this.v1.toArray(),
                                e.v2 = this.v2.toArray(),
                                e.v3 = this.v3.toArray(),
                                e
                        }
                        fromJSON(e) {
                            return super.fromJSON(e),
                                this.v0.fromArray(e.v0),
                                this.v1.fromArray(e.v1),
                                this.v2.fromArray(e.v2),
                                this.v3.fromArray(e.v3),
                                this
                        }
                    }
                    class $a extends Ha {
                        constructor(e=new jt, t=new jt) {
                            super(),
                                this.isLineCurve = !0,
                                this.type = "LineCurve",
                                this.v1 = e,
                                this.v2 = t
                        }
                        getPoint(e, t=new jt) {
                            const n = t;
                            return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
                                n.multiplyScalar(e).add(this.v1)),
                                n
                        }
                        getPointAt(e, t) {
                            return this.getPoint(e, t)
                        }
                        getTangent(e, t=new jt) {
                            return t.subVectors(this.v2, this.v1).normalize()
                        }
                        getTangentAt(e, t) {
                            return this.getTangent(e, t)
                        }
                        copy(e) {
                            return super.copy(e),
                                this.v1.copy(e.v1),
                                this.v2.copy(e.v2),
                                this
                        }
                        toJSON() {
                            const e = super.toJSON();
                            return e.v1 = this.v1.toArray(),
                                e.v2 = this.v2.toArray(),
                                e
                        }
                        fromJSON(e) {
                            return super.fromJSON(e),
                                this.v1.fromArray(e.v1),
                                this.v2.fromArray(e.v2),
                                this
                        }
                    }
                    class es extends Ha {
                        constructor(e=new jt, t=new jt, n=new jt) {
                            super(),
                                this.isQuadraticBezierCurve = !0,
                                this.type = "QuadraticBezierCurve",
                                this.v0 = e,
                                this.v1 = t,
                                this.v2 = n
                        }
                        getPoint(e, t=new jt) {
                            const n = t
                                , i = this.v0
                                , r = this.v1
                                , a = this.v2;
                            return n.set(Xa(e, i.x, r.x, a.x), Xa(e, i.y, r.y, a.y)),
                                n
                        }
                        copy(e) {
                            return super.copy(e),
                                this.v0.copy(e.v0),
                                this.v1.copy(e.v1),
                                this.v2.copy(e.v2),
                                this
                        }
                        toJSON() {
                            const e = super.toJSON();
                            return e.v0 = this.v0.toArray(),
                                e.v1 = this.v1.toArray(),
                                e.v2 = this.v2.toArray(),
                                e
                        }
                        fromJSON(e) {
                            return super.fromJSON(e),
                                this.v0.fromArray(e.v0),
                                this.v1.fromArray(e.v1),
                                this.v2.fromArray(e.v2),
                                this
                        }
                    }
                    class ts extends Ha {
                        constructor(e=new An, t=new An, n=new An) {
                            super(),
                                this.isQuadraticBezierCurve3 = !0,
                                this.type = "QuadraticBezierCurve3",
                                this.v0 = e,
                                this.v1 = t,
                                this.v2 = n
                        }
                        getPoint(e, t=new An) {
                            const n = t
                                , i = this.v0
                                , r = this.v1
                                , a = this.v2;
                            return n.set(Xa(e, i.x, r.x, a.x), Xa(e, i.y, r.y, a.y), Xa(e, i.z, r.z, a.z)),
                                n
                        }
                        copy(e) {
                            return super.copy(e),
                                this.v0.copy(e.v0),
                                this.v1.copy(e.v1),
                                this.v2.copy(e.v2),
                                this
                        }
                        toJSON() {
                            const e = super.toJSON();
                            return e.v0 = this.v0.toArray(),
                                e.v1 = this.v1.toArray(),
                                e.v2 = this.v2.toArray(),
                                e
                        }
                        fromJSON(e) {
                            return super.fromJSON(e),
                                this.v0.fromArray(e.v0),
                                this.v1.fromArray(e.v1),
                                this.v2.fromArray(e.v2),
                                this
                        }
                    }
                    class ns extends Ha {
                        constructor(e=[]) {
                            super(),
                                this.isSplineCurve = !0,
                                this.type = "SplineCurve",
                                this.points = e
                        }
                        getPoint(e, t=new jt) {
                            const n = t
                                , i = this.points
                                , r = (i.length - 1) * e
                                , a = Math.floor(r)
                                , s = r - a
                                , o = i[0 === a ? a : a - 1]
                                , l = i[a]
                                , c = i[a > i.length - 2 ? i.length - 1 : a + 1]
                                , h = i[a > i.length - 3 ? i.length - 1 : a + 2];
                            return n.set(Ka(s, o.x, l.x, c.x, h.x), Ka(s, o.y, l.y, c.y, h.y)),
                                n
                        }
                        copy(e) {
                            super.copy(e),
                                this.points = [];
                            for (let t = 0, n = e.points.length; t < n; t++) {
                                const n = e.points[t];
                                this.points.push(n.clone())
                            }
                            return this
                        }
                        toJSON() {
                            const e = super.toJSON();
                            e.points = [];
                            for (let t = 0, n = this.points.length; t < n; t++) {
                                const n = this.points[t];
                                e.points.push(n.toArray())
                            }
                            return e
                        }
                        fromJSON(e) {
                            super.fromJSON(e),
                                this.points = [];
                            for (let t = 0, n = e.points.length; t < n; t++) {
                                const n = e.points[t];
                                this.points.push((new jt).fromArray(n))
                            }
                            return this
                        }
                    }
                    var is = Object.freeze({
                        __proto__: null,
                        ArcCurve: class extends Va {
                            constructor(e, t, n, i, r, a) {
                                super(e, t, n, n, i, r, a),
                                    this.isArcCurve = !0,
                                    this.type = "ArcCurve"
                            }
                        }
                        ,
                        CatmullRomCurve3: class extends Ha {
                            constructor(e=[], t=!1, n="centripetal", i=.5) {
                                super(),
                                    this.isCatmullRomCurve3 = !0,
                                    this.type = "CatmullRomCurve3",
                                    this.points = e,
                                    this.closed = t,
                                    this.curveType = n,
                                    this.tension = i
                            }
                            getPoint(e, t=new An) {
                                const n = t
                                    , i = this.points
                                    , r = i.length
                                    , a = (r - (this.closed ? 0 : 1)) * e;
                                let s, o, l = Math.floor(a), c = a - l;
                                this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r : 0 === c && l === r - 1 && (l = r - 2,
                                    c = 1),
                                    this.closed || l > 0 ? s = i[(l - 1) % r] : (ja.subVectors(i[0], i[1]).add(i[0]),
                                        s = ja);
                                const h = i[l % r]
                                    , d = i[(l + 1) % r];
                                if (this.closed || l + 2 < r ? o = i[(l + 2) % r] : (ja.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]),
                                    o = ja),
                                "centripetal" === this.curveType || "chordal" === this.curveType) {
                                    const e = "chordal" === this.curveType ? .5 : .25;
                                    let t = Math.pow(s.distanceToSquared(h), e)
                                        , n = Math.pow(h.distanceToSquared(d), e)
                                        , i = Math.pow(d.distanceToSquared(o), e);
                                    n < 1e-4 && (n = 1),
                                    t < 1e-4 && (t = n),
                                    i < 1e-4 && (i = n),
                                        Qa.initNonuniformCatmullRom(s.x, h.x, d.x, o.x, t, n, i),
                                        Ya.initNonuniformCatmullRom(s.y, h.y, d.y, o.y, t, n, i),
                                        qa.initNonuniformCatmullRom(s.z, h.z, d.z, o.z, t, n, i)
                                } else
                                    "catmullrom" === this.curveType && (Qa.initCatmullRom(s.x, h.x, d.x, o.x, this.tension),
                                        Ya.initCatmullRom(s.y, h.y, d.y, o.y, this.tension),
                                        qa.initCatmullRom(s.z, h.z, d.z, o.z, this.tension));
                                return n.set(Qa.calc(c), Ya.calc(c), qa.calc(c)),
                                    n
                            }
                            copy(e) {
                                super.copy(e),
                                    this.points = [];
                                for (let t = 0, n = e.points.length; t < n; t++) {
                                    const n = e.points[t];
                                    this.points.push(n.clone())
                                }
                                return this.closed = e.closed,
                                    this.curveType = e.curveType,
                                    this.tension = e.tension,
                                    this
                            }
                            toJSON() {
                                const e = super.toJSON();
                                e.points = [];
                                for (let t = 0, n = this.points.length; t < n; t++) {
                                    const n = this.points[t];
                                    e.points.push(n.toArray())
                                }
                                return e.closed = this.closed,
                                    e.curveType = this.curveType,
                                    e.tension = this.tension,
                                    e
                            }
                            fromJSON(e) {
                                super.fromJSON(e),
                                    this.points = [];
                                for (let t = 0, n = e.points.length; t < n; t++) {
                                    const n = e.points[t];
                                    this.points.push((new An).fromArray(n))
                                }
                                return this.closed = e.closed,
                                    this.curveType = e.curveType,
                                    this.tension = e.tension,
                                    this
                            }
                        }
                        ,
                        CubicBezierCurve: Ja,
                        CubicBezierCurve3: class extends Ha {
                            constructor(e=new An, t=new An, n=new An, i=new An) {
                                super(),
                                    this.isCubicBezierCurve3 = !0,
                                    this.type = "CubicBezierCurve3",
                                    this.v0 = e,
                                    this.v1 = t,
                                    this.v2 = n,
                                    this.v3 = i
                            }
                            getPoint(e, t=new An) {
                                const n = t
                                    , i = this.v0
                                    , r = this.v1
                                    , a = this.v2
                                    , s = this.v3;
                                return n.set(Za(e, i.x, r.x, a.x, s.x), Za(e, i.y, r.y, a.y, s.y), Za(e, i.z, r.z, a.z, s.z)),
                                    n
                            }
                            copy(e) {
                                return super.copy(e),
                                    this.v0.copy(e.v0),
                                    this.v1.copy(e.v1),
                                    this.v2.copy(e.v2),
                                    this.v3.copy(e.v3),
                                    this
                            }
                            toJSON() {
                                const e = super.toJSON();
                                return e.v0 = this.v0.toArray(),
                                    e.v1 = this.v1.toArray(),
                                    e.v2 = this.v2.toArray(),
                                    e.v3 = this.v3.toArray(),
                                    e
                            }
                            fromJSON(e) {
                                return super.fromJSON(e),
                                    this.v0.fromArray(e.v0),
                                    this.v1.fromArray(e.v1),
                                    this.v2.fromArray(e.v2),
                                    this.v3.fromArray(e.v3),
                                    this
                            }
                        }
                        ,
                        EllipseCurve: Va,
                        LineCurve: $a,
                        LineCurve3: class extends Ha {
                            constructor(e=new An, t=new An) {
                                super(),
                                    this.isLineCurve3 = !0,
                                    this.type = "LineCurve3",
                                    this.v1 = e,
                                    this.v2 = t
                            }
                            getPoint(e, t=new An) {
                                const n = t;
                                return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
                                    n.multiplyScalar(e).add(this.v1)),
                                    n
                            }
                            getPointAt(e, t) {
                                return this.getPoint(e, t)
                            }
                            getTangent(e, t=new An) {
                                return t.subVectors(this.v2, this.v1).normalize()
                            }
                            getTangentAt(e, t) {
                                return this.getTangent(e, t)
                            }
                            copy(e) {
                                return super.copy(e),
                                    this.v1.copy(e.v1),
                                    this.v2.copy(e.v2),
                                    this
                            }
                            toJSON() {
                                const e = super.toJSON();
                                return e.v1 = this.v1.toArray(),
                                    e.v2 = this.v2.toArray(),
                                    e
                            }
                            fromJSON(e) {
                                return super.fromJSON(e),
                                    this.v1.fromArray(e.v1),
                                    this.v2.fromArray(e.v2),
                                    this
                            }
                        }
                        ,
                        QuadraticBezierCurve: es,
                        QuadraticBezierCurve3: ts,
                        SplineCurve: ns
                    });
                    class rs extends Ha {
                        constructor() {
                            super(),
                                this.type = "CurvePath",
                                this.curves = [],
                                this.autoClose = !1
                        }
                        add(e) {
                            this.curves.push(e)
                        }
                        closePath() {
                            const e = this.curves[0].getPoint(0)
                                , t = this.curves[this.curves.length - 1].getPoint(1);
                            if (!e.equals(t)) {
                                const n = !0 === e.isVector2 ? "LineCurve" : "LineCurve3";
                                this.curves.push(new is[n](t,e))
                            }
                            return this
                        }
                        getPoint(e, t) {
                            const n = e * this.getLength()
                                , i = this.getCurveLengths();
                            let r = 0;
                            for (; r < i.length; ) {
                                if (i[r] >= n) {
                                    const e = i[r] - n
                                        , a = this.curves[r]
                                        , s = a.getLength()
                                        , o = 0 === s ? 0 : 1 - e / s;
                                    return a.getPointAt(o, t)
                                }
                                r++
                            }
                            return null
                        }
                        getLength() {
                            const e = this.getCurveLengths();
                            return e[e.length - 1]
                        }
                        updateArcLengths() {
                            this.needsUpdate = !0,
                                this.cacheLengths = null,
                                this.getCurveLengths()
                        }
                        getCurveLengths() {
                            if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
                                return this.cacheLengths;
                            const e = [];
                            let t = 0;
                            for (let n = 0, i = this.curves.length; n < i; n++)
                                t += this.curves[n].getLength(),
                                    e.push(t);
                            return this.cacheLengths = e,
                                e
                        }
                        getSpacedPoints(e=40) {
                            const t = [];
                            for (let n = 0; n <= e; n++)
                                t.push(this.getPoint(n / e));
                            return this.autoClose && t.push(t[0]),
                                t
                        }
                        getPoints(e=12) {
                            const t = [];
                            let n;
                            for (let i = 0, r = this.curves; i < r.length; i++) {
                                const a = r[i]
                                    , s = a.isEllipseCurve ? 2 * e : a.isLineCurve || a.isLineCurve3 ? 1 : a.isSplineCurve ? e * a.points.length : e
                                    , o = a.getPoints(s);
                                for (let e = 0; e < o.length; e++) {
                                    const i = o[e];
                                    n && n.equals(i) || (t.push(i),
                                        n = i)
                                }
                            }
                            return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]),
                                t
                        }
                        copy(e) {
                            super.copy(e),
                                this.curves = [];
                            for (let t = 0, n = e.curves.length; t < n; t++) {
                                const n = e.curves[t];
                                this.curves.push(n.clone())
                            }
                            return this.autoClose = e.autoClose,
                                this
                        }
                        toJSON() {
                            const e = super.toJSON();
                            e.autoClose = this.autoClose,
                                e.curves = [];
                            for (let t = 0, n = this.curves.length; t < n; t++) {
                                const n = this.curves[t];
                                e.curves.push(n.toJSON())
                            }
                            return e
                        }
                        fromJSON(e) {
                            super.fromJSON(e),
                                this.autoClose = e.autoClose,
                                this.curves = [];
                            for (let t = 0, n = e.curves.length; t < n; t++) {
                                const n = e.curves[t];
                                this.curves.push((new is[n.type]).fromJSON(n))
                            }
                            return this
                        }
                    }
                    class as extends rs {
                        constructor(e) {
                            super(),
                                this.type = "Path",
                                this.currentPoint = new jt,
                            e && this.setFromPoints(e)
                        }
                        setFromPoints(e) {
                            this.moveTo(e[0].x, e[0].y);
                            for (let t = 1, n = e.length; t < n; t++)
                                this.lineTo(e[t].x, e[t].y);
                            return this
                        }
                        moveTo(e, t) {
                            return this.currentPoint.set(e, t),
                                this
                        }
                        lineTo(e, t) {
                            const n = new $a(this.currentPoint.clone(),new jt(e,t));
                            return this.curves.push(n),
                                this.currentPoint.set(e, t),
                                this
                        }
                        quadraticCurveTo(e, t, n, i) {
                            const r = new es(this.currentPoint.clone(),new jt(e,t),new jt(n,i));
                            return this.curves.push(r),
                                this.currentPoint.set(n, i),
                                this
                        }
                        bezierCurveTo(e, t, n, i, r, a) {
                            const s = new Ja(this.currentPoint.clone(),new jt(e,t),new jt(n,i),new jt(r,a));
                            return this.curves.push(s),
                                this.currentPoint.set(r, a),
                                this
                        }
                        splineThru(e) {
                            const t = [this.currentPoint.clone()].concat(e)
                                , n = new ns(t);
                            return this.curves.push(n),
                                this.currentPoint.copy(e[e.length - 1]),
                                this
                        }
                        arc(e, t, n, i, r, a) {
                            const s = this.currentPoint.x
                                , o = this.currentPoint.y;
                            return this.absarc(e + s, t + o, n, i, r, a),
                                this
                        }
                        absarc(e, t, n, i, r, a) {
                            return this.absellipse(e, t, n, n, i, r, a),
                                this
                        }
                        ellipse(e, t, n, i, r, a, s, o) {
                            const l = this.currentPoint.x
                                , c = this.currentPoint.y;
                            return this.absellipse(e + l, t + c, n, i, r, a, s, o),
                                this
                        }
                        absellipse(e, t, n, i, r, a, s, o) {
                            const l = new Va(e,t,n,i,r,a,s,o);
                            if (this.curves.length > 0) {
                                const e = l.getPoint(0);
                                e.equals(this.currentPoint) || this.lineTo(e.x, e.y)
                            }
                            this.curves.push(l);
                            const c = l.getPoint(1);
                            return this.currentPoint.copy(c),
                                this
                        }
                        copy(e) {
                            return super.copy(e),
                                this.currentPoint.copy(e.currentPoint),
                                this
                        }
                        toJSON() {
                            const e = super.toJSON();
                            return e.currentPoint = this.currentPoint.toArray(),
                                e
                        }
                        fromJSON(e) {
                            return super.fromJSON(e),
                                this.currentPoint.fromArray(e.currentPoint),
                                this
                        }
                    }
                    class ss extends as {
                        constructor(e) {
                            super(e),
                                this.uuid = zt(),
                                this.type = "Shape",
                                this.holes = []
                        }
                        getPointsHoles(e) {
                            const t = [];
                            for (let n = 0, i = this.holes.length; n < i; n++)
                                t[n] = this.holes[n].getPoints(e);
                            return t
                        }
                        extractPoints(e) {
                            return {
                                shape: this.getPoints(e),
                                holes: this.getPointsHoles(e)
                            }
                        }
                        copy(e) {
                            super.copy(e),
                                this.holes = [];
                            for (let t = 0, n = e.holes.length; t < n; t++) {
                                const n = e.holes[t];
                                this.holes.push(n.clone())
                            }
                            return this
                        }
                        toJSON() {
                            const e = super.toJSON();
                            e.uuid = this.uuid,
                                e.holes = [];
                            for (let t = 0, n = this.holes.length; t < n; t++) {
                                const n = this.holes[t];
                                e.holes.push(n.toJSON())
                            }
                            return e
                        }
                        fromJSON(e) {
                            super.fromJSON(e),
                                this.uuid = e.uuid,
                                this.holes = [];
                            for (let t = 0, n = e.holes.length; t < n; t++) {
                                const n = e.holes[t];
                                this.holes.push((new as).fromJSON(n))
                            }
                            return this
                        }
                    }
                    class os {
                        static triangulate(e, t, n=2) {
                            const i = t && t.length
                                , r = i ? t[0] * n : e.length;
                            let a = ls(e, 0, r, n, !0);
                            const s = [];
                            if (!a || a.next === a.prev)
                                return s;
                            let o, l, c, h, d, u, p;
                            if (i && (a = function(e, t, n, i) {
                                const r = [];
                                let a, s, o, l, c;
                                for (a = 0,
                                         s = t.length; a < s; a++)
                                    o = t[a] * i,
                                        l = a < s - 1 ? t[a + 1] * i : e.length,
                                        c = ls(e, o, l, i, !1),
                                    c === c.next && (c.steiner = !0),
                                        r.push(As(c));
                                for (r.sort(ms),
                                         a = 0; a < r.length; a++)
                                    n = gs(r[a], n);
                                return n
                            }(e, t, a, n)),
                            e.length > 80 * n) {
                                o = c = e[0],
                                    l = h = e[1];
                                for (let t = n; t < r; t += n)
                                    d = e[t],
                                        u = e[t + 1],
                                    d < o && (o = d),
                                    u < l && (l = u),
                                    d > c && (c = d),
                                    u > h && (h = u);
                                p = Math.max(c - o, h - l),
                                    p = 0 !== p ? 32767 / p : 0
                            }
                            return hs(a, s, n, o, l, p, 0),
                                s
                        }
                    }
                    function ls(e, t, n, i, r) {
                        let a, s;
                        if (r === function(e, t, n, i) {
                            let r = 0;
                            for (let a = t, s = n - i; a < n; a += i)
                                r += (e[s] - e[a]) * (e[a + 1] + e[s + 1]),
                                    s = a;
                            return r
                        }(e, t, n, i) > 0)
                            for (a = t; a < n; a += i)
                                s = _s(a, e[a], e[a + 1], s);
                        else
                            for (a = n - i; a >= t; a -= i)
                                s = _s(a, e[a], e[a + 1], s);
                        return s && ks(s, s.next) && (Is(s),
                            s = s.next),
                            s
                    }
                    function cs(e, t) {
                        if (!e)
                            return e;
                        t || (t = e);
                        let n, i = e;
                        do {
                            if (n = !1,
                            i.steiner || !ks(i, i.next) && 0 !== xs(i.prev, i, i.next))
                                i = i.next;
                            else {
                                if (Is(i),
                                    i = t = i.prev,
                                i === i.next)
                                    break;
                                n = !0
                            }
                        } while (n || i !== t);
                        return t
                    }
                    function hs(e, t, n, i, r, a, s) {
                        if (!e)
                            return;
                        !s && a && function(e, t, n, i) {
                            let r = e;
                            do {
                                0 === r.z && (r.z = ws(r.x, r.y, t, n, i)),
                                    r.prevZ = r.prev,
                                    r.nextZ = r.next,
                                    r = r.next
                            } while (r !== e);
                            r.prevZ.nextZ = null,
                                r.prevZ = null,
                                function(e) {
                                    let t, n, i, r, a, s, o, l, c = 1;
                                    do {
                                        for (n = e,
                                                 e = null,
                                                 a = null,
                                                 s = 0; n; ) {
                                            for (s++,
                                                     i = n,
                                                     o = 0,
                                                     t = 0; t < c && (o++,
                                                i = i.nextZ,
                                                i); t++)
                                                ;
                                            for (l = c; o > 0 || l > 0 && i; )
                                                0 !== o && (0 === l || !i || n.z <= i.z) ? (r = n,
                                                    n = n.nextZ,
                                                    o--) : (r = i,
                                                    i = i.nextZ,
                                                    l--),
                                                    a ? a.nextZ = r : e = r,
                                                    r.prevZ = a,
                                                    a = r;
                                            n = i
                                        }
                                        a.nextZ = null,
                                            c *= 2
                                    } while (s > 1)
                                }(r)
                        }(e, i, r, a);
                        let o, l, c = e;
                        for (; e.prev !== e.next; )
                            if (o = e.prev,
                                l = e.next,
                                a ? us(e, i, r, a) : ds(e))
                                t.push(o.i / n | 0),
                                    t.push(e.i / n | 0),
                                    t.push(l.i / n | 0),
                                    Is(e),
                                    e = l.next,
                                    c = l.next;
                            else if ((e = l) === c) {
                                s ? 1 === s ? hs(e = ps(cs(e), t, n), t, n, i, r, a, 2) : 2 === s && fs(e, t, n, i, r, a) : hs(cs(e), t, n, i, r, a, 1);
                                break
                            }
                    }
                    function ds(e) {
                        const t = e.prev
                            , n = e
                            , i = e.next;
                        if (xs(t, n, i) >= 0)
                            return !1;
                        const r = t.x
                            , a = n.x
                            , s = i.x
                            , o = t.y
                            , l = n.y
                            , c = i.y
                            , h = r < a ? r < s ? r : s : a < s ? a : s
                            , d = o < l ? o < c ? o : c : l < c ? l : c
                            , u = r > a ? r > s ? r : s : a > s ? a : s
                            , p = o > l ? o > c ? o : c : l > c ? l : c;
                        let f = i.next;
                        for (; f !== t; ) {
                            if (f.x >= h && f.x <= u && f.y >= d && f.y <= p && ys(r, o, a, l, s, c, f.x, f.y) && xs(f.prev, f, f.next) >= 0)
                                return !1;
                            f = f.next
                        }
                        return !0
                    }
                    function us(e, t, n, i) {
                        const r = e.prev
                            , a = e
                            , s = e.next;
                        if (xs(r, a, s) >= 0)
                            return !1;
                        const o = r.x
                            , l = a.x
                            , c = s.x
                            , h = r.y
                            , d = a.y
                            , u = s.y
                            , p = o < l ? o < c ? o : c : l < c ? l : c
                            , f = h < d ? h < u ? h : u : d < u ? d : u
                            , m = o > l ? o > c ? o : c : l > c ? l : c
                            , g = h > d ? h > u ? h : u : d > u ? d : u
                            , v = ws(p, f, t, n, i)
                            , w = ws(m, g, t, n, i);
                        let A = e.prevZ
                            , y = e.nextZ;
                        for (; A && A.z >= v && y && y.z <= w; ) {
                            if (A.x >= p && A.x <= m && A.y >= f && A.y <= g && A !== r && A !== s && ys(o, h, l, d, c, u, A.x, A.y) && xs(A.prev, A, A.next) >= 0)
                                return !1;
                            if (A = A.prevZ,
                            y.x >= p && y.x <= m && y.y >= f && y.y <= g && y !== r && y !== s && ys(o, h, l, d, c, u, y.x, y.y) && xs(y.prev, y, y.next) >= 0)
                                return !1;
                            y = y.nextZ
                        }
                        for (; A && A.z >= v; ) {
                            if (A.x >= p && A.x <= m && A.y >= f && A.y <= g && A !== r && A !== s && ys(o, h, l, d, c, u, A.x, A.y) && xs(A.prev, A, A.next) >= 0)
                                return !1;
                            A = A.prevZ
                        }
                        for (; y && y.z <= w; ) {
                            if (y.x >= p && y.x <= m && y.y >= f && y.y <= g && y !== r && y !== s && ys(o, h, l, d, c, u, y.x, y.y) && xs(y.prev, y, y.next) >= 0)
                                return !1;
                            y = y.nextZ
                        }
                        return !0
                    }
                    function ps(e, t, n) {
                        let i = e;
                        do {
                            const r = i.prev
                                , a = i.next.next;
                            !ks(r, a) && Es(r, i, i.next, a) && Ts(r, a) && Ts(a, r) && (t.push(r.i / n | 0),
                                t.push(i.i / n | 0),
                                t.push(a.i / n | 0),
                                Is(i),
                                Is(i.next),
                                i = e = a),
                                i = i.next
                        } while (i !== e);
                        return cs(i)
                    }
                    function fs(e, t, n, i, r, a) {
                        let s = e;
                        do {
                            let e = s.next.next;
                            for (; e !== s.prev; ) {
                                if (s.i !== e.i && bs(s, e)) {
                                    let o = Cs(s, e);
                                    return s = cs(s, s.next),
                                        o = cs(o, o.next),
                                        hs(s, t, n, i, r, a, 0),
                                        void hs(o, t, n, i, r, a, 0)
                                }
                                e = e.next
                            }
                            s = s.next
                        } while (s !== e)
                    }
                    function ms(e, t) {
                        return e.x - t.x
                    }
                    function gs(e, t) {
                        const n = function(e, t) {
                            let n, i = t, r = -1 / 0;
                            const a = e.x
                                , s = e.y;
                            do {
                                if (s <= i.y && s >= i.next.y && i.next.y !== i.y) {
                                    const e = i.x + (s - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
                                    if (e <= a && e > r && (r = e,
                                        n = i.x < i.next.x ? i : i.next,
                                    e === a))
                                        return n
                                }
                                i = i.next
                            } while (i !== t);
                            if (!n)
                                return null;
                            const o = n
                                , l = n.x
                                , c = n.y;
                            let h, d = 1 / 0;
                            i = n;
                            do {
                                a >= i.x && i.x >= l && a !== i.x && ys(s < c ? a : r, s, l, c, s < c ? r : a, s, i.x, i.y) && (h = Math.abs(s - i.y) / (a - i.x),
                                Ts(i, e) && (h < d || h === d && (i.x > n.x || i.x === n.x && vs(n, i))) && (n = i,
                                    d = h)),
                                    i = i.next
                            } while (i !== o);
                            return n
                        }(e, t);
                        if (!n)
                            return t;
                        const i = Cs(n, e);
                        return cs(i, i.next),
                            cs(n, n.next)
                    }
                    function vs(e, t) {
                        return xs(e.prev, e, t.prev) < 0 && xs(t.next, e, e.next) < 0
                    }
                    function ws(e, t, n, i, r) {
                        return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - n) * r | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - i) * r | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
                    }
                    function As(e) {
                        let t = e
                            , n = e;
                        do {
                            (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t),
                                t = t.next
                        } while (t !== e);
                        return n
                    }
                    function ys(e, t, n, i, r, a, s, o) {
                        return (r - s) * (t - o) >= (e - s) * (a - o) && (e - s) * (i - o) >= (n - s) * (t - o) && (n - s) * (a - o) >= (r - s) * (i - o)
                    }
                    function bs(e, t) {
                        return e.next.i !== t.i && e.prev.i !== t.i && !function(e, t) {
                            let n = e;
                            do {
                                if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && Es(n, n.next, e, t))
                                    return !0;
                                n = n.next
                            } while (n !== e);
                            return !1
                        }(e, t) && (Ts(e, t) && Ts(t, e) && function(e, t) {
                            let n = e
                                , i = !1;
                            const r = (e.x + t.x) / 2
                                , a = (e.y + t.y) / 2;
                            do {
                                n.y > a != n.next.y > a && n.next.y !== n.y && r < (n.next.x - n.x) * (a - n.y) / (n.next.y - n.y) + n.x && (i = !i),
                                    n = n.next
                            } while (n !== e);
                            return i
                        }(e, t) && (xs(e.prev, e, t.prev) || xs(e, t.prev, t)) || ks(e, t) && xs(e.prev, e, e.next) > 0 && xs(t.prev, t, t.next) > 0)
                    }
                    function xs(e, t, n) {
                        return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y)
                    }
                    function ks(e, t) {
                        return e.x === t.x && e.y === t.y
                    }
                    function Es(e, t, n, i) {
                        const r = Ms(xs(e, t, n))
                            , a = Ms(xs(e, t, i))
                            , s = Ms(xs(n, i, e))
                            , o = Ms(xs(n, i, t));
                        return r !== a && s !== o || (!(0 !== r || !Ss(e, n, t)) || (!(0 !== a || !Ss(e, i, t)) || (!(0 !== s || !Ss(n, e, i)) || !(0 !== o || !Ss(n, t, i)))))
                    }
                    function Ss(e, t, n) {
                        return t.x <= Math.max(e.x, n.x) && t.x >= Math.min(e.x, n.x) && t.y <= Math.max(e.y, n.y) && t.y >= Math.min(e.y, n.y)
                    }
                    function Ms(e) {
                        return e > 0 ? 1 : e < 0 ? -1 : 0
                    }
                    function Ts(e, t) {
                        return xs(e.prev, e, e.next) < 0 ? xs(e, t, e.next) >= 0 && xs(e, e.prev, t) >= 0 : xs(e, t, e.prev) < 0 || xs(e, e.next, t) < 0
                    }
                    function Cs(e, t) {
                        const n = new Ps(e.i,e.x,e.y)
                            , i = new Ps(t.i,t.x,t.y)
                            , r = e.next
                            , a = t.prev;
                        return e.next = t,
                            t.prev = e,
                            n.next = r,
                            r.prev = n,
                            i.next = n,
                            n.prev = i,
                            a.next = i,
                            i.prev = a,
                            i
                    }
                    function _s(e, t, n, i) {
                        const r = new Ps(e,t,n);
                        return i ? (r.next = i.next,
                            r.prev = i,
                            i.next.prev = r,
                            i.next = r) : (r.prev = r,
                            r.next = r),
                            r
                    }
                    function Is(e) {
                        e.next.prev = e.prev,
                            e.prev.next = e.next,
                        e.prevZ && (e.prevZ.nextZ = e.nextZ),
                        e.nextZ && (e.nextZ.prevZ = e.prevZ)
                    }
                    function Ps(e, t, n) {
                        this.i = e,
                            this.x = t,
                            this.y = n,
                            this.prev = null,
                            this.next = null,
                            this.z = 0,
                            this.prevZ = null,
                            this.nextZ = null,
                            this.steiner = !1
                    }
                    class Rs {
                        static area(e) {
                            const t = e.length;
                            let n = 0;
                            for (let i = t - 1, r = 0; r < t; i = r++)
                                n += e[i].x * e[r].y - e[r].x * e[i].y;
                            return .5 * n
                        }
                        static isClockWise(e) {
                            return Rs.area(e) < 0
                        }
                        static triangulateShape(e, t) {
                            const n = []
                                , i = []
                                , r = [];
                            Ls(e),
                                Ns(n, e);
                            let a = e.length;
                            t.forEach(Ls);
                            for (let e = 0; e < t.length; e++)
                                i.push(a),
                                    a += t[e].length,
                                    Ns(n, t[e]);
                            const s = os.triangulate(n, i);
                            for (let e = 0; e < s.length; e += 3)
                                r.push(s.slice(e, e + 3));
                            return r
                        }
                    }
                    function Ls(e) {
                        const t = e.length;
                        t > 2 && e[t - 1].equals(e[0]) && e.pop()
                    }
                    function Ns(e, t) {
                        for (let n = 0; n < t.length; n++)
                            e.push(t[n].x),
                                e.push(t[n].y)
                    }
                    class Ds extends sr {
                        constructor(e=1, t=1, n=1, i=1) {
                            super(),
                                this.type = "PlaneGeometry",
                                this.parameters = {
                                    width: e,
                                    height: t,
                                    widthSegments: n,
                                    heightSegments: i
                                };
                            const r = e / 2
                                , a = t / 2
                                , s = Math.floor(n)
                                , o = Math.floor(i)
                                , l = s + 1
                                , c = o + 1
                                , h = e / s
                                , d = t / o
                                , u = []
                                , p = []
                                , f = []
                                , m = [];
                            for (let e = 0; e < c; e++) {
                                const t = e * d - a;
                                for (let n = 0; n < l; n++) {
                                    const i = n * h - r;
                                    p.push(i, -t, 0),
                                        f.push(0, 0, 1),
                                        m.push(n / s),
                                        m.push(1 - e / o)
                                }
                            }
                            for (let e = 0; e < o; e++)
                                for (let t = 0; t < s; t++) {
                                    const n = t + l * e
                                        , i = t + l * (e + 1)
                                        , r = t + 1 + l * (e + 1)
                                        , a = t + 1 + l * e;
                                    u.push(n, i, a),
                                        u.push(i, r, a)
                                }
                            this.setIndex(u),
                                this.setAttribute("position", new Ji(p,3)),
                                this.setAttribute("normal", new Ji(f,3)),
                                this.setAttribute("uv", new Ji(m,2))
                        }
                        copy(e) {
                            return super.copy(e),
                                this.parameters = Object.assign({}, e.parameters),
                                this
                        }
                        static fromJSON(e) {
                            return new Ds(e.width,e.height,e.widthSegments,e.heightSegments)
                        }
                    }
                    class Bs extends sr {
                        constructor(e=new ss([new jt(0,.5), new jt(-.5,-.5), new jt(.5,-.5)]), t=12) {
                            super(),
                                this.type = "ShapeGeometry",
                                this.parameters = {
                                    shapes: e,
                                    curveSegments: t
                                };
                            const n = []
                                , i = []
                                , r = []
                                , a = [];
                            let s = 0
                                , o = 0;
                            if (!1 === Array.isArray(e))
                                l(e);
                            else
                                for (let t = 0; t < e.length; t++)
                                    l(e[t]),
                                        this.addGroup(s, o, t),
                                        s += o,
                                        o = 0;
                            function l(e) {
                                const s = i.length / 3
                                    , l = e.extractPoints(t);
                                let c = l.shape;
                                const h = l.holes;
                                !1 === Rs.isClockWise(c) && (c = c.reverse());
                                for (let e = 0, t = h.length; e < t; e++) {
                                    const t = h[e];
                                    !0 === Rs.isClockWise(t) && (h[e] = t.reverse())
                                }
                                const d = Rs.triangulateShape(c, h);
                                for (let e = 0, t = h.length; e < t; e++) {
                                    const t = h[e];
                                    c = c.concat(t)
                                }
                                for (let e = 0, t = c.length; e < t; e++) {
                                    const t = c[e];
                                    i.push(t.x, t.y, 0),
                                        r.push(0, 0, 1),
                                        a.push(t.x, t.y)
                                }
                                for (let e = 0, t = d.length; e < t; e++) {
                                    const t = d[e]
                                        , i = t[0] + s
                                        , r = t[1] + s
                                        , a = t[2] + s;
                                    n.push(i, r, a),
                                        o += 3
                                }
                            }
                            this.setIndex(n),
                                this.setAttribute("position", new Ji(i,3)),
                                this.setAttribute("normal", new Ji(r,3)),
                                this.setAttribute("uv", new Ji(a,2))
                        }
                        copy(e) {
                            return super.copy(e),
                                this.parameters = Object.assign({}, e.parameters),
                                this
                        }
                        toJSON() {
                            const e = super.toJSON();
                            return function(e, t) {
                                if (t.shapes = [],
                                    Array.isArray(e))
                                    for (let n = 0, i = e.length; n < i; n++) {
                                        const i = e[n];
                                        t.shapes.push(i.uuid)
                                    }
                                else
                                    t.shapes.push(e.uuid);
                                return t
                            }(this.parameters.shapes, e)
                        }
                        static fromJSON(e, t) {
                            const n = [];
                            for (let i = 0, r = e.shapes.length; i < r; i++) {
                                const r = t[e.shapes[i]];
                                n.push(r)
                            }
                            return new Bs(n,e.curveSegments)
                        }
                    }
                    class Us extends sr {
                        constructor(e=1, t=32, n=16, i=0, r=2 * Math.PI, a=0, s=Math.PI) {
                            super(),
                                this.type = "SphereGeometry",
                                this.parameters = {
                                    radius: e,
                                    widthSegments: t,
                                    heightSegments: n,
                                    phiStart: i,
                                    phiLength: r,
                                    thetaStart: a,
                                    thetaLength: s
                                },
                                t = Math.max(3, Math.floor(t)),
                                n = Math.max(2, Math.floor(n));
                            const o = Math.min(a + s, Math.PI);
                            let l = 0;
                            const c = []
                                , h = new An
                                , d = new An
                                , u = []
                                , p = []
                                , f = []
                                , m = [];
                            for (let u = 0; u <= n; u++) {
                                const g = []
                                    , v = u / n;
                                let w = 0;
                                0 === u && 0 === a ? w = .5 / t : u === n && o === Math.PI && (w = -.5 / t);
                                for (let n = 0; n <= t; n++) {
                                    const o = n / t;
                                    h.x = -e * Math.cos(i + o * r) * Math.sin(a + v * s),
                                        h.y = e * Math.cos(a + v * s),
                                        h.z = e * Math.sin(i + o * r) * Math.sin(a + v * s),
                                        p.push(h.x, h.y, h.z),
                                        d.copy(h).normalize(),
                                        f.push(d.x, d.y, d.z),
                                        m.push(o + w, 1 - v),
                                        g.push(l++)
                                }
                                c.push(g)
                            }
                            for (let e = 0; e < n; e++)
                                for (let i = 0; i < t; i++) {
                                    const t = c[e][i + 1]
                                        , r = c[e][i]
                                        , s = c[e + 1][i]
                                        , l = c[e + 1][i + 1];
                                    (0 !== e || a > 0) && u.push(t, r, l),
                                    (e !== n - 1 || o < Math.PI) && u.push(r, s, l)
                                }
                            this.setIndex(u),
                                this.setAttribute("position", new Ji(p,3)),
                                this.setAttribute("normal", new Ji(f,3)),
                                this.setAttribute("uv", new Ji(m,2))
                        }
                        copy(e) {
                            return super.copy(e),
                                this.parameters = Object.assign({}, e.parameters),
                                this
                        }
                        static fromJSON(e) {
                            return new Us(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)
                        }
                    }
                    class zs extends Gi {
                        constructor(e) {
                            super(),
                                this.isMeshStandardMaterial = !0,
                                this.type = "MeshStandardMaterial",
                                this.defines = {
                                    STANDARD: ""
                                },
                                this.color = new Wi(16777215),
                                this.roughness = 1,
                                this.metalness = 0,
                                this.map = null,
                                this.lightMap = null,
                                this.lightMapIntensity = 1,
                                this.aoMap = null,
                                this.aoMapIntensity = 1,
                                this.emissive = new Wi(0),
                                this.emissiveIntensity = 1,
                                this.emissiveMap = null,
                                this.bumpMap = null,
                                this.bumpScale = 1,
                                this.normalMap = null,
                                this.normalMapType = 0,
                                this.normalScale = new jt(1,1),
                                this.displacementMap = null,
                                this.displacementScale = 1,
                                this.displacementBias = 0,
                                this.roughnessMap = null,
                                this.metalnessMap = null,
                                this.alphaMap = null,
                                this.envMap = null,
                                this.envMapRotation = new ai,
                                this.envMapIntensity = 1,
                                this.wireframe = !1,
                                this.wireframeLinewidth = 1,
                                this.wireframeLinecap = "round",
                                this.wireframeLinejoin = "round",
                                this.flatShading = !1,
                                this.fog = !0,
                                this.setValues(e)
                        }
                        copy(e) {
                            return super.copy(e),
                                this.defines = {
                                    STANDARD: ""
                                },
                                this.color.copy(e.color),
                                this.roughness = e.roughness,
                                this.metalness = e.metalness,
                                this.map = e.map,
                                this.lightMap = e.lightMap,
                                this.lightMapIntensity = e.lightMapIntensity,
                                this.aoMap = e.aoMap,
                                this.aoMapIntensity = e.aoMapIntensity,
                                this.emissive.copy(e.emissive),
                                this.emissiveMap = e.emissiveMap,
                                this.emissiveIntensity = e.emissiveIntensity,
                                this.bumpMap = e.bumpMap,
                                this.bumpScale = e.bumpScale,
                                this.normalMap = e.normalMap,
                                this.normalMapType = e.normalMapType,
                                this.normalScale.copy(e.normalScale),
                                this.displacementMap = e.displacementMap,
                                this.displacementScale = e.displacementScale,
                                this.displacementBias = e.displacementBias,
                                this.roughnessMap = e.roughnessMap,
                                this.metalnessMap = e.metalnessMap,
                                this.alphaMap = e.alphaMap,
                                this.envMap = e.envMap,
                                this.envMapRotation.copy(e.envMapRotation),
                                this.envMapIntensity = e.envMapIntensity,
                                this.wireframe = e.wireframe,
                                this.wireframeLinewidth = e.wireframeLinewidth,
                                this.wireframeLinecap = e.wireframeLinecap,
                                this.wireframeLinejoin = e.wireframeLinejoin,
                                this.flatShading = e.flatShading,
                                this.fog = e.fog,
                                this
                        }
                    }
                    class Os extends zs {
                        constructor(e) {
                            super(),
                                this.isMeshPhysicalMaterial = !0,
                                this.defines = {
                                    STANDARD: "",
                                    PHYSICAL: ""
                                },
                                this.type = "MeshPhysicalMaterial",
                                this.anisotropyRotation = 0,
                                this.anisotropyMap = null,
                                this.clearcoatMap = null,
                                this.clearcoatRoughness = 0,
                                this.clearcoatRoughnessMap = null,
                                this.clearcoatNormalScale = new jt(1,1),
                                this.clearcoatNormalMap = null,
                                this.ior = 1.5,
                                Object.defineProperty(this, "reflectivity", {
                                    get: function() {
                                        return Ot(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                                    },
                                    set: function(e) {
                                        this.ior = (1 + .4 * e) / (1 - .4 * e)
                                    }
                                }),
                                this.iridescenceMap = null,
                                this.iridescenceIOR = 1.3,
                                this.iridescenceThicknessRange = [100, 400],
                                this.iridescenceThicknessMap = null,
                                this.sheenColor = new Wi(0),
                                this.sheenColorMap = null,
                                this.sheenRoughness = 1,
                                this.sheenRoughnessMap = null,
                                this.transmissionMap = null,
                                this.thickness = 0,
                                this.thicknessMap = null,
                                this.attenuationDistance = 1 / 0,
                                this.attenuationColor = new Wi(1,1,1),
                                this.specularIntensity = 1,
                                this.specularIntensityMap = null,
                                this.specularColor = new Wi(1,1,1),
                                this.specularColorMap = null,
                                this._anisotropy = 0,
                                this._clearcoat = 0,
                                this._dispersion = 0,
                                this._iridescence = 0,
                                this._sheen = 0,
                                this._transmission = 0,
                                this.setValues(e)
                        }
                        get anisotropy() {
                            return this._anisotropy
                        }
                        set anisotropy(e) {
                            this._anisotropy > 0 != e > 0 && this.version++,
                                this._anisotropy = e
                        }
                        get clearcoat() {
                            return this._clearcoat
                        }
                        set clearcoat(e) {
                            this._clearcoat > 0 != e > 0 && this.version++,
                                this._clearcoat = e
                        }
                        get iridescence() {
                            return this._iridescence
                        }
                        set iridescence(e) {
                            this._iridescence > 0 != e > 0 && this.version++,
                                this._iridescence = e
                        }
                        get dispersion() {
                            return this._dispersion
                        }
                        set dispersion(e) {
                            this._dispersion > 0 != e > 0 && this.version++,
                                this._dispersion = e
                        }
                        get sheen() {
                            return this._sheen
                        }
                        set sheen(e) {
                            this._sheen > 0 != e > 0 && this.version++,
                                this._sheen = e
                        }
                        get transmission() {
                            return this._transmission
                        }
                        set transmission(e) {
                            this._transmission > 0 != e > 0 && this.version++,
                                this._transmission = e
                        }
                        copy(e) {
                            return super.copy(e),
                                this.defines = {
                                    STANDARD: "",
                                    PHYSICAL: ""
                                },
                                this.anisotropy = e.anisotropy,
                                this.anisotropyRotation = e.anisotropyRotation,
                                this.anisotropyMap = e.anisotropyMap,
                                this.clearcoat = e.clearcoat,
                                this.clearcoatMap = e.clearcoatMap,
                                this.clearcoatRoughness = e.clearcoatRoughness,
                                this.clearcoatRoughnessMap = e.clearcoatRoughnessMap,
                                this.clearcoatNormalMap = e.clearcoatNormalMap,
                                this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
                                this.dispersion = e.dispersion,
                                this.ior = e.ior,
                                this.iridescence = e.iridescence,
                                this.iridescenceMap = e.iridescenceMap,
                                this.iridescenceIOR = e.iridescenceIOR,
                                this.iridescenceThicknessRange = [...e.iridescenceThicknessRange],
                                this.iridescenceThicknessMap = e.iridescenceThicknessMap,
                                this.sheen = e.sheen,
                                this.sheenColor.copy(e.sheenColor),
                                this.sheenColorMap = e.sheenColorMap,
                                this.sheenRoughness = e.sheenRoughness,
                                this.sheenRoughnessMap = e.sheenRoughnessMap,
                                this.transmission = e.transmission,
                                this.transmissionMap = e.transmissionMap,
                                this.thickness = e.thickness,
                                this.thicknessMap = e.thicknessMap,
                                this.attenuationDistance = e.attenuationDistance,
                                this.attenuationColor.copy(e.attenuationColor),
                                this.specularIntensity = e.specularIntensity,
                                this.specularIntensityMap = e.specularIntensityMap,
                                this.specularColor.copy(e.specularColor),
                                this.specularColorMap = e.specularColorMap,
                                this
                        }
                    }
                    class Fs extends Gi {
                        constructor(e) {
                            super(),
                                this.isMeshLambertMaterial = !0,
                                this.type = "MeshLambertMaterial",
                                this.color = new Wi(16777215),
                                this.map = null,
                                this.lightMap = null,
                                this.lightMapIntensity = 1,
                                this.aoMap = null,
                                this.aoMapIntensity = 1,
                                this.emissive = new Wi(0),
                                this.emissiveIntensity = 1,
                                this.emissiveMap = null,
                                this.bumpMap = null,
                                this.bumpScale = 1,
                                this.normalMap = null,
                                this.normalMapType = 0,
                                this.normalScale = new jt(1,1),
                                this.displacementMap = null,
                                this.displacementScale = 1,
                                this.displacementBias = 0,
                                this.specularMap = null,
                                this.alphaMap = null,
                                this.envMap = null,
                                this.envMapRotation = new ai,
                                this.combine = 0,
                                this.reflectivity = 1,
                                this.refractionRatio = .98,
                                this.wireframe = !1,
                                this.wireframeLinewidth = 1,
                                this.wireframeLinecap = "round",
                                this.wireframeLinejoin = "round",
                                this.flatShading = !1,
                                this.fog = !0,
                                this.setValues(e)
                        }
                        copy(e) {
                            return super.copy(e),
                                this.color.copy(e.color),
                                this.map = e.map,
                                this.lightMap = e.lightMap,
                                this.lightMapIntensity = e.lightMapIntensity,
                                this.aoMap = e.aoMap,
                                this.aoMapIntensity = e.aoMapIntensity,
                                this.emissive.copy(e.emissive),
                                this.emissiveMap = e.emissiveMap,
                                this.emissiveIntensity = e.emissiveIntensity,
                                this.bumpMap = e.bumpMap,
                                this.bumpScale = e.bumpScale,
                                this.normalMap = e.normalMap,
                                this.normalMapType = e.normalMapType,
                                this.normalScale.copy(e.normalScale),
                                this.displacementMap = e.displacementMap,
                                this.displacementScale = e.displacementScale,
                                this.displacementBias = e.displacementBias,
                                this.specularMap = e.specularMap,
                                this.alphaMap = e.alphaMap,
                                this.envMap = e.envMap,
                                this.envMapRotation.copy(e.envMapRotation),
                                this.combine = e.combine,
                                this.reflectivity = e.reflectivity,
                                this.refractionRatio = e.refractionRatio,
                                this.wireframe = e.wireframe,
                                this.wireframeLinewidth = e.wireframeLinewidth,
                                this.wireframeLinecap = e.wireframeLinecap,
                                this.wireframeLinejoin = e.wireframeLinejoin,
                                this.flatShading = e.flatShading,
                                this.fog = e.fog,
                                this
                        }
                    }
                    class Ws extends Gi {
                        constructor(e) {
                            super(),
                                this.isMeshDepthMaterial = !0,
                                this.type = "MeshDepthMaterial",
                                this.depthPacking = 3200,
                                this.map = null,
                                this.alphaMap = null,
                                this.displacementMap = null,
                                this.displacementScale = 1,
                                this.displacementBias = 0,
                                this.wireframe = !1,
                                this.wireframeLinewidth = 1,
                                this.setValues(e)
                        }
                        copy(e) {
                            return super.copy(e),
                                this.depthPacking = e.depthPacking,
                                this.map = e.map,
                                this.alphaMap = e.alphaMap,
                                this.displacementMap = e.displacementMap,
                                this.displacementScale = e.displacementScale,
                                this.displacementBias = e.displacementBias,
                                this.wireframe = e.wireframe,
                                this.wireframeLinewidth = e.wireframeLinewidth,
                                this
                        }
                    }
                    class Hs extends Gi {
                        constructor(e) {
                            super(),
                                this.isMeshDistanceMaterial = !0,
                                this.type = "MeshDistanceMaterial",
                                this.map = null,
                                this.alphaMap = null,
                                this.displacementMap = null,
                                this.displacementScale = 1,
                                this.displacementBias = 0,
                                this.setValues(e)
                        }
                        copy(e) {
                            return super.copy(e),
                                this.map = e.map,
                                this.alphaMap = e.alphaMap,
                                this.displacementMap = e.displacementMap,
                                this.displacementScale = e.displacementScale,
                                this.displacementBias = e.displacementBias,
                                this
                        }
                    }
                    function Vs(e, t, n) {
                        return !e || !n && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
                    }
                    function Gs(e) {
                        return ArrayBuffer.isView(e) && !(e instanceof DataView)
                    }
                    function js(e) {
                        const t = e.length
                            , n = new Array(t);
                        for (let e = 0; e !== t; ++e)
                            n[e] = e;
                        return n.sort((function(t, n) {
                                return e[t] - e[n]
                            }
                        )),
                            n
                    }
                    function Qs(e, t, n) {
                        const i = e.length
                            , r = new e.constructor(i);
                        for (let a = 0, s = 0; s !== i; ++a) {
                            const i = n[a] * t;
                            for (let n = 0; n !== t; ++n)
                                r[s++] = e[i + n]
                        }
                        return r
                    }
                    function Ys(e, t, n, i) {
                        let r = 1
                            , a = e[0];
                        for (; void 0 !== a && void 0 === a[i]; )
                            a = e[r++];
                        if (void 0 === a)
                            return;
                        let s = a[i];
                        if (void 0 !== s)
                            if (Array.isArray(s))
                                do {
                                    s = a[i],
                                    void 0 !== s && (t.push(a.time),
                                        n.push(...s)),
                                        a = e[r++]
                                } while (void 0 !== a);
                            else if (void 0 !== s.toArray)
                                do {
                                    s = a[i],
                                    void 0 !== s && (t.push(a.time),
                                        s.toArray(n, n.length)),
                                        a = e[r++]
                                } while (void 0 !== a);
                            else
                                do {
                                    s = a[i],
                                    void 0 !== s && (t.push(a.time),
                                        n.push(s)),
                                        a = e[r++]
                                } while (void 0 !== a)
                    }
                    class qs {
                        constructor(e, t, n, i) {
                            this.parameterPositions = e,
                                this._cachedIndex = 0,
                                this.resultBuffer = void 0 !== i ? i : new t.constructor(n),
                                this.sampleValues = t,
                                this.valueSize = n,
                                this.settings = null,
                                this.DefaultSettings_ = {}
                        }
                        evaluate(e) {
                            const t = this.parameterPositions;
                            let n = this._cachedIndex
                                , i = t[n]
                                , r = t[n - 1];
                            e: {
                                t: {
                                    let a;
                                    n: {
                                        i: if (!(e < i)) {
                                            for (let a = n + 2; ; ) {
                                                if (void 0 === i) {
                                                    if (e < r)
                                                        break i;
                                                    return n = t.length,
                                                        this._cachedIndex = n,
                                                        this.copySampleValue_(n - 1)
                                                }
                                                if (n === a)
                                                    break;
                                                if (r = i,
                                                    i = t[++n],
                                                e < i)
                                                    break t
                                            }
                                            a = t.length;
                                            break n
                                        }
                                        if (e >= r)
                                            break e;
                                        {
                                            const s = t[1];
                                            e < s && (n = 2,
                                                r = s);
                                            for (let a = n - 2; ; ) {
                                                if (void 0 === r)
                                                    return this._cachedIndex = 0,
                                                        this.copySampleValue_(0);
                                                if (n === a)
                                                    break;
                                                if (i = r,
                                                    r = t[--n - 1],
                                                e >= r)
                                                    break t
                                            }
                                            a = n,
                                                n = 0
                                        }
                                    }
                                    for (; n < a; ) {
                                        const i = n + a >>> 1;
                                        e < t[i] ? a = i : n = i + 1
                                    }
                                    if (i = t[n],
                                        r = t[n - 1],
                                    void 0 === r)
                                        return this._cachedIndex = 0,
                                            this.copySampleValue_(0);
                                    if (void 0 === i)
                                        return n = t.length,
                                            this._cachedIndex = n,
                                            this.copySampleValue_(n - 1)
                                }
                                this._cachedIndex = n,
                                    this.intervalChanged_(n, r, i)
                            }
                            return this.interpolate_(n, r, e, i)
                        }
                        getSettings_() {
                            return this.settings || this.DefaultSettings_
                        }
                        copySampleValue_(e) {
                            const t = this.resultBuffer
                                , n = this.sampleValues
                                , i = this.valueSize
                                , r = e * i;
                            for (let e = 0; e !== i; ++e)
                                t[e] = n[r + e];
                            return t
                        }
                        interpolate_() {
                            throw new Error("call to abstract method")
                        }
                        intervalChanged_() {}
                    }
                    class Ks extends qs {
                        constructor(e, t, n, i) {
                            super(e, t, n, i),
                                this._weightPrev = -0,
                                this._offsetPrev = -0,
                                this._weightNext = -0,
                                this._offsetNext = -0,
                                this.DefaultSettings_ = {
                                    endingStart: ut,
                                    endingEnd: ut
                                }
                        }
                        intervalChanged_(e, t, n) {
                            const i = this.parameterPositions;
                            let r = e - 2
                                , a = e + 1
                                , s = i[r]
                                , o = i[a];
                            if (void 0 === s)
                                switch (this.getSettings_().endingStart) {
                                    case pt:
                                        r = e,
                                            s = 2 * t - n;
                                        break;
                                    case ft:
                                        r = i.length - 2,
                                            s = t + i[r] - i[r + 1];
                                        break;
                                    default:
                                        r = e,
                                            s = n
                                }
                            if (void 0 === o)
                                switch (this.getSettings_().endingEnd) {
                                    case pt:
                                        a = e,
                                            o = 2 * n - t;
                                        break;
                                    case ft:
                                        a = 1,
                                            o = n + i[1] - i[0];
                                        break;
                                    default:
                                        a = e - 1,
                                            o = t
                                }
                            const l = .5 * (n - t)
                                , c = this.valueSize;
                            this._weightPrev = l / (t - s),
                                this._weightNext = l / (o - n),
                                this._offsetPrev = r * c,
                                this._offsetNext = a * c
                        }
                        interpolate_(e, t, n, i) {
                            const r = this.resultBuffer
                                , a = this.sampleValues
                                , s = this.valueSize
                                , o = e * s
                                , l = o - s
                                , c = this._offsetPrev
                                , h = this._offsetNext
                                , d = this._weightPrev
                                , u = this._weightNext
                                , p = (n - t) / (i - t)
                                , f = p * p
                                , m = f * p
                                , g = -d * m + 2 * d * f - d * p
                                , v = (1 + d) * m + (-1.5 - 2 * d) * f + (-.5 + d) * p + 1
                                , w = (-1 - u) * m + (1.5 + u) * f + .5 * p
                                , A = u * m - u * f;
                            for (let e = 0; e !== s; ++e)
                                r[e] = g * a[c + e] + v * a[l + e] + w * a[o + e] + A * a[h + e];
                            return r
                        }
                    }
                    class Xs extends qs {
                        constructor(e, t, n, i) {
                            super(e, t, n, i)
                        }
                        interpolate_(e, t, n, i) {
                            const r = this.resultBuffer
                                , a = this.sampleValues
                                , s = this.valueSize
                                , o = e * s
                                , l = o - s
                                , c = (n - t) / (i - t)
                                , h = 1 - c;
                            for (let e = 0; e !== s; ++e)
                                r[e] = a[l + e] * h + a[o + e] * c;
                            return r
                        }
                    }
                    class Zs extends qs {
                        constructor(e, t, n, i) {
                            super(e, t, n, i)
                        }
                        interpolate_(e) {
                            return this.copySampleValue_(e - 1)
                        }
                    }
                    class Js {
                        constructor(e, t, n, i) {
                            if (void 0 === e)
                                throw new Error("THREE.KeyframeTrack: track name is undefined");
                            if (void 0 === t || 0 === t.length)
                                throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
                            this.name = e,
                                this.times = Vs(t, this.TimeBufferType),
                                this.values = Vs(n, this.ValueBufferType),
                                this.setInterpolation(i || this.DefaultInterpolation)
                        }
                        static toJSON(e) {
                            const t = e.constructor;
                            let n;
                            if (t.toJSON !== this.toJSON)
                                n = t.toJSON(e);
                            else {
                                n = {
                                    name: e.name,
                                    times: Vs(e.times, Array),
                                    values: Vs(e.values, Array)
                                };
                                const t = e.getInterpolation();
                                t !== e.DefaultInterpolation && (n.interpolation = t)
                            }
                            return n.type = e.ValueTypeName,
                                n
                        }
                        InterpolantFactoryMethodDiscrete(e) {
                            return new Zs(this.times,this.values,this.getValueSize(),e)
                        }
                        InterpolantFactoryMethodLinear(e) {
                            return new Xs(this.times,this.values,this.getValueSize(),e)
                        }
                        InterpolantFactoryMethodSmooth(e) {
                            return new Ks(this.times,this.values,this.getValueSize(),e)
                        }
                        setInterpolation(e) {
                            let t;
                            switch (e) {
                                case ct:
                                    t = this.InterpolantFactoryMethodDiscrete;
                                    break;
                                case ht:
                                    t = this.InterpolantFactoryMethodLinear;
                                    break;
                                case dt:
                                    t = this.InterpolantFactoryMethodSmooth
                            }
                            if (void 0 === t) {
                                const t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                                if (void 0 === this.createInterpolant) {
                                    if (e === this.DefaultInterpolation)
                                        throw new Error(t);
                                    this.setInterpolation(this.DefaultInterpolation)
                                }
                                return console.warn("THREE.KeyframeTrack:", t),
                                    this
                            }
                            return this.createInterpolant = t,
                                this
                        }
                        getInterpolation() {
                            switch (this.createInterpolant) {
                                case this.InterpolantFactoryMethodDiscrete:
                                    return ct;
                                case this.InterpolantFactoryMethodLinear:
                                    return ht;
                                case this.InterpolantFactoryMethodSmooth:
                                    return dt
                            }
                        }
                        getValueSize() {
                            return this.values.length / this.times.length
                        }
                        shift(e) {
                            if (0 !== e) {
                                const t = this.times;
                                for (let n = 0, i = t.length; n !== i; ++n)
                                    t[n] += e
                            }
                            return this
                        }
                        scale(e) {
                            if (1 !== e) {
                                const t = this.times;
                                for (let n = 0, i = t.length; n !== i; ++n)
                                    t[n] *= e
                            }
                            return this
                        }
                        trim(e, t) {
                            const n = this.times
                                , i = n.length;
                            let r = 0
                                , a = i - 1;
                            for (; r !== i && n[r] < e; )
                                ++r;
                            for (; -1 !== a && n[a] > t; )
                                --a;
                            if (++a,
                            0 !== r || a !== i) {
                                r >= a && (a = Math.max(a, 1),
                                    r = a - 1);
                                const e = this.getValueSize();
                                this.times = n.slice(r, a),
                                    this.values = this.values.slice(r * e, a * e)
                            }
                            return this
                        }
                        validate() {
                            let e = !0;
                            const t = this.getValueSize();
                            t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
                                e = !1);
                            const n = this.times
                                , i = this.values
                                , r = n.length;
                            0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this),
                                e = !1);
                            let a = null;
                            for (let t = 0; t !== r; t++) {
                                const i = n[t];
                                if ("number" == typeof i && isNaN(i)) {
                                    console.error("THREE.KeyframeTrack: Time is not a valid number.", this, t, i),
                                        e = !1;
                                    break
                                }
                                if (null !== a && a > i) {
                                    console.error("THREE.KeyframeTrack: Out of order keys.", this, t, i, a),
                                        e = !1;
                                    break
                                }
                                a = i
                            }
                            if (void 0 !== i && Gs(i))
                                for (let t = 0, n = i.length; t !== n; ++t) {
                                    const n = i[t];
                                    if (isNaN(n)) {
                                        console.error("THREE.KeyframeTrack: Value is not a valid number.", this, t, n),
                                            e = !1;
                                        break
                                    }
                                }
                            return e
                        }
                        optimize() {
                            const e = this.times.slice()
                                , t = this.values.slice()
                                , n = this.getValueSize()
                                , i = this.getInterpolation() === dt
                                , r = e.length - 1;
                            let a = 1;
                            for (let s = 1; s < r; ++s) {
                                let r = !1;
                                const o = e[s];
                                if (o !== e[s + 1] && (1 !== s || o !== e[0]))
                                    if (i)
                                        r = !0;
                                    else {
                                        const e = s * n
                                            , i = e - n
                                            , a = e + n;
                                        for (let s = 0; s !== n; ++s) {
                                            const n = t[e + s];
                                            if (n !== t[i + s] || n !== t[a + s]) {
                                                r = !0;
                                                break
                                            }
                                        }
                                    }
                                if (r) {
                                    if (s !== a) {
                                        e[a] = e[s];
                                        const i = s * n
                                            , r = a * n;
                                        for (let e = 0; e !== n; ++e)
                                            t[r + e] = t[i + e]
                                    }
                                    ++a
                                }
                            }
                            if (r > 0) {
                                e[a] = e[r];
                                for (let e = r * n, i = a * n, s = 0; s !== n; ++s)
                                    t[i + s] = t[e + s];
                                ++a
                            }
                            return a !== e.length ? (this.times = e.slice(0, a),
                                this.values = t.slice(0, a * n)) : (this.times = e,
                                this.values = t),
                                this
                        }
                        clone() {
                            const e = this.times.slice()
                                , t = this.values.slice()
                                , n = new (0,
                                this.constructor)(this.name,e,t);
                            return n.createInterpolant = this.createInterpolant,
                                n
                        }
                    }
                    Js.prototype.TimeBufferType = Float32Array,
                        Js.prototype.ValueBufferType = Float32Array,
                        Js.prototype.DefaultInterpolation = ht;
                    class $s extends Js {
                        constructor(e, t, n) {
                            super(e, t, n)
                        }
                    }
                    $s.prototype.ValueTypeName = "bool",
                        $s.prototype.ValueBufferType = Array,
                        $s.prototype.DefaultInterpolation = ct,
                        $s.prototype.InterpolantFactoryMethodLinear = void 0,
                        $s.prototype.InterpolantFactoryMethodSmooth = void 0;
                    class eo extends Js {
                    }
                    eo.prototype.ValueTypeName = "color";
                    class to extends Js {
                    }
                    to.prototype.ValueTypeName = "number";
                    class no extends qs {
                        constructor(e, t, n, i) {
                            super(e, t, n, i)
                        }
                        interpolate_(e, t, n, i) {
                            const r = this.resultBuffer
                                , a = this.sampleValues
                                , s = this.valueSize
                                , o = (n - t) / (i - t);
                            let l = e * s;
                            for (let e = l + s; l !== e; l += 4)
                                wn.slerpFlat(r, 0, a, l - s, a, l, o);
                            return r
                        }
                    }
                    class io extends Js {
                        InterpolantFactoryMethodLinear(e) {
                            return new no(this.times,this.values,this.getValueSize(),e)
                        }
                    }
                    io.prototype.ValueTypeName = "quaternion",
                        io.prototype.InterpolantFactoryMethodSmooth = void 0;
                    class ro extends Js {
                        constructor(e, t, n) {
                            super(e, t, n)
                        }
                    }
                    ro.prototype.ValueTypeName = "string",
                        ro.prototype.ValueBufferType = Array,
                        ro.prototype.DefaultInterpolation = ct,
                        ro.prototype.InterpolantFactoryMethodLinear = void 0,
                        ro.prototype.InterpolantFactoryMethodSmooth = void 0;
                    class ao extends Js {
                    }
                    ao.prototype.ValueTypeName = "vector";
                    class so {
                        constructor(e="", t=-1, n=[], i=2500) {
                            this.name = e,
                                this.tracks = n,
                                this.duration = t,
                                this.blendMode = i,
                                this.uuid = zt(),
                            this.duration < 0 && this.resetDuration()
                        }
                        static parse(e) {
                            const t = []
                                , n = e.tracks
                                , i = 1 / (e.fps || 1);
                            for (let e = 0, r = n.length; e !== r; ++e)
                                t.push(oo(n[e]).scale(i));
                            const r = new this(e.name,e.duration,t,e.blendMode);
                            return r.uuid = e.uuid,
                                r
                        }
                        static toJSON(e) {
                            const t = []
                                , n = e.tracks
                                , i = {
                                name: e.name,
                                duration: e.duration,
                                tracks: t,
                                uuid: e.uuid,
                                blendMode: e.blendMode
                            };
                            for (let e = 0, i = n.length; e !== i; ++e)
                                t.push(Js.toJSON(n[e]));
                            return i
                        }
                        static CreateFromMorphTargetSequence(e, t, n, i) {
                            const r = t.length
                                , a = [];
                            for (let e = 0; e < r; e++) {
                                let s = []
                                    , o = [];
                                s.push((e + r - 1) % r, e, (e + 1) % r),
                                    o.push(0, 1, 0);
                                const l = js(s);
                                s = Qs(s, 1, l),
                                    o = Qs(o, 1, l),
                                i || 0 !== s[0] || (s.push(r),
                                    o.push(o[0])),
                                    a.push(new to(".morphTargetInfluences[" + t[e].name + "]",s,o).scale(1 / n))
                            }
                            return new this(e,-1,a)
                        }
                        static findByName(e, t) {
                            let n = e;
                            if (!Array.isArray(e)) {
                                const t = e;
                                n = t.geometry && t.geometry.animations || t.animations
                            }
                            for (let e = 0; e < n.length; e++)
                                if (n[e].name === t)
                                    return n[e];
                            return null
                        }
                        static CreateClipsFromMorphTargetSequences(e, t, n) {
                            const i = {}
                                , r = /^([\w-]*?)([\d]+)$/;
                            for (let t = 0, n = e.length; t < n; t++) {
                                const n = e[t]
                                    , a = n.name.match(r);
                                if (a && a.length > 1) {
                                    const e = a[1];
                                    let t = i[e];
                                    t || (i[e] = t = []),
                                        t.push(n)
                                }
                            }
                            const a = [];
                            for (const e in i)
                                a.push(this.CreateFromMorphTargetSequence(e, i[e], t, n));
                            return a
                        }
                        static parseAnimation(e, t) {
                            if (!e)
                                return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
                                    null;
                            const n = function(e, t, n, i, r) {
                                if (0 !== n.length) {
                                    const a = []
                                        , s = [];
                                    Ys(n, a, s, i),
                                    0 !== a.length && r.push(new e(t,a,s))
                                }
                            }
                                , i = []
                                , r = e.name || "default"
                                , a = e.fps || 30
                                , s = e.blendMode;
                            let o = e.length || -1;
                            const l = e.hierarchy || [];
                            for (let e = 0; e < l.length; e++) {
                                const r = l[e].keys;
                                if (r && 0 !== r.length)
                                    if (r[0].morphTargets) {
                                        const e = {};
                                        let t;
                                        for (t = 0; t < r.length; t++)
                                            if (r[t].morphTargets)
                                                for (let n = 0; n < r[t].morphTargets.length; n++)
                                                    e[r[t].morphTargets[n]] = -1;
                                        for (const n in e) {
                                            const e = []
                                                , a = [];
                                            for (let i = 0; i !== r[t].morphTargets.length; ++i) {
                                                const i = r[t];
                                                e.push(i.time),
                                                    a.push(i.morphTarget === n ? 1 : 0)
                                            }
                                            i.push(new to(".morphTargetInfluence[" + n + "]",e,a))
                                        }
                                        o = e.length * a
                                    } else {
                                        const a = ".bones[" + t[e].name + "]";
                                        n(ao, a + ".position", r, "pos", i),
                                            n(io, a + ".quaternion", r, "rot", i),
                                            n(ao, a + ".scale", r, "scl", i)
                                    }
                            }
                            if (0 === i.length)
                                return null;
                            return new this(r,o,i,s)
                        }
                        resetDuration() {
                            let e = 0;
                            for (let t = 0, n = this.tracks.length; t !== n; ++t) {
                                const n = this.tracks[t];
                                e = Math.max(e, n.times[n.times.length - 1])
                            }
                            return this.duration = e,
                                this
                        }
                        trim() {
                            for (let e = 0; e < this.tracks.length; e++)
                                this.tracks[e].trim(0, this.duration);
                            return this
                        }
                        validate() {
                            let e = !0;
                            for (let t = 0; t < this.tracks.length; t++)
                                e = e && this.tracks[t].validate();
                            return e
                        }
                        optimize() {
                            for (let e = 0; e < this.tracks.length; e++)
                                this.tracks[e].optimize();
                            return this
                        }
                        clone() {
                            const e = [];
                            for (let t = 0; t < this.tracks.length; t++)
                                e.push(this.tracks[t].clone());
                            return new this.constructor(this.name,this.duration,e,this.blendMode)
                        }
                        toJSON() {
                            return this.constructor.toJSON(this)
                        }
                    }
                    function oo(e) {
                        if (void 0 === e.type)
                            throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                        const t = function(e) {
                            switch (e.toLowerCase()) {
                                case "scalar":
                                case "double":
                                case "float":
                                case "number":
                                case "integer":
                                    return to;
                                case "vector":
                                case "vector2":
                                case "vector3":
                                case "vector4":
                                    return ao;
                                case "color":
                                    return eo;
                                case "quaternion":
                                    return io;
                                case "bool":
                                case "boolean":
                                    return $s;
                                case "string":
                                    return ro
                            }
                            throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
                        }(e.type);
                        if (void 0 === e.times) {
                            const t = []
                                , n = [];
                            Ys(e.keys, t, n, "value"),
                                e.times = t,
                                e.values = n
                        }
                        return void 0 !== t.parse ? t.parse(e) : new t(e.name,e.times,e.values,e.interpolation)
                    }
                    const lo = {
                        enabled: !1,
                        files: {},
                        add: function(e, t) {
                            !1 !== this.enabled && (this.files[e] = t)
                        },
                        get: function(e) {
                            if (!1 !== this.enabled)
                                return this.files[e]
                        },
                        remove: function(e) {
                            delete this.files[e]
                        },
                        clear: function() {
                            this.files = {}
                        }
                    };
                    class co {
                        constructor(e, t, n) {
                            const i = this;
                            let r, a = !1, s = 0, o = 0;
                            const l = [];
                            this.onStart = void 0,
                                this.onLoad = e,
                                this.onProgress = t,
                                this.onError = n,
                                this.itemStart = function(e) {
                                    o++,
                                    !1 === a && void 0 !== i.onStart && i.onStart(e, s, o),
                                        a = !0
                                }
                                ,
                                this.itemEnd = function(e) {
                                    s++,
                                    void 0 !== i.onProgress && i.onProgress(e, s, o),
                                    s === o && (a = !1,
                                    void 0 !== i.onLoad && i.onLoad())
                                }
                                ,
                                this.itemError = function(e) {
                                    void 0 !== i.onError && i.onError(e)
                                }
                                ,
                                this.resolveURL = function(e) {
                                    return r ? r(e) : e
                                }
                                ,
                                this.setURLModifier = function(e) {
                                    return r = e,
                                        this
                                }
                                ,
                                this.addHandler = function(e, t) {
                                    return l.push(e, t),
                                        this
                                }
                                ,
                                this.removeHandler = function(e) {
                                    const t = l.indexOf(e);
                                    return -1 !== t && l.splice(t, 2),
                                        this
                                }
                                ,
                                this.getHandler = function(e) {
                                    for (let t = 0, n = l.length; t < n; t += 2) {
                                        const n = l[t]
                                            , i = l[t + 1];
                                        if (n.global && (n.lastIndex = 0),
                                            n.test(e))
                                            return i
                                    }
                                    return null
                                }
                        }
                    }
                    const ho = new co;
                    class uo {
                        constructor(e) {
                            this.manager = void 0 !== e ? e : ho,
                                this.crossOrigin = "anonymous",
                                this.withCredentials = !1,
                                this.path = "",
                                this.resourcePath = "",
                                this.requestHeader = {}
                        }
                        load() {}
                        loadAsync(e, t) {
                            const n = this;
                            return new Promise((function(i, r) {
                                    n.load(e, i, t, r)
                                }
                            ))
                        }
                        parse() {}
                        setCrossOrigin(e) {
                            return this.crossOrigin = e,
                                this
                        }
                        setWithCredentials(e) {
                            return this.withCredentials = e,
                                this
                        }
                        setPath(e) {
                            return this.path = e,
                                this
                        }
                        setResourcePath(e) {
                            return this.resourcePath = e,
                                this
                        }
                        setRequestHeader(e) {
                            return this.requestHeader = e,
                                this
                        }
                    }
                    uo.DEFAULT_MATERIAL_NAME = "__DEFAULT";
                    const po = {};
                    class fo extends Error {
                        constructor(e, t) {
                            super(e),
                                this.response = t
                        }
                    }
                    class mo extends uo {
                        constructor(e) {
                            super(e)
                        }
                        load(e, t, n, i) {
                            void 0 === e && (e = ""),
                            void 0 !== this.path && (e = this.path + e),
                                e = this.manager.resolveURL(e);
                            const r = lo.get(e);
                            if (void 0 !== r)
                                return this.manager.itemStart(e),
                                    setTimeout(( () => {
                                            t && t(r),
                                                this.manager.itemEnd(e)
                                        }
                                    ), 0),
                                    r;
                            if (void 0 !== po[e])
                                return void po[e].push({
                                    onLoad: t,
                                    onProgress: n,
                                    onError: i
                                });
                            po[e] = [],
                                po[e].push({
                                    onLoad: t,
                                    onProgress: n,
                                    onError: i
                                });
                            const a = new Request(e,{
                                headers: new Headers(this.requestHeader),
                                credentials: this.withCredentials ? "include" : "same-origin"
                            })
                                , s = this.mimeType
                                , o = this.responseType;
                            fetch(a).then((t => {
                                    if (200 === t.status || 0 === t.status) {
                                        if (0 === t.status && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                                        "undefined" == typeof ReadableStream || void 0 === t.body || void 0 === t.body.getReader)
                                            return t;
                                        const n = po[e]
                                            , i = t.body.getReader()
                                            , r = t.headers.get("X-File-Size") || t.headers.get("Content-Length")
                                            , a = r ? parseInt(r) : 0
                                            , s = 0 !== a;
                                        let o = 0;
                                        const l = new ReadableStream({
                                            start(e) {
                                                !function t() {
                                                    i.read().then(( ({done: i, value: r}) => {
                                                            if (i)
                                                                e.close();
                                                            else {
                                                                o += r.byteLength;
                                                                const i = new ProgressEvent("progress",{
                                                                    lengthComputable: s,
                                                                    loaded: o,
                                                                    total: a
                                                                });
                                                                for (let e = 0, t = n.length; e < t; e++) {
                                                                    const t = n[e];
                                                                    t.onProgress && t.onProgress(i)
                                                                }
                                                                e.enqueue(r),
                                                                    t()
                                                            }
                                                        }
                                                    ), (t => {
                                                            e.error(t)
                                                        }
                                                    ))
                                                }()
                                            }
                                        });
                                        return new Response(l)
                                    }
                                    throw new fo(`fetch for "${t.url}" responded with ${t.status}: ${t.statusText}`,t)
                                }
                            )).then((e => {
                                    switch (o) {
                                        case "arraybuffer":
                                            return e.arrayBuffer();
                                        case "blob":
                                            return e.blob();
                                        case "document":
                                            return e.text().then((e => (new DOMParser).parseFromString(e, s)));
                                        case "json":
                                            return e.json();
                                        default:
                                            if (void 0 === s)
                                                return e.text();
                                        {
                                            const t = /charset="?([^;"\s]*)"?/i.exec(s)
                                                , n = t && t[1] ? t[1].toLowerCase() : void 0
                                                , i = new TextDecoder(n);
                                            return e.arrayBuffer().then((e => i.decode(e)))
                                        }
                                    }
                                }
                            )).then((t => {
                                    lo.add(e, t);
                                    const n = po[e];
                                    delete po[e];
                                    for (let e = 0, i = n.length; e < i; e++) {
                                        const i = n[e];
                                        i.onLoad && i.onLoad(t)
                                    }
                                }
                            )).catch((t => {
                                    const n = po[e];
                                    if (void 0 === n)
                                        throw this.manager.itemError(e),
                                            t;
                                    delete po[e];
                                    for (let e = 0, i = n.length; e < i; e++) {
                                        const i = n[e];
                                        i.onError && i.onError(t)
                                    }
                                    this.manager.itemError(e)
                                }
                            )).finally(( () => {
                                    this.manager.itemEnd(e)
                                }
                            )),
                                this.manager.itemStart(e)
                        }
                        setResponseType(e) {
                            return this.responseType = e,
                                this
                        }
                        setMimeType(e) {
                            return this.mimeType = e,
                                this
                        }
                    }
                    class go extends uo {
                        constructor(e) {
                            super(e)
                        }
                        load(e, t, n, i) {
                            void 0 !== this.path && (e = this.path + e),
                                e = this.manager.resolveURL(e);
                            const r = this
                                , a = lo.get(e);
                            if (void 0 !== a)
                                return r.manager.itemStart(e),
                                    setTimeout((function() {
                                            t && t(a),
                                                r.manager.itemEnd(e)
                                        }
                                    ), 0),
                                    a;
                            const s = Kt("img");
                            function o() {
                                c(),
                                    lo.add(e, this),
                                t && t(this),
                                    r.manager.itemEnd(e)
                            }
                            function l(t) {
                                c(),
                                i && i(t),
                                    r.manager.itemError(e),
                                    r.manager.itemEnd(e)
                            }
                            function c() {
                                s.removeEventListener("load", o, !1),
                                    s.removeEventListener("error", l, !1)
                            }
                            return s.addEventListener("load", o, !1),
                                s.addEventListener("error", l, !1),
                            "data:" !== e.slice(0, 5) && void 0 !== this.crossOrigin && (s.crossOrigin = this.crossOrigin),
                                r.manager.itemStart(e),
                                s.src = e,
                                s
                        }
                    }
                    class vo extends uo {
                        constructor(e) {
                            super(e)
                        }
                        load(e, t, n, i) {
                            const r = new un
                                , a = new go(this.manager);
                            return a.setCrossOrigin(this.crossOrigin),
                                a.setPath(this.path),
                                a.load(e, (function(e) {
                                        r.image = e,
                                            r.needsUpdate = !0,
                                        void 0 !== t && t(r)
                                    }
                                ), n, i),
                                r
                        }
                    }
                    class wo extends xi {
                        constructor(e, t=1) {
                            super(),
                                this.isLight = !0,
                                this.type = "Light",
                                this.color = new Wi(e),
                                this.intensity = t
                        }
                        dispose() {}
                        copy(e, t) {
                            return super.copy(e, t),
                                this.color.copy(e.color),
                                this.intensity = e.intensity,
                                this
                        }
                        toJSON(e) {
                            const t = super.toJSON(e);
                            return t.object.color = this.color.getHex(),
                                t.object.intensity = this.intensity,
                            void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()),
                            void 0 !== this.distance && (t.object.distance = this.distance),
                            void 0 !== this.angle && (t.object.angle = this.angle),
                            void 0 !== this.decay && (t.object.decay = this.decay),
                            void 0 !== this.penumbra && (t.object.penumbra = this.penumbra),
                            void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()),
                            void 0 !== this.target && (t.object.target = this.target.uuid),
                                t
                        }
                    }
                    class Ao extends wo {
                        constructor(e, t, n) {
                            super(e, n),
                                this.isHemisphereLight = !0,
                                this.type = "HemisphereLight",
                                this.position.copy(xi.DEFAULT_UP),
                                this.updateMatrix(),
                                this.groundColor = new Wi(t)
                        }
                        copy(e, t) {
                            return super.copy(e, t),
                                this.groundColor.copy(e.groundColor),
                                this
                        }
                    }
                    const yo = new Kn
                        , bo = new An
                        , xo = new An;
                    class ko {
                        constructor(e) {
                            this.camera = e,
                                this.intensity = 1,
                                this.bias = 0,
                                this.normalBias = 0,
                                this.radius = 1,
                                this.blurSamples = 8,
                                this.mapSize = new jt(512,512),
                                this.map = null,
                                this.mapPass = null,
                                this.matrix = new Kn,
                                this.autoUpdate = !0,
                                this.needsUpdate = !1,
                                this._frustum = new Aa,
                                this._frameExtents = new jt(1,1),
                                this._viewportCount = 1,
                                this._viewports = [new pn(0,0,1,1)]
                        }
                        getViewportCount() {
                            return this._viewportCount
                        }
                        getFrustum() {
                            return this._frustum
                        }
                        updateMatrices(e) {
                            const t = this.camera
                                , n = this.matrix;
                            bo.setFromMatrixPosition(e.matrixWorld),
                                t.position.copy(bo),
                                xo.setFromMatrixPosition(e.target.matrixWorld),
                                t.lookAt(xo),
                                t.updateMatrixWorld(),
                                yo.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
                                this._frustum.setFromProjectionMatrix(yo),
                                n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
                                n.multiply(yo)
                        }
                        getViewport(e) {
                            return this._viewports[e]
                        }
                        getFrameExtents() {
                            return this._frameExtents
                        }
                        dispose() {
                            this.map && this.map.dispose(),
                            this.mapPass && this.mapPass.dispose()
                        }
                        copy(e) {
                            return this.camera = e.camera.clone(),
                                this.intensity = e.intensity,
                                this.bias = e.bias,
                                this.radius = e.radius,
                                this.mapSize.copy(e.mapSize),
                                this
                        }
                        clone() {
                            return (new this.constructor).copy(this)
                        }
                        toJSON() {
                            const e = {};
                            return 1 !== this.intensity && (e.intensity = this.intensity),
                            0 !== this.bias && (e.bias = this.bias),
                            0 !== this.normalBias && (e.normalBias = this.normalBias),
                            1 !== this.radius && (e.radius = this.radius),
                            512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()),
                                e.camera = this.camera.toJSON(!1).object,
                                delete e.camera.matrix,
                                e
                        }
                    }
                    class Eo extends ko {
                        constructor() {
                            super(new Ir(50,1,.5,500)),
                                this.isSpotLightShadow = !0,
                                this.focus = 1
                        }
                        updateMatrices(e) {
                            const t = this.camera
                                , n = 2 * Ut * e.angle * this.focus
                                , i = this.mapSize.width / this.mapSize.height
                                , r = e.distance || t.far;
                            n === t.fov && i === t.aspect && r === t.far || (t.fov = n,
                                t.aspect = i,
                                t.far = r,
                                t.updateProjectionMatrix()),
                                super.updateMatrices(e)
                        }
                        copy(e) {
                            return super.copy(e),
                                this.focus = e.focus,
                                this
                        }
                    }
                    class So extends wo {
                        constructor(e, t, n=0, i=Math.PI / 3, r=0, a=2) {
                            super(e, t),
                                this.isSpotLight = !0,
                                this.type = "SpotLight",
                                this.position.copy(xi.DEFAULT_UP),
                                this.updateMatrix(),
                                this.target = new xi,
                                this.distance = n,
                                this.angle = i,
                                this.penumbra = r,
                                this.decay = a,
                                this.map = null,
                                this.shadow = new Eo
                        }
                        get power() {
                            return this.intensity * Math.PI
                        }
                        set power(e) {
                            this.intensity = e / Math.PI
                        }
                        dispose() {
                            this.shadow.dispose()
                        }
                        copy(e, t) {
                            return super.copy(e, t),
                                this.distance = e.distance,
                                this.angle = e.angle,
                                this.penumbra = e.penumbra,
                                this.decay = e.decay,
                                this.target = e.target.clone(),
                                this.shadow = e.shadow.clone(),
                                this
                        }
                    }
                    const Mo = new Kn
                        , To = new An
                        , Co = new An;
                    class _o extends ko {
                        constructor() {
                            super(new Ir(90,1,.5,500)),
                                this.isPointLightShadow = !0,
                                this._frameExtents = new jt(4,2),
                                this._viewportCount = 6,
                                this._viewports = [new pn(2,1,1,1), new pn(0,1,1,1), new pn(3,1,1,1), new pn(1,1,1,1), new pn(3,0,1,1), new pn(1,0,1,1)],
                                this._cubeDirections = [new An(1,0,0), new An(-1,0,0), new An(0,0,1), new An(0,0,-1), new An(0,1,0), new An(0,-1,0)],
                                this._cubeUps = [new An(0,1,0), new An(0,1,0), new An(0,1,0), new An(0,1,0), new An(0,0,1), new An(0,0,-1)]
                        }
                        updateMatrices(e, t=0) {
                            const n = this.camera
                                , i = this.matrix
                                , r = e.distance || n.far;
                            r !== n.far && (n.far = r,
                                n.updateProjectionMatrix()),
                                To.setFromMatrixPosition(e.matrixWorld),
                                n.position.copy(To),
                                Co.copy(n.position),
                                Co.add(this._cubeDirections[t]),
                                n.up.copy(this._cubeUps[t]),
                                n.lookAt(Co),
                                n.updateMatrixWorld(),
                                i.makeTranslation(-To.x, -To.y, -To.z),
                                Mo.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
                                this._frustum.setFromProjectionMatrix(Mo)
                        }
                    }
                    class Io extends wo {
                        constructor(e, t, n=0, i=2) {
                            super(e, t),
                                this.isPointLight = !0,
                                this.type = "PointLight",
                                this.distance = n,
                                this.decay = i,
                                this.shadow = new _o
                        }
                        get power() {
                            return 4 * this.intensity * Math.PI
                        }
                        set power(e) {
                            this.intensity = e / (4 * Math.PI)
                        }
                        dispose() {
                            this.shadow.dispose()
                        }
                        copy(e, t) {
                            return super.copy(e, t),
                                this.distance = e.distance,
                                this.decay = e.decay,
                                this.shadow = e.shadow.clone(),
                                this
                        }
                    }
                    class Po extends Mr {
                        constructor(e=-1, t=1, n=1, i=-1, r=.1, a=2e3) {
                            super(),
                                this.isOrthographicCamera = !0,
                                this.type = "OrthographicCamera",
                                this.zoom = 1,
                                this.view = null,
                                this.left = e,
                                this.right = t,
                                this.top = n,
                                this.bottom = i,
                                this.near = r,
                                this.far = a,
                                this.updateProjectionMatrix()
                        }
                        copy(e, t) {
                            return super.copy(e, t),
                                this.left = e.left,
                                this.right = e.right,
                                this.top = e.top,
                                this.bottom = e.bottom,
                                this.near = e.near,
                                this.far = e.far,
                                this.zoom = e.zoom,
                                this.view = null === e.view ? null : Object.assign({}, e.view),
                                this
                        }
                        setViewOffset(e, t, n, i, r, a) {
                            null === this.view && (this.view = {
                                enabled: !0,
                                fullWidth: 1,
                                fullHeight: 1,
                                offsetX: 0,
                                offsetY: 0,
                                width: 1,
                                height: 1
                            }),
                                this.view.enabled = !0,
                                this.view.fullWidth = e,
                                this.view.fullHeight = t,
                                this.view.offsetX = n,
                                this.view.offsetY = i,
                                this.view.width = r,
                                this.view.height = a,
                                this.updateProjectionMatrix()
                        }
                        clearViewOffset() {
                            null !== this.view && (this.view.enabled = !1),
                                this.updateProjectionMatrix()
                        }
                        updateProjectionMatrix() {
                            const e = (this.right - this.left) / (2 * this.zoom)
                                , t = (this.top - this.bottom) / (2 * this.zoom)
                                , n = (this.right + this.left) / 2
                                , i = (this.top + this.bottom) / 2;
                            let r = n - e
                                , a = n + e
                                , s = i + t
                                , o = i - t;
                            if (null !== this.view && this.view.enabled) {
                                const e = (this.right - this.left) / this.view.fullWidth / this.zoom
                                    , t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                                r += e * this.view.offsetX,
                                    a = r + e * this.view.width,
                                    s -= t * this.view.offsetY,
                                    o = s - t * this.view.height
                            }
                            this.projectionMatrix.makeOrthographic(r, a, s, o, this.near, this.far, this.coordinateSystem),
                                this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                        }
                        toJSON(e) {
                            const t = super.toJSON(e);
                            return t.object.zoom = this.zoom,
                                t.object.left = this.left,
                                t.object.right = this.right,
                                t.object.top = this.top,
                                t.object.bottom = this.bottom,
                                t.object.near = this.near,
                                t.object.far = this.far,
                            null !== this.view && (t.object.view = Object.assign({}, this.view)),
                                t
                        }
                    }
                    class Ro extends ko {
                        constructor() {
                            super(new Po(-5,5,5,-5,.5,500)),
                                this.isDirectionalLightShadow = !0
                        }
                    }
                    class Lo extends wo {
                        constructor(e, t) {
                            super(e, t),
                                this.isDirectionalLight = !0,
                                this.type = "DirectionalLight",
                                this.position.copy(xi.DEFAULT_UP),
                                this.updateMatrix(),
                                this.target = new xi,
                                this.shadow = new Ro
                        }
                        dispose() {
                            this.shadow.dispose()
                        }
                        copy(e) {
                            return super.copy(e),
                                this.target = e.target.clone(),
                                this.shadow = e.shadow.clone(),
                                this
                        }
                    }
                    class No {
                        static decodeText(e) {
                            if (console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."),
                            "undefined" != typeof TextDecoder)
                                return (new TextDecoder).decode(e);
                            let t = "";
                            for (let n = 0, i = e.length; n < i; n++)
                                t += String.fromCharCode(e[n]);
                            try {
                                return decodeURIComponent(escape(t))
                            } catch (e) {
                                return t
                            }
                        }
                        static extractUrlBase(e) {
                            const t = e.lastIndexOf("/");
                            return -1 === t ? "./" : e.slice(0, t + 1)
                        }
                        static resolveURL(e, t) {
                            return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
                                /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
                        }
                    }
                    class Do extends uo {
                        constructor(e) {
                            super(e),
                                this.isImageBitmapLoader = !0,
                            "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
                            "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
                                this.options = {
                                    premultiplyAlpha: "none"
                                }
                        }
                        setOptions(e) {
                            return this.options = e,
                                this
                        }
                        load(e, t, n, i) {
                            void 0 === e && (e = ""),
                            void 0 !== this.path && (e = this.path + e),
                                e = this.manager.resolveURL(e);
                            const r = this
                                , a = lo.get(e);
                            if (void 0 !== a)
                                return r.manager.itemStart(e),
                                    a.then ? void a.then((n => {
                                            t && t(n),
                                                r.manager.itemEnd(e)
                                        }
                                    )).catch((e => {
                                            i && i(e)
                                        }
                                    )) : (setTimeout((function() {
                                            t && t(a),
                                                r.manager.itemEnd(e)
                                        }
                                    ), 0),
                                        a);
                            const s = {};
                            s.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include",
                                s.headers = this.requestHeader;
                            const o = fetch(e, s).then((function(e) {
                                    return e.blob()
                                }
                            )).then((function(e) {
                                    return createImageBitmap(e, Object.assign(r.options, {
                                        colorSpaceConversion: "none"
                                    }))
                                }
                            )).then((function(n) {
                                    return lo.add(e, n),
                                    t && t(n),
                                        r.manager.itemEnd(e),
                                        n
                                }
                            )).catch((function(t) {
                                    i && i(t),
                                        lo.remove(e),
                                        r.manager.itemError(e),
                                        r.manager.itemEnd(e)
                                }
                            ));
                            lo.add(e, o),
                                r.manager.itemStart(e)
                        }
                    }
                    class Bo extends Ir {
                        constructor(e=[]) {
                            super(),
                                this.isArrayCamera = !0,
                                this.cameras = e,
                                this.index = 0
                        }
                    }
                    const Uo = "\\[\\]\\.:\\/"
                        , zo = new RegExp("[" + Uo + "]","g")
                        , Oo = "[^" + Uo + "]"
                        , Fo = "[^" + Uo.replace("\\.", "") + "]"
                        , Wo = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", Oo) + /(WCOD+)?/.source.replace("WCOD", Fo) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Oo) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Oo) + "$")
                        , Ho = ["material", "materials", "bones", "map"];
                    class Vo {
                        constructor(e, t, n) {
                            this.path = t,
                                this.parsedPath = n || Vo.parseTrackName(t),
                                this.node = Vo.findNode(e, this.parsedPath.nodeName),
                                this.rootNode = e,
                                this.getValue = this._getValue_unbound,
                                this.setValue = this._setValue_unbound
                        }
                        static create(e, t, n) {
                            return e && e.isAnimationObjectGroup ? new Vo.Composite(e,t,n) : new Vo(e,t,n)
                        }
                        static sanitizeNodeName(e) {
                            return e.replace(/\s/g, "_").replace(zo, "")
                        }
                        static parseTrackName(e) {
                            const t = Wo.exec(e);
                            if (null === t)
                                throw new Error("PropertyBinding: Cannot parse trackName: " + e);
                            const n = {
                                nodeName: t[2],
                                objectName: t[3],
                                objectIndex: t[4],
                                propertyName: t[5],
                                propertyIndex: t[6]
                            }
                                , i = n.nodeName && n.nodeName.lastIndexOf(".");
                            if (void 0 !== i && -1 !== i) {
                                const e = n.nodeName.substring(i + 1);
                                -1 !== Ho.indexOf(e) && (n.nodeName = n.nodeName.substring(0, i),
                                    n.objectName = e)
                            }
                            if (null === n.propertyName || 0 === n.propertyName.length)
                                throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
                            return n
                        }
                        static findNode(e, t) {
                            if (void 0 === t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid)
                                return e;
                            if (e.skeleton) {
                                const n = e.skeleton.getBoneByName(t);
                                if (void 0 !== n)
                                    return n
                            }
                            if (e.children) {
                                const n = function(e) {
                                    for (let i = 0; i < e.length; i++) {
                                        const r = e[i];
                                        if (r.name === t || r.uuid === t)
                                            return r;
                                        const a = n(r.children);
                                        if (a)
                                            return a
                                    }
                                    return null
                                }
                                    , i = n(e.children);
                                if (i)
                                    return i
                            }
                            return null
                        }
                        _getValue_unavailable() {}
                        _setValue_unavailable() {}
                        _getValue_direct(e, t) {
                            e[t] = this.targetObject[this.propertyName]
                        }
                        _getValue_array(e, t) {
                            const n = this.resolvedProperty;
                            for (let i = 0, r = n.length; i !== r; ++i)
                                e[t++] = n[i]
                        }
                        _getValue_arrayElement(e, t) {
                            e[t] = this.resolvedProperty[this.propertyIndex]
                        }
                        _getValue_toArray(e, t) {
                            this.resolvedProperty.toArray(e, t)
                        }
                        _setValue_direct(e, t) {
                            this.targetObject[this.propertyName] = e[t]
                        }
                        _setValue_direct_setNeedsUpdate(e, t) {
                            this.targetObject[this.propertyName] = e[t],
                                this.targetObject.needsUpdate = !0
                        }
                        _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
                            this.targetObject[this.propertyName] = e[t],
                                this.targetObject.matrixWorldNeedsUpdate = !0
                        }
                        _setValue_array(e, t) {
                            const n = this.resolvedProperty;
                            for (let i = 0, r = n.length; i !== r; ++i)
                                n[i] = e[t++]
                        }
                        _setValue_array_setNeedsUpdate(e, t) {
                            const n = this.resolvedProperty;
                            for (let i = 0, r = n.length; i !== r; ++i)
                                n[i] = e[t++];
                            this.targetObject.needsUpdate = !0
                        }
                        _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
                            const n = this.resolvedProperty;
                            for (let i = 0, r = n.length; i !== r; ++i)
                                n[i] = e[t++];
                            this.targetObject.matrixWorldNeedsUpdate = !0
                        }
                        _setValue_arrayElement(e, t) {
                            this.resolvedProperty[this.propertyIndex] = e[t]
                        }
                        _setValue_arrayElement_setNeedsUpdate(e, t) {
                            this.resolvedProperty[this.propertyIndex] = e[t],
                                this.targetObject.needsUpdate = !0
                        }
                        _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
                            this.resolvedProperty[this.propertyIndex] = e[t],
                                this.targetObject.matrixWorldNeedsUpdate = !0
                        }
                        _setValue_fromArray(e, t) {
                            this.resolvedProperty.fromArray(e, t)
                        }
                        _setValue_fromArray_setNeedsUpdate(e, t) {
                            this.resolvedProperty.fromArray(e, t),
                                this.targetObject.needsUpdate = !0
                        }
                        _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
                            this.resolvedProperty.fromArray(e, t),
                                this.targetObject.matrixWorldNeedsUpdate = !0
                        }
                        _getValue_unbound(e, t) {
                            this.bind(),
                                this.getValue(e, t)
                        }
                        _setValue_unbound(e, t) {
                            this.bind(),
                                this.setValue(e, t)
                        }
                        bind() {
                            let e = this.node;
                            const t = this.parsedPath
                                , n = t.objectName
                                , i = t.propertyName;
                            let r = t.propertyIndex;
                            if (e || (e = Vo.findNode(this.rootNode, t.nodeName),
                                this.node = e),
                                this.getValue = this._getValue_unavailable,
                                this.setValue = this._setValue_unavailable,
                                !e)
                                return void console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
                            if (n) {
                                let i = t.objectIndex;
                                switch (n) {
                                    case "materials":
                                        if (!e.material)
                                            return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                        if (!e.material.materials)
                                            return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                        e = e.material.materials;
                                        break;
                                    case "bones":
                                        if (!e.skeleton)
                                            return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                        e = e.skeleton.bones;
                                        for (let t = 0; t < e.length; t++)
                                            if (e[t].name === i) {
                                                i = t;
                                                break
                                            }
                                        break;
                                    case "map":
                                        if ("map"in e) {
                                            e = e.map;
                                            break
                                        }
                                        if (!e.material)
                                            return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                        if (!e.material.map)
                                            return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                                        e = e.material.map;
                                        break;
                                    default:
                                        if (void 0 === e[n])
                                            return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                        e = e[n]
                                }
                                if (void 0 !== i) {
                                    if (void 0 === e[i])
                                        return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                                    e = e[i]
                                }
                            }
                            const a = e[i];
                            if (void 0 === a) {
                                const n = t.nodeName;
                                return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + i + " but it wasn't found.", e)
                            }
                            let s = this.Versioning.None;
                            this.targetObject = e,
                                !0 === e.isMaterial ? s = this.Versioning.NeedsUpdate : !0 === e.isObject3D && (s = this.Versioning.MatrixWorldNeedsUpdate);
                            let o = this.BindingType.Direct;
                            if (void 0 !== r) {
                                if ("morphTargetInfluences" === i) {
                                    if (!e.geometry)
                                        return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                                    if (!e.geometry.morphAttributes)
                                        return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                    void 0 !== e.morphTargetDictionary[r] && (r = e.morphTargetDictionary[r])
                                }
                                o = this.BindingType.ArrayElement,
                                    this.resolvedProperty = a,
                                    this.propertyIndex = r
                            } else
                                void 0 !== a.fromArray && void 0 !== a.toArray ? (o = this.BindingType.HasFromToArray,
                                    this.resolvedProperty = a) : Array.isArray(a) ? (o = this.BindingType.EntireArray,
                                    this.resolvedProperty = a) : this.propertyName = i;
                            this.getValue = this.GetterByBindingType[o],
                                this.setValue = this.SetterByBindingTypeAndVersioning[o][s]
                        }
                        unbind() {
                            this.node = null,
                                this.getValue = this._getValue_unbound,
                                this.setValue = this._setValue_unbound
                        }
                    }
                    Vo.Composite = class {
                        constructor(e, t, n) {
                            const i = n || Vo.parseTrackName(t);
                            this._targetGroup = e,
                                this._bindings = e.subscribe_(t, i)
                        }
                        getValue(e, t) {
                            this.bind();
                            const n = this._targetGroup.nCachedObjects_
                                , i = this._bindings[n];
                            void 0 !== i && i.getValue(e, t)
                        }
                        setValue(e, t) {
                            const n = this._bindings;
                            for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)
                                n[i].setValue(e, t)
                        }
                        bind() {
                            const e = this._bindings;
                            for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
                                e[t].bind()
                        }
                        unbind() {
                            const e = this._bindings;
                            for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
                                e[t].unbind()
                        }
                    }
                        ,
                        Vo.prototype.BindingType = {
                            Direct: 0,
                            EntireArray: 1,
                            ArrayElement: 2,
                            HasFromToArray: 3
                        },
                        Vo.prototype.Versioning = {
                            None: 0,
                            NeedsUpdate: 1,
                            MatrixWorldNeedsUpdate: 2
                        },
                        Vo.prototype.GetterByBindingType = [Vo.prototype._getValue_direct, Vo.prototype._getValue_array, Vo.prototype._getValue_arrayElement, Vo.prototype._getValue_toArray],
                        Vo.prototype.SetterByBindingTypeAndVersioning = [[Vo.prototype._setValue_direct, Vo.prototype._setValue_direct_setNeedsUpdate, Vo.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Vo.prototype._setValue_array, Vo.prototype._setValue_array_setNeedsUpdate, Vo.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Vo.prototype._setValue_arrayElement, Vo.prototype._setValue_arrayElement_setNeedsUpdate, Vo.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Vo.prototype._setValue_fromArray, Vo.prototype._setValue_fromArray_setNeedsUpdate, Vo.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
                    new Float32Array(1);
                    const Go = new Kn;
                    class jo {
                        constructor(e, t, n=0, i=1 / 0) {
                            this.ray = new qn(e,t),
                                this.near = n,
                                this.far = i,
                                this.camera = null,
                                this.layers = new si,
                                this.params = {
                                    Mesh: {},
                                    Line: {
                                        threshold: 1
                                    },
                                    LOD: {},
                                    Points: {
                                        threshold: 1
                                    },
                                    Sprite: {}
                                }
                        }
                        set(e, t) {
                            this.ray.set(e, t)
                        }
                        setFromCamera(e, t) {
                            t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
                                this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(),
                                this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t),
                                this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
                                this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
                        }
                        setFromXRController(e) {
                            return Go.identity().extractRotation(e.matrixWorld),
                                this.ray.origin.setFromMatrixPosition(e.matrixWorld),
                                this.ray.direction.set(0, 0, -1).applyMatrix4(Go),
                                this
                        }
                        intersectObject(e, t=!0, n=[]) {
                            return Yo(e, this, n, t),
                                n.sort(Qo),
                                n
                        }
                        intersectObjects(e, t=!0, n=[]) {
                            for (let i = 0, r = e.length; i < r; i++)
                                Yo(e[i], this, n, t);
                            return n.sort(Qo),
                                n
                        }
                    }
                    function Qo(e, t) {
                        return e.distance - t.distance
                    }
                    function Yo(e, t, n, i) {
                        let r = !0;
                        if (e.layers.test(t.layers)) {
                            !1 === e.raycast(t, n) && (r = !1)
                        }
                        if (!0 === r && !0 === i) {
                            const i = e.children;
                            for (let e = 0, r = i.length; e < r; e++)
                                Yo(i[e], t, n, !0)
                        }
                    }
                    class qo {
                        constructor(e=1, t=0, n=0) {
                            this.radius = e,
                                this.phi = t,
                                this.theta = n
                        }
                        set(e, t, n) {
                            return this.radius = e,
                                this.phi = t,
                                this.theta = n,
                                this
                        }
                        copy(e) {
                            return this.radius = e.radius,
                                this.phi = e.phi,
                                this.theta = e.theta,
                                this
                        }
                        makeSafe() {
                            const e = 1e-6;
                            return this.phi = Ot(this.phi, e, Math.PI - e),
                                this
                        }
                        setFromVector3(e) {
                            return this.setFromCartesianCoords(e.x, e.y, e.z)
                        }
                        setFromCartesianCoords(e, t, n) {
                            return this.radius = Math.sqrt(e * e + t * t + n * n),
                                0 === this.radius ? (this.theta = 0,
                                    this.phi = 0) : (this.theta = Math.atan2(e, n),
                                    this.phi = Math.acos(Ot(t / this.radius, -1, 1))),
                                this
                        }
                        clone() {
                            return (new this.constructor).copy(this)
                        }
                    }
                    class Ko {
                        constructor() {
                            this.type = "ShapePath",
                                this.color = new Wi,
                                this.subPaths = [],
                                this.currentPath = null
                        }
                        moveTo(e, t) {
                            return this.currentPath = new as,
                                this.subPaths.push(this.currentPath),
                                this.currentPath.moveTo(e, t),
                                this
                        }
                        lineTo(e, t) {
                            return this.currentPath.lineTo(e, t),
                                this
                        }
                        quadraticCurveTo(e, t, n, i) {
                            return this.currentPath.quadraticCurveTo(e, t, n, i),
                                this
                        }
                        bezierCurveTo(e, t, n, i, r, a) {
                            return this.currentPath.bezierCurveTo(e, t, n, i, r, a),
                                this
                        }
                        splineThru(e) {
                            return this.currentPath.splineThru(e),
                                this
                        }
                        toShapes(e) {
                            function t(e, t) {
                                const n = t.length;
                                let i = !1;
                                for (let r = n - 1, a = 0; a < n; r = a++) {
                                    let n = t[r]
                                        , s = t[a]
                                        , o = s.x - n.x
                                        , l = s.y - n.y;
                                    if (Math.abs(l) > Number.EPSILON) {
                                        if (l < 0 && (n = t[a],
                                            o = -o,
                                            s = t[r],
                                            l = -l),
                                        e.y < n.y || e.y > s.y)
                                            continue;
                                        if (e.y === n.y) {
                                            if (e.x === n.x)
                                                return !0
                                        } else {
                                            const t = l * (e.x - n.x) - o * (e.y - n.y);
                                            if (0 === t)
                                                return !0;
                                            if (t < 0)
                                                continue;
                                            i = !i
                                        }
                                    } else {
                                        if (e.y !== n.y)
                                            continue;
                                        if (s.x <= e.x && e.x <= n.x || n.x <= e.x && e.x <= s.x)
                                            return !0
                                    }
                                }
                                return i
                            }
                            const n = Rs.isClockWise
                                , i = this.subPaths;
                            if (0 === i.length)
                                return [];
                            let r, a, s;
                            const o = [];
                            if (1 === i.length)
                                return a = i[0],
                                    s = new ss,
                                    s.curves = a.curves,
                                    o.push(s),
                                    o;
                            let l = !n(i[0].getPoints());
                            l = e ? !l : l;
                            const c = []
                                , h = [];
                            let d, u, p = [], f = 0;
                            h[f] = void 0,
                                p[f] = [];
                            for (let t = 0, s = i.length; t < s; t++)
                                a = i[t],
                                    d = a.getPoints(),
                                    r = n(d),
                                    r = e ? !r : r,
                                    r ? (!l && h[f] && f++,
                                        h[f] = {
                                            s: new ss,
                                            p: d
                                        },
                                        h[f].s.curves = a.curves,
                                    l && f++,
                                        p[f] = []) : p[f].push({
                                        h: a,
                                        p: d[0]
                                    });
                            if (!h[0])
                                return function(e) {
                                    const t = [];
                                    for (let n = 0, i = e.length; n < i; n++) {
                                        const i = e[n]
                                            , r = new ss;
                                        r.curves = i.curves,
                                            t.push(r)
                                    }
                                    return t
                                }(i);
                            if (h.length > 1) {
                                let e = !1
                                    , n = 0;
                                for (let e = 0, t = h.length; e < t; e++)
                                    c[e] = [];
                                for (let i = 0, r = h.length; i < r; i++) {
                                    const r = p[i];
                                    for (let a = 0; a < r.length; a++) {
                                        const s = r[a];
                                        let o = !0;
                                        for (let r = 0; r < h.length; r++)
                                            t(s.p, h[r].p) && (i !== r && n++,
                                                o ? (o = !1,
                                                    c[r].push(s)) : e = !0);
                                        o && c[i].push(s)
                                    }
                                }
                                n > 0 && !1 === e && (p = c)
                            }
                            for (let e = 0, t = h.length; e < t; e++) {
                                s = h[e].s,
                                    o.push(s),
                                    u = p[e];
                                for (let e = 0, t = u.length; e < t; e++)
                                    s.holes.push(u[e].h)
                            }
                            return o
                        }
                    }
                    function Xo(e, t, n, i) {
                        const r = function(e) {
                            switch (e) {
                                case pe:
                                case fe:
                                    return {
                                        byteLength: 1,
                                        components: 1
                                    };
                                case ge:
                                case me:
                                case ye:
                                    return {
                                        byteLength: 2,
                                        components: 1
                                    };
                                case be:
                                case xe:
                                    return {
                                        byteLength: 2,
                                        components: 4
                                    };
                                case we:
                                case ve:
                                case Ae:
                                    return {
                                        byteLength: 4,
                                        components: 1
                                    };
                                case Ee:
                                    return {
                                        byteLength: 4,
                                        components: 3
                                    }
                            }
                            throw new Error(`Unknown texture type ${e}.`)
                        }(i);
                        switch (n) {
                            case 1021:
                            case 1024:
                                return e * t;
                            case 1025:
                                return e * t * 2;
                            case Ce:
                            case _e:
                                return e * t / r.components * r.byteLength;
                            case 1030:
                            case Ie:
                                return e * t * 2 / r.components * r.byteLength;
                            case 1022:
                                return e * t * 3 / r.components * r.byteLength;
                            case Se:
                            case Pe:
                                return e * t * 4 / r.components * r.byteLength;
                            case Re:
                            case Le:
                                return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 8;
                            case Ne:
                            case De:
                                return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 16;
                            case Ue:
                            case Oe:
                                return Math.max(e, 16) * Math.max(t, 8) / 4;
                            case Be:
                            case ze:
                                return Math.max(e, 8) * Math.max(t, 8) / 2;
                            case Fe:
                            case We:
                                return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 8;
                            case He:
                            case Ve:
                                return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 16;
                            case Ge:
                                return Math.floor((e + 4) / 5) * Math.floor((t + 3) / 4) * 16;
                            case je:
                                return Math.floor((e + 4) / 5) * Math.floor((t + 4) / 5) * 16;
                            case Qe:
                                return Math.floor((e + 5) / 6) * Math.floor((t + 4) / 5) * 16;
                            case Ye:
                                return Math.floor((e + 5) / 6) * Math.floor((t + 5) / 6) * 16;
                            case qe:
                                return Math.floor((e + 7) / 8) * Math.floor((t + 4) / 5) * 16;
                            case Ke:
                                return Math.floor((e + 7) / 8) * Math.floor((t + 5) / 6) * 16;
                            case Xe:
                                return Math.floor((e + 7) / 8) * Math.floor((t + 7) / 8) * 16;
                            case Ze:
                                return Math.floor((e + 9) / 10) * Math.floor((t + 4) / 5) * 16;
                            case Je:
                                return Math.floor((e + 9) / 10) * Math.floor((t + 5) / 6) * 16;
                            case $e:
                                return Math.floor((e + 9) / 10) * Math.floor((t + 7) / 8) * 16;
                            case et:
                                return Math.floor((e + 9) / 10) * Math.floor((t + 9) / 10) * 16;
                            case tt:
                                return Math.floor((e + 11) / 12) * Math.floor((t + 9) / 10) * 16;
                            case nt:
                                return Math.floor((e + 11) / 12) * Math.floor((t + 11) / 12) * 16;
                            case it:
                            case rt:
                            case at:
                                return Math.ceil(e / 4) * Math.ceil(t / 4) * 16;
                            case 36283:
                            case st:
                                return Math.ceil(e / 4) * Math.ceil(t / 4) * 8;
                            case ot:
                            case lt:
                                return Math.ceil(e / 4) * Math.ceil(t / 4) * 16
                        }
                        throw new Error(`Unable to determine texture byte length for ${n} format.`)
                    }
                    var Zo;
                    "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
                        detail: {
                            revision: m
                        }
                    })),
                    "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = m),
                        function(e) {
                            e[e.ImperialUnitsEnabled = 0] = "ImperialUnitsEnabled",
                                e[e.ResetHintEnabled = 1] = "ResetHintEnabled",
                                e[e.GhostCarEnabled = 2] = "GhostCarEnabled",
                                e[e.DefaultCameraMode = 3] = "DefaultCameraMode",
                                e[e.CockpitCameraToggle = 4] = "CockpitCameraToggle",
                                e[e.Checkpoints = 5] = "Checkpoints",
                                e[e.Timer = 6] = "Timer",
                                e[e.Speedometer = 7] = "Speedometer",
                                e[e.Language = 8] = "Language",
                                e[e.CarShadowQuality = 9] = "CarShadowQuality",
                                e[e.TrackShadowEnabled = 10] = "TrackShadowEnabled",
                                e[e.CloudsEnabled = 11] = "CloudsEnabled",
                                e[e.ParticlesEnabled = 12] = "ParticlesEnabled",
                                e[e.SkidmarksEnabled = 13] = "SkidmarksEnabled",
                                e[e.RenderScale = 14] = "RenderScale",
                                e[e.Antialiasing = 15] = "Antialiasing",
                                e[e.SoundEffectVolume = 16] = "SoundEffectVolume",
                                e[e.MusicVolume = 17] = "MusicVolume",
                                e[e.CheckpointVolume = 18] = "CheckpointVolume"
                        }(Zo || (Zo = {}));
                    const Jo = Zo;
                    var $o, el, tl, nl, il, rl, al, sl, ol, ll, cl = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, hl = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    el = new WeakMap,
                        tl = new WeakMap,
                        nl = new WeakMap,
                        il = new WeakMap,
                        rl = new WeakMap,
                        al = new WeakMap,
                        $o = new WeakSet,
                        sl = function e(t, n) {
                            const i = this.context;
                            if (null == i)
                                n(null);
                            else if (0 == t.length)
                                n(null);
                            else {
                                const r = t[0]
                                    , a = new XMLHttpRequest;
                                a.open("GET", r, !0),
                                    a.responseType = "arraybuffer",
                                    a.onload = () => {
                                        i.decodeAudioData(a.response).then((e => {
                                                n(e)
                                            }
                                        )).catch(( () => {
                                                hl(this, $o, "m", e).call(this, t.slice(1), n)
                                            }
                                        ))
                                    }
                                    ,
                                    a.send()
                            }
                        }
                        ,
                        ol = function(e) {
                            var t;
                            let n = Math.min(Math.max(e.getSettingFloat(Jo.SoundEffectVolume), 0), 1);
                            Number.isNaN(n) && (n = 0),
                                null == hl(this, rl, "f") && null != this.context && null != this.destinationMaster ? (cl(this, rl, this.context.createGain(), "f"),
                                    hl(this, rl, "f").gain.value = n,
                                    hl(this, rl, "f").connect(this.destinationMaster)) : null === (t = hl(this, rl, "f")) || void 0 === t || t.gain.setTargetAtTime(n, 0, .1)
                        }
                        ,
                        ll = function(e, t, n) {
                            if (t && hl(this, el, "f").hasLoaded()) {
                                if (null == hl(this, nl, "f")) {
                                    const e = this.getBuffer("music");
                                    if (null != e && null != this.context && null != this.destinationMaster) {
                                        const t = this.context.createBufferSource();
                                        t.buffer = e,
                                            t.loop = !0;
                                        const n = this.context.createGain();
                                        n.gain.value = 0,
                                            t.connect(n),
                                            n.connect(this.destinationMaster),
                                            t.start(0),
                                            cl(this, nl, {
                                                source: t,
                                                gain: n
                                            }, "f")
                                    }
                                } else {
                                    let e = Math.min(Math.max(n.getSettingFloat(Jo.MusicVolume), 0), 1);
                                    Number.isNaN(e) && (e = 0),
                                        hl(this, nl, "f").gain.gain.setTargetAtTime(.25 * e, 0, .5)
                                }
                                cl(this, il, 0, "f")
                            } else
                                null != hl(this, nl, "f") && (hl(this, nl, "f").gain.gain.setTargetAtTime(0, 0, .5),
                                    hl(this, il, "f") >= 5 ? (hl(this, nl, "f").source.stop(),
                                        cl(this, nl, null, "f")) : cl(this, il, hl(this, il, "f") + e, "f"))
                        }
                    ;
                    const dl = class {
                            constructor(e) {
                                $o.add(this),
                                    el.set(this, void 0),
                                    this.context = null,
                                    tl.set(this, new Map),
                                    nl.set(this, null),
                                    il.set(this, 0),
                                    rl.set(this, null),
                                    al.set(this, null),
                                    cl(this, el, e, "f");
                                try {
                                    const e = new (window.AudioContext || window.webkitAudioContext);
                                    if ("running" != e.state) {
                                        const t = ["click", "contextmenu", "auxclick", "dblclick", "mousedown", "mouseup", "pointerup", "touchend", "keydown", "keyup"]
                                            , n = () => {
                                                e.resume().catch((e => {
                                                        console.error(e)
                                                    }
                                                ));
                                                for (const e of t)
                                                    window.removeEventListener(e, n)
                                            }
                                        ;
                                        for (const e of t)
                                            window.addEventListener(e, n)
                                    }
                                    this.context = e
                                } catch (e) {
                                    this.context = null,
                                        console.error("Failed to create audio context: ", e)
                                }
                                null != this.context ? (cl(this, al, this.context.createGain(), "f"),
                                    hl(this, al, "f").gain.value = 1,
                                    hl(this, al, "f").connect(this.context.destination)) : cl(this, al, null, "f")
                            }
                            get destinationSfx() {
                                return hl(this, rl, "f")
                            }
                            get destinationMaster() {
                                return hl(this, al, "f")
                            }
                            mute() {
                                null != hl(this, al, "f") && hl(this, al, "f").gain.setTargetAtTime(0, 0, .25)
                            }
                            unmute() {
                                null != hl(this, al, "f") && hl(this, al, "f").gain.setTargetAtTime(1, 0, .25)
                            }
                            load(e, t) {
                                hl(this, el, "f").addResource(),
                                    hl(this, $o, "m", sl).call(this, t, (t => {
                                            hl(this, el, "f").loadedResource(),
                                                null == t ? (console.warn('Audio "' + e + '" failed to load'),
                                                    hl(this, tl, "f").set(e, null)) : hl(this, tl, "f").set(e, t)
                                        }
                                    ))
                            }
                            getBuffer(e) {
                                var t;
                                return null == this.context ? null : hl(this, tl, "f").has(e) && null !== (t = hl(this, tl, "f").get(e)) && void 0 !== t ? t : null
                            }
                            playUIClick() {
                                const e = this.getBuffer("click");
                                if (null != e && null != this.context && null != this.destinationSfx) {
                                    const t = this.context.createBufferSource();
                                    t.buffer = e;
                                    const n = this.context.createGain();
                                    n.gain.value = .0075,
                                        t.connect(n),
                                        n.connect(this.destinationSfx),
                                        t.start(0)
                                }
                            }
                            refreshListener(e) {
                                if (null != this.context) {
                                    const t = new An
                                        , n = new wn
                                        , i = new An;
                                    e.camera.matrix.decompose(t, n, i);
                                    const r = this.context.listener;
                                    r.positionX && r.positionY && r.positionZ ? (r.positionX.value = t.x,
                                        r.positionY.value = t.y,
                                        r.positionZ.value = t.z) : r.setPosition(t.x, t.y, t.z);
                                    const a = new An(0,0,-1);
                                    a.applyQuaternion(n);
                                    const s = new An(0,1,0);
                                    s.applyQuaternion(n),
                                        r.forwardX && r.forwardY && r.forwardZ && r.upX && r.upY && r.upZ ? (r.forwardX.value = a.x,
                                            r.forwardY.value = a.y,
                                            r.forwardZ.value = a.z,
                                            r.upX.value = s.x,
                                            r.upY.value = s.y,
                                            r.upZ.value = s.z) : r.setOrientation(a.x, a.y, a.z, s.x, s.y, s.z)
                                }
                            }
                            update(e, t, n, i) {
                                this.refreshListener(n),
                                    hl(this, $o, "m", ol).call(this, i),
                                    hl(this, $o, "m", ll).call(this, e, t, i)
                            }
                        }
                    ;
                    function ul(e, t=!1) {
                        const n = null !== e[0].index
                            , i = new Set(Object.keys(e[0].attributes))
                            , r = new Set(Object.keys(e[0].morphAttributes))
                            , a = {}
                            , s = {}
                            , o = e[0].morphTargetsRelative
                            , l = new sr;
                        let c = 0;
                        for (let h = 0; h < e.length; ++h) {
                            const d = e[h];
                            let u = 0;
                            if (n !== (null !== d.index))
                                return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + h + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),
                                    null;
                            for (const e in d.attributes) {
                                if (!i.has(e))
                                    return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + h + '. All geometries must have compatible attributes; make sure "' + e + '" attribute exists among all geometries, or in none of them.'),
                                        null;
                                void 0 === a[e] && (a[e] = []),
                                    a[e].push(d.attributes[e]),
                                    u++
                            }
                            if (u !== i.size)
                                return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + h + ". Make sure all geometries have the same number of attributes."),
                                    null;
                            if (o !== d.morphTargetsRelative)
                                return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + h + ". .morphTargetsRelative must be consistent throughout all geometries."),
                                    null;
                            for (const e in d.morphAttributes) {
                                if (!r.has(e))
                                    return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + h + ".  .morphAttributes must be consistent throughout all geometries."),
                                        null;
                                void 0 === s[e] && (s[e] = []),
                                    s[e].push(d.morphAttributes[e])
                            }
                            if (t) {
                                let e;
                                if (n)
                                    e = d.index.count;
                                else {
                                    if (void 0 === d.attributes.position)
                                        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + h + ". The geometry must have either an index or a position attribute"),
                                            null;
                                    e = d.attributes.position.count
                                }
                                l.addGroup(c, e, h),
                                    c += e
                            }
                        }
                        if (n) {
                            let t = 0;
                            const n = [];
                            for (let i = 0; i < e.length; ++i) {
                                const r = e[i].index;
                                for (let e = 0; e < r.count; ++e)
                                    n.push(r.getX(e) + t);
                                t += e[i].attributes.position.count
                            }
                            l.setIndex(n)
                        }
                        for (const e in a) {
                            const t = pl(a[e]);
                            if (!t)
                                return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + e + " attribute."),
                                    null;
                            l.setAttribute(e, t)
                        }
                        for (const e in s) {
                            const t = s[e][0].length;
                            if (0 === t)
                                break;
                            l.morphAttributes = l.morphAttributes || {},
                                l.morphAttributes[e] = [];
                            for (let n = 0; n < t; ++n) {
                                const t = [];
                                for (let i = 0; i < s[e].length; ++i)
                                    t.push(s[e][i][n]);
                                const i = pl(t);
                                if (!i)
                                    return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + e + " morphAttribute."),
                                        null;
                                l.morphAttributes[e].push(i)
                            }
                        }
                        return l
                    }
                    function pl(e) {
                        let t, n, i, r = -1, a = 0;
                        for (let s = 0; s < e.length; ++s) {
                            const o = e[s];
                            if (void 0 === t && (t = o.array.constructor),
                            t !== o.array.constructor)
                                return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),
                                    null;
                            if (void 0 === n && (n = o.itemSize),
                            n !== o.itemSize)
                                return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),
                                    null;
                            if (void 0 === i && (i = o.normalized),
                            i !== o.normalized)
                                return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),
                                    null;
                            if (-1 === r && (r = o.gpuType),
                            r !== o.gpuType)
                                return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."),
                                    null;
                            a += o.count * n
                        }
                        const s = new t(a)
                            , o = new Ki(s,n,i);
                        let l = 0;
                        for (let t = 0; t < e.length; ++t) {
                            const i = e[t];
                            if (i.isInterleavedBufferAttribute) {
                                const e = l / n;
                                for (let t = 0, r = i.count; t < r; t++)
                                    for (let r = 0; r < n; r++) {
                                        const n = i.getComponent(t, r);
                                        o.setComponent(t + e, r, n)
                                    }
                            } else
                                s.set(i.array, l);
                            l += i.count * n
                        }
                        return void 0 !== r && (o.gpuType = r),
                            o
                    }
                    function fl(e, t=1e-4) {
                        t = Math.max(t, Number.EPSILON);
                        const n = {}
                            , i = e.getIndex()
                            , r = e.getAttribute("position")
                            , a = i ? i.count : r.count;
                        let s = 0;
                        const o = Object.keys(e.attributes)
                            , l = {}
                            , c = {}
                            , h = []
                            , d = ["getX", "getY", "getZ", "getW"]
                            , u = ["setX", "setY", "setZ", "setW"];
                        for (let t = 0, n = o.length; t < n; t++) {
                            const n = o[t]
                                , i = e.attributes[n];
                            l[n] = new i.constructor(new i.array.constructor(i.count * i.itemSize),i.itemSize,i.normalized);
                            const r = e.morphAttributes[n];
                            r && (c[n] || (c[n] = []),
                                r.forEach(( (e, t) => {
                                        const i = new e.array.constructor(e.count * e.itemSize);
                                        c[n][t] = new e.constructor(i,e.itemSize,e.normalized)
                                    }
                                )))
                        }
                        const p = .5 * t
                            , f = Math.log10(1 / t)
                            , m = Math.pow(10, f)
                            , g = p * m;
                        for (let t = 0; t < a; t++) {
                            const r = i ? i.getX(t) : t;
                            let a = "";
                            for (let t = 0, n = o.length; t < n; t++) {
                                const n = o[t]
                                    , i = e.getAttribute(n)
                                    , s = i.itemSize;
                                for (let e = 0; e < s; e++)
                                    a += ~~(i[d[e]](r) * m + g) + ","
                            }
                            if (a in n)
                                h.push(n[a]);
                            else {
                                for (let t = 0, n = o.length; t < n; t++) {
                                    const n = o[t]
                                        , i = e.getAttribute(n)
                                        , a = e.morphAttributes[n]
                                        , h = i.itemSize
                                        , p = l[n]
                                        , f = c[n];
                                    for (let e = 0; e < h; e++) {
                                        const t = d[e]
                                            , n = u[e];
                                        if (p[n](s, i[t](r)),
                                            a)
                                            for (let e = 0, i = a.length; e < i; e++)
                                                f[e][n](s, a[e][t](r))
                                    }
                                }
                                n[a] = s,
                                    h.push(s),
                                    s++
                            }
                        }
                        const v = e.clone();
                        for (const t in e.attributes) {
                            const e = l[t];
                            if (v.setAttribute(t, new e.constructor(e.array.slice(0, s * e.itemSize),e.itemSize,e.normalized)),
                            t in c)
                                for (let e = 0; e < c[t].length; e++) {
                                    const n = c[t][e];
                                    v.morphAttributes[t][e] = new n.constructor(n.array.slice(0, s * n.itemSize),n.itemSize,n.normalized)
                                }
                        }
                        return v.setIndex(h),
                            v
                    }
                    function ml(e, t) {
                        if (0 === t)
                            return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),
                                e;
                        if (2 === t || 1 === t) {
                            let n = e.getIndex();
                            if (null === n) {
                                const t = []
                                    , i = e.getAttribute("position");
                                if (void 0 === i)
                                    return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),
                                        e;
                                for (let e = 0; e < i.count; e++)
                                    t.push(e);
                                e.setIndex(t),
                                    n = e.getIndex()
                            }
                            const i = n.count - 2
                                , r = [];
                            if (2 === t)
                                for (let e = 1; e <= i; e++)
                                    r.push(n.getX(0)),
                                        r.push(n.getX(e)),
                                        r.push(n.getX(e + 1));
                            else
                                for (let e = 0; e < i; e++)
                                    e % 2 == 0 ? (r.push(n.getX(e)),
                                        r.push(n.getX(e + 1)),
                                        r.push(n.getX(e + 2))) : (r.push(n.getX(e + 2)),
                                        r.push(n.getX(e + 1)),
                                        r.push(n.getX(e)));
                            r.length / 3 !== i && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
                            const a = e.clone();
                            return a.setIndex(r),
                                a.clearGroups(),
                                a
                        }
                        return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", t),
                            e
                    }
                    class gl extends uo {
                        constructor(e) {
                            super(e),
                                this.dracoLoader = null,
                                this.ktx2Loader = null,
                                this.meshoptDecoder = null,
                                this.pluginCallbacks = [],
                                this.register((function(e) {
                                        return new xl(e)
                                    }
                                )),
                                this.register((function(e) {
                                        return new kl(e)
                                    }
                                )),
                                this.register((function(e) {
                                        return new Rl(e)
                                    }
                                )),
                                this.register((function(e) {
                                        return new Ll(e)
                                    }
                                )),
                                this.register((function(e) {
                                        return new Nl(e)
                                    }
                                )),
                                this.register((function(e) {
                                        return new Sl(e)
                                    }
                                )),
                                this.register((function(e) {
                                        return new Ml(e)
                                    }
                                )),
                                this.register((function(e) {
                                        return new Tl(e)
                                    }
                                )),
                                this.register((function(e) {
                                        return new Cl(e)
                                    }
                                )),
                                this.register((function(e) {
                                        return new bl(e)
                                    }
                                )),
                                this.register((function(e) {
                                        return new _l(e)
                                    }
                                )),
                                this.register((function(e) {
                                        return new El(e)
                                    }
                                )),
                                this.register((function(e) {
                                        return new Pl(e)
                                    }
                                )),
                                this.register((function(e) {
                                        return new Il(e)
                                    }
                                )),
                                this.register((function(e) {
                                        return new Al(e)
                                    }
                                )),
                                this.register((function(e) {
                                        return new Dl(e)
                                    }
                                )),
                                this.register((function(e) {
                                        return new Bl(e)
                                    }
                                ))
                        }
                        load(e, t, n, i) {
                            const r = this;
                            let a;
                            if ("" !== this.resourcePath)
                                a = this.resourcePath;
                            else if ("" !== this.path) {
                                const t = No.extractUrlBase(e);
                                a = No.resolveURL(t, this.path)
                            } else
                                a = No.extractUrlBase(e);
                            this.manager.itemStart(e);
                            const s = function(t) {
                                i ? i(t) : console.error(t),
                                    r.manager.itemError(e),
                                    r.manager.itemEnd(e)
                            }
                                , o = new mo(this.manager);
                            o.setPath(this.path),
                                o.setResponseType("arraybuffer"),
                                o.setRequestHeader(this.requestHeader),
                                o.setWithCredentials(this.withCredentials),
                                o.load(e, (function(n) {
                                        try {
                                            r.parse(n, a, (function(n) {
                                                    t(n),
                                                        r.manager.itemEnd(e)
                                                }
                                            ), s)
                                        } catch (e) {
                                            s(e)
                                        }
                                    }
                                ), n, s)
                        }
                        setDRACOLoader(e) {
                            return this.dracoLoader = e,
                                this
                        }
                        setKTX2Loader(e) {
                            return this.ktx2Loader = e,
                                this
                        }
                        setMeshoptDecoder(e) {
                            return this.meshoptDecoder = e,
                                this
                        }
                        register(e) {
                            return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e),
                                this
                        }
                        unregister(e) {
                            return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
                                this
                        }
                        parse(e, t, n, i) {
                            let r;
                            const a = {}
                                , s = {}
                                , o = new TextDecoder;
                            if ("string" == typeof e)
                                r = JSON.parse(e);
                            else if (e instanceof ArrayBuffer) {
                                if (o.decode(new Uint8Array(e,0,4)) === Ul) {
                                    try {
                                        a[wl.KHR_BINARY_GLTF] = new Fl(e)
                                    } catch (e) {
                                        return void (i && i(e))
                                    }
                                    r = JSON.parse(a[wl.KHR_BINARY_GLTF].content)
                                } else
                                    r = JSON.parse(o.decode(e))
                            } else
                                r = e;
                            if (void 0 === r.asset || r.asset.version[0] < 2)
                                return void (i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
                            const l = new dc(r,{
                                path: t || this.resourcePath || "",
                                crossOrigin: this.crossOrigin,
                                requestHeader: this.requestHeader,
                                manager: this.manager,
                                ktx2Loader: this.ktx2Loader,
                                meshoptDecoder: this.meshoptDecoder
                            });
                            l.fileLoader.setRequestHeader(this.requestHeader);
                            for (let e = 0; e < this.pluginCallbacks.length; e++) {
                                const t = this.pluginCallbacks[e](l);
                                t.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),
                                    s[t.name] = t,
                                    a[t.name] = !0
                            }
                            if (r.extensionsUsed)
                                for (let e = 0; e < r.extensionsUsed.length; ++e) {
                                    const t = r.extensionsUsed[e]
                                        , n = r.extensionsRequired || [];
                                    switch (t) {
                                        case wl.KHR_MATERIALS_UNLIT:
                                            a[t] = new yl;
                                            break;
                                        case wl.KHR_DRACO_MESH_COMPRESSION:
                                            a[t] = new Wl(r,this.dracoLoader);
                                            break;
                                        case wl.KHR_TEXTURE_TRANSFORM:
                                            a[t] = new Hl;
                                            break;
                                        case wl.KHR_MESH_QUANTIZATION:
                                            a[t] = new Vl;
                                            break;
                                        default:
                                            n.indexOf(t) >= 0 && void 0 === s[t] && console.warn('THREE.GLTFLoader: Unknown extension "' + t + '".')
                                    }
                                }
                            l.setExtensions(a),
                                l.setPlugins(s),
                                l.parse(n, i)
                        }
                        parseAsync(e, t) {
                            const n = this;
                            return new Promise((function(i, r) {
                                    n.parse(e, t, i, r)
                                }
                            ))
                        }
                    }
                    function vl() {
                        let e = {};
                        return {
                            get: function(t) {
                                return e[t]
                            },
                            add: function(t, n) {
                                e[t] = n
                            },
                            remove: function(t) {
                                delete e[t]
                            },
                            removeAll: function() {
                                e = {}
                            }
                        }
                    }
                    const wl = {
                        KHR_BINARY_GLTF: "KHR_binary_glTF",
                        KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
                        KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
                        KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
                        KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
                        KHR_MATERIALS_IOR: "KHR_materials_ior",
                        KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
                        KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
                        KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
                        KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
                        KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
                        KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
                        KHR_MATERIALS_VOLUME: "KHR_materials_volume",
                        KHR_TEXTURE_BASISU: "KHR_texture_basisu",
                        KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
                        KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
                        KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
                        EXT_MATERIALS_BUMP: "EXT_materials_bump",
                        EXT_TEXTURE_WEBP: "EXT_texture_webp",
                        EXT_TEXTURE_AVIF: "EXT_texture_avif",
                        EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
                        EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
                    };
                    class Al {
                        constructor(e) {
                            this.parser = e,
                                this.name = wl.KHR_LIGHTS_PUNCTUAL,
                                this.cache = {
                                    refs: {},
                                    uses: {}
                                }
                        }
                        _markDefs() {
                            const e = this.parser
                                , t = this.parser.json.nodes || [];
                            for (let n = 0, i = t.length; n < i; n++) {
                                const i = t[n];
                                i.extensions && i.extensions[this.name] && void 0 !== i.extensions[this.name].light && e._addNodeRef(this.cache, i.extensions[this.name].light)
                            }
                        }
                        _loadLight(e) {
                            const t = this.parser
                                , n = "light:" + e;
                            let i = t.cache.get(n);
                            if (i)
                                return i;
                            const r = t.json
                                , a = ((r.extensions && r.extensions[this.name] || {}).lights || [])[e];
                            let s;
                            const o = new Wi(16777215);
                            void 0 !== a.color && o.setRGB(a.color[0], a.color[1], a.color[2], vt);
                            const l = void 0 !== a.range ? a.range : 0;
                            switch (a.type) {
                                case "directional":
                                    s = new Lo(o),
                                        s.target.position.set(0, 0, -1),
                                        s.add(s.target);
                                    break;
                                case "point":
                                    s = new Io(o),
                                        s.distance = l;
                                    break;
                                case "spot":
                                    s = new So(o),
                                        s.distance = l,
                                        a.spot = a.spot || {},
                                        a.spot.innerConeAngle = void 0 !== a.spot.innerConeAngle ? a.spot.innerConeAngle : 0,
                                        a.spot.outerConeAngle = void 0 !== a.spot.outerConeAngle ? a.spot.outerConeAngle : Math.PI / 4,
                                        s.angle = a.spot.outerConeAngle,
                                        s.penumbra = 1 - a.spot.innerConeAngle / a.spot.outerConeAngle,
                                        s.target.position.set(0, 0, -1),
                                        s.add(s.target);
                                    break;
                                default:
                                    throw new Error("THREE.GLTFLoader: Unexpected light type: " + a.type)
                            }
                            return s.position.set(0, 0, 0),
                                ac(s, a),
                            void 0 !== a.intensity && (s.intensity = a.intensity),
                                s.name = t.createUniqueName(a.name || "light_" + e),
                                i = Promise.resolve(s),
                                t.cache.add(n, i),
                                i
                        }
                        getDependency(e, t) {
                            if ("light" === e)
                                return this._loadLight(t)
                        }
                        createNodeAttachment(e) {
                            const t = this
                                , n = this.parser
                                , i = n.json.nodes[e]
                                , r = (i.extensions && i.extensions[this.name] || {}).light;
                            return void 0 === r ? null : this._loadLight(r).then((function(e) {
                                    return n._getNodeRef(t.cache, r, e)
                                }
                            ))
                        }
                    }
                    class yl {
                        constructor() {
                            this.name = wl.KHR_MATERIALS_UNLIT
                        }
                        getMaterialType() {
                            return ji
                        }
                        extendParams(e, t, n) {
                            const i = [];
                            e.color = new Wi(1,1,1),
                                e.opacity = 1;
                            const r = t.pbrMetallicRoughness;
                            if (r) {
                                if (Array.isArray(r.baseColorFactor)) {
                                    const t = r.baseColorFactor;
                                    e.color.setRGB(t[0], t[1], t[2], vt),
                                        e.opacity = t[3]
                                }
                                void 0 !== r.baseColorTexture && i.push(n.assignTexture(e, "map", r.baseColorTexture, gt))
                            }
                            return Promise.all(i)
                        }
                    }
                    class bl {
                        constructor(e) {
                            this.parser = e,
                                this.name = wl.KHR_MATERIALS_EMISSIVE_STRENGTH
                        }
                        extendMaterialParams(e, t) {
                            const n = this.parser.json.materials[e];
                            if (!n.extensions || !n.extensions[this.name])
                                return Promise.resolve();
                            const i = n.extensions[this.name].emissiveStrength;
                            return void 0 !== i && (t.emissiveIntensity = i),
                                Promise.resolve()
                        }
                    }
                    class xl {
                        constructor(e) {
                            this.parser = e,
                                this.name = wl.KHR_MATERIALS_CLEARCOAT
                        }
                        getMaterialType(e) {
                            const t = this.parser.json.materials[e];
                            return t.extensions && t.extensions[this.name] ? Os : null
                        }
                        extendMaterialParams(e, t) {
                            const n = this.parser
                                , i = n.json.materials[e];
                            if (!i.extensions || !i.extensions[this.name])
                                return Promise.resolve();
                            const r = []
                                , a = i.extensions[this.name];
                            if (void 0 !== a.clearcoatFactor && (t.clearcoat = a.clearcoatFactor),
                            void 0 !== a.clearcoatTexture && r.push(n.assignTexture(t, "clearcoatMap", a.clearcoatTexture)),
                            void 0 !== a.clearcoatRoughnessFactor && (t.clearcoatRoughness = a.clearcoatRoughnessFactor),
                            void 0 !== a.clearcoatRoughnessTexture && r.push(n.assignTexture(t, "clearcoatRoughnessMap", a.clearcoatRoughnessTexture)),
                            void 0 !== a.clearcoatNormalTexture && (r.push(n.assignTexture(t, "clearcoatNormalMap", a.clearcoatNormalTexture)),
                            void 0 !== a.clearcoatNormalTexture.scale)) {
                                const e = a.clearcoatNormalTexture.scale;
                                t.clearcoatNormalScale = new jt(e,e)
                            }
                            return Promise.all(r)
                        }
                    }
                    class kl {
                        constructor(e) {
                            this.parser = e,
                                this.name = wl.KHR_MATERIALS_DISPERSION
                        }
                        getMaterialType(e) {
                            const t = this.parser.json.materials[e];
                            return t.extensions && t.extensions[this.name] ? Os : null
                        }
                        extendMaterialParams(e, t) {
                            const n = this.parser.json.materials[e];
                            if (!n.extensions || !n.extensions[this.name])
                                return Promise.resolve();
                            const i = n.extensions[this.name];
                            return t.dispersion = void 0 !== i.dispersion ? i.dispersion : 0,
                                Promise.resolve()
                        }
                    }
                    class El {
                        constructor(e) {
                            this.parser = e,
                                this.name = wl.KHR_MATERIALS_IRIDESCENCE
                        }
                        getMaterialType(e) {
                            const t = this.parser.json.materials[e];
                            return t.extensions && t.extensions[this.name] ? Os : null
                        }
                        extendMaterialParams(e, t) {
                            const n = this.parser
                                , i = n.json.materials[e];
                            if (!i.extensions || !i.extensions[this.name])
                                return Promise.resolve();
                            const r = []
                                , a = i.extensions[this.name];
                            return void 0 !== a.iridescenceFactor && (t.iridescence = a.iridescenceFactor),
                            void 0 !== a.iridescenceTexture && r.push(n.assignTexture(t, "iridescenceMap", a.iridescenceTexture)),
                            void 0 !== a.iridescenceIor && (t.iridescenceIOR = a.iridescenceIor),
                            void 0 === t.iridescenceThicknessRange && (t.iridescenceThicknessRange = [100, 400]),
                            void 0 !== a.iridescenceThicknessMinimum && (t.iridescenceThicknessRange[0] = a.iridescenceThicknessMinimum),
                            void 0 !== a.iridescenceThicknessMaximum && (t.iridescenceThicknessRange[1] = a.iridescenceThicknessMaximum),
                            void 0 !== a.iridescenceThicknessTexture && r.push(n.assignTexture(t, "iridescenceThicknessMap", a.iridescenceThicknessTexture)),
                                Promise.all(r)
                        }
                    }
                    class Sl {
                        constructor(e) {
                            this.parser = e,
                                this.name = wl.KHR_MATERIALS_SHEEN
                        }
                        getMaterialType(e) {
                            const t = this.parser.json.materials[e];
                            return t.extensions && t.extensions[this.name] ? Os : null
                        }
                        extendMaterialParams(e, t) {
                            const n = this.parser
                                , i = n.json.materials[e];
                            if (!i.extensions || !i.extensions[this.name])
                                return Promise.resolve();
                            const r = [];
                            t.sheenColor = new Wi(0,0,0),
                                t.sheenRoughness = 0,
                                t.sheen = 1;
                            const a = i.extensions[this.name];
                            if (void 0 !== a.sheenColorFactor) {
                                const e = a.sheenColorFactor;
                                t.sheenColor.setRGB(e[0], e[1], e[2], vt)
                            }
                            return void 0 !== a.sheenRoughnessFactor && (t.sheenRoughness = a.sheenRoughnessFactor),
                            void 0 !== a.sheenColorTexture && r.push(n.assignTexture(t, "sheenColorMap", a.sheenColorTexture, gt)),
                            void 0 !== a.sheenRoughnessTexture && r.push(n.assignTexture(t, "sheenRoughnessMap", a.sheenRoughnessTexture)),
                                Promise.all(r)
                        }
                    }
                    class Ml {
                        constructor(e) {
                            this.parser = e,
                                this.name = wl.KHR_MATERIALS_TRANSMISSION
                        }
                        getMaterialType(e) {
                            const t = this.parser.json.materials[e];
                            return t.extensions && t.extensions[this.name] ? Os : null
                        }
                        extendMaterialParams(e, t) {
                            const n = this.parser
                                , i = n.json.materials[e];
                            if (!i.extensions || !i.extensions[this.name])
                                return Promise.resolve();
                            const r = []
                                , a = i.extensions[this.name];
                            return void 0 !== a.transmissionFactor && (t.transmission = a.transmissionFactor),
                            void 0 !== a.transmissionTexture && r.push(n.assignTexture(t, "transmissionMap", a.transmissionTexture)),
                                Promise.all(r)
                        }
                    }
                    class Tl {
                        constructor(e) {
                            this.parser = e,
                                this.name = wl.KHR_MATERIALS_VOLUME
                        }
                        getMaterialType(e) {
                            const t = this.parser.json.materials[e];
                            return t.extensions && t.extensions[this.name] ? Os : null
                        }
                        extendMaterialParams(e, t) {
                            const n = this.parser
                                , i = n.json.materials[e];
                            if (!i.extensions || !i.extensions[this.name])
                                return Promise.resolve();
                            const r = []
                                , a = i.extensions[this.name];
                            t.thickness = void 0 !== a.thicknessFactor ? a.thicknessFactor : 0,
                            void 0 !== a.thicknessTexture && r.push(n.assignTexture(t, "thicknessMap", a.thicknessTexture)),
                                t.attenuationDistance = a.attenuationDistance || 1 / 0;
                            const s = a.attenuationColor || [1, 1, 1];
                            return t.attenuationColor = (new Wi).setRGB(s[0], s[1], s[2], vt),
                                Promise.all(r)
                        }
                    }
                    class Cl {
                        constructor(e) {
                            this.parser = e,
                                this.name = wl.KHR_MATERIALS_IOR
                        }
                        getMaterialType(e) {
                            const t = this.parser.json.materials[e];
                            return t.extensions && t.extensions[this.name] ? Os : null
                        }
                        extendMaterialParams(e, t) {
                            const n = this.parser.json.materials[e];
                            if (!n.extensions || !n.extensions[this.name])
                                return Promise.resolve();
                            const i = n.extensions[this.name];
                            return t.ior = void 0 !== i.ior ? i.ior : 1.5,
                                Promise.resolve()
                        }
                    }
                    class _l {
                        constructor(e) {
                            this.parser = e,
                                this.name = wl.KHR_MATERIALS_SPECULAR
                        }
                        getMaterialType(e) {
                            const t = this.parser.json.materials[e];
                            return t.extensions && t.extensions[this.name] ? Os : null
                        }
                        extendMaterialParams(e, t) {
                            const n = this.parser
                                , i = n.json.materials[e];
                            if (!i.extensions || !i.extensions[this.name])
                                return Promise.resolve();
                            const r = []
                                , a = i.extensions[this.name];
                            t.specularIntensity = void 0 !== a.specularFactor ? a.specularFactor : 1,
                            void 0 !== a.specularTexture && r.push(n.assignTexture(t, "specularIntensityMap", a.specularTexture));
                            const s = a.specularColorFactor || [1, 1, 1];
                            return t.specularColor = (new Wi).setRGB(s[0], s[1], s[2], vt),
                            void 0 !== a.specularColorTexture && r.push(n.assignTexture(t, "specularColorMap", a.specularColorTexture, gt)),
                                Promise.all(r)
                        }
                    }
                    class Il {
                        constructor(e) {
                            this.parser = e,
                                this.name = wl.EXT_MATERIALS_BUMP
                        }
                        getMaterialType(e) {
                            const t = this.parser.json.materials[e];
                            return t.extensions && t.extensions[this.name] ? Os : null
                        }
                        extendMaterialParams(e, t) {
                            const n = this.parser
                                , i = n.json.materials[e];
                            if (!i.extensions || !i.extensions[this.name])
                                return Promise.resolve();
                            const r = []
                                , a = i.extensions[this.name];
                            return t.bumpScale = void 0 !== a.bumpFactor ? a.bumpFactor : 1,
                            void 0 !== a.bumpTexture && r.push(n.assignTexture(t, "bumpMap", a.bumpTexture)),
                                Promise.all(r)
                        }
                    }
                    class Pl {
                        constructor(e) {
                            this.parser = e,
                                this.name = wl.KHR_MATERIALS_ANISOTROPY
                        }
                        getMaterialType(e) {
                            const t = this.parser.json.materials[e];
                            return t.extensions && t.extensions[this.name] ? Os : null
                        }
                        extendMaterialParams(e, t) {
                            const n = this.parser
                                , i = n.json.materials[e];
                            if (!i.extensions || !i.extensions[this.name])
                                return Promise.resolve();
                            const r = []
                                , a = i.extensions[this.name];
                            return void 0 !== a.anisotropyStrength && (t.anisotropy = a.anisotropyStrength),
                            void 0 !== a.anisotropyRotation && (t.anisotropyRotation = a.anisotropyRotation),
                            void 0 !== a.anisotropyTexture && r.push(n.assignTexture(t, "anisotropyMap", a.anisotropyTexture)),
                                Promise.all(r)
                        }
                    }
                    class Rl {
                        constructor(e) {
                            this.parser = e,
                                this.name = wl.KHR_TEXTURE_BASISU
                        }
                        loadTexture(e) {
                            const t = this.parser
                                , n = t.json
                                , i = n.textures[e];
                            if (!i.extensions || !i.extensions[this.name])
                                return null;
                            const r = i.extensions[this.name]
                                , a = t.options.ktx2Loader;
                            if (!a) {
                                if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
                                    throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                                return null
                            }
                            return t.loadTextureImage(e, r.source, a)
                        }
                    }
                    class Ll {
                        constructor(e) {
                            this.parser = e,
                                this.name = wl.EXT_TEXTURE_WEBP,
                                this.isSupported = null
                        }
                        loadTexture(e) {
                            const t = this.name
                                , n = this.parser
                                , i = n.json
                                , r = i.textures[e];
                            if (!r.extensions || !r.extensions[t])
                                return null;
                            const a = r.extensions[t]
                                , s = i.images[a.source];
                            let o = n.textureLoader;
                            if (s.uri) {
                                const e = n.options.manager.getHandler(s.uri);
                                null !== e && (o = e)
                            }
                            return this.detectSupport().then((function(r) {
                                    if (r)
                                        return n.loadTextureImage(e, a.source, o);
                                    if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
                                        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                                    return n.loadTexture(e)
                                }
                            ))
                        }
                        detectSupport() {
                            return this.isSupported || (this.isSupported = new Promise((function(e) {
                                    const t = new Image;
                                    t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",
                                        t.onload = t.onerror = function() {
                                            e(1 === t.height)
                                        }
                                }
                            ))),
                                this.isSupported
                        }
                    }
                    class Nl {
                        constructor(e) {
                            this.parser = e,
                                this.name = wl.EXT_TEXTURE_AVIF,
                                this.isSupported = null
                        }
                        loadTexture(e) {
                            const t = this.name
                                , n = this.parser
                                , i = n.json
                                , r = i.textures[e];
                            if (!r.extensions || !r.extensions[t])
                                return null;
                            const a = r.extensions[t]
                                , s = i.images[a.source];
                            let o = n.textureLoader;
                            if (s.uri) {
                                const e = n.options.manager.getHandler(s.uri);
                                null !== e && (o = e)
                            }
                            return this.detectSupport().then((function(r) {
                                    if (r)
                                        return n.loadTextureImage(e, a.source, o);
                                    if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
                                        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
                                    return n.loadTexture(e)
                                }
                            ))
                        }
                        detectSupport() {
                            return this.isSupported || (this.isSupported = new Promise((function(e) {
                                    const t = new Image;
                                    t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",
                                        t.onload = t.onerror = function() {
                                            e(1 === t.height)
                                        }
                                }
                            ))),
                                this.isSupported
                        }
                    }
                    class Dl {
                        constructor(e) {
                            this.name = wl.EXT_MESHOPT_COMPRESSION,
                                this.parser = e
                        }
                        loadBufferView(e) {
                            const t = this.parser.json
                                , n = t.bufferViews[e];
                            if (n.extensions && n.extensions[this.name]) {
                                const e = n.extensions[this.name]
                                    , i = this.parser.getDependency("buffer", e.buffer)
                                    , r = this.parser.options.meshoptDecoder;
                                if (!r || !r.supported) {
                                    if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
                                        throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                                    return null
                                }
                                return i.then((function(t) {
                                        const n = e.byteOffset || 0
                                            , i = e.byteLength || 0
                                            , a = e.count
                                            , s = e.byteStride
                                            , o = new Uint8Array(t,n,i);
                                        return r.decodeGltfBufferAsync ? r.decodeGltfBufferAsync(a, s, o, e.mode, e.filter).then((function(e) {
                                                return e.buffer
                                            }
                                        )) : r.ready.then((function() {
                                                const t = new ArrayBuffer(a * s);
                                                return r.decodeGltfBuffer(new Uint8Array(t), a, s, o, e.mode, e.filter),
                                                    t
                                            }
                                        ))
                                    }
                                ))
                            }
                            return null
                        }
                    }
                    class Bl {
                        constructor(e) {
                            this.name = wl.EXT_MESH_GPU_INSTANCING,
                                this.parser = e
                        }
                        createNodeMesh(e) {
                            const t = this.parser.json
                                , n = t.nodes[e];
                            if (!n.extensions || !n.extensions[this.name] || void 0 === n.mesh)
                                return null;
                            const i = t.meshes[n.mesh];
                            for (const e of i.primitives)
                                if (e.mode !== Yl.TRIANGLES && e.mode !== Yl.TRIANGLE_STRIP && e.mode !== Yl.TRIANGLE_FAN && void 0 !== e.mode)
                                    return null;
                            const r = n.extensions[this.name].attributes
                                , a = []
                                , s = {};
                            for (const e in r)
                                a.push(this.parser.getDependency("accessor", r[e]).then((t => (s[e] = t,
                                    s[e]))));
                            return a.length < 1 ? null : (a.push(this.parser.createNodeMesh(e)),
                                Promise.all(a).then((e => {
                                        const t = e.pop()
                                            , n = t.isGroup ? t.children : [t]
                                            , i = e[0].count
                                            , r = [];
                                        for (const e of n) {
                                            const t = new Kn
                                                , n = new An
                                                , a = new wn
                                                , o = new An(1,1,1)
                                                , l = new ua(e.geometry,e.material,i);
                                            for (let e = 0; e < i; e++)
                                                s.TRANSLATION && n.fromBufferAttribute(s.TRANSLATION, e),
                                                s.ROTATION && a.fromBufferAttribute(s.ROTATION, e),
                                                s.SCALE && o.fromBufferAttribute(s.SCALE, e),
                                                    l.setMatrixAt(e, t.compose(n, a, o));
                                            for (const t in s)
                                                if ("_COLOR_0" === t) {
                                                    const e = s[t];
                                                    l.instanceColor = new ra(e.array,e.itemSize,e.normalized)
                                                } else
                                                    "TRANSLATION" !== t && "ROTATION" !== t && "SCALE" !== t && e.geometry.setAttribute(t, s[t]);
                                            xi.prototype.copy.call(l, e),
                                                this.parser.assignFinalMaterial(l),
                                                r.push(l)
                                        }
                                        return t.isGroup ? (t.clear(),
                                            t.add(...r),
                                            t) : r[0]
                                    }
                                )))
                        }
                    }
                    const Ul = "glTF"
                        , zl = 1313821514
                        , Ol = 5130562;
                    class Fl {
                        constructor(e) {
                            this.name = wl.KHR_BINARY_GLTF,
                                this.content = null,
                                this.body = null;
                            const t = new DataView(e,0,12)
                                , n = new TextDecoder;
                            if (this.header = {
                                magic: n.decode(new Uint8Array(e.slice(0, 4))),
                                version: t.getUint32(4, !0),
                                length: t.getUint32(8, !0)
                            },
                            this.header.magic !== Ul)
                                throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
                            if (this.header.version < 2)
                                throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
                            const i = this.header.length - 12
                                , r = new DataView(e,12);
                            let a = 0;
                            for (; a < i; ) {
                                const t = r.getUint32(a, !0);
                                a += 4;
                                const i = r.getUint32(a, !0);
                                if (a += 4,
                                i === zl) {
                                    const i = new Uint8Array(e,12 + a,t);
                                    this.content = n.decode(i)
                                } else if (i === Ol) {
                                    const n = 12 + a;
                                    this.body = e.slice(n, n + t)
                                }
                                a += t
                            }
                            if (null === this.content)
                                throw new Error("THREE.GLTFLoader: JSON content not found.")
                        }
                    }
                    class Wl {
                        constructor(e, t) {
                            if (!t)
                                throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
                            this.name = wl.KHR_DRACO_MESH_COMPRESSION,
                                this.json = e,
                                this.dracoLoader = t,
                                this.dracoLoader.preload()
                        }
                        decodePrimitive(e, t) {
                            const n = this.json
                                , i = this.dracoLoader
                                , r = e.extensions[this.name].bufferView
                                , a = e.extensions[this.name].attributes
                                , s = {}
                                , o = {}
                                , l = {};
                            for (const e in a) {
                                const t = Jl[e] || e.toLowerCase();
                                s[t] = a[e]
                            }
                            for (const t in e.attributes) {
                                const i = Jl[t] || t.toLowerCase();
                                if (void 0 !== a[t]) {
                                    const r = n.accessors[e.attributes[t]]
                                        , a = ql[r.componentType];
                                    l[i] = a.name,
                                        o[i] = !0 === r.normalized
                                }
                            }
                            return t.getDependency("bufferView", r).then((function(e) {
                                    return new Promise((function(t, n) {
                                            i.decodeDracoFile(e, (function(e) {
                                                    for (const t in e.attributes) {
                                                        const n = e.attributes[t]
                                                            , i = o[t];
                                                        void 0 !== i && (n.normalized = i)
                                                    }
                                                    t(e)
                                                }
                                            ), s, l, vt, n)
                                        }
                                    ))
                                }
                            ))
                        }
                    }
                    class Hl {
                        constructor() {
                            this.name = wl.KHR_TEXTURE_TRANSFORM
                        }
                        extendTexture(e, t) {
                            return void 0 !== t.texCoord && t.texCoord !== e.channel || void 0 !== t.offset || void 0 !== t.rotation || void 0 !== t.scale ? (e = e.clone(),
                            void 0 !== t.texCoord && (e.channel = t.texCoord),
                            void 0 !== t.offset && e.offset.fromArray(t.offset),
                            void 0 !== t.rotation && (e.rotation = t.rotation),
                            void 0 !== t.scale && e.repeat.fromArray(t.scale),
                                e.needsUpdate = !0,
                                e) : e
                        }
                    }
                    class Vl {
                        constructor() {
                            this.name = wl.KHR_MESH_QUANTIZATION
                        }
                    }
                    class Gl extends qs {
                        constructor(e, t, n, i) {
                            super(e, t, n, i)
                        }
                        copySampleValue_(e) {
                            const t = this.resultBuffer
                                , n = this.sampleValues
                                , i = this.valueSize
                                , r = e * i * 3 + i;
                            for (let e = 0; e !== i; e++)
                                t[e] = n[r + e];
                            return t
                        }
                        interpolate_(e, t, n, i) {
                            const r = this.resultBuffer
                                , a = this.sampleValues
                                , s = this.valueSize
                                , o = 2 * s
                                , l = 3 * s
                                , c = i - t
                                , h = (n - t) / c
                                , d = h * h
                                , u = d * h
                                , p = e * l
                                , f = p - l
                                , m = -2 * u + 3 * d
                                , g = u - d
                                , v = 1 - m
                                , w = g - d + h;
                            for (let e = 0; e !== s; e++) {
                                const t = a[f + e + s]
                                    , n = a[f + e + o] * c
                                    , i = a[p + e + s]
                                    , l = a[p + e] * c;
                                r[e] = v * t + w * n + m * i + g * l
                            }
                            return r
                        }
                    }
                    const jl = new wn;
                    class Ql extends Gl {
                        interpolate_(e, t, n, i) {
                            const r = super.interpolate_(e, t, n, i);
                            return jl.fromArray(r).normalize().toArray(r),
                                r
                        }
                    }
                    const Yl = {
                        FLOAT: 5126,
                        FLOAT_MAT3: 35675,
                        FLOAT_MAT4: 35676,
                        FLOAT_VEC2: 35664,
                        FLOAT_VEC3: 35665,
                        FLOAT_VEC4: 35666,
                        LINEAR: 9729,
                        REPEAT: 10497,
                        SAMPLER_2D: 35678,
                        POINTS: 0,
                        LINES: 1,
                        LINE_LOOP: 2,
                        LINE_STRIP: 3,
                        TRIANGLES: 4,
                        TRIANGLE_STRIP: 5,
                        TRIANGLE_FAN: 6,
                        UNSIGNED_BYTE: 5121,
                        UNSIGNED_SHORT: 5123
                    }
                        , ql = {
                        5120: Int8Array,
                        5121: Uint8Array,
                        5122: Int16Array,
                        5123: Uint16Array,
                        5125: Uint32Array,
                        5126: Float32Array
                    }
                        , Kl = {
                        9728: oe,
                        9729: he,
                        9984: le,
                        9985: de,
                        9986: ce,
                        9987: ue
                    }
                        , Xl = {
                        33071: ae,
                        33648: se,
                        10497: re
                    }
                        , Zl = {
                        SCALAR: 1,
                        VEC2: 2,
                        VEC3: 3,
                        VEC4: 4,
                        MAT2: 4,
                        MAT3: 9,
                        MAT4: 16
                    }
                        , Jl = {
                        POSITION: "position",
                        NORMAL: "normal",
                        TANGENT: "tangent",
                        TEXCOORD_0: "uv",
                        TEXCOORD_1: "uv1",
                        TEXCOORD_2: "uv2",
                        TEXCOORD_3: "uv3",
                        COLOR_0: "color",
                        WEIGHTS_0: "skinWeight",
                        JOINTS_0: "skinIndex"
                    }
                        , $l = {
                        scale: "scale",
                        translation: "position",
                        rotation: "quaternion",
                        weights: "morphTargetInfluences"
                    }
                        , ec = {
                        CUBICSPLINE: void 0,
                        LINEAR: ht,
                        STEP: ct
                    }
                        , tc = "OPAQUE"
                        , nc = "MASK"
                        , ic = "BLEND";
                    function rc(e, t, n) {
                        for (const i in n.extensions)
                            void 0 === e[i] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {},
                                t.userData.gltfExtensions[i] = n.extensions[i])
                    }
                    function ac(e, t) {
                        void 0 !== t.extras && ("object" == typeof t.extras ? Object.assign(e.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras))
                    }
                    function sc(e, t) {
                        if (e.updateMorphTargets(),
                        void 0 !== t.weights)
                            for (let n = 0, i = t.weights.length; n < i; n++)
                                e.morphTargetInfluences[n] = t.weights[n];
                        if (t.extras && Array.isArray(t.extras.targetNames)) {
                            const n = t.extras.targetNames;
                            if (e.morphTargetInfluences.length === n.length) {
                                e.morphTargetDictionary = {};
                                for (let t = 0, i = n.length; t < i; t++)
                                    e.morphTargetDictionary[n[t]] = t
                            } else
                                console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
                        }
                    }
                    function oc(e) {
                        let t;
                        const n = e.extensions && e.extensions[wl.KHR_DRACO_MESH_COMPRESSION];
                        if (t = n ? "draco:" + n.bufferView + ":" + n.indices + ":" + lc(n.attributes) : e.indices + ":" + lc(e.attributes) + ":" + e.mode,
                        void 0 !== e.targets)
                            for (let n = 0, i = e.targets.length; n < i; n++)
                                t += ":" + lc(e.targets[n]);
                        return t
                    }
                    function lc(e) {
                        let t = "";
                        const n = Object.keys(e).sort();
                        for (let i = 0, r = n.length; i < r; i++)
                            t += n[i] + ":" + e[n[i]] + ";";
                        return t
                    }
                    function cc(e) {
                        switch (e) {
                            case Int8Array:
                                return 1 / 127;
                            case Uint8Array:
                                return 1 / 255;
                            case Int16Array:
                                return 1 / 32767;
                            case Uint16Array:
                                return 1 / 65535;
                            default:
                                throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
                        }
                    }
                    const hc = new Kn;
                    class dc {
                        constructor(e={}, t={}) {
                            this.json = e,
                                this.extensions = {},
                                this.plugins = {},
                                this.options = t,
                                this.cache = new vl,
                                this.associations = new Map,
                                this.primitiveCache = {},
                                this.nodeCache = {},
                                this.meshCache = {
                                    refs: {},
                                    uses: {}
                                },
                                this.cameraCache = {
                                    refs: {},
                                    uses: {}
                                },
                                this.lightCache = {
                                    refs: {},
                                    uses: {}
                                },
                                this.sourceCache = {},
                                this.textureCache = {},
                                this.nodeNamesUsed = {};
                            let n = !1
                                , i = -1
                                , r = !1
                                , a = -1;
                            if ("undefined" != typeof navigator) {
                                const e = navigator.userAgent;
                                n = !0 === /^((?!chrome|android).)*safari/i.test(e);
                                const t = e.match(/Version\/(\d+)/);
                                i = n && t ? parseInt(t[1], 10) : -1,
                                    r = e.indexOf("Firefox") > -1,
                                    a = r ? e.match(/Firefox\/([0-9]+)\./)[1] : -1
                            }
                            "undefined" == typeof createImageBitmap || n && i < 17 || r && a < 98 ? this.textureLoader = new vo(this.options.manager) : this.textureLoader = new Do(this.options.manager),
                                this.textureLoader.setCrossOrigin(this.options.crossOrigin),
                                this.textureLoader.setRequestHeader(this.options.requestHeader),
                                this.fileLoader = new mo(this.options.manager),
                                this.fileLoader.setResponseType("arraybuffer"),
                            "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
                        }
                        setExtensions(e) {
                            this.extensions = e
                        }
                        setPlugins(e) {
                            this.plugins = e
                        }
                        parse(e, t) {
                            const n = this
                                , i = this.json
                                , r = this.extensions;
                            this.cache.removeAll(),
                                this.nodeCache = {},
                                this._invokeAll((function(e) {
                                        return e._markDefs && e._markDefs()
                                    }
                                )),
                                Promise.all(this._invokeAll((function(e) {
                                        return e.beforeRoot && e.beforeRoot()
                                    }
                                ))).then((function() {
                                        return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
                                    }
                                )).then((function(t) {
                                        const a = {
                                            scene: t[0][i.scene || 0],
                                            scenes: t[0],
                                            animations: t[1],
                                            cameras: t[2],
                                            asset: i.asset,
                                            parser: n,
                                            userData: {}
                                        };
                                        return rc(r, a, i),
                                            ac(a, i),
                                            Promise.all(n._invokeAll((function(e) {
                                                    return e.afterRoot && e.afterRoot(a)
                                                }
                                            ))).then((function() {
                                                    for (const e of a.scenes)
                                                        e.updateMatrixWorld();
                                                    e(a)
                                                }
                                            ))
                                    }
                                )).catch(t)
                        }
                        _markDefs() {
                            const e = this.json.nodes || []
                                , t = this.json.skins || []
                                , n = this.json.meshes || [];
                            for (let n = 0, i = t.length; n < i; n++) {
                                const i = t[n].joints;
                                for (let t = 0, n = i.length; t < n; t++)
                                    e[i[t]].isBone = !0
                            }
                            for (let t = 0, i = e.length; t < i; t++) {
                                const i = e[t];
                                void 0 !== i.mesh && (this._addNodeRef(this.meshCache, i.mesh),
                                void 0 !== i.skin && (n[i.mesh].isSkinnedMesh = !0)),
                                void 0 !== i.camera && this._addNodeRef(this.cameraCache, i.camera)
                            }
                        }
                        _addNodeRef(e, t) {
                            void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0),
                                e.refs[t]++)
                        }
                        _getNodeRef(e, t, n) {
                            if (e.refs[t] <= 1)
                                return n;
                            const i = n.clone()
                                , r = (e, t) => {
                                    const n = this.associations.get(e);
                                    null != n && this.associations.set(t, n);
                                    for (const [n,i] of e.children.entries())
                                        r(i, t.children[n])
                                }
                            ;
                            return r(n, i),
                                i.name += "_instance_" + e.uses[t]++,
                                i
                        }
                        _invokeOne(e) {
                            const t = Object.values(this.plugins);
                            t.push(this);
                            for (let n = 0; n < t.length; n++) {
                                const i = e(t[n]);
                                if (i)
                                    return i
                            }
                            return null
                        }
                        _invokeAll(e) {
                            const t = Object.values(this.plugins);
                            t.unshift(this);
                            const n = [];
                            for (let i = 0; i < t.length; i++) {
                                const r = e(t[i]);
                                r && n.push(r)
                            }
                            return n
                        }
                        getDependency(e, t) {
                            const n = e + ":" + t;
                            let i = this.cache.get(n);
                            if (!i) {
                                switch (e) {
                                    case "scene":
                                        i = this.loadScene(t);
                                        break;
                                    case "node":
                                        i = this._invokeOne((function(e) {
                                                return e.loadNode && e.loadNode(t)
                                            }
                                        ));
                                        break;
                                    case "mesh":
                                        i = this._invokeOne((function(e) {
                                                return e.loadMesh && e.loadMesh(t)
                                            }
                                        ));
                                        break;
                                    case "accessor":
                                        i = this.loadAccessor(t);
                                        break;
                                    case "bufferView":
                                        i = this._invokeOne((function(e) {
                                                return e.loadBufferView && e.loadBufferView(t)
                                            }
                                        ));
                                        break;
                                    case "buffer":
                                        i = this.loadBuffer(t);
                                        break;
                                    case "material":
                                        i = this._invokeOne((function(e) {
                                                return e.loadMaterial && e.loadMaterial(t)
                                            }
                                        ));
                                        break;
                                    case "texture":
                                        i = this._invokeOne((function(e) {
                                                return e.loadTexture && e.loadTexture(t)
                                            }
                                        ));
                                        break;
                                    case "skin":
                                        i = this.loadSkin(t);
                                        break;
                                    case "animation":
                                        i = this._invokeOne((function(e) {
                                                return e.loadAnimation && e.loadAnimation(t)
                                            }
                                        ));
                                        break;
                                    case "camera":
                                        i = this.loadCamera(t);
                                        break;
                                    default:
                                        if (i = this._invokeOne((function(n) {
                                                return n != this && n.getDependency && n.getDependency(e, t)
                                            }
                                        )),
                                            !i)
                                            throw new Error("Unknown type: " + e)
                                }
                                this.cache.add(n, i)
                            }
                            return i
                        }
                        getDependencies(e) {
                            let t = this.cache.get(e);
                            if (!t) {
                                const n = this
                                    , i = this.json[e + ("mesh" === e ? "es" : "s")] || [];
                                t = Promise.all(i.map((function(t, i) {
                                        return n.getDependency(e, i)
                                    }
                                ))),
                                    this.cache.add(e, t)
                            }
                            return t
                        }
                        loadBuffer(e) {
                            const t = this.json.buffers[e]
                                , n = this.fileLoader;
                            if (t.type && "arraybuffer" !== t.type)
                                throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
                            if (void 0 === t.uri && 0 === e)
                                return Promise.resolve(this.extensions[wl.KHR_BINARY_GLTF].body);
                            const i = this.options;
                            return new Promise((function(e, r) {
                                    n.load(No.resolveURL(t.uri, i.path), e, void 0, (function() {
                                            r(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
                                        }
                                    ))
                                }
                            ))
                        }
                        loadBufferView(e) {
                            const t = this.json.bufferViews[e];
                            return this.getDependency("buffer", t.buffer).then((function(e) {
                                    const n = t.byteLength || 0
                                        , i = t.byteOffset || 0;
                                    return e.slice(i, i + n)
                                }
                            ))
                        }
                        loadAccessor(e) {
                            const t = this
                                , n = this.json
                                , i = this.json.accessors[e];
                            if (void 0 === i.bufferView && void 0 === i.sparse) {
                                const e = Zl[i.type]
                                    , t = ql[i.componentType]
                                    , n = !0 === i.normalized
                                    , r = new t(i.count * e);
                                return Promise.resolve(new Ki(r,e,n))
                            }
                            const r = [];
                            return void 0 !== i.bufferView ? r.push(this.getDependency("bufferView", i.bufferView)) : r.push(null),
                            void 0 !== i.sparse && (r.push(this.getDependency("bufferView", i.sparse.indices.bufferView)),
                                r.push(this.getDependency("bufferView", i.sparse.values.bufferView))),
                                Promise.all(r).then((function(e) {
                                        const r = e[0]
                                            , a = Zl[i.type]
                                            , s = ql[i.componentType]
                                            , o = s.BYTES_PER_ELEMENT
                                            , l = o * a
                                            , c = i.byteOffset || 0
                                            , h = void 0 !== i.bufferView ? n.bufferViews[i.bufferView].byteStride : void 0
                                            , d = !0 === i.normalized;
                                        let u, p;
                                        if (h && h !== l) {
                                            const e = Math.floor(c / h)
                                                , n = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + e + ":" + i.count;
                                            let l = t.cache.get(n);
                                            l || (u = new s(r,e * h,i.count * h / o),
                                                l = new Fr(u,h / o),
                                                t.cache.add(n, l)),
                                                p = new Hr(l,a,c % h / o,d)
                                        } else
                                            u = null === r ? new s(i.count * a) : new s(r,c,i.count * a),
                                                p = new Ki(u,a,d);
                                        if (void 0 !== i.sparse) {
                                            const t = Zl.SCALAR
                                                , n = ql[i.sparse.indices.componentType]
                                                , o = i.sparse.indices.byteOffset || 0
                                                , l = i.sparse.values.byteOffset || 0
                                                , c = new n(e[1],o,i.sparse.count * t)
                                                , h = new s(e[2],l,i.sparse.count * a);
                                            null !== r && (p = new Ki(p.array.slice(),p.itemSize,p.normalized)),
                                                p.normalized = !1;
                                            for (let e = 0, t = c.length; e < t; e++) {
                                                const t = c[e];
                                                if (p.setX(t, h[e * a]),
                                                a >= 2 && p.setY(t, h[e * a + 1]),
                                                a >= 3 && p.setZ(t, h[e * a + 2]),
                                                a >= 4 && p.setW(t, h[e * a + 3]),
                                                a >= 5)
                                                    throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                                            }
                                            p.normalized = d
                                        }
                                        return p
                                    }
                                ))
                        }
                        loadTexture(e) {
                            const t = this.json
                                , n = this.options
                                , i = t.textures[e].source
                                , r = t.images[i];
                            let a = this.textureLoader;
                            if (r.uri) {
                                const e = n.manager.getHandler(r.uri);
                                null !== e && (a = e)
                            }
                            return this.loadTextureImage(e, i, a)
                        }
                        loadTextureImage(e, t, n) {
                            const i = this
                                , r = this.json
                                , a = r.textures[e]
                                , s = r.images[t]
                                , o = (s.uri || s.bufferView) + ":" + a.sampler;
                            if (this.textureCache[o])
                                return this.textureCache[o];
                            const l = this.loadImageSource(t, n).then((function(t) {
                                    t.flipY = !1,
                                        t.name = a.name || s.name || "",
                                    "" === t.name && "string" == typeof s.uri && !1 === s.uri.startsWith("data:image/") && (t.name = s.uri);
                                    const n = (r.samplers || {})[a.sampler] || {};
                                    return t.magFilter = Kl[n.magFilter] || he,
                                        t.minFilter = Kl[n.minFilter] || ue,
                                        t.wrapS = Xl[n.wrapS] || re,
                                        t.wrapT = Xl[n.wrapT] || re,
                                        t.generateMipmaps = !t.isCompressedTexture && t.minFilter !== oe && t.minFilter !== he,
                                        i.associations.set(t, {
                                            textures: e
                                        }),
                                        t
                                }
                            )).catch((function() {
                                    return null
                                }
                            ));
                            return this.textureCache[o] = l,
                                l
                        }
                        loadImageSource(e, t) {
                            const n = this
                                , i = this.json
                                , r = this.options;
                            if (void 0 !== this.sourceCache[e])
                                return this.sourceCache[e].then((e => e.clone()));
                            const a = i.images[e]
                                , s = self.URL || self.webkitURL;
                            let o = a.uri || ""
                                , l = !1;
                            if (void 0 !== a.bufferView)
                                o = n.getDependency("bufferView", a.bufferView).then((function(e) {
                                        l = !0;
                                        const t = new Blob([e],{
                                            type: a.mimeType
                                        });
                                        return o = s.createObjectURL(t),
                                            o
                                    }
                                ));
                            else if (void 0 === a.uri)
                                throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
                            const c = Promise.resolve(o).then((function(e) {
                                    return new Promise((function(n, i) {
                                            let a = n;
                                            !0 === t.isImageBitmapLoader && (a = function(e) {
                                                    const t = new un(e);
                                                    t.needsUpdate = !0,
                                                        n(t)
                                                }
                                            ),
                                                t.load(No.resolveURL(e, r.path), a, void 0, i)
                                        }
                                    ))
                                }
                            )).then((function(e) {
                                    var t;
                                    return !0 === l && s.revokeObjectURL(o),
                                        ac(e, a),
                                        e.userData.mimeType = a.mimeType || ((t = a.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/) ? "image/jpeg" : t.search(/\.webp($|\?)/i) > 0 || 0 === t.search(/^data\:image\/webp/) ? "image/webp" : t.search(/\.ktx2($|\?)/i) > 0 || 0 === t.search(/^data\:image\/ktx2/) ? "image/ktx2" : "image/png"),
                                        e
                                }
                            )).catch((function(e) {
                                    throw console.error("THREE.GLTFLoader: Couldn't load texture", o),
                                        e
                                }
                            ));
                            return this.sourceCache[e] = c,
                                c
                        }
                        assignTexture(e, t, n, i) {
                            const r = this;
                            return this.getDependency("texture", n.index).then((function(a) {
                                    if (!a)
                                        return null;
                                    if (void 0 !== n.texCoord && n.texCoord > 0 && ((a = a.clone()).channel = n.texCoord),
                                        r.extensions[wl.KHR_TEXTURE_TRANSFORM]) {
                                        const e = void 0 !== n.extensions ? n.extensions[wl.KHR_TEXTURE_TRANSFORM] : void 0;
                                        if (e) {
                                            const t = r.associations.get(a);
                                            a = r.extensions[wl.KHR_TEXTURE_TRANSFORM].extendTexture(a, e),
                                                r.associations.set(a, t)
                                        }
                                    }
                                    return void 0 !== i && (a.colorSpace = i),
                                        e[t] = a,
                                        a
                                }
                            ))
                        }
                        assignFinalMaterial(e) {
                            const t = e.geometry;
                            let n = e.material;
                            const i = void 0 === t.attributes.tangent
                                , r = void 0 !== t.attributes.color
                                , a = void 0 === t.attributes.normal;
                            if (e.isPoints) {
                                const e = "PointsMaterial:" + n.uuid;
                                let t = this.cache.get(e);
                                t || (t = new Na,
                                    Gi.prototype.copy.call(t, n),
                                    t.color.copy(n.color),
                                    t.map = n.map,
                                    t.sizeAttenuation = !1,
                                    this.cache.add(e, t)),
                                    n = t
                            } else if (e.isLine) {
                                const e = "LineBasicMaterial:" + n.uuid;
                                let t = this.cache.get(e);
                                t || (t = new ya,
                                    Gi.prototype.copy.call(t, n),
                                    t.color.copy(n.color),
                                    t.map = n.map,
                                    this.cache.add(e, t)),
                                    n = t
                            }
                            if (i || r || a) {
                                let e = "ClonedMaterial:" + n.uuid + ":";
                                i && (e += "derivative-tangents:"),
                                r && (e += "vertex-colors:"),
                                a && (e += "flat-shading:");
                                let t = this.cache.get(e);
                                t || (t = n.clone(),
                                r && (t.vertexColors = !0),
                                a && (t.flatShading = !0),
                                i && (t.normalScale && (t.normalScale.y *= -1),
                                t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)),
                                    this.cache.add(e, t),
                                    this.associations.set(t, this.associations.get(n))),
                                    n = t
                            }
                            e.material = n
                        }
                        getMaterialType() {
                            return zs
                        }
                        loadMaterial(e) {
                            const t = this
                                , n = this.json
                                , i = this.extensions
                                , r = n.materials[e];
                            let a;
                            const s = {}
                                , o = [];
                            if ((r.extensions || {})[wl.KHR_MATERIALS_UNLIT]) {
                                const e = i[wl.KHR_MATERIALS_UNLIT];
                                a = e.getMaterialType(),
                                    o.push(e.extendParams(s, r, t))
                            } else {
                                const n = r.pbrMetallicRoughness || {};
                                if (s.color = new Wi(1,1,1),
                                    s.opacity = 1,
                                    Array.isArray(n.baseColorFactor)) {
                                    const e = n.baseColorFactor;
                                    s.color.setRGB(e[0], e[1], e[2], vt),
                                        s.opacity = e[3]
                                }
                                void 0 !== n.baseColorTexture && o.push(t.assignTexture(s, "map", n.baseColorTexture, gt)),
                                    s.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1,
                                    s.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1,
                                void 0 !== n.metallicRoughnessTexture && (o.push(t.assignTexture(s, "metalnessMap", n.metallicRoughnessTexture)),
                                    o.push(t.assignTexture(s, "roughnessMap", n.metallicRoughnessTexture))),
                                    a = this._invokeOne((function(t) {
                                            return t.getMaterialType && t.getMaterialType(e)
                                        }
                                    )),
                                    o.push(Promise.all(this._invokeAll((function(t) {
                                            return t.extendMaterialParams && t.extendMaterialParams(e, s)
                                        }
                                    ))))
                            }
                            !0 === r.doubleSided && (s.side = 2);
                            const l = r.alphaMode || tc;
                            if (l === ic ? (s.transparent = !0,
                                s.depthWrite = !1) : (s.transparent = !1,
                            l === nc && (s.alphaTest = void 0 !== r.alphaCutoff ? r.alphaCutoff : .5)),
                            void 0 !== r.normalTexture && a !== ji && (o.push(t.assignTexture(s, "normalMap", r.normalTexture)),
                                s.normalScale = new jt(1,1),
                            void 0 !== r.normalTexture.scale)) {
                                const e = r.normalTexture.scale;
                                s.normalScale.set(e, e)
                            }
                            if (void 0 !== r.occlusionTexture && a !== ji && (o.push(t.assignTexture(s, "aoMap", r.occlusionTexture)),
                            void 0 !== r.occlusionTexture.strength && (s.aoMapIntensity = r.occlusionTexture.strength)),
                            void 0 !== r.emissiveFactor && a !== ji) {
                                const e = r.emissiveFactor;
                                s.emissive = (new Wi).setRGB(e[0], e[1], e[2], vt)
                            }
                            return void 0 !== r.emissiveTexture && a !== ji && o.push(t.assignTexture(s, "emissiveMap", r.emissiveTexture, gt)),
                                Promise.all(o).then((function() {
                                        const n = new a(s);
                                        return r.name && (n.name = r.name),
                                            ac(n, r),
                                            t.associations.set(n, {
                                                materials: e
                                            }),
                                        r.extensions && rc(i, n, r),
                                            n
                                    }
                                ))
                        }
                        createUniqueName(e) {
                            const t = Vo.sanitizeNodeName(e || "");
                            return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0,
                                t)
                        }
                        loadGeometries(e) {
                            const t = this
                                , n = this.extensions
                                , i = this.primitiveCache;
                            function r(e) {
                                return n[wl.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then((function(n) {
                                        return uc(n, e, t)
                                    }
                                ))
                            }
                            const a = [];
                            for (let n = 0, s = e.length; n < s; n++) {
                                const s = e[n]
                                    , o = oc(s)
                                    , l = i[o];
                                if (l)
                                    a.push(l.promise);
                                else {
                                    let e;
                                    e = s.extensions && s.extensions[wl.KHR_DRACO_MESH_COMPRESSION] ? r(s) : uc(new sr, s, t),
                                        i[o] = {
                                            primitive: s,
                                            promise: e
                                        },
                                        a.push(e)
                                }
                            }
                            return Promise.all(a)
                        }
                        loadMesh(e) {
                            const t = this
                                , n = this.json
                                , i = this.extensions
                                , r = n.meshes[e]
                                , a = r.primitives
                                , s = [];
                            for (let e = 0, t = a.length; e < t; e++) {
                                const t = void 0 === a[e].material ? (void 0 === (o = this.cache).DefaultMaterial && (o.DefaultMaterial = new zs({
                                    color: 16777215,
                                    emissive: 0,
                                    metalness: 1,
                                    roughness: 1,
                                    transparent: !1,
                                    depthTest: !0,
                                    side: 0
                                })),
                                    o.DefaultMaterial) : this.getDependency("material", a[e].material);
                                s.push(t)
                            }
                            var o;
                            return s.push(t.loadGeometries(a)),
                                Promise.all(s).then((function(n) {
                                        const s = n.slice(0, n.length - 1)
                                            , o = n[n.length - 1]
                                            , l = [];
                                        for (let n = 0, c = o.length; n < c; n++) {
                                            const c = o[n]
                                                , h = a[n];
                                            let d;
                                            const u = s[n];
                                            if (h.mode === Yl.TRIANGLES || h.mode === Yl.TRIANGLE_STRIP || h.mode === Yl.TRIANGLE_FAN || void 0 === h.mode)
                                                d = !0 === r.isSkinnedMesh ? new Jr(c,u) : new wr(c,u),
                                                !0 === d.isSkinnedMesh && d.normalizeSkinWeights(),
                                                    h.mode === Yl.TRIANGLE_STRIP ? d.geometry = ml(d.geometry, 1) : h.mode === Yl.TRIANGLE_FAN && (d.geometry = ml(d.geometry, 2));
                                            else if (h.mode === Yl.LINES)
                                                d = new Ra(c,u);
                                            else if (h.mode === Yl.LINE_STRIP)
                                                d = new Ca(c,u);
                                            else if (h.mode === Yl.LINE_LOOP)
                                                d = new La(c,u);
                                            else {
                                                if (h.mode !== Yl.POINTS)
                                                    throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + h.mode);
                                                d = new Oa(c,u)
                                            }
                                            Object.keys(d.geometry.morphAttributes).length > 0 && sc(d, r),
                                                d.name = t.createUniqueName(r.name || "mesh_" + e),
                                                ac(d, r),
                                            h.extensions && rc(i, d, h),
                                                t.assignFinalMaterial(d),
                                                l.push(d)
                                        }
                                        for (let n = 0, i = l.length; n < i; n++)
                                            t.associations.set(l[n], {
                                                meshes: e,
                                                primitives: n
                                            });
                                        if (1 === l.length)
                                            return r.extensions && rc(i, l[0], r),
                                                l[0];
                                        const c = new Dr;
                                        r.extensions && rc(i, c, r),
                                            t.associations.set(c, {
                                                meshes: e
                                            });
                                        for (let e = 0, t = l.length; e < t; e++)
                                            c.add(l[e]);
                                        return c
                                    }
                                ))
                        }
                        loadCamera(e) {
                            let t;
                            const n = this.json.cameras[e]
                                , i = n[n.type];
                            if (i)
                                return "perspective" === n.type ? t = new Ir(Gt.radToDeg(i.yfov),i.aspectRatio || 1,i.znear || 1,i.zfar || 2e6) : "orthographic" === n.type && (t = new Po(-i.xmag,i.xmag,i.ymag,-i.ymag,i.znear,i.zfar)),
                                n.name && (t.name = this.createUniqueName(n.name)),
                                    ac(t, n),
                                    Promise.resolve(t);
                            console.warn("THREE.GLTFLoader: Missing camera parameters.")
                        }
                        loadSkin(e) {
                            const t = this.json.skins[e]
                                , n = [];
                            for (let e = 0, i = t.joints.length; e < i; e++)
                                n.push(this._loadNodeShallow(t.joints[e]));
                            return void 0 !== t.inverseBindMatrices ? n.push(this.getDependency("accessor", t.inverseBindMatrices)) : n.push(null),
                                Promise.all(n).then((function(e) {
                                        const n = e.pop()
                                            , i = e
                                            , r = []
                                            , a = [];
                                        for (let e = 0, s = i.length; e < s; e++) {
                                            const s = i[e];
                                            if (s) {
                                                r.push(s);
                                                const t = new Kn;
                                                null !== n && t.fromArray(n.array, 16 * e),
                                                    a.push(t)
                                            } else
                                                console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[e])
                                        }
                                        return new ia(r,a)
                                    }
                                ))
                        }
                        loadAnimation(e) {
                            const t = this.json
                                , n = this
                                , i = t.animations[e]
                                , r = i.name ? i.name : "animation_" + e
                                , a = []
                                , s = []
                                , o = []
                                , l = []
                                , c = [];
                            for (let e = 0, t = i.channels.length; e < t; e++) {
                                const t = i.channels[e]
                                    , n = i.samplers[t.sampler]
                                    , r = t.target
                                    , h = r.node
                                    , d = void 0 !== i.parameters ? i.parameters[n.input] : n.input
                                    , u = void 0 !== i.parameters ? i.parameters[n.output] : n.output;
                                void 0 !== r.node && (a.push(this.getDependency("node", h)),
                                    s.push(this.getDependency("accessor", d)),
                                    o.push(this.getDependency("accessor", u)),
                                    l.push(n),
                                    c.push(r))
                            }
                            return Promise.all([Promise.all(a), Promise.all(s), Promise.all(o), Promise.all(l), Promise.all(c)]).then((function(e) {
                                    const t = e[0]
                                        , i = e[1]
                                        , a = e[2]
                                        , s = e[3]
                                        , o = e[4]
                                        , l = [];
                                    for (let e = 0, r = t.length; e < r; e++) {
                                        const r = t[e]
                                            , c = i[e]
                                            , h = a[e]
                                            , d = s[e]
                                            , u = o[e];
                                        if (void 0 === r)
                                            continue;
                                        r.updateMatrix && r.updateMatrix();
                                        const p = n._createAnimationTracks(r, c, h, d, u);
                                        if (p)
                                            for (let e = 0; e < p.length; e++)
                                                l.push(p[e])
                                    }
                                    return new so(r,void 0,l)
                                }
                            ))
                        }
                        createNodeMesh(e) {
                            const t = this.json
                                , n = this
                                , i = t.nodes[e];
                            return void 0 === i.mesh ? null : n.getDependency("mesh", i.mesh).then((function(e) {
                                    const t = n._getNodeRef(n.meshCache, i.mesh, e);
                                    return void 0 !== i.weights && t.traverse((function(e) {
                                            if (e.isMesh)
                                                for (let t = 0, n = i.weights.length; t < n; t++)
                                                    e.morphTargetInfluences[t] = i.weights[t]
                                        }
                                    )),
                                        t
                                }
                            ))
                        }
                        loadNode(e) {
                            const t = this
                                , n = this.json.nodes[e]
                                , i = t._loadNodeShallow(e)
                                , r = []
                                , a = n.children || [];
                            for (let e = 0, n = a.length; e < n; e++)
                                r.push(t.getDependency("node", a[e]));
                            const s = void 0 === n.skin ? Promise.resolve(null) : t.getDependency("skin", n.skin);
                            return Promise.all([i, Promise.all(r), s]).then((function(e) {
                                    const t = e[0]
                                        , n = e[1]
                                        , i = e[2];
                                    null !== i && t.traverse((function(e) {
                                            e.isSkinnedMesh && e.bind(i, hc)
                                        }
                                    ));
                                    for (let e = 0, i = n.length; e < i; e++)
                                        t.add(n[e]);
                                    return t
                                }
                            ))
                        }
                        _loadNodeShallow(e) {
                            const t = this.json
                                , n = this.extensions
                                , i = this;
                            if (void 0 !== this.nodeCache[e])
                                return this.nodeCache[e];
                            const r = t.nodes[e]
                                , a = r.name ? i.createUniqueName(r.name) : ""
                                , s = []
                                , o = i._invokeOne((function(t) {
                                    return t.createNodeMesh && t.createNodeMesh(e)
                                }
                            ));
                            return o && s.push(o),
                            void 0 !== r.camera && s.push(i.getDependency("camera", r.camera).then((function(e) {
                                    return i._getNodeRef(i.cameraCache, r.camera, e)
                                }
                            ))),
                                i._invokeAll((function(t) {
                                        return t.createNodeAttachment && t.createNodeAttachment(e)
                                    }
                                )).forEach((function(e) {
                                        s.push(e)
                                    }
                                )),
                                this.nodeCache[e] = Promise.all(s).then((function(t) {
                                        let s;
                                        if (s = !0 === r.isBone ? new $r : t.length > 1 ? new Dr : 1 === t.length ? t[0] : new xi,
                                        s !== t[0])
                                            for (let e = 0, n = t.length; e < n; e++)
                                                s.add(t[e]);
                                        if (r.name && (s.userData.name = r.name,
                                            s.name = a),
                                            ac(s, r),
                                        r.extensions && rc(n, s, r),
                                        void 0 !== r.matrix) {
                                            const e = new Kn;
                                            e.fromArray(r.matrix),
                                                s.applyMatrix4(e)
                                        } else
                                            void 0 !== r.translation && s.position.fromArray(r.translation),
                                            void 0 !== r.rotation && s.quaternion.fromArray(r.rotation),
                                            void 0 !== r.scale && s.scale.fromArray(r.scale);
                                        return i.associations.has(s) || i.associations.set(s, {}),
                                            i.associations.get(s).nodes = e,
                                            s
                                    }
                                )),
                                this.nodeCache[e]
                        }
                        loadScene(e) {
                            const t = this.extensions
                                , n = this.json.scenes[e]
                                , i = this
                                , r = new Dr;
                            n.name && (r.name = i.createUniqueName(n.name)),
                                ac(r, n),
                            n.extensions && rc(t, r, n);
                            const a = n.nodes || []
                                , s = [];
                            for (let e = 0, t = a.length; e < t; e++)
                                s.push(i.getDependency("node", a[e]));
                            return Promise.all(s).then((function(e) {
                                    for (let t = 0, n = e.length; t < n; t++)
                                        r.add(e[t]);
                                    return i.associations = (e => {
                                            const t = new Map;
                                            for (const [e,n] of i.associations)
                                                (e instanceof Gi || e instanceof un) && t.set(e, n);
                                            return e.traverse((e => {
                                                    const n = i.associations.get(e);
                                                    null != n && t.set(e, n)
                                                }
                                            )),
                                                t
                                        }
                                    )(r),
                                        r
                                }
                            ))
                        }
                        _createAnimationTracks(e, t, n, i, r) {
                            const a = []
                                , s = e.name ? e.name : e.uuid
                                , o = [];
                            let l;
                            switch ($l[r.path] === $l.weights ? e.traverse((function(e) {
                                    e.morphTargetInfluences && o.push(e.name ? e.name : e.uuid)
                                }
                            )) : o.push(s),
                                $l[r.path]) {
                                case $l.weights:
                                    l = to;
                                    break;
                                case $l.rotation:
                                    l = io;
                                    break;
                                case $l.position:
                                case $l.scale:
                                    l = ao;
                                    break;
                                default:
                                    if (1 === n.itemSize)
                                        l = to;
                                    else
                                        l = ao
                            }
                            const c = void 0 !== i.interpolation ? ec[i.interpolation] : ht
                                , h = this._getArrayFromAccessor(n);
                            for (let e = 0, n = o.length; e < n; e++) {
                                const n = new l(o[e] + "." + $l[r.path],t.array,h,c);
                                "CUBICSPLINE" === i.interpolation && this._createCubicSplineTrackInterpolant(n),
                                    a.push(n)
                            }
                            return a
                        }
                        _getArrayFromAccessor(e) {
                            let t = e.array;
                            if (e.normalized) {
                                const e = cc(t.constructor)
                                    , n = new Float32Array(t.length);
                                for (let i = 0, r = t.length; i < r; i++)
                                    n[i] = t[i] * e;
                                t = n
                            }
                            return t
                        }
                        _createCubicSplineTrackInterpolant(e) {
                            e.createInterpolant = function(e) {
                                return new (this instanceof io ? Ql : Gl)(this.times,this.values,this.getValueSize() / 3,e)
                            }
                                ,
                                e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0
                        }
                    }
                    function uc(e, t, n) {
                        const i = t.attributes
                            , r = [];
                        function a(t, i) {
                            return n.getDependency("accessor", t).then((function(t) {
                                    e.setAttribute(i, t)
                                }
                            ))
                        }
                        for (const t in i) {
                            const n = Jl[t] || t.toLowerCase();
                            n in e.attributes || r.push(a(i[t], n))
                        }
                        if (void 0 !== t.indices && !e.index) {
                            const i = n.getDependency("accessor", t.indices).then((function(t) {
                                    e.setIndex(t)
                                }
                            ));
                            r.push(i)
                        }
                        return nn.workingColorSpace !== vt && "COLOR_0"in i && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${nn.workingColorSpace}" not supported.`),
                            ac(e, t),
                            function(e, t, n) {
                                const i = t.attributes
                                    , r = new xn;
                                if (void 0 === i.POSITION)
                                    return;
                                {
                                    const e = n.json.accessors[i.POSITION]
                                        , t = e.min
                                        , a = e.max;
                                    if (void 0 === t || void 0 === a)
                                        return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                                    if (r.set(new An(t[0],t[1],t[2]), new An(a[0],a[1],a[2])),
                                        e.normalized) {
                                        const t = cc(ql[e.componentType]);
                                        r.min.multiplyScalar(t),
                                            r.max.multiplyScalar(t)
                                    }
                                }
                                const a = t.targets;
                                if (void 0 !== a) {
                                    const e = new An
                                        , t = new An;
                                    for (let i = 0, r = a.length; i < r; i++) {
                                        const r = a[i];
                                        if (void 0 !== r.POSITION) {
                                            const i = n.json.accessors[r.POSITION]
                                                , a = i.min
                                                , s = i.max;
                                            if (void 0 !== a && void 0 !== s) {
                                                if (t.setX(Math.max(Math.abs(a[0]), Math.abs(s[0]))),
                                                    t.setY(Math.max(Math.abs(a[1]), Math.abs(s[1]))),
                                                    t.setZ(Math.max(Math.abs(a[2]), Math.abs(s[2]))),
                                                    i.normalized) {
                                                    const e = cc(ql[i.componentType]);
                                                    t.multiplyScalar(e)
                                                }
                                                e.max(t)
                                            } else
                                                console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                                        }
                                    }
                                    r.expandByVector(e)
                                }
                                e.boundingBox = r;
                                const s = new Fn;
                                r.getCenter(s.center),
                                    s.radius = r.min.distanceTo(r.max) / 2,
                                    e.boundingSphere = s
                            }(e, t, n),
                            Promise.all(r).then((function() {
                                    return void 0 !== t.targets ? function(e, t, n) {
                                        let i = !1
                                            , r = !1
                                            , a = !1;
                                        for (let e = 0, n = t.length; e < n; e++) {
                                            const n = t[e];
                                            if (void 0 !== n.POSITION && (i = !0),
                                            void 0 !== n.NORMAL && (r = !0),
                                            void 0 !== n.COLOR_0 && (a = !0),
                                            i && r && a)
                                                break
                                        }
                                        if (!i && !r && !a)
                                            return Promise.resolve(e);
                                        const s = []
                                            , o = []
                                            , l = [];
                                        for (let c = 0, h = t.length; c < h; c++) {
                                            const h = t[c];
                                            if (i) {
                                                const t = void 0 !== h.POSITION ? n.getDependency("accessor", h.POSITION) : e.attributes.position;
                                                s.push(t)
                                            }
                                            if (r) {
                                                const t = void 0 !== h.NORMAL ? n.getDependency("accessor", h.NORMAL) : e.attributes.normal;
                                                o.push(t)
                                            }
                                            if (a) {
                                                const t = void 0 !== h.COLOR_0 ? n.getDependency("accessor", h.COLOR_0) : e.attributes.color;
                                                l.push(t)
                                            }
                                        }
                                        return Promise.all([Promise.all(s), Promise.all(o), Promise.all(l)]).then((function(t) {
                                                const n = t[0]
                                                    , s = t[1]
                                                    , o = t[2];
                                                return i && (e.morphAttributes.position = n),
                                                r && (e.morphAttributes.normal = s),
                                                a && (e.morphAttributes.color = o),
                                                    e.morphTargetsRelative = !0,
                                                    e
                                            }
                                        ))
                                    }(e, t.targets, n) : e
                                }
                            ))
                    }
                    /**
                     * @license
                     * Copyright 2010-2025 Three.js Authors
                     * SPDX-License-Identifier: MIT
                     */
                    function pc() {
                        let e = null
                            , t = !1
                            , n = null
                            , i = null;
                        function r(t, a) {
                            n(t, a),
                                i = e.requestAnimationFrame(r)
                        }
                        return {
                            start: function() {
                                !0 !== t && null !== n && (i = e.requestAnimationFrame(r),
                                    t = !0)
                            },
                            stop: function() {
                                e.cancelAnimationFrame(i),
                                    t = !1
                            },
                            setAnimationLoop: function(e) {
                                n = e
                            },
                            setContext: function(t) {
                                e = t
                            }
                        }
                    }
                    function fc(e) {
                        const t = new WeakMap;
                        return {
                            get: function(e) {
                                return e.isInterleavedBufferAttribute && (e = e.data),
                                    t.get(e)
                            },
                            remove: function(n) {
                                n.isInterleavedBufferAttribute && (n = n.data);
                                const i = t.get(n);
                                i && (e.deleteBuffer(i.buffer),
                                    t.delete(n))
                            },
                            update: function(n, i) {
                                if (n.isInterleavedBufferAttribute && (n = n.data),
                                    n.isGLBufferAttribute) {
                                    const e = t.get(n);
                                    return void ((!e || e.version < n.version) && t.set(n, {
                                        buffer: n.buffer,
                                        type: n.type,
                                        bytesPerElement: n.elementSize,
                                        version: n.version
                                    }))
                                }
                                const r = t.get(n);
                                if (void 0 === r)
                                    t.set(n, function(t, n) {
                                        const i = t.array
                                            , r = t.usage
                                            , a = i.byteLength
                                            , s = e.createBuffer();
                                        let o;
                                        if (e.bindBuffer(n, s),
                                            e.bufferData(n, i, r),
                                            t.onUploadCallback(),
                                        i instanceof Float32Array)
                                            o = e.FLOAT;
                                        else if (i instanceof Uint16Array)
                                            o = t.isFloat16BufferAttribute ? e.HALF_FLOAT : e.UNSIGNED_SHORT;
                                        else if (i instanceof Int16Array)
                                            o = e.SHORT;
                                        else if (i instanceof Uint32Array)
                                            o = e.UNSIGNED_INT;
                                        else if (i instanceof Int32Array)
                                            o = e.INT;
                                        else if (i instanceof Int8Array)
                                            o = e.BYTE;
                                        else if (i instanceof Uint8Array)
                                            o = e.UNSIGNED_BYTE;
                                        else {
                                            if (!(i instanceof Uint8ClampedArray))
                                                throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + i);
                                            o = e.UNSIGNED_BYTE
                                        }
                                        return {
                                            buffer: s,
                                            type: o,
                                            bytesPerElement: i.BYTES_PER_ELEMENT,
                                            version: t.version,
                                            size: a
                                        }
                                    }(n, i));
                                else if (r.version < n.version) {
                                    if (r.size !== n.array.byteLength)
                                        throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
                                    !function(t, n, i) {
                                        const r = n.array
                                            , a = n.updateRanges;
                                        if (e.bindBuffer(i, t),
                                        0 === a.length)
                                            e.bufferSubData(i, 0, r);
                                        else {
                                            a.sort(( (e, t) => e.start - t.start));
                                            let t = 0;
                                            for (let e = 1; e < a.length; e++) {
                                                const n = a[t]
                                                    , i = a[e];
                                                i.start <= n.start + n.count + 1 ? n.count = Math.max(n.count, i.start + i.count - n.start) : (++t,
                                                    a[t] = i)
                                            }
                                            a.length = t + 1;
                                            for (let t = 0, n = a.length; t < n; t++) {
                                                const n = a[t];
                                                e.bufferSubData(i, n.start * r.BYTES_PER_ELEMENT, r, n.start, n.count)
                                            }
                                            n.clearUpdateRanges()
                                        }
                                        n.onUploadCallback()
                                    }(r.buffer, n, i),
                                        r.version = n.version
                                }
                            }
                        }
                    }
                    const mc = {
                        alphahash_fragment: "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",
                        alphahash_pars_fragment: "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",
                        alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",
                        alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                        alphatest_fragment: "#ifdef USE_ALPHATEST\n\t#ifdef ALPHA_TO_COVERAGE\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\tif ( diffuseColor.a < alphaTest ) discard;\n\t#endif\n#endif",
                        alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
                        aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
                        aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                        batching_pars_vertex: "#ifdef USE_BATCHING\n\t#if ! defined( GL_ANGLE_multi_draw )\n\t#define gl_DrawID _gl_DrawID\n\tuniform int _gl_DrawID;\n\t#endif\n\tuniform highp sampler2D batchingTexture;\n\tuniform highp usampler2D batchingIdTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n\tfloat getIndirectIndex( const in int i ) {\n\t\tint size = textureSize( batchingIdTexture, 0 ).x;\n\t\tint x = i % size;\n\t\tint y = i / size;\n\t\treturn float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\n\t}\n#endif\n#ifdef USE_BATCHING_COLOR\n\tuniform sampler2D batchingColorTexture;\n\tvec3 getBatchingColor( const in float i ) {\n\t\tint size = textureSize( batchingColorTexture, 0 ).x;\n\t\tint j = int( i );\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\treturn texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n\t}\n#endif",
                        batching_vertex: "#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\n#endif",
                        begin_vertex: "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",
                        beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
                        bsdfs: "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",
                        iridescence_fragment: "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
                        bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
                        clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#ifdef ALPHA_TO_COVERAGE\n\t\tfloat distanceToPlane, distanceGradient;\n\t\tfloat clipOpacity = 1.0;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\tif ( clipOpacity == 0.0 ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tfloat unionClipOpacity = 1.0;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\n\t\t#endif\n\t\tdiffuseColor.a *= clipOpacity;\n\t\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tbool clipped = true;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tif ( clipped ) discard;\n\t\t#endif\n\t#endif\n#endif",
                        clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                        clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
                        clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
                        color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
                        color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
                        color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvarying vec3 vColor;\n#endif",
                        color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n\tvec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\n\tvColor.xyz *= batchingColor.xyz;\n#endif",
                        common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",
                        cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
                        defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
                        displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
                        displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",
                        emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE\n\t\temissiveColor = sRGBTransferEOTF( emissiveColor );\n\t#endif\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                        emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
                        colorspace_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                        colorspace_pars_fragment: "vec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferEOTF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
                        envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
                        envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform mat3 envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
                        envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
                        envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
                        envmap_physical_pars_fragment: "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",
                        envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
                        fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
                        fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
                        fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                        fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
                        gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",
                        lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                        lights_lambert_fragment: "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
                        lights_lambert_pars_fragment: "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",
                        lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif ( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
                        lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
                        lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",
                        lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                        lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",
                        lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n\tmaterial.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif",
                        lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\tfloat dispersion;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                        lights_fragment_begin: "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
                        lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
                        lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif",
                        logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF )\n\tgl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                        logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
                        logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
                        logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\tvFragDepth = 1.0 + gl_Position.w;\n\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif",
                        map_fragment: "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
                        map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
                        map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
                        map_particle_pars_fragment: "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                        metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
                        metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                        morphinstance_vertex: "#ifdef USE_INSTANCING_MORPH\n\tfloat morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n\t}\n#endif",
                        morphcolor_vertex: "#if defined( USE_MORPHCOLORS )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
                        morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif",
                        morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_INSTANCING_MORPH\n\t\tuniform float morphTargetBaseInfluence;\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t#endif\n\tuniform sampler2DArray morphTargetsTexture;\n\tuniform ivec2 morphTargetsTextureSize;\n\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t}\n#endif",
                        morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif",
                        normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;",
                        normal_fragment_maps: "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
                        normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                        normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                        normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
                        normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",
                        clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif",
                        clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",
                        clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",
                        iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
                        opaque_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
                        packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\nconst float Inv255 = 1. / 255.;\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\nvec4 packDepthToRGBA( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec4( 0., 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec4( 1., 1., 1., 1. );\n\tfloat vuf;\n\tfloat af = modf( v * PackFactors.a, vuf );\n\tfloat bf = modf( vuf * ShiftRight8, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\n}\nvec3 packDepthToRGB( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec3( 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec3( 1., 1., 1. );\n\tfloat vuf;\n\tfloat bf = modf( v * PackFactors.b, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec3( vuf * Inv255, gf * PackUpscale, bf );\n}\nvec2 packDepthToRG( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec2( 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec2( 1., 1. );\n\tfloat vuf;\n\tfloat gf = modf( v * 256., vuf );\n\treturn vec2( vuf * Inv255, gf );\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors4 );\n}\nfloat unpackRGBToDepth( const in vec3 v ) {\n\treturn dot( v, UnpackFactors3 );\n}\nfloat unpackRGToDepth( const in vec2 v ) {\n\treturn v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\n}\nvec4 pack2HalfToRGBA( const in vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( const in vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",
                        premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                        project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
                        dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                        dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
                        roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
                        roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                        shadowmap_pars_fragment: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tfloat shadow = 1.0;\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\t\n\t\tfloat lightToPositionLength = length( lightToPosition );\n\t\tif ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n\t\t\tfloat dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\t\tdp += shadowBias;\n\t\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\t\tshadow = (\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t\t) * ( 1.0 / 9.0 );\n\t\t\t#else\n\t\t\t\tshadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n#endif",
                        shadowmap_pars_vertex: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
                        shadowmap_vertex: "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",
                        shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
                        skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                        skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",
                        skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                        skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
                        specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                        specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                        tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                        tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 CineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor *= toneMappingExposure;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\tcolor = clamp( color, 0.0, 1.0 );\n\treturn color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n\tconst float StartCompression = 0.8 - 0.04;\n\tconst float Desaturation = 0.15;\n\tcolor *= toneMappingExposure;\n\tfloat x = min( color.r, min( color.g, color.b ) );\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\tcolor -= offset;\n\tfloat peak = max( color.r, max( color.g, color.b ) );\n\tif ( peak < StartCompression ) return color;\n\tfloat d = 1. - StartCompression;\n\tfloat newPeak = 1. - d * d / ( peak + d - StartCompression );\n\tcolor *= newPeak / peak;\n\tfloat g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n\treturn mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
                        transmission_fragment: "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",
                        transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec4 transmittedLight;\n\t\tvec3 transmittance;\n\t\t#ifdef USE_DISPERSION\n\t\t\tfloat halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n\t\t\tvec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n\t\t\tfor ( int i = 0; i < 3; i ++ ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\t\t\t\tvec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n\t\t\t\ttransmittedLight[ i ] = transmissionSample[ i ];\n\t\t\t\ttransmittedLight.a += transmissionSample.a;\n\t\t\t\ttransmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n\t\t\t}\n\t\t\ttransmittedLight.a /= 3.0;\n\t\t#else\n\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\trefractionCoords += 1.0;\n\t\t\trefractionCoords /= 2.0;\n\t\t\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\t\ttransmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\t#endif\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",
                        uv_pars_fragment: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
                        uv_pars_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
                        uv_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",
                        worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
                        background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                        background_frag: "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                        backgroundCube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                        backgroundCube_frag: "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                        cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                        cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                        depth_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
                        depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#elif DEPTH_PACKING == 3202\n\t\tgl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\n\t#elif DEPTH_PACKING == 3203\n\t\tgl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\n\t#endif\n}",
                        distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                        distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
                        equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                        equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                        linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                        linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                        meshbasic_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                        meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        meshlambert_vert: "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                        meshlambert_frag: "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                        meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                        meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
                        meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                        meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
                        meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n\tuniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                        meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                        points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                        shadow_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                        shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
                        sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix[ 3 ];\n\tvec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                        sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}"
                    }
                        , gc = {
                        common: {
                            diffuse: {
                                value: new Wi(16777215)
                            },
                            opacity: {
                                value: 1
                            },
                            map: {
                                value: null
                            },
                            mapTransform: {
                                value: new Qt
                            },
                            alphaMap: {
                                value: null
                            },
                            alphaMapTransform: {
                                value: new Qt
                            },
                            alphaTest: {
                                value: 0
                            }
                        },
                        specularmap: {
                            specularMap: {
                                value: null
                            },
                            specularMapTransform: {
                                value: new Qt
                            }
                        },
                        envmap: {
                            envMap: {
                                value: null
                            },
                            envMapRotation: {
                                value: new Qt
                            },
                            flipEnvMap: {
                                value: -1
                            },
                            reflectivity: {
                                value: 1
                            },
                            ior: {
                                value: 1.5
                            },
                            refractionRatio: {
                                value: .98
                            }
                        },
                        aomap: {
                            aoMap: {
                                value: null
                            },
                            aoMapIntensity: {
                                value: 1
                            },
                            aoMapTransform: {
                                value: new Qt
                            }
                        },
                        lightmap: {
                            lightMap: {
                                value: null
                            },
                            lightMapIntensity: {
                                value: 1
                            },
                            lightMapTransform: {
                                value: new Qt
                            }
                        },
                        bumpmap: {
                            bumpMap: {
                                value: null
                            },
                            bumpMapTransform: {
                                value: new Qt
                            },
                            bumpScale: {
                                value: 1
                            }
                        },
                        normalmap: {
                            normalMap: {
                                value: null
                            },
                            normalMapTransform: {
                                value: new Qt
                            },
                            normalScale: {
                                value: new jt(1,1)
                            }
                        },
                        displacementmap: {
                            displacementMap: {
                                value: null
                            },
                            displacementMapTransform: {
                                value: new Qt
                            },
                            displacementScale: {
                                value: 1
                            },
                            displacementBias: {
                                value: 0
                            }
                        },
                        emissivemap: {
                            emissiveMap: {
                                value: null
                            },
                            emissiveMapTransform: {
                                value: new Qt
                            }
                        },
                        metalnessmap: {
                            metalnessMap: {
                                value: null
                            },
                            metalnessMapTransform: {
                                value: new Qt
                            }
                        },
                        roughnessmap: {
                            roughnessMap: {
                                value: null
                            },
                            roughnessMapTransform: {
                                value: new Qt
                            }
                        },
                        gradientmap: {
                            gradientMap: {
                                value: null
                            }
                        },
                        fog: {
                            fogDensity: {
                                value: 25e-5
                            },
                            fogNear: {
                                value: 1
                            },
                            fogFar: {
                                value: 2e3
                            },
                            fogColor: {
                                value: new Wi(16777215)
                            }
                        },
                        lights: {
                            ambientLightColor: {
                                value: []
                            },
                            lightProbe: {
                                value: []
                            },
                            directionalLights: {
                                value: [],
                                properties: {
                                    direction: {},
                                    color: {}
                                }
                            },
                            directionalLightShadows: {
                                value: [],
                                properties: {
                                    shadowIntensity: 1,
                                    shadowBias: {},
                                    shadowNormalBias: {},
                                    shadowRadius: {},
                                    shadowMapSize: {}
                                }
                            },
                            directionalShadowMap: {
                                value: []
                            },
                            directionalShadowMatrix: {
                                value: []
                            },
                            spotLights: {
                                value: [],
                                properties: {
                                    color: {},
                                    position: {},
                                    direction: {},
                                    distance: {},
                                    coneCos: {},
                                    penumbraCos: {},
                                    decay: {}
                                }
                            },
                            spotLightShadows: {
                                value: [],
                                properties: {
                                    shadowIntensity: 1,
                                    shadowBias: {},
                                    shadowNormalBias: {},
                                    shadowRadius: {},
                                    shadowMapSize: {}
                                }
                            },
                            spotLightMap: {
                                value: []
                            },
                            spotShadowMap: {
                                value: []
                            },
                            spotLightMatrix: {
                                value: []
                            },
                            pointLights: {
                                value: [],
                                properties: {
                                    color: {},
                                    position: {},
                                    decay: {},
                                    distance: {}
                                }
                            },
                            pointLightShadows: {
                                value: [],
                                properties: {
                                    shadowIntensity: 1,
                                    shadowBias: {},
                                    shadowNormalBias: {},
                                    shadowRadius: {},
                                    shadowMapSize: {},
                                    shadowCameraNear: {},
                                    shadowCameraFar: {}
                                }
                            },
                            pointShadowMap: {
                                value: []
                            },
                            pointShadowMatrix: {
                                value: []
                            },
                            hemisphereLights: {
                                value: [],
                                properties: {
                                    direction: {},
                                    skyColor: {},
                                    groundColor: {}
                                }
                            },
                            rectAreaLights: {
                                value: [],
                                properties: {
                                    color: {},
                                    position: {},
                                    width: {},
                                    height: {}
                                }
                            },
                            ltc_1: {
                                value: null
                            },
                            ltc_2: {
                                value: null
                            }
                        },
                        points: {
                            diffuse: {
                                value: new Wi(16777215)
                            },
                            opacity: {
                                value: 1
                            },
                            size: {
                                value: 1
                            },
                            scale: {
                                value: 1
                            },
                            map: {
                                value: null
                            },
                            alphaMap: {
                                value: null
                            },
                            alphaMapTransform: {
                                value: new Qt
                            },
                            alphaTest: {
                                value: 0
                            },
                            uvTransform: {
                                value: new Qt
                            }
                        },
                        sprite: {
                            diffuse: {
                                value: new Wi(16777215)
                            },
                            opacity: {
                                value: 1
                            },
                            center: {
                                value: new jt(.5,.5)
                            },
                            rotation: {
                                value: 0
                            },
                            map: {
                                value: null
                            },
                            mapTransform: {
                                value: new Qt
                            },
                            alphaMap: {
                                value: null
                            },
                            alphaMapTransform: {
                                value: new Qt
                            },
                            alphaTest: {
                                value: 0
                            }
                        }
                    }
                        , vc = {
                        basic: {
                            uniforms: xr([gc.common, gc.specularmap, gc.envmap, gc.aomap, gc.lightmap, gc.fog]),
                            vertexShader: mc.meshbasic_vert,
                            fragmentShader: mc.meshbasic_frag
                        },
                        lambert: {
                            uniforms: xr([gc.common, gc.specularmap, gc.envmap, gc.aomap, gc.lightmap, gc.emissivemap, gc.bumpmap, gc.normalmap, gc.displacementmap, gc.fog, gc.lights, {
                                emissive: {
                                    value: new Wi(0)
                                }
                            }]),
                            vertexShader: mc.meshlambert_vert,
                            fragmentShader: mc.meshlambert_frag
                        },
                        phong: {
                            uniforms: xr([gc.common, gc.specularmap, gc.envmap, gc.aomap, gc.lightmap, gc.emissivemap, gc.bumpmap, gc.normalmap, gc.displacementmap, gc.fog, gc.lights, {
                                emissive: {
                                    value: new Wi(0)
                                },
                                specular: {
                                    value: new Wi(1118481)
                                },
                                shininess: {
                                    value: 30
                                }
                            }]),
                            vertexShader: mc.meshphong_vert,
                            fragmentShader: mc.meshphong_frag
                        },
                        standard: {
                            uniforms: xr([gc.common, gc.envmap, gc.aomap, gc.lightmap, gc.emissivemap, gc.bumpmap, gc.normalmap, gc.displacementmap, gc.roughnessmap, gc.metalnessmap, gc.fog, gc.lights, {
                                emissive: {
                                    value: new Wi(0)
                                },
                                roughness: {
                                    value: 1
                                },
                                metalness: {
                                    value: 0
                                },
                                envMapIntensity: {
                                    value: 1
                                }
                            }]),
                            vertexShader: mc.meshphysical_vert,
                            fragmentShader: mc.meshphysical_frag
                        },
                        toon: {
                            uniforms: xr([gc.common, gc.aomap, gc.lightmap, gc.emissivemap, gc.bumpmap, gc.normalmap, gc.displacementmap, gc.gradientmap, gc.fog, gc.lights, {
                                emissive: {
                                    value: new Wi(0)
                                }
                            }]),
                            vertexShader: mc.meshtoon_vert,
                            fragmentShader: mc.meshtoon_frag
                        },
                        matcap: {
                            uniforms: xr([gc.common, gc.bumpmap, gc.normalmap, gc.displacementmap, gc.fog, {
                                matcap: {
                                    value: null
                                }
                            }]),
                            vertexShader: mc.meshmatcap_vert,
                            fragmentShader: mc.meshmatcap_frag
                        },
                        points: {
                            uniforms: xr([gc.points, gc.fog]),
                            vertexShader: mc.points_vert,
                            fragmentShader: mc.points_frag
                        },
                        dashed: {
                            uniforms: xr([gc.common, gc.fog, {
                                scale: {
                                    value: 1
                                },
                                dashSize: {
                                    value: 1
                                },
                                totalSize: {
                                    value: 2
                                }
                            }]),
                            vertexShader: mc.linedashed_vert,
                            fragmentShader: mc.linedashed_frag
                        },
                        depth: {
                            uniforms: xr([gc.common, gc.displacementmap]),
                            vertexShader: mc.depth_vert,
                            fragmentShader: mc.depth_frag
                        },
                        normal: {
                            uniforms: xr([gc.common, gc.bumpmap, gc.normalmap, gc.displacementmap, {
                                opacity: {
                                    value: 1
                                }
                            }]),
                            vertexShader: mc.meshnormal_vert,
                            fragmentShader: mc.meshnormal_frag
                        },
                        sprite: {
                            uniforms: xr([gc.sprite, gc.fog]),
                            vertexShader: mc.sprite_vert,
                            fragmentShader: mc.sprite_frag
                        },
                        background: {
                            uniforms: {
                                uvTransform: {
                                    value: new Qt
                                },
                                t2D: {
                                    value: null
                                },
                                backgroundIntensity: {
                                    value: 1
                                }
                            },
                            vertexShader: mc.background_vert,
                            fragmentShader: mc.background_frag
                        },
                        backgroundCube: {
                            uniforms: {
                                envMap: {
                                    value: null
                                },
                                flipEnvMap: {
                                    value: -1
                                },
                                backgroundBlurriness: {
                                    value: 0
                                },
                                backgroundIntensity: {
                                    value: 1
                                },
                                backgroundRotation: {
                                    value: new Qt
                                }
                            },
                            vertexShader: mc.backgroundCube_vert,
                            fragmentShader: mc.backgroundCube_frag
                        },
                        cube: {
                            uniforms: {
                                tCube: {
                                    value: null
                                },
                                tFlip: {
                                    value: -1
                                },
                                opacity: {
                                    value: 1
                                }
                            },
                            vertexShader: mc.cube_vert,
                            fragmentShader: mc.cube_frag
                        },
                        equirect: {
                            uniforms: {
                                tEquirect: {
                                    value: null
                                }
                            },
                            vertexShader: mc.equirect_vert,
                            fragmentShader: mc.equirect_frag
                        },
                        distanceRGBA: {
                            uniforms: xr([gc.common, gc.displacementmap, {
                                referencePosition: {
                                    value: new An
                                },
                                nearDistance: {
                                    value: 1
                                },
                                farDistance: {
                                    value: 1e3
                                }
                            }]),
                            vertexShader: mc.distanceRGBA_vert,
                            fragmentShader: mc.distanceRGBA_frag
                        },
                        shadow: {
                            uniforms: xr([gc.lights, gc.fog, {
                                color: {
                                    value: new Wi(0)
                                },
                                opacity: {
                                    value: 1
                                }
                            }]),
                            vertexShader: mc.shadow_vert,
                            fragmentShader: mc.shadow_frag
                        }
                    };
                    vc.physical = {
                        uniforms: xr([vc.standard.uniforms, {
                            clearcoat: {
                                value: 0
                            },
                            clearcoatMap: {
                                value: null
                            },
                            clearcoatMapTransform: {
                                value: new Qt
                            },
                            clearcoatNormalMap: {
                                value: null
                            },
                            clearcoatNormalMapTransform: {
                                value: new Qt
                            },
                            clearcoatNormalScale: {
                                value: new jt(1,1)
                            },
                            clearcoatRoughness: {
                                value: 0
                            },
                            clearcoatRoughnessMap: {
                                value: null
                            },
                            clearcoatRoughnessMapTransform: {
                                value: new Qt
                            },
                            dispersion: {
                                value: 0
                            },
                            iridescence: {
                                value: 0
                            },
                            iridescenceMap: {
                                value: null
                            },
                            iridescenceMapTransform: {
                                value: new Qt
                            },
                            iridescenceIOR: {
                                value: 1.3
                            },
                            iridescenceThicknessMinimum: {
                                value: 100
                            },
                            iridescenceThicknessMaximum: {
                                value: 400
                            },
                            iridescenceThicknessMap: {
                                value: null
                            },
                            iridescenceThicknessMapTransform: {
                                value: new Qt
                            },
                            sheen: {
                                value: 0
                            },
                            sheenColor: {
                                value: new Wi(0)
                            },
                            sheenColorMap: {
                                value: null
                            },
                            sheenColorMapTransform: {
                                value: new Qt
                            },
                            sheenRoughness: {
                                value: 1
                            },
                            sheenRoughnessMap: {
                                value: null
                            },
                            sheenRoughnessMapTransform: {
                                value: new Qt
                            },
                            transmission: {
                                value: 0
                            },
                            transmissionMap: {
                                value: null
                            },
                            transmissionMapTransform: {
                                value: new Qt
                            },
                            transmissionSamplerSize: {
                                value: new jt
                            },
                            transmissionSamplerMap: {
                                value: null
                            },
                            thickness: {
                                value: 0
                            },
                            thicknessMap: {
                                value: null
                            },
                            thicknessMapTransform: {
                                value: new Qt
                            },
                            attenuationDistance: {
                                value: 0
                            },
                            attenuationColor: {
                                value: new Wi(0)
                            },
                            specularColor: {
                                value: new Wi(1,1,1)
                            },
                            specularColorMap: {
                                value: null
                            },
                            specularColorMapTransform: {
                                value: new Qt
                            },
                            specularIntensity: {
                                value: 1
                            },
                            specularIntensityMap: {
                                value: null
                            },
                            specularIntensityMapTransform: {
                                value: new Qt
                            },
                            anisotropyVector: {
                                value: new jt
                            },
                            anisotropyMap: {
                                value: null
                            },
                            anisotropyMapTransform: {
                                value: new Qt
                            }
                        }]),
                        vertexShader: mc.meshphysical_vert,
                        fragmentShader: mc.meshphysical_frag
                    };
                    const wc = {
                        r: 0,
                        b: 0,
                        g: 0
                    }
                        , Ac = new ai
                        , yc = new Kn;
                    function bc(e, t, n, i, r, a, s) {
                        const o = new Wi(0);
                        let l, c, h = !0 === a ? 0 : 1, d = null, u = 0, p = null;
                        function f(e) {
                            let i = !0 === e.isScene ? e.background : null;
                            if (i && i.isTexture) {
                                i = (e.backgroundBlurriness > 0 ? n : t).get(i)
                            }
                            return i
                        }
                        function m(t, n) {
                            t.getRGB(wc, kr(e)),
                                i.buffers.color.setClear(wc.r, wc.g, wc.b, n, s)
                        }
                        return {
                            getClearColor: function() {
                                return o
                            },
                            setClearColor: function(e, t=1) {
                                o.set(e),
                                    h = t,
                                    m(o, h)
                            },
                            getClearAlpha: function() {
                                return h
                            },
                            setClearAlpha: function(e) {
                                h = e,
                                    m(o, h)
                            },
                            render: function(t) {
                                let n = !1;
                                const r = f(t);
                                null === r ? m(o, h) : r && r.isColor && (m(r, 1),
                                    n = !0);
                                const a = e.xr.getEnvironmentBlendMode();
                                "additive" === a ? i.buffers.color.setClear(0, 0, 0, 1, s) : "alpha-blend" === a && i.buffers.color.setClear(0, 0, 0, 0, s),
                                (e.autoClear || n) && (i.buffers.depth.setTest(!0),
                                    i.buffers.depth.setMask(!0),
                                    i.buffers.color.setMask(!0),
                                    e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil))
                            },
                            addToRenderList: function(t, n) {
                                const i = f(n);
                                i && (i.isCubeTexture || i.mapping === ie) ? (void 0 === c && (c = new wr(new yr(1,1,1),new Sr({
                                    name: "BackgroundCubeMaterial",
                                    uniforms: br(vc.backgroundCube.uniforms),
                                    vertexShader: vc.backgroundCube.vertexShader,
                                    fragmentShader: vc.backgroundCube.fragmentShader,
                                    side: 1,
                                    depthTest: !1,
                                    depthWrite: !1,
                                    fog: !1
                                })),
                                    c.geometry.deleteAttribute("normal"),
                                    c.geometry.deleteAttribute("uv"),
                                    c.onBeforeRender = function(e, t, n) {
                                        this.matrixWorld.copyPosition(n.matrixWorld)
                                    }
                                    ,
                                    Object.defineProperty(c.material, "envMap", {
                                        get: function() {
                                            return this.uniforms.envMap.value
                                        }
                                    }),
                                    r.update(c)),
                                    Ac.copy(n.backgroundRotation),
                                    Ac.x *= -1,
                                    Ac.y *= -1,
                                    Ac.z *= -1,
                                i.isCubeTexture && !1 === i.isRenderTargetTexture && (Ac.y *= -1,
                                    Ac.z *= -1),
                                    c.material.uniforms.envMap.value = i,
                                    c.material.uniforms.flipEnvMap.value = i.isCubeTexture && !1 === i.isRenderTargetTexture ? -1 : 1,
                                    c.material.uniforms.backgroundBlurriness.value = n.backgroundBlurriness,
                                    c.material.uniforms.backgroundIntensity.value = n.backgroundIntensity,
                                    c.material.uniforms.backgroundRotation.value.setFromMatrix4(yc.makeRotationFromEuler(Ac)),
                                    c.material.toneMapped = nn.getTransfer(i.colorSpace) !== At,
                                d === i && u === i.version && p === e.toneMapping || (c.material.needsUpdate = !0,
                                    d = i,
                                    u = i.version,
                                    p = e.toneMapping),
                                    c.layers.enableAll(),
                                    t.unshift(c, c.geometry, c.material, 0, 0, null)) : i && i.isTexture && (void 0 === l && (l = new wr(new Ds(2,2),new Sr({
                                    name: "BackgroundMaterial",
                                    uniforms: br(vc.background.uniforms),
                                    vertexShader: vc.background.vertexShader,
                                    fragmentShader: vc.background.fragmentShader,
                                    side: 0,
                                    depthTest: !1,
                                    depthWrite: !1,
                                    fog: !1
                                })),
                                    l.geometry.deleteAttribute("normal"),
                                    Object.defineProperty(l.material, "map", {
                                        get: function() {
                                            return this.uniforms.t2D.value
                                        }
                                    }),
                                    r.update(l)),
                                    l.material.uniforms.t2D.value = i,
                                    l.material.uniforms.backgroundIntensity.value = n.backgroundIntensity,
                                    l.material.toneMapped = nn.getTransfer(i.colorSpace) !== At,
                                !0 === i.matrixAutoUpdate && i.updateMatrix(),
                                    l.material.uniforms.uvTransform.value.copy(i.matrix),
                                d === i && u === i.version && p === e.toneMapping || (l.material.needsUpdate = !0,
                                    d = i,
                                    u = i.version,
                                    p = e.toneMapping),
                                    l.layers.enableAll(),
                                    t.unshift(l, l.geometry, l.material, 0, 0, null))
                            },
                            dispose: function() {
                                void 0 !== c && (c.geometry.dispose(),
                                    c.material.dispose(),
                                    c = void 0),
                                void 0 !== l && (l.geometry.dispose(),
                                    l.material.dispose(),
                                    l = void 0)
                            }
                        }
                    }
                    function xc(e, t) {
                        const n = e.getParameter(e.MAX_VERTEX_ATTRIBS)
                            , i = {}
                            , r = c(null);
                        let a = r
                            , s = !1;
                        function o(t) {
                            return e.bindVertexArray(t)
                        }
                        function l(t) {
                            return e.deleteVertexArray(t)
                        }
                        function c(e) {
                            const t = []
                                , i = []
                                , r = [];
                            for (let e = 0; e < n; e++)
                                t[e] = 0,
                                    i[e] = 0,
                                    r[e] = 0;
                            return {
                                geometry: null,
                                program: null,
                                wireframe: !1,
                                newAttributes: t,
                                enabledAttributes: i,
                                attributeDivisors: r,
                                object: e,
                                attributes: {},
                                index: null
                            }
                        }
                        function h() {
                            const e = a.newAttributes;
                            for (let t = 0, n = e.length; t < n; t++)
                                e[t] = 0
                        }
                        function d(e) {
                            u(e, 0)
                        }
                        function u(t, n) {
                            const i = a.newAttributes
                                , r = a.enabledAttributes
                                , s = a.attributeDivisors;
                            i[t] = 1,
                            0 === r[t] && (e.enableVertexAttribArray(t),
                                r[t] = 1),
                            s[t] !== n && (e.vertexAttribDivisor(t, n),
                                s[t] = n)
                        }
                        function p() {
                            const t = a.newAttributes
                                , n = a.enabledAttributes;
                            for (let i = 0, r = n.length; i < r; i++)
                                n[i] !== t[i] && (e.disableVertexAttribArray(i),
                                    n[i] = 0)
                        }
                        function f(t, n, i, r, a, s, o) {
                            !0 === o ? e.vertexAttribIPointer(t, n, i, a, s) : e.vertexAttribPointer(t, n, i, r, a, s)
                        }
                        function m() {
                            g(),
                                s = !0,
                            a !== r && (a = r,
                                o(a.object))
                        }
                        function g() {
                            r.geometry = null,
                                r.program = null,
                                r.wireframe = !1
                        }
                        return {
                            setup: function(n, r, l, m, g) {
                                let v = !1;
                                const w = function(t, n, r) {
                                    const a = !0 === r.wireframe;
                                    let s = i[t.id];
                                    void 0 === s && (s = {},
                                        i[t.id] = s);
                                    let o = s[n.id];
                                    void 0 === o && (o = {},
                                        s[n.id] = o);
                                    let l = o[a];
                                    void 0 === l && (l = c(e.createVertexArray()),
                                        o[a] = l);
                                    return l
                                }(m, l, r);
                                a !== w && (a = w,
                                    o(a.object)),
                                    v = function(e, t, n, i) {
                                        const r = a.attributes
                                            , s = t.attributes;
                                        let o = 0;
                                        const l = n.getAttributes();
                                        for (const t in l) {
                                            if (l[t].location >= 0) {
                                                const n = r[t];
                                                let i = s[t];
                                                if (void 0 === i && ("instanceMatrix" === t && e.instanceMatrix && (i = e.instanceMatrix),
                                                "instanceColor" === t && e.instanceColor && (i = e.instanceColor)),
                                                void 0 === n)
                                                    return !0;
                                                if (n.attribute !== i)
                                                    return !0;
                                                if (i && n.data !== i.data)
                                                    return !0;
                                                o++
                                            }
                                        }
                                        return a.attributesNum !== o || a.index !== i
                                    }(n, m, l, g),
                                v && function(e, t, n, i) {
                                    const r = {}
                                        , s = t.attributes;
                                    let o = 0;
                                    const l = n.getAttributes();
                                    for (const t in l) {
                                        if (l[t].location >= 0) {
                                            let n = s[t];
                                            void 0 === n && ("instanceMatrix" === t && e.instanceMatrix && (n = e.instanceMatrix),
                                            "instanceColor" === t && e.instanceColor && (n = e.instanceColor));
                                            const i = {};
                                            i.attribute = n,
                                            n && n.data && (i.data = n.data),
                                                r[t] = i,
                                                o++
                                        }
                                    }
                                    a.attributes = r,
                                        a.attributesNum = o,
                                        a.index = i
                                }(n, m, l, g),
                                null !== g && t.update(g, e.ELEMENT_ARRAY_BUFFER),
                                (v || s) && (s = !1,
                                    function(n, i, r, a) {
                                        h();
                                        const s = a.attributes
                                            , o = r.getAttributes()
                                            , l = i.defaultAttributeValues;
                                        for (const i in o) {
                                            const r = o[i];
                                            if (r.location >= 0) {
                                                let o = s[i];
                                                if (void 0 === o && ("instanceMatrix" === i && n.instanceMatrix && (o = n.instanceMatrix),
                                                "instanceColor" === i && n.instanceColor && (o = n.instanceColor)),
                                                void 0 !== o) {
                                                    const i = o.normalized
                                                        , s = o.itemSize
                                                        , l = t.get(o);
                                                    if (void 0 === l)
                                                        continue;
                                                    const c = l.buffer
                                                        , h = l.type
                                                        , p = l.bytesPerElement
                                                        , m = h === e.INT || h === e.UNSIGNED_INT || o.gpuType === ve;
                                                    if (o.isInterleavedBufferAttribute) {
                                                        const t = o.data
                                                            , l = t.stride
                                                            , g = o.offset;
                                                        if (t.isInstancedInterleavedBuffer) {
                                                            for (let e = 0; e < r.locationSize; e++)
                                                                u(r.location + e, t.meshPerAttribute);
                                                            !0 !== n.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = t.meshPerAttribute * t.count)
                                                        } else
                                                            for (let e = 0; e < r.locationSize; e++)
                                                                d(r.location + e);
                                                        e.bindBuffer(e.ARRAY_BUFFER, c);
                                                        for (let e = 0; e < r.locationSize; e++)
                                                            f(r.location + e, s / r.locationSize, h, i, l * p, (g + s / r.locationSize * e) * p, m)
                                                    } else {
                                                        if (o.isInstancedBufferAttribute) {
                                                            for (let e = 0; e < r.locationSize; e++)
                                                                u(r.location + e, o.meshPerAttribute);
                                                            !0 !== n.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = o.meshPerAttribute * o.count)
                                                        } else
                                                            for (let e = 0; e < r.locationSize; e++)
                                                                d(r.location + e);
                                                        e.bindBuffer(e.ARRAY_BUFFER, c);
                                                        for (let e = 0; e < r.locationSize; e++)
                                                            f(r.location + e, s / r.locationSize, h, i, s * p, s / r.locationSize * e * p, m)
                                                    }
                                                } else if (void 0 !== l) {
                                                    const t = l[i];
                                                    if (void 0 !== t)
                                                        switch (t.length) {
                                                            case 2:
                                                                e.vertexAttrib2fv(r.location, t);
                                                                break;
                                                            case 3:
                                                                e.vertexAttrib3fv(r.location, t);
                                                                break;
                                                            case 4:
                                                                e.vertexAttrib4fv(r.location, t);
                                                                break;
                                                            default:
                                                                e.vertexAttrib1fv(r.location, t)
                                                        }
                                                }
                                            }
                                        }
                                        p()
                                    }(n, r, l, m),
                                null !== g && e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t.get(g).buffer))
                            },
                            reset: m,
                            resetDefaultState: g,
                            dispose: function() {
                                m();
                                for (const e in i) {
                                    const t = i[e];
                                    for (const e in t) {
                                        const n = t[e];
                                        for (const e in n)
                                            l(n[e].object),
                                                delete n[e];
                                        delete t[e]
                                    }
                                    delete i[e]
                                }
                            },
                            releaseStatesOfGeometry: function(e) {
                                if (void 0 === i[e.id])
                                    return;
                                const t = i[e.id];
                                for (const e in t) {
                                    const n = t[e];
                                    for (const e in n)
                                        l(n[e].object),
                                            delete n[e];
                                    delete t[e]
                                }
                                delete i[e.id]
                            },
                            releaseStatesOfProgram: function(e) {
                                for (const t in i) {
                                    const n = i[t];
                                    if (void 0 === n[e.id])
                                        continue;
                                    const r = n[e.id];
                                    for (const e in r)
                                        l(r[e].object),
                                            delete r[e];
                                    delete n[e.id]
                                }
                            },
                            initAttributes: h,
                            enableAttribute: d,
                            disableUnusedAttributes: p
                        }
                    }
                    function kc(e, t, n) {
                        let i;
                        function r(t, r, a) {
                            0 !== a && (e.drawArraysInstanced(i, t, r, a),
                                n.update(r, i, a))
                        }
                        this.setMode = function(e) {
                            i = e
                        }
                            ,
                            this.render = function(t, r) {
                                e.drawArrays(i, t, r),
                                    n.update(r, i, 1)
                            }
                            ,
                            this.renderInstances = r,
                            this.renderMultiDraw = function(e, r, a) {
                                if (0 === a)
                                    return;
                                t.get("WEBGL_multi_draw").multiDrawArraysWEBGL(i, e, 0, r, 0, a);
                                let s = 0;
                                for (let e = 0; e < a; e++)
                                    s += r[e];
                                n.update(s, i, 1)
                            }
                            ,
                            this.renderMultiDrawInstances = function(e, a, s, o) {
                                if (0 === s)
                                    return;
                                const l = t.get("WEBGL_multi_draw");
                                if (null === l)
                                    for (let t = 0; t < e.length; t++)
                                        r(e[t], a[t], o[t]);
                                else {
                                    l.multiDrawArraysInstancedWEBGL(i, e, 0, a, 0, o, 0, s);
                                    let t = 0;
                                    for (let e = 0; e < s; e++)
                                        t += a[e] * o[e];
                                    n.update(t, i, 1)
                                }
                            }
                    }
                    function Ec(e, t, n, i) {
                        let r;
                        function a(t) {
                            if ("highp" === t) {
                                if (e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision > 0)
                                    return "highp";
                                t = "mediump"
                            }
                            return "mediump" === t && e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
                        }
                        let s = void 0 !== n.precision ? n.precision : "highp";
                        const o = a(s);
                        o !== s && (console.warn("THREE.WebGLRenderer:", s, "not supported, using", o, "instead."),
                            s = o);
                        const l = !0 === n.logarithmicDepthBuffer
                            , c = !0 === n.reverseDepthBuffer && t.has("EXT_clip_control")
                            , h = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)
                            , d = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
                        return {
                            isWebGL2: !0,
                            getMaxAnisotropy: function() {
                                if (void 0 !== r)
                                    return r;
                                if (!0 === t.has("EXT_texture_filter_anisotropic")) {
                                    const n = t.get("EXT_texture_filter_anisotropic");
                                    r = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                                } else
                                    r = 0;
                                return r
                            },
                            getMaxPrecision: a,
                            textureFormatReadable: function(t) {
                                return t === Se || i.convert(t) === e.getParameter(e.IMPLEMENTATION_COLOR_READ_FORMAT)
                            },
                            textureTypeReadable: function(n) {
                                const r = n === ye && (t.has("EXT_color_buffer_half_float") || t.has("EXT_color_buffer_float"));
                                return !(n !== pe && i.convert(n) !== e.getParameter(e.IMPLEMENTATION_COLOR_READ_TYPE) && n !== Ae && !r)
                            },
                            precision: s,
                            logarithmicDepthBuffer: l,
                            reverseDepthBuffer: c,
                            maxTextures: h,
                            maxVertexTextures: d,
                            maxTextureSize: e.getParameter(e.MAX_TEXTURE_SIZE),
                            maxCubemapSize: e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE),
                            maxAttributes: e.getParameter(e.MAX_VERTEX_ATTRIBS),
                            maxVertexUniforms: e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS),
                            maxVaryings: e.getParameter(e.MAX_VARYING_VECTORS),
                            maxFragmentUniforms: e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS),
                            vertexTextures: d > 0,
                            maxSamples: e.getParameter(e.MAX_SAMPLES)
                        }
                    }
                    function Sc(e) {
                        const t = this;
                        let n = null
                            , i = 0
                            , r = !1
                            , a = !1;
                        const s = new ga
                            , o = new Qt
                            , l = {
                            value: null,
                            needsUpdate: !1
                        };
                        function c(e, n, i, r) {
                            const a = null !== e ? e.length : 0;
                            let c = null;
                            if (0 !== a) {
                                if (c = l.value,
                                !0 !== r || null === c) {
                                    const t = i + 4 * a
                                        , r = n.matrixWorldInverse;
                                    o.getNormalMatrix(r),
                                    (null === c || c.length < t) && (c = new Float32Array(t));
                                    for (let t = 0, n = i; t !== a; ++t,
                                        n += 4)
                                        s.copy(e[t]).applyMatrix4(r, o),
                                            s.normal.toArray(c, n),
                                            c[n + 3] = s.constant
                                }
                                l.value = c,
                                    l.needsUpdate = !0
                            }
                            return t.numPlanes = a,
                                t.numIntersection = 0,
                                c
                        }
                        this.uniform = l,
                            this.numPlanes = 0,
                            this.numIntersection = 0,
                            this.init = function(e, t) {
                                const n = 0 !== e.length || t || 0 !== i || r;
                                return r = t,
                                    i = e.length,
                                    n
                            }
                            ,
                            this.beginShadows = function() {
                                a = !0,
                                    c(null)
                            }
                            ,
                            this.endShadows = function() {
                                a = !1
                            }
                            ,
                            this.setGlobalState = function(e, t) {
                                n = c(e, t, 0)
                            }
                            ,
                            this.setState = function(s, o, h) {
                                const d = s.clippingPlanes
                                    , u = s.clipIntersection
                                    , p = s.clipShadows
                                    , f = e.get(s);
                                if (!r || null === d || 0 === d.length || a && !p)
                                    a ? c(null) : function() {
                                        l.value !== n && (l.value = n,
                                            l.needsUpdate = i > 0);
                                        t.numPlanes = i,
                                            t.numIntersection = 0
                                    }();
                                else {
                                    const e = a ? 0 : i
                                        , t = 4 * e;
                                    let r = f.clippingState || null;
                                    l.value = r,
                                        r = c(d, o, t, h);
                                    for (let e = 0; e !== t; ++e)
                                        r[e] = n[e];
                                    f.clippingState = r,
                                        this.numIntersection = u ? this.numPlanes : 0,
                                        this.numPlanes += e
                                }
                            }
                    }
                    function Mc(e) {
                        let t = new WeakMap;
                        function n(e, t) {
                            return t === te ? e.mapping = $ : t === ne && (e.mapping = ee),
                                e
                        }
                        function i(e) {
                            const n = e.target;
                            n.removeEventListener("dispose", i);
                            const r = t.get(n);
                            void 0 !== r && (t.delete(n),
                                r.dispose())
                        }
                        return {
                            get: function(r) {
                                if (r && r.isTexture) {
                                    const a = r.mapping;
                                    if (a === te || a === ne) {
                                        if (t.has(r)) {
                                            return n(t.get(r).texture, r.mapping)
                                        }
                                        {
                                            const a = r.image;
                                            if (a && a.height > 0) {
                                                const s = new Nr(a.height);
                                                return s.fromEquirectangularTexture(e, r),
                                                    t.set(r, s),
                                                    r.addEventListener("dispose", i),
                                                    n(s.texture, r.mapping)
                                            }
                                            return null
                                        }
                                    }
                                }
                                return r
                            },
                            dispose: function() {
                                t = new WeakMap
                            }
                        }
                    }
                    const Tc = [.125, .215, .35, .446, .526, .582]
                        , Cc = 20
                        , _c = new Po
                        , Ic = new Wi;
                    let Pc = null
                        , Rc = 0
                        , Lc = 0
                        , Nc = !1;
                    const Dc = (1 + Math.sqrt(5)) / 2
                        , Bc = 1 / Dc
                        , Uc = [new An(-Dc,Bc,0), new An(Dc,Bc,0), new An(-Bc,0,Dc), new An(Bc,0,Dc), new An(0,Dc,-Bc), new An(0,Dc,Bc), new An(-1,1,-1), new An(1,1,-1), new An(-1,1,1), new An(1,1,1)]
                        , zc = new An;
                    class Oc {
                        constructor(e) {
                            this._renderer = e,
                                this._pingPongRenderTarget = null,
                                this._lodMax = 0,
                                this._cubeSize = 0,
                                this._lodPlanes = [],
                                this._sizeLods = [],
                                this._sigmas = [],
                                this._blurMaterial = null,
                                this._cubemapMaterial = null,
                                this._equirectMaterial = null,
                                this._compileMaterial(this._blurMaterial)
                        }
                        fromScene(e, t=0, n=.1, i=100, r={}) {
                            const {size: a=256, position: s=zc} = r;
                            Pc = this._renderer.getRenderTarget(),
                                Rc = this._renderer.getActiveCubeFace(),
                                Lc = this._renderer.getActiveMipmapLevel(),
                                Nc = this._renderer.xr.enabled,
                                this._renderer.xr.enabled = !1,
                                this._setSize(a);
                            const o = this._allocateTargets();
                            return o.depthBuffer = !0,
                                this._sceneToCubeUV(e, n, i, o, s),
                            t > 0 && this._blur(o, 0, 0, t),
                                this._applyPMREM(o),
                                this._cleanup(o),
                                o
                        }
                        fromEquirectangular(e, t=null) {
                            return this._fromTexture(e, t)
                        }
                        fromCubemap(e, t=null) {
                            return this._fromTexture(e, t)
                        }
                        compileCubemapShader() {
                            null === this._cubemapMaterial && (this._cubemapMaterial = Vc(),
                                this._compileMaterial(this._cubemapMaterial))
                        }
                        compileEquirectangularShader() {
                            null === this._equirectMaterial && (this._equirectMaterial = Hc(),
                                this._compileMaterial(this._equirectMaterial))
                        }
                        dispose() {
                            this._dispose(),
                            null !== this._cubemapMaterial && this._cubemapMaterial.dispose(),
                            null !== this._equirectMaterial && this._equirectMaterial.dispose()
                        }
                        _setSize(e) {
                            this._lodMax = Math.floor(Math.log2(e)),
                                this._cubeSize = Math.pow(2, this._lodMax)
                        }
                        _dispose() {
                            null !== this._blurMaterial && this._blurMaterial.dispose(),
                            null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
                            for (let e = 0; e < this._lodPlanes.length; e++)
                                this._lodPlanes[e].dispose()
                        }
                        _cleanup(e) {
                            this._renderer.setRenderTarget(Pc, Rc, Lc),
                                this._renderer.xr.enabled = Nc,
                                e.scissorTest = !1,
                                Wc(e, 0, 0, e.width, e.height)
                        }
                        _fromTexture(e, t) {
                            e.mapping === $ || e.mapping === ee ? this._setSize(0 === e.image.length ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4),
                                Pc = this._renderer.getRenderTarget(),
                                Rc = this._renderer.getActiveCubeFace(),
                                Lc = this._renderer.getActiveMipmapLevel(),
                                Nc = this._renderer.xr.enabled,
                                this._renderer.xr.enabled = !1;
                            const n = t || this._allocateTargets();
                            return this._textureToCubeUV(e, n),
                                this._applyPMREM(n),
                                this._cleanup(n),
                                n
                        }
                        _allocateTargets() {
                            const e = 3 * Math.max(this._cubeSize, 112)
                                , t = 4 * this._cubeSize
                                , n = {
                                magFilter: he,
                                minFilter: he,
                                generateMipmaps: !1,
                                type: ye,
                                format: Se,
                                colorSpace: vt,
                                depthBuffer: !1
                            }
                                , i = Fc(e, t, n);
                            if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
                                null !== this._pingPongRenderTarget && this._dispose(),
                                    this._pingPongRenderTarget = Fc(e, t, n);
                                const {_lodMax: i} = this;
                                ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = function(e) {
                                    const t = []
                                        , n = []
                                        , i = [];
                                    let r = e;
                                    const a = e - 4 + 1 + Tc.length;
                                    for (let s = 0; s < a; s++) {
                                        const a = Math.pow(2, r);
                                        n.push(a);
                                        let o = 1 / a;
                                        s > e - 4 ? o = Tc[s - e + 4 - 1] : 0 === s && (o = 0),
                                            i.push(o);
                                        const l = 1 / (a - 2)
                                            , c = -l
                                            , h = 1 + l
                                            , d = [c, c, h, c, h, h, c, c, h, h, c, h]
                                            , u = 6
                                            , p = 6
                                            , f = 3
                                            , m = 2
                                            , g = 1
                                            , v = new Float32Array(f * p * u)
                                            , w = new Float32Array(m * p * u)
                                            , A = new Float32Array(g * p * u);
                                        for (let e = 0; e < u; e++) {
                                            const t = e % 3 * 2 / 3 - 1
                                                , n = e > 2 ? 0 : -1
                                                , i = [t, n, 0, t + 2 / 3, n, 0, t + 2 / 3, n + 1, 0, t, n, 0, t + 2 / 3, n + 1, 0, t, n + 1, 0];
                                            v.set(i, f * p * e),
                                                w.set(d, m * p * e);
                                            const r = [e, e, e, e, e, e];
                                            A.set(r, g * p * e)
                                        }
                                        const y = new sr;
                                        y.setAttribute("position", new Ki(v,f)),
                                            y.setAttribute("uv", new Ki(w,m)),
                                            y.setAttribute("faceIndex", new Ki(A,g)),
                                            t.push(y),
                                        r > 4 && r--
                                    }
                                    return {
                                        lodPlanes: t,
                                        sizeLods: n,
                                        sigmas: i
                                    }
                                }(i)),
                                    this._blurMaterial = function(e, t, n) {
                                        const i = new Float32Array(Cc)
                                            , r = new An(0,1,0)
                                            , a = new Sr({
                                            name: "SphericalGaussianBlur",
                                            defines: {
                                                n: Cc,
                                                CUBEUV_TEXEL_WIDTH: 1 / t,
                                                CUBEUV_TEXEL_HEIGHT: 1 / n,
                                                CUBEUV_MAX_MIP: `${e}.0`
                                            },
                                            uniforms: {
                                                envMap: {
                                                    value: null
                                                },
                                                samples: {
                                                    value: 1
                                                },
                                                weights: {
                                                    value: i
                                                },
                                                latitudinal: {
                                                    value: !1
                                                },
                                                dTheta: {
                                                    value: 0
                                                },
                                                mipInt: {
                                                    value: 0
                                                },
                                                poleAxis: {
                                                    value: r
                                                }
                                            },
                                            vertexShader: Gc(),
                                            fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                                            blending: 0,
                                            depthTest: !1,
                                            depthWrite: !1
                                        });
                                        return a
                                    }(i, e, t)
                            }
                            return i
                        }
                        _compileMaterial(e) {
                            const t = new wr(this._lodPlanes[0],e);
                            this._renderer.compile(t, _c)
                        }
                        _sceneToCubeUV(e, t, n, i, r) {
                            const a = new Ir(90,1,t,n)
                                , s = [1, -1, 1, 1, 1, 1]
                                , o = [1, 1, 1, -1, -1, -1]
                                , l = this._renderer
                                , c = l.autoClear
                                , h = l.toneMapping;
                            l.getClearColor(Ic),
                                l.toneMapping = 0,
                                l.autoClear = !1;
                            const d = new ji({
                                name: "PMREM.Background",
                                side: 1,
                                depthWrite: !1,
                                depthTest: !1
                            })
                                , u = new wr(new yr,d);
                            let p = !1;
                            const f = e.background;
                            f ? f.isColor && (d.color.copy(f),
                                e.background = null,
                                p = !0) : (d.color.copy(Ic),
                                p = !0);
                            for (let t = 0; t < 6; t++) {
                                const n = t % 3;
                                0 === n ? (a.up.set(0, s[t], 0),
                                    a.position.set(r.x, r.y, r.z),
                                    a.lookAt(r.x + o[t], r.y, r.z)) : 1 === n ? (a.up.set(0, 0, s[t]),
                                    a.position.set(r.x, r.y, r.z),
                                    a.lookAt(r.x, r.y + o[t], r.z)) : (a.up.set(0, s[t], 0),
                                    a.position.set(r.x, r.y, r.z),
                                    a.lookAt(r.x, r.y, r.z + o[t]));
                                const c = this._cubeSize;
                                Wc(i, n * c, t > 2 ? c : 0, c, c),
                                    l.setRenderTarget(i),
                                p && l.render(u, a),
                                    l.render(e, a)
                            }
                            u.geometry.dispose(),
                                u.material.dispose(),
                                l.toneMapping = h,
                                l.autoClear = c,
                                e.background = f
                        }
                        _textureToCubeUV(e, t) {
                            const n = this._renderer
                                , i = e.mapping === $ || e.mapping === ee;
                            i ? (null === this._cubemapMaterial && (this._cubemapMaterial = Vc()),
                                this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === e.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = Hc());
                            const r = i ? this._cubemapMaterial : this._equirectMaterial
                                , a = new wr(this._lodPlanes[0],r);
                            r.uniforms.envMap.value = e;
                            const s = this._cubeSize;
                            Wc(t, 0, 0, 3 * s, 2 * s),
                                n.setRenderTarget(t),
                                n.render(a, _c)
                        }
                        _applyPMREM(e) {
                            const t = this._renderer
                                , n = t.autoClear;
                            t.autoClear = !1;
                            const i = this._lodPlanes.length;
                            for (let t = 1; t < i; t++) {
                                const n = Math.sqrt(this._sigmas[t] * this._sigmas[t] - this._sigmas[t - 1] * this._sigmas[t - 1])
                                    , r = Uc[(i - t - 1) % Uc.length];
                                this._blur(e, t - 1, t, n, r)
                            }
                            t.autoClear = n
                        }
                        _blur(e, t, n, i, r) {
                            const a = this._pingPongRenderTarget;
                            this._halfBlur(e, a, t, n, i, "latitudinal", r),
                                this._halfBlur(a, e, n, n, i, "longitudinal", r)
                        }
                        _halfBlur(e, t, n, i, r, a, s) {
                            const o = this._renderer
                                , l = this._blurMaterial;
                            "latitudinal" !== a && "longitudinal" !== a && console.error("blur direction must be either latitudinal or longitudinal!");
                            const c = new wr(this._lodPlanes[i],l)
                                , h = l.uniforms
                                , d = this._sizeLods[n] - 1
                                , u = isFinite(r) ? Math.PI / (2 * d) : 2 * Math.PI / 39
                                , p = r / u
                                , f = isFinite(r) ? 1 + Math.floor(3 * p) : Cc;
                            f > Cc && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);
                            const m = [];
                            let g = 0;
                            for (let e = 0; e < Cc; ++e) {
                                const t = e / p
                                    , n = Math.exp(-t * t / 2);
                                m.push(n),
                                    0 === e ? g += n : e < f && (g += 2 * n)
                            }
                            for (let e = 0; e < m.length; e++)
                                m[e] = m[e] / g;
                            h.envMap.value = e.texture,
                                h.samples.value = f,
                                h.weights.value = m,
                                h.latitudinal.value = "latitudinal" === a,
                            s && (h.poleAxis.value = s);
                            const {_lodMax: v} = this;
                            h.dTheta.value = u,
                                h.mipInt.value = v - n;
                            const w = this._sizeLods[i];
                            Wc(t, 3 * w * (i > v - 4 ? i - v + 4 : 0), 4 * (this._cubeSize - w), 3 * w, 2 * w),
                                o.setRenderTarget(t),
                                o.render(c, _c)
                        }
                    }
                    function Fc(e, t, n) {
                        const i = new mn(e,t,n);
                        return i.texture.mapping = ie,
                            i.texture.name = "PMREM.cubeUv",
                            i.scissorTest = !0,
                            i
                    }
                    function Wc(e, t, n, i, r) {
                        e.viewport.set(t, n, i, r),
                            e.scissor.set(t, n, i, r)
                    }
                    function Hc() {
                        return new Sr({
                            name: "EquirectangularToCubeUV",
                            uniforms: {
                                envMap: {
                                    value: null
                                }
                            },
                            vertexShader: Gc(),
                            fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
                            blending: 0,
                            depthTest: !1,
                            depthWrite: !1
                        })
                    }
                    function Vc() {
                        return new Sr({
                            name: "CubemapToCubeUV",
                            uniforms: {
                                envMap: {
                                    value: null
                                },
                                flipEnvMap: {
                                    value: -1
                                }
                            },
                            vertexShader: Gc(),
                            fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
                            blending: 0,
                            depthTest: !1,
                            depthWrite: !1
                        })
                    }
                    function Gc() {
                        return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"
                    }
                    function jc(e) {
                        let t = new WeakMap
                            , n = null;
                        function i(e) {
                            const n = e.target;
                            n.removeEventListener("dispose", i);
                            const r = t.get(n);
                            void 0 !== r && (t.delete(n),
                                r.dispose())
                        }
                        return {
                            get: function(r) {
                                if (r && r.isTexture) {
                                    const a = r.mapping
                                        , s = a === te || a === ne
                                        , o = a === $ || a === ee;
                                    if (s || o) {
                                        let a = t.get(r);
                                        const l = void 0 !== a ? a.texture.pmremVersion : 0;
                                        if (r.isRenderTargetTexture && r.pmremVersion !== l)
                                            return null === n && (n = new Oc(e)),
                                                a = s ? n.fromEquirectangular(r, a) : n.fromCubemap(r, a),
                                                a.texture.pmremVersion = r.pmremVersion,
                                                t.set(r, a),
                                                a.texture;
                                        if (void 0 !== a)
                                            return a.texture;
                                        {
                                            const l = r.image;
                                            return s && l && l.height > 0 || o && l && function(e) {
                                                let t = 0;
                                                const n = 6;
                                                for (let i = 0; i < n; i++)
                                                    void 0 !== e[i] && t++;
                                                return t === n
                                            }(l) ? (null === n && (n = new Oc(e)),
                                                a = s ? n.fromEquirectangular(r) : n.fromCubemap(r),
                                                a.texture.pmremVersion = r.pmremVersion,
                                                t.set(r, a),
                                                r.addEventListener("dispose", i),
                                                a.texture) : null
                                        }
                                    }
                                }
                                return r
                            },
                            dispose: function() {
                                t = new WeakMap,
                                null !== n && (n.dispose(),
                                    n = null)
                            }
                        }
                    }
                    function Qc(e) {
                        const t = {};
                        function n(n) {
                            if (void 0 !== t[n])
                                return t[n];
                            let i;
                            switch (n) {
                                case "WEBGL_depth_texture":
                                    i = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
                                    break;
                                case "EXT_texture_filter_anisotropic":
                                    i = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                                    break;
                                case "WEBGL_compressed_texture_s3tc":
                                    i = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                                    break;
                                case "WEBGL_compressed_texture_pvrtc":
                                    i = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                                    break;
                                default:
                                    i = e.getExtension(n)
                            }
                            return t[n] = i,
                                i
                        }
                        return {
                            has: function(e) {
                                return null !== n(e)
                            },
                            init: function() {
                                n("EXT_color_buffer_float"),
                                    n("WEBGL_clip_cull_distance"),
                                    n("OES_texture_float_linear"),
                                    n("EXT_color_buffer_half_float"),
                                    n("WEBGL_multisampled_render_to_texture"),
                                    n("WEBGL_render_shared_exponent")
                            },
                            get: function(e) {
                                const t = n(e);
                                return null === t && Jt("THREE.WebGLRenderer: " + e + " extension not supported."),
                                    t
                            }
                        }
                    }
                    function Yc(e, t, n, i) {
                        const r = {}
                            , a = new WeakMap;
                        function s(e) {
                            const o = e.target;
                            null !== o.index && t.remove(o.index);
                            for (const e in o.attributes)
                                t.remove(o.attributes[e]);
                            o.removeEventListener("dispose", s),
                                delete r[o.id];
                            const l = a.get(o);
                            l && (t.remove(l),
                                a.delete(o)),
                                i.releaseStatesOfGeometry(o),
                            !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount,
                                n.memory.geometries--
                        }
                        function o(e) {
                            const n = []
                                , i = e.index
                                , r = e.attributes.position;
                            let s = 0;
                            if (null !== i) {
                                const e = i.array;
                                s = i.version;
                                for (let t = 0, i = e.length; t < i; t += 3) {
                                    const i = e[t + 0]
                                        , r = e[t + 1]
                                        , a = e[t + 2];
                                    n.push(i, r, r, a, a, i)
                                }
                            } else {
                                if (void 0 === r)
                                    return;
                                {
                                    const e = r.array;
                                    s = r.version;
                                    for (let t = 0, i = e.length / 3 - 1; t < i; t += 3) {
                                        const e = t + 0
                                            , i = t + 1
                                            , r = t + 2;
                                        n.push(e, i, i, r, r, e)
                                    }
                                }
                            }
                            const o = new (qt(n) ? Zi : Xi)(n,1);
                            o.version = s;
                            const l = a.get(e);
                            l && t.remove(l),
                                a.set(e, o)
                        }
                        return {
                            get: function(e, t) {
                                return !0 === r[t.id] || (t.addEventListener("dispose", s),
                                    r[t.id] = !0,
                                    n.memory.geometries++),
                                    t
                            },
                            update: function(n) {
                                const i = n.attributes;
                                for (const n in i)
                                    t.update(i[n], e.ARRAY_BUFFER)
                            },
                            getWireframeAttribute: function(e) {
                                const t = a.get(e);
                                if (t) {
                                    const n = e.index;
                                    null !== n && t.version < n.version && o(e)
                                } else
                                    o(e);
                                return a.get(e)
                            }
                        }
                    }
                    function qc(e, t, n) {
                        let i, r, a;
                        function s(t, s, o) {
                            0 !== o && (e.drawElementsInstanced(i, s, r, t * a, o),
                                n.update(s, i, o))
                        }
                        this.setMode = function(e) {
                            i = e
                        }
                            ,
                            this.setIndex = function(e) {
                                r = e.type,
                                    a = e.bytesPerElement
                            }
                            ,
                            this.render = function(t, s) {
                                e.drawElements(i, s, r, t * a),
                                    n.update(s, i, 1)
                            }
                            ,
                            this.renderInstances = s,
                            this.renderMultiDraw = function(e, a, s) {
                                if (0 === s)
                                    return;
                                t.get("WEBGL_multi_draw").multiDrawElementsWEBGL(i, a, 0, r, e, 0, s);
                                let o = 0;
                                for (let e = 0; e < s; e++)
                                    o += a[e];
                                n.update(o, i, 1)
                            }
                            ,
                            this.renderMultiDrawInstances = function(e, o, l, c) {
                                if (0 === l)
                                    return;
                                const h = t.get("WEBGL_multi_draw");
                                if (null === h)
                                    for (let t = 0; t < e.length; t++)
                                        s(e[t] / a, o[t], c[t]);
                                else {
                                    h.multiDrawElementsInstancedWEBGL(i, o, 0, r, e, 0, c, 0, l);
                                    let t = 0;
                                    for (let e = 0; e < l; e++)
                                        t += o[e] * c[e];
                                    n.update(t, i, 1)
                                }
                            }
                    }
                    function Kc(e) {
                        const t = {
                            frame: 0,
                            calls: 0,
                            triangles: 0,
                            points: 0,
                            lines: 0
                        };
                        return {
                            memory: {
                                geometries: 0,
                                textures: 0
                            },
                            render: t,
                            programs: null,
                            autoReset: !0,
                            reset: function() {
                                t.calls = 0,
                                    t.triangles = 0,
                                    t.points = 0,
                                    t.lines = 0
                            },
                            update: function(n, i, r) {
                                switch (t.calls++,
                                    i) {
                                    case e.TRIANGLES:
                                        t.triangles += r * (n / 3);
                                        break;
                                    case e.LINES:
                                        t.lines += r * (n / 2);
                                        break;
                                    case e.LINE_STRIP:
                                        t.lines += r * (n - 1);
                                        break;
                                    case e.LINE_LOOP:
                                        t.lines += r * n;
                                        break;
                                    case e.POINTS:
                                        t.points += r * n;
                                        break;
                                    default:
                                        console.error("THREE.WebGLInfo: Unknown draw mode:", i)
                                }
                            }
                        }
                    }
                    function Xc(e, t, n) {
                        const i = new WeakMap
                            , r = new pn;
                        return {
                            update: function(a, s, o) {
                                const l = a.morphTargetInfluences
                                    , c = s.morphAttributes.position || s.morphAttributes.normal || s.morphAttributes.color
                                    , h = void 0 !== c ? c.length : 0;
                                let d = i.get(s);
                                if (void 0 === d || d.count !== h) {
                                    void 0 !== d && d.texture.dispose();
                                    const u = void 0 !== s.morphAttributes.position
                                        , p = void 0 !== s.morphAttributes.normal
                                        , f = void 0 !== s.morphAttributes.color
                                        , m = s.morphAttributes.position || []
                                        , g = s.morphAttributes.normal || []
                                        , v = s.morphAttributes.color || [];
                                    let w = 0;
                                    !0 === u && (w = 1),
                                    !0 === p && (w = 2),
                                    !0 === f && (w = 3);
                                    let A = s.attributes.position.count * w
                                        , y = 1;
                                    A > t.maxTextureSize && (y = Math.ceil(A / t.maxTextureSize),
                                        A = t.maxTextureSize);
                                    const b = new Float32Array(A * y * 4 * h)
                                        , x = new gn(b,A,y,h);
                                    x.type = Ae,
                                        x.needsUpdate = !0;
                                    const k = 4 * w;
                                    for (let S = 0; S < h; S++) {
                                        const M = m[S]
                                            , T = g[S]
                                            , C = v[S]
                                            , _ = A * y * 4 * S;
                                        for (let I = 0; I < M.count; I++) {
                                            const P = I * k;
                                            !0 === u && (r.fromBufferAttribute(M, I),
                                                b[_ + P + 0] = r.x,
                                                b[_ + P + 1] = r.y,
                                                b[_ + P + 2] = r.z,
                                                b[_ + P + 3] = 0),
                                            !0 === p && (r.fromBufferAttribute(T, I),
                                                b[_ + P + 4] = r.x,
                                                b[_ + P + 5] = r.y,
                                                b[_ + P + 6] = r.z,
                                                b[_ + P + 7] = 0),
                                            !0 === f && (r.fromBufferAttribute(C, I),
                                                b[_ + P + 8] = r.x,
                                                b[_ + P + 9] = r.y,
                                                b[_ + P + 10] = r.z,
                                                b[_ + P + 11] = 4 === C.itemSize ? r.w : 1)
                                        }
                                    }
                                    function E() {
                                        x.dispose(),
                                            i.delete(s),
                                            s.removeEventListener("dispose", E)
                                    }
                                    d = {
                                        count: h,
                                        texture: x,
                                        size: new jt(A,y)
                                    },
                                        i.set(s, d),
                                        s.addEventListener("dispose", E)
                                }
                                if (!0 === a.isInstancedMesh && null !== a.morphTexture)
                                    o.getUniforms().setValue(e, "morphTexture", a.morphTexture, n);
                                else {
                                    let R = 0;
                                    for (let N = 0; N < l.length; N++)
                                        R += l[N];
                                    const L = s.morphTargetsRelative ? 1 : 1 - R;
                                    o.getUniforms().setValue(e, "morphTargetBaseInfluence", L),
                                        o.getUniforms().setValue(e, "morphTargetInfluences", l)
                                }
                                o.getUniforms().setValue(e, "morphTargetsTexture", d.texture, n),
                                    o.getUniforms().setValue(e, "morphTargetsTextureSize", d.size)
                            }
                        }
                    }
                    function Zc(e, t, n, i) {
                        let r = new WeakMap;
                        function a(e) {
                            const t = e.target;
                            t.removeEventListener("dispose", a),
                                n.remove(t.instanceMatrix),
                            null !== t.instanceColor && n.remove(t.instanceColor)
                        }
                        return {
                            update: function(s) {
                                const o = i.render.frame
                                    , l = s.geometry
                                    , c = t.get(s, l);
                                if (r.get(c) !== o && (t.update(c),
                                    r.set(c, o)),
                                s.isInstancedMesh && (!1 === s.hasEventListener("dispose", a) && s.addEventListener("dispose", a),
                                r.get(s) !== o && (n.update(s.instanceMatrix, e.ARRAY_BUFFER),
                                null !== s.instanceColor && n.update(s.instanceColor, e.ARRAY_BUFFER),
                                    r.set(s, o))),
                                    s.isSkinnedMesh) {
                                    const e = s.skeleton;
                                    r.get(e) !== o && (e.update(),
                                        r.set(e, o))
                                }
                                return c
                            },
                            dispose: function() {
                                r = new WeakMap
                            }
                        }
                    }
                    const Jc = new un
                        , $c = new Wa(1,1)
                        , eh = new gn
                        , th = new vn
                        , nh = new Lr
                        , ih = []
                        , rh = []
                        , ah = new Float32Array(16)
                        , sh = new Float32Array(9)
                        , oh = new Float32Array(4);
                    function lh(e, t, n) {
                        const i = e[0];
                        if (i <= 0 || i > 0)
                            return e;
                        const r = t * n;
                        let a = ih[r];
                        if (void 0 === a && (a = new Float32Array(r),
                            ih[r] = a),
                        0 !== t) {
                            i.toArray(a, 0);
                            for (let i = 1, r = 0; i !== t; ++i)
                                r += n,
                                    e[i].toArray(a, r)
                        }
                        return a
                    }
                    function ch(e, t) {
                        if (e.length !== t.length)
                            return !1;
                        for (let n = 0, i = e.length; n < i; n++)
                            if (e[n] !== t[n])
                                return !1;
                        return !0
                    }
                    function hh(e, t) {
                        for (let n = 0, i = t.length; n < i; n++)
                            e[n] = t[n]
                    }
                    function dh(e, t) {
                        let n = rh[t];
                        void 0 === n && (n = new Int32Array(t),
                            rh[t] = n);
                        for (let i = 0; i !== t; ++i)
                            n[i] = e.allocateTextureUnit();
                        return n
                    }
                    function uh(e, t) {
                        const n = this.cache;
                        n[0] !== t && (e.uniform1f(this.addr, t),
                            n[0] = t)
                    }
                    function ph(e, t) {
                        const n = this.cache;
                        if (void 0 !== t.x)
                            n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y),
                                n[0] = t.x,
                                n[1] = t.y);
                        else {
                            if (ch(n, t))
                                return;
                            e.uniform2fv(this.addr, t),
                                hh(n, t)
                        }
                    }
                    function fh(e, t) {
                        const n = this.cache;
                        if (void 0 !== t.x)
                            n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z),
                                n[0] = t.x,
                                n[1] = t.y,
                                n[2] = t.z);
                        else if (void 0 !== t.r)
                            n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b),
                                n[0] = t.r,
                                n[1] = t.g,
                                n[2] = t.b);
                        else {
                            if (ch(n, t))
                                return;
                            e.uniform3fv(this.addr, t),
                                hh(n, t)
                        }
                    }
                    function mh(e, t) {
                        const n = this.cache;
                        if (void 0 !== t.x)
                            n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w),
                                n[0] = t.x,
                                n[1] = t.y,
                                n[2] = t.z,
                                n[3] = t.w);
                        else {
                            if (ch(n, t))
                                return;
                            e.uniform4fv(this.addr, t),
                                hh(n, t)
                        }
                    }
                    function gh(e, t) {
                        const n = this.cache
                            , i = t.elements;
                        if (void 0 === i) {
                            if (ch(n, t))
                                return;
                            e.uniformMatrix2fv(this.addr, !1, t),
                                hh(n, t)
                        } else {
                            if (ch(n, i))
                                return;
                            oh.set(i),
                                e.uniformMatrix2fv(this.addr, !1, oh),
                                hh(n, i)
                        }
                    }
                    function vh(e, t) {
                        const n = this.cache
                            , i = t.elements;
                        if (void 0 === i) {
                            if (ch(n, t))
                                return;
                            e.uniformMatrix3fv(this.addr, !1, t),
                                hh(n, t)
                        } else {
                            if (ch(n, i))
                                return;
                            sh.set(i),
                                e.uniformMatrix3fv(this.addr, !1, sh),
                                hh(n, i)
                        }
                    }
                    function wh(e, t) {
                        const n = this.cache
                            , i = t.elements;
                        if (void 0 === i) {
                            if (ch(n, t))
                                return;
                            e.uniformMatrix4fv(this.addr, !1, t),
                                hh(n, t)
                        } else {
                            if (ch(n, i))
                                return;
                            ah.set(i),
                                e.uniformMatrix4fv(this.addr, !1, ah),
                                hh(n, i)
                        }
                    }
                    function Ah(e, t) {
                        const n = this.cache;
                        n[0] !== t && (e.uniform1i(this.addr, t),
                            n[0] = t)
                    }
                    function yh(e, t) {
                        const n = this.cache;
                        if (void 0 !== t.x)
                            n[0] === t.x && n[1] === t.y || (e.uniform2i(this.addr, t.x, t.y),
                                n[0] = t.x,
                                n[1] = t.y);
                        else {
                            if (ch(n, t))
                                return;
                            e.uniform2iv(this.addr, t),
                                hh(n, t)
                        }
                    }
                    function bh(e, t) {
                        const n = this.cache;
                        if (void 0 !== t.x)
                            n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3i(this.addr, t.x, t.y, t.z),
                                n[0] = t.x,
                                n[1] = t.y,
                                n[2] = t.z);
                        else {
                            if (ch(n, t))
                                return;
                            e.uniform3iv(this.addr, t),
                                hh(n, t)
                        }
                    }
                    function xh(e, t) {
                        const n = this.cache;
                        if (void 0 !== t.x)
                            n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4i(this.addr, t.x, t.y, t.z, t.w),
                                n[0] = t.x,
                                n[1] = t.y,
                                n[2] = t.z,
                                n[3] = t.w);
                        else {
                            if (ch(n, t))
                                return;
                            e.uniform4iv(this.addr, t),
                                hh(n, t)
                        }
                    }
                    function kh(e, t) {
                        const n = this.cache;
                        n[0] !== t && (e.uniform1ui(this.addr, t),
                            n[0] = t)
                    }
                    function Eh(e, t) {
                        const n = this.cache;
                        if (void 0 !== t.x)
                            n[0] === t.x && n[1] === t.y || (e.uniform2ui(this.addr, t.x, t.y),
                                n[0] = t.x,
                                n[1] = t.y);
                        else {
                            if (ch(n, t))
                                return;
                            e.uniform2uiv(this.addr, t),
                                hh(n, t)
                        }
                    }
                    function Sh(e, t) {
                        const n = this.cache;
                        if (void 0 !== t.x)
                            n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3ui(this.addr, t.x, t.y, t.z),
                                n[0] = t.x,
                                n[1] = t.y,
                                n[2] = t.z);
                        else {
                            if (ch(n, t))
                                return;
                            e.uniform3uiv(this.addr, t),
                                hh(n, t)
                        }
                    }
                    function Mh(e, t) {
                        const n = this.cache;
                        if (void 0 !== t.x)
                            n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4ui(this.addr, t.x, t.y, t.z, t.w),
                                n[0] = t.x,
                                n[1] = t.y,
                                n[2] = t.z,
                                n[3] = t.w);
                        else {
                            if (ch(n, t))
                                return;
                            e.uniform4uiv(this.addr, t),
                                hh(n, t)
                        }
                    }
                    function Th(e, t, n) {
                        const i = this.cache
                            , r = n.allocateTextureUnit();
                        let a;
                        i[0] !== r && (e.uniform1i(this.addr, r),
                            i[0] = r),
                            this.type === e.SAMPLER_2D_SHADOW ? ($c.compareFunction = 515,
                                a = $c) : a = Jc,
                            n.setTexture2D(t || a, r)
                    }
                    function Ch(e, t, n) {
                        const i = this.cache
                            , r = n.allocateTextureUnit();
                        i[0] !== r && (e.uniform1i(this.addr, r),
                            i[0] = r),
                            n.setTexture3D(t || th, r)
                    }
                    function _h(e, t, n) {
                        const i = this.cache
                            , r = n.allocateTextureUnit();
                        i[0] !== r && (e.uniform1i(this.addr, r),
                            i[0] = r),
                            n.setTextureCube(t || nh, r)
                    }
                    function Ih(e, t, n) {
                        const i = this.cache
                            , r = n.allocateTextureUnit();
                        i[0] !== r && (e.uniform1i(this.addr, r),
                            i[0] = r),
                            n.setTexture2DArray(t || eh, r)
                    }
                    function Ph(e, t) {
                        e.uniform1fv(this.addr, t)
                    }
                    function Rh(e, t) {
                        const n = lh(t, this.size, 2);
                        e.uniform2fv(this.addr, n)
                    }
                    function Lh(e, t) {
                        const n = lh(t, this.size, 3);
                        e.uniform3fv(this.addr, n)
                    }
                    function Nh(e, t) {
                        const n = lh(t, this.size, 4);
                        e.uniform4fv(this.addr, n)
                    }
                    function Dh(e, t) {
                        const n = lh(t, this.size, 4);
                        e.uniformMatrix2fv(this.addr, !1, n)
                    }
                    function Bh(e, t) {
                        const n = lh(t, this.size, 9);
                        e.uniformMatrix3fv(this.addr, !1, n)
                    }
                    function Uh(e, t) {
                        const n = lh(t, this.size, 16);
                        e.uniformMatrix4fv(this.addr, !1, n)
                    }
                    function zh(e, t) {
                        e.uniform1iv(this.addr, t)
                    }
                    function Oh(e, t) {
                        e.uniform2iv(this.addr, t)
                    }
                    function Fh(e, t) {
                        e.uniform3iv(this.addr, t)
                    }
                    function Wh(e, t) {
                        e.uniform4iv(this.addr, t)
                    }
                    function Hh(e, t) {
                        e.uniform1uiv(this.addr, t)
                    }
                    function Vh(e, t) {
                        e.uniform2uiv(this.addr, t)
                    }
                    function Gh(e, t) {
                        e.uniform3uiv(this.addr, t)
                    }
                    function jh(e, t) {
                        e.uniform4uiv(this.addr, t)
                    }
                    function Qh(e, t, n) {
                        const i = this.cache
                            , r = t.length
                            , a = dh(n, r);
                        ch(i, a) || (e.uniform1iv(this.addr, a),
                            hh(i, a));
                        for (let e = 0; e !== r; ++e)
                            n.setTexture2D(t[e] || Jc, a[e])
                    }
                    function Yh(e, t, n) {
                        const i = this.cache
                            , r = t.length
                            , a = dh(n, r);
                        ch(i, a) || (e.uniform1iv(this.addr, a),
                            hh(i, a));
                        for (let e = 0; e !== r; ++e)
                            n.setTexture3D(t[e] || th, a[e])
                    }
                    function qh(e, t, n) {
                        const i = this.cache
                            , r = t.length
                            , a = dh(n, r);
                        ch(i, a) || (e.uniform1iv(this.addr, a),
                            hh(i, a));
                        for (let e = 0; e !== r; ++e)
                            n.setTextureCube(t[e] || nh, a[e])
                    }
                    function Kh(e, t, n) {
                        const i = this.cache
                            , r = t.length
                            , a = dh(n, r);
                        ch(i, a) || (e.uniform1iv(this.addr, a),
                            hh(i, a));
                        for (let e = 0; e !== r; ++e)
                            n.setTexture2DArray(t[e] || eh, a[e])
                    }
                    class Xh {
                        constructor(e, t, n) {
                            this.id = e,
                                this.addr = n,
                                this.cache = [],
                                this.type = t.type,
                                this.setValue = function(e) {
                                    switch (e) {
                                        case 5126:
                                            return uh;
                                        case 35664:
                                            return ph;
                                        case 35665:
                                            return fh;
                                        case 35666:
                                            return mh;
                                        case 35674:
                                            return gh;
                                        case 35675:
                                            return vh;
                                        case 35676:
                                            return wh;
                                        case 5124:
                                        case 35670:
                                            return Ah;
                                        case 35667:
                                        case 35671:
                                            return yh;
                                        case 35668:
                                        case 35672:
                                            return bh;
                                        case 35669:
                                        case 35673:
                                            return xh;
                                        case 5125:
                                            return kh;
                                        case 36294:
                                            return Eh;
                                        case 36295:
                                            return Sh;
                                        case 36296:
                                            return Mh;
                                        case 35678:
                                        case 36198:
                                        case 36298:
                                        case 36306:
                                        case 35682:
                                            return Th;
                                        case 35679:
                                        case 36299:
                                        case 36307:
                                            return Ch;
                                        case 35680:
                                        case 36300:
                                        case 36308:
                                        case 36293:
                                            return _h;
                                        case 36289:
                                        case 36303:
                                        case 36311:
                                        case 36292:
                                            return Ih
                                    }
                                }(t.type)
                        }
                    }
                    class Zh {
                        constructor(e, t, n) {
                            this.id = e,
                                this.addr = n,
                                this.cache = [],
                                this.type = t.type,
                                this.size = t.size,
                                this.setValue = function(e) {
                                    switch (e) {
                                        case 5126:
                                            return Ph;
                                        case 35664:
                                            return Rh;
                                        case 35665:
                                            return Lh;
                                        case 35666:
                                            return Nh;
                                        case 35674:
                                            return Dh;
                                        case 35675:
                                            return Bh;
                                        case 35676:
                                            return Uh;
                                        case 5124:
                                        case 35670:
                                            return zh;
                                        case 35667:
                                        case 35671:
                                            return Oh;
                                        case 35668:
                                        case 35672:
                                            return Fh;
                                        case 35669:
                                        case 35673:
                                            return Wh;
                                        case 5125:
                                            return Hh;
                                        case 36294:
                                            return Vh;
                                        case 36295:
                                            return Gh;
                                        case 36296:
                                            return jh;
                                        case 35678:
                                        case 36198:
                                        case 36298:
                                        case 36306:
                                        case 35682:
                                            return Qh;
                                        case 35679:
                                        case 36299:
                                        case 36307:
                                            return Yh;
                                        case 35680:
                                        case 36300:
                                        case 36308:
                                        case 36293:
                                            return qh;
                                        case 36289:
                                        case 36303:
                                        case 36311:
                                        case 36292:
                                            return Kh
                                    }
                                }(t.type)
                        }
                    }
                    class Jh {
                        constructor(e) {
                            this.id = e,
                                this.seq = [],
                                this.map = {}
                        }
                        setValue(e, t, n) {
                            const i = this.seq;
                            for (let r = 0, a = i.length; r !== a; ++r) {
                                const a = i[r];
                                a.setValue(e, t[a.id], n)
                            }
                        }
                    }
                    const $h = /(\w+)(\])?(\[|\.)?/g;
                    function ed(e, t) {
                        e.seq.push(t),
                            e.map[t.id] = t
                    }
                    function td(e, t, n) {
                        const i = e.name
                            , r = i.length;
                        for ($h.lastIndex = 0; ; ) {
                            const a = $h.exec(i)
                                , s = $h.lastIndex;
                            let o = a[1];
                            const l = "]" === a[2]
                                , c = a[3];
                            if (l && (o |= 0),
                            void 0 === c || "[" === c && s + 2 === r) {
                                ed(n, void 0 === c ? new Xh(o,e,t) : new Zh(o,e,t));
                                break
                            }
                            {
                                let e = n.map[o];
                                void 0 === e && (e = new Jh(o),
                                    ed(n, e)),
                                    n = e
                            }
                        }
                    }
                    class nd {
                        constructor(e, t) {
                            this.seq = [],
                                this.map = {};
                            const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
                            for (let i = 0; i < n; ++i) {
                                const n = e.getActiveUniform(t, i);
                                td(n, e.getUniformLocation(t, n.name), this)
                            }
                        }
                        setValue(e, t, n, i) {
                            const r = this.map[t];
                            void 0 !== r && r.setValue(e, n, i)
                        }
                        setOptional(e, t, n) {
                            const i = t[n];
                            void 0 !== i && this.setValue(e, n, i)
                        }
                        static upload(e, t, n, i) {
                            for (let r = 0, a = t.length; r !== a; ++r) {
                                const a = t[r]
                                    , s = n[a.id];
                                !1 !== s.needsUpdate && a.setValue(e, s.value, i)
                            }
                        }
                        static seqWithValue(e, t) {
                            const n = [];
                            for (let i = 0, r = e.length; i !== r; ++i) {
                                const r = e[i];
                                r.id in t && n.push(r)
                            }
                            return n
                        }
                    }
                    function id(e, t, n) {
                        const i = e.createShader(t);
                        return e.shaderSource(i, n),
                            e.compileShader(i),
                            i
                    }
                    let rd = 0;
                    const ad = new Qt;
                    function sd(e, t, n) {
                        const i = e.getShaderParameter(t, e.COMPILE_STATUS)
                            , r = e.getShaderInfoLog(t).trim();
                        if (i && "" === r)
                            return "";
                        const a = /ERROR: 0:(\d+)/.exec(r);
                        if (a) {
                            const i = parseInt(a[1]);
                            return n.toUpperCase() + "\n\n" + r + "\n\n" + function(e, t) {
                                const n = e.split("\n")
                                    , i = []
                                    , r = Math.max(t - 6, 0)
                                    , a = Math.min(t + 6, n.length);
                                for (let e = r; e < a; e++) {
                                    const r = e + 1;
                                    i.push(`${r === t ? ">" : " "} ${r}: ${n[e]}`)
                                }
                                return i.join("\n")
                            }(e.getShaderSource(t), i)
                        }
                        return r
                    }
                    function od(e, t) {
                        const n = function(e) {
                            nn._getMatrix(ad, nn.workingColorSpace, e);
                            const t = `mat3( ${ad.elements.map((e => e.toFixed(4)))} )`;
                            switch (nn.getTransfer(e)) {
                                case wt:
                                    return [t, "LinearTransferOETF"];
                                case At:
                                    return [t, "sRGBTransferOETF"];
                                default:
                                    return console.warn("THREE.WebGLProgram: Unsupported color space: ", e),
                                        [t, "LinearTransferOETF"]
                            }
                        }(t);
                        return [`vec4 ${e}( vec4 value ) {`, `\treturn ${n[1]}( vec4( value.rgb * ${n[0]}, value.a ) );`, "}"].join("\n")
                    }
                    function ld(e, t) {
                        let n;
                        switch (t) {
                            case 1:
                                n = "Linear";
                                break;
                            case 2:
                                n = "Reinhard";
                                break;
                            case 3:
                                n = "Cineon";
                                break;
                            case 4:
                                n = "ACESFilmic";
                                break;
                            case 6:
                                n = "AgX";
                                break;
                            case 7:
                                n = "Neutral";
                                break;
                            case 5:
                                n = "Custom";
                                break;
                            default:
                                console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t),
                                    n = "Linear"
                        }
                        return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
                    }
                    const cd = new An;
                    function hd() {
                        nn.getLuminanceCoefficients(cd);
                        return ["float luminance( const in vec3 rgb ) {", `\tconst vec3 weights = vec3( ${cd.x.toFixed(4)}, ${cd.y.toFixed(4)}, ${cd.z.toFixed(4)} );`, "\treturn dot( weights, rgb );", "}"].join("\n")
                    }
                    function dd(e) {
                        return "" !== e
                    }
                    function ud(e, t) {
                        const n = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps;
                        return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
                    }
                    function pd(e, t) {
                        return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
                    }
                    const fd = /^[ \t]*#include +<([\w\d./]+)>/gm;
                    function md(e) {
                        return e.replace(fd, vd)
                    }
                    const gd = new Map;
                    function vd(e, t) {
                        let n = mc[t];
                        if (void 0 === n) {
                            const e = gd.get(t);
                            if (void 0 === e)
                                throw new Error("Can not resolve #include <" + t + ">");
                            n = mc[e],
                                console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', t, e)
                        }
                        return md(n)
                    }
                    const wd = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
                    function Ad(e) {
                        return e.replace(wd, yd)
                    }
                    function yd(e, t, n, i) {
                        let r = "";
                        for (let e = parseInt(t); e < parseInt(n); e++)
                            r += i.replace(/\[\s*i\s*\]/g, "[ " + e + " ]").replace(/UNROLLED_LOOP_INDEX/g, e);
                        return r
                    }
                    function bd(e) {
                        let t = `precision ${e.precision} float;\n\tprecision ${e.precision} int;\n\tprecision ${e.precision} sampler2D;\n\tprecision ${e.precision} samplerCube;\n\tprecision ${e.precision} sampler3D;\n\tprecision ${e.precision} sampler2DArray;\n\tprecision ${e.precision} sampler2DShadow;\n\tprecision ${e.precision} samplerCubeShadow;\n\tprecision ${e.precision} sampler2DArrayShadow;\n\tprecision ${e.precision} isampler2D;\n\tprecision ${e.precision} isampler3D;\n\tprecision ${e.precision} isamplerCube;\n\tprecision ${e.precision} isampler2DArray;\n\tprecision ${e.precision} usampler2D;\n\tprecision ${e.precision} usampler3D;\n\tprecision ${e.precision} usamplerCube;\n\tprecision ${e.precision} usampler2DArray;\n\t`;
                        return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"),
                            t
                    }
                    function xd(e, t, n, i) {
                        const r = e.getContext()
                            , a = n.defines;
                        let s = n.vertexShader
                            , o = n.fragmentShader;
                        const l = function(e) {
                            let t = "SHADOWMAP_TYPE_BASIC";
                            return 1 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF" : 2 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === e.shadowMapType && (t = "SHADOWMAP_TYPE_VSM"),
                                t
                        }(n)
                            , c = function(e) {
                            let t = "ENVMAP_TYPE_CUBE";
                            if (e.envMap)
                                switch (e.envMapMode) {
                                    case $:
                                    case ee:
                                        t = "ENVMAP_TYPE_CUBE";
                                        break;
                                    case ie:
                                        t = "ENVMAP_TYPE_CUBE_UV"
                                }
                            return t
                        }(n)
                            , h = function(e) {
                            let t = "ENVMAP_MODE_REFLECTION";
                            e.envMap && e.envMapMode === ee && (t = "ENVMAP_MODE_REFRACTION");
                            return t
                        }(n)
                            , d = function(e) {
                            let t = "ENVMAP_BLENDING_NONE";
                            if (e.envMap)
                                switch (e.combine) {
                                    case 0:
                                        t = "ENVMAP_BLENDING_MULTIPLY";
                                        break;
                                    case 1:
                                        t = "ENVMAP_BLENDING_MIX";
                                        break;
                                    case 2:
                                        t = "ENVMAP_BLENDING_ADD"
                                }
                            return t
                        }(n)
                            , u = function(e) {
                            const t = e.envMapCubeUVHeight;
                            if (null === t)
                                return null;
                            const n = Math.log2(t) - 2
                                , i = 1 / t;
                            return {
                                texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
                                texelHeight: i,
                                maxMip: n
                            }
                        }(n)
                            , p = function(e) {
                            return [e.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", e.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(dd).join("\n")
                        }(n)
                            , f = function(e) {
                            const t = [];
                            for (const n in e) {
                                const i = e[n];
                                !1 !== i && t.push("#define " + n + " " + i)
                            }
                            return t.join("\n")
                        }(a)
                            , m = r.createProgram();
                        let g, v, w = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
                        n.isRawShaderMaterial ? (g = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, f].filter(dd).join("\n"),
                        g.length > 0 && (g += "\n"),
                            v = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, f].filter(dd).join("\n"),
                        v.length > 0 && (v += "\n")) : (g = [bd(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, f, n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", n.batching ? "#define USE_BATCHING" : "", n.batchingColor ? "#define USE_BATCHING_COLOR" : "", n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + h : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.mapUv ? "#define MAP_UV " + n.mapUv : "", n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "", n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "", n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "", n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "", n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "", n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "", n.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv : "", n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "", n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "", n.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv : "", n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "", n.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv : "", n.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv : "", n.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv : "", n.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv : "", n.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv : "", n.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv : "", n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "", n.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv : "", n.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv : "", n.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv : "", n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphColors ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "\tuniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "\tattribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "\tattribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "\tattribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(dd).join("\n"),
                            v = [bd(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, f, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + h : "", n.envMap ? "#define " + d : "", u ? "#define CUBEUV_TEXEL_WIDTH " + u.texelWidth : "", u ? "#define CUBEUV_TEXEL_HEIGHT " + u.texelHeight : "", u ? "#define CUBEUV_MAX_MIP " + u.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.dispersion ? "#define USE_DISPERSION" : "", n.iridescence ? "#define USE_IRIDESCENCE" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor || n.batchingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? mc.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? ld("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", mc.colorspace_pars_fragment, od("linearToOutputTexel", n.outputColorSpace), hd(), n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(dd).join("\n")),
                            s = md(s),
                            s = ud(s, n),
                            s = pd(s, n),
                            o = md(o),
                            o = ud(o, n),
                            o = pd(o, n),
                            s = Ad(s),
                            o = Ad(o),
                        !0 !== n.isRawShaderMaterial && (w = "#version 300 es\n",
                            g = [p, "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g,
                            v = ["#define varying in", n.glslVersion === It ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === It ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v);
                        const A = w + g + s
                            , y = w + v + o
                            , b = id(r, r.VERTEX_SHADER, A)
                            , x = id(r, r.FRAGMENT_SHADER, y);
                        function k(t) {
                            if (e.debug.checkShaderErrors) {
                                const n = r.getProgramInfoLog(m).trim()
                                    , i = r.getShaderInfoLog(b).trim()
                                    , a = r.getShaderInfoLog(x).trim();
                                let s = !0
                                    , o = !0;
                                if (!1 === r.getProgramParameter(m, r.LINK_STATUS))
                                    if (s = !1,
                                    "function" == typeof e.debug.onShaderError)
                                        e.debug.onShaderError(r, m, b, x);
                                    else {
                                        const e = sd(r, b, "vertex")
                                            , i = sd(r, x, "fragment");
                                        console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(m, r.VALIDATE_STATUS) + "\n\nMaterial Name: " + t.name + "\nMaterial Type: " + t.type + "\n\nProgram Info Log: " + n + "\n" + e + "\n" + i)
                                    }
                                else
                                    "" !== n ? console.warn("THREE.WebGLProgram: Program Info Log:", n) : "" !== i && "" !== a || (o = !1);
                                o && (t.diagnostics = {
                                    runnable: s,
                                    programLog: n,
                                    vertexShader: {
                                        log: i,
                                        prefix: g
                                    },
                                    fragmentShader: {
                                        log: a,
                                        prefix: v
                                    }
                                })
                            }
                            r.deleteShader(b),
                                r.deleteShader(x),
                                E = new nd(r,m),
                                S = function(e, t) {
                                    const n = {}
                                        , i = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES);
                                    for (let r = 0; r < i; r++) {
                                        const i = e.getActiveAttrib(t, r)
                                            , a = i.name;
                                        let s = 1;
                                        i.type === e.FLOAT_MAT2 && (s = 2),
                                        i.type === e.FLOAT_MAT3 && (s = 3),
                                        i.type === e.FLOAT_MAT4 && (s = 4),
                                            n[a] = {
                                                type: i.type,
                                                location: e.getAttribLocation(t, a),
                                                locationSize: s
                                            }
                                    }
                                    return n
                                }(r, m)
                        }
                        let E, S;
                        r.attachShader(m, b),
                            r.attachShader(m, x),
                            void 0 !== n.index0AttributeName ? r.bindAttribLocation(m, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(m, 0, "position"),
                            r.linkProgram(m),
                            this.getUniforms = function() {
                                return void 0 === E && k(this),
                                    E
                            }
                            ,
                            this.getAttributes = function() {
                                return void 0 === S && k(this),
                                    S
                            }
                        ;
                        let M = !1 === n.rendererExtensionParallelShaderCompile;
                        return this.isReady = function() {
                            return !1 === M && (M = r.getProgramParameter(m, 37297)),
                                M
                        }
                            ,
                            this.destroy = function() {
                                i.releaseStatesOfProgram(this),
                                    r.deleteProgram(m),
                                    this.program = void 0
                            }
                            ,
                            this.type = n.shaderType,
                            this.name = n.shaderName,
                            this.id = rd++,
                            this.cacheKey = t,
                            this.usedTimes = 1,
                            this.program = m,
                            this.vertexShader = b,
                            this.fragmentShader = x,
                            this
                    }
                    let kd = 0;
                    class Ed {
                        constructor() {
                            this.shaderCache = new Map,
                                this.materialCache = new Map
                        }
                        update(e) {
                            const t = e.vertexShader
                                , n = e.fragmentShader
                                , i = this._getShaderStage(t)
                                , r = this._getShaderStage(n)
                                , a = this._getShaderCacheForMaterial(e);
                            return !1 === a.has(i) && (a.add(i),
                                i.usedTimes++),
                            !1 === a.has(r) && (a.add(r),
                                r.usedTimes++),
                                this
                        }
                        remove(e) {
                            const t = this.materialCache.get(e);
                            for (const e of t)
                                e.usedTimes--,
                                0 === e.usedTimes && this.shaderCache.delete(e.code);
                            return this.materialCache.delete(e),
                                this
                        }
                        getVertexShaderID(e) {
                            return this._getShaderStage(e.vertexShader).id
                        }
                        getFragmentShaderID(e) {
                            return this._getShaderStage(e.fragmentShader).id
                        }
                        dispose() {
                            this.shaderCache.clear(),
                                this.materialCache.clear()
                        }
                        _getShaderCacheForMaterial(e) {
                            const t = this.materialCache;
                            let n = t.get(e);
                            return void 0 === n && (n = new Set,
                                t.set(e, n)),
                                n
                        }
                        _getShaderStage(e) {
                            const t = this.shaderCache;
                            let n = t.get(e);
                            return void 0 === n && (n = new Sd(e),
                                t.set(e, n)),
                                n
                        }
                    }
                    class Sd {
                        constructor(e) {
                            this.id = kd++,
                                this.code = e,
                                this.usedTimes = 0
                        }
                    }
                    function Md(e, t, n, i, r, a, s) {
                        const o = new si
                            , l = new Ed
                            , c = new Set
                            , h = []
                            , d = r.logarithmicDepthBuffer
                            , u = r.vertexTextures;
                        let p = r.precision;
                        const f = {
                            MeshDepthMaterial: "depth",
                            MeshDistanceMaterial: "distanceRGBA",
                            MeshNormalMaterial: "normal",
                            MeshBasicMaterial: "basic",
                            MeshLambertMaterial: "lambert",
                            MeshPhongMaterial: "phong",
                            MeshToonMaterial: "toon",
                            MeshStandardMaterial: "physical",
                            MeshPhysicalMaterial: "physical",
                            MeshMatcapMaterial: "matcap",
                            LineBasicMaterial: "basic",
                            LineDashedMaterial: "dashed",
                            PointsMaterial: "points",
                            ShadowMaterial: "shadow",
                            SpriteMaterial: "sprite"
                        };
                        function m(e) {
                            return c.add(e),
                                0 === e ? "uv" : `uv${e}`
                        }
                        return {
                            getParameters: function(a, o, h, g, v) {
                                const w = g.fog
                                    , A = v.geometry
                                    , y = a.isMeshStandardMaterial ? g.environment : null
                                    , b = (a.isMeshStandardMaterial ? n : t).get(a.envMap || y)
                                    , x = b && b.mapping === ie ? b.image.height : null
                                    , k = f[a.type];
                                null !== a.precision && (p = r.getMaxPrecision(a.precision),
                                p !== a.precision && console.warn("THREE.WebGLProgram.getParameters:", a.precision, "not supported, using", p, "instead."));
                                const E = A.morphAttributes.position || A.morphAttributes.normal || A.morphAttributes.color
                                    , S = void 0 !== E ? E.length : 0;
                                let M, T, C, _, I = 0;
                                if (void 0 !== A.morphAttributes.position && (I = 1),
                                void 0 !== A.morphAttributes.normal && (I = 2),
                                void 0 !== A.morphAttributes.color && (I = 3),
                                    k) {
                                    const e = vc[k];
                                    M = e.vertexShader,
                                        T = e.fragmentShader
                                } else
                                    M = a.vertexShader,
                                        T = a.fragmentShader,
                                        l.update(a),
                                        C = l.getVertexShaderID(a),
                                        _ = l.getFragmentShaderID(a);
                                const P = e.getRenderTarget()
                                    , R = e.state.buffers.depth.getReversed()
                                    , L = !0 === v.isInstancedMesh
                                    , N = !0 === v.isBatchedMesh
                                    , D = !!a.map
                                    , B = !!a.matcap
                                    , U = !!b
                                    , z = !!a.aoMap
                                    , O = !!a.lightMap
                                    , F = !!a.bumpMap
                                    , W = !!a.normalMap
                                    , H = !!a.displacementMap
                                    , V = !!a.emissiveMap
                                    , G = !!a.metalnessMap
                                    , j = !!a.roughnessMap
                                    , Q = a.anisotropy > 0
                                    , Y = a.clearcoat > 0
                                    , q = a.dispersion > 0
                                    , K = a.iridescence > 0
                                    , X = a.sheen > 0
                                    , Z = a.transmission > 0
                                    , J = Q && !!a.anisotropyMap
                                    , $ = Y && !!a.clearcoatMap
                                    , ee = Y && !!a.clearcoatNormalMap
                                    , te = Y && !!a.clearcoatRoughnessMap
                                    , ne = K && !!a.iridescenceMap
                                    , re = K && !!a.iridescenceThicknessMap
                                    , ae = X && !!a.sheenColorMap
                                    , se = X && !!a.sheenRoughnessMap
                                    , oe = !!a.specularMap
                                    , le = !!a.specularColorMap
                                    , ce = !!a.specularIntensityMap
                                    , he = Z && !!a.transmissionMap
                                    , de = Z && !!a.thicknessMap
                                    , ue = !!a.gradientMap
                                    , pe = !!a.alphaMap
                                    , fe = a.alphaTest > 0
                                    , me = !!a.alphaHash
                                    , ge = !!a.extensions;
                                let ve = 0;
                                a.toneMapped && (null !== P && !0 !== P.isXRRenderTarget || (ve = e.toneMapping));
                                const we = {
                                    shaderID: k,
                                    shaderType: a.type,
                                    shaderName: a.name,
                                    vertexShader: M,
                                    fragmentShader: T,
                                    defines: a.defines,
                                    customVertexShaderID: C,
                                    customFragmentShaderID: _,
                                    isRawShaderMaterial: !0 === a.isRawShaderMaterial,
                                    glslVersion: a.glslVersion,
                                    precision: p,
                                    batching: N,
                                    batchingColor: N && null !== v._colorsTexture,
                                    instancing: L,
                                    instancingColor: L && null !== v.instanceColor,
                                    instancingMorph: L && null !== v.morphTexture,
                                    supportsVertexTextures: u,
                                    outputColorSpace: null === P ? e.outputColorSpace : !0 === P.isXRRenderTarget ? P.texture.colorSpace : vt,
                                    alphaToCoverage: !!a.alphaToCoverage,
                                    map: D,
                                    matcap: B,
                                    envMap: U,
                                    envMapMode: U && b.mapping,
                                    envMapCubeUVHeight: x,
                                    aoMap: z,
                                    lightMap: O,
                                    bumpMap: F,
                                    normalMap: W,
                                    displacementMap: u && H,
                                    emissiveMap: V,
                                    normalMapObjectSpace: W && 1 === a.normalMapType,
                                    normalMapTangentSpace: W && 0 === a.normalMapType,
                                    metalnessMap: G,
                                    roughnessMap: j,
                                    anisotropy: Q,
                                    anisotropyMap: J,
                                    clearcoat: Y,
                                    clearcoatMap: $,
                                    clearcoatNormalMap: ee,
                                    clearcoatRoughnessMap: te,
                                    dispersion: q,
                                    iridescence: K,
                                    iridescenceMap: ne,
                                    iridescenceThicknessMap: re,
                                    sheen: X,
                                    sheenColorMap: ae,
                                    sheenRoughnessMap: se,
                                    specularMap: oe,
                                    specularColorMap: le,
                                    specularIntensityMap: ce,
                                    transmission: Z,
                                    transmissionMap: he,
                                    thicknessMap: de,
                                    gradientMap: ue,
                                    opaque: !1 === a.transparent && 1 === a.blending && !1 === a.alphaToCoverage,
                                    alphaMap: pe,
                                    alphaTest: fe,
                                    alphaHash: me,
                                    combine: a.combine,
                                    mapUv: D && m(a.map.channel),
                                    aoMapUv: z && m(a.aoMap.channel),
                                    lightMapUv: O && m(a.lightMap.channel),
                                    bumpMapUv: F && m(a.bumpMap.channel),
                                    normalMapUv: W && m(a.normalMap.channel),
                                    displacementMapUv: H && m(a.displacementMap.channel),
                                    emissiveMapUv: V && m(a.emissiveMap.channel),
                                    metalnessMapUv: G && m(a.metalnessMap.channel),
                                    roughnessMapUv: j && m(a.roughnessMap.channel),
                                    anisotropyMapUv: J && m(a.anisotropyMap.channel),
                                    clearcoatMapUv: $ && m(a.clearcoatMap.channel),
                                    clearcoatNormalMapUv: ee && m(a.clearcoatNormalMap.channel),
                                    clearcoatRoughnessMapUv: te && m(a.clearcoatRoughnessMap.channel),
                                    iridescenceMapUv: ne && m(a.iridescenceMap.channel),
                                    iridescenceThicknessMapUv: re && m(a.iridescenceThicknessMap.channel),
                                    sheenColorMapUv: ae && m(a.sheenColorMap.channel),
                                    sheenRoughnessMapUv: se && m(a.sheenRoughnessMap.channel),
                                    specularMapUv: oe && m(a.specularMap.channel),
                                    specularColorMapUv: le && m(a.specularColorMap.channel),
                                    specularIntensityMapUv: ce && m(a.specularIntensityMap.channel),
                                    transmissionMapUv: he && m(a.transmissionMap.channel),
                                    thicknessMapUv: de && m(a.thicknessMap.channel),
                                    alphaMapUv: pe && m(a.alphaMap.channel),
                                    vertexTangents: !!A.attributes.tangent && (W || Q),
                                    vertexColors: a.vertexColors,
                                    vertexAlphas: !0 === a.vertexColors && !!A.attributes.color && 4 === A.attributes.color.itemSize,
                                    pointsUvs: !0 === v.isPoints && !!A.attributes.uv && (D || pe),
                                    fog: !!w,
                                    useFog: !0 === a.fog,
                                    fogExp2: !!w && w.isFogExp2,
                                    flatShading: !0 === a.flatShading,
                                    sizeAttenuation: !0 === a.sizeAttenuation,
                                    logarithmicDepthBuffer: d,
                                    reverseDepthBuffer: R,
                                    skinning: !0 === v.isSkinnedMesh,
                                    morphTargets: void 0 !== A.morphAttributes.position,
                                    morphNormals: void 0 !== A.morphAttributes.normal,
                                    morphColors: void 0 !== A.morphAttributes.color,
                                    morphTargetsCount: S,
                                    morphTextureStride: I,
                                    numDirLights: o.directional.length,
                                    numPointLights: o.point.length,
                                    numSpotLights: o.spot.length,
                                    numSpotLightMaps: o.spotLightMap.length,
                                    numRectAreaLights: o.rectArea.length,
                                    numHemiLights: o.hemi.length,
                                    numDirLightShadows: o.directionalShadowMap.length,
                                    numPointLightShadows: o.pointShadowMap.length,
                                    numSpotLightShadows: o.spotShadowMap.length,
                                    numSpotLightShadowsWithMaps: o.numSpotLightShadowsWithMaps,
                                    numLightProbes: o.numLightProbes,
                                    numClippingPlanes: s.numPlanes,
                                    numClipIntersection: s.numIntersection,
                                    dithering: a.dithering,
                                    shadowMapEnabled: e.shadowMap.enabled && h.length > 0,
                                    shadowMapType: e.shadowMap.type,
                                    toneMapping: ve,
                                    decodeVideoTexture: D && !0 === a.map.isVideoTexture && nn.getTransfer(a.map.colorSpace) === At,
                                    decodeVideoTextureEmissive: V && !0 === a.emissiveMap.isVideoTexture && nn.getTransfer(a.emissiveMap.colorSpace) === At,
                                    premultipliedAlpha: a.premultipliedAlpha,
                                    doubleSided: 2 === a.side,
                                    flipSided: 1 === a.side,
                                    useDepthPacking: a.depthPacking >= 0,
                                    depthPacking: a.depthPacking || 0,
                                    index0AttributeName: a.index0AttributeName,
                                    extensionClipCullDistance: ge && !0 === a.extensions.clipCullDistance && i.has("WEBGL_clip_cull_distance"),
                                    extensionMultiDraw: (ge && !0 === a.extensions.multiDraw || N) && i.has("WEBGL_multi_draw"),
                                    rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"),
                                    customProgramCacheKey: a.customProgramCacheKey()
                                };
                                return we.vertexUv1s = c.has(1),
                                    we.vertexUv2s = c.has(2),
                                    we.vertexUv3s = c.has(3),
                                    c.clear(),
                                    we
                            },
                            getProgramCacheKey: function(t) {
                                const n = [];
                                if (t.shaderID ? n.push(t.shaderID) : (n.push(t.customVertexShaderID),
                                    n.push(t.customFragmentShaderID)),
                                void 0 !== t.defines)
                                    for (const e in t.defines)
                                        n.push(e),
                                            n.push(t.defines[e]);
                                return !1 === t.isRawShaderMaterial && (!function(e, t) {
                                    e.push(t.precision),
                                        e.push(t.outputColorSpace),
                                        e.push(t.envMapMode),
                                        e.push(t.envMapCubeUVHeight),
                                        e.push(t.mapUv),
                                        e.push(t.alphaMapUv),
                                        e.push(t.lightMapUv),
                                        e.push(t.aoMapUv),
                                        e.push(t.bumpMapUv),
                                        e.push(t.normalMapUv),
                                        e.push(t.displacementMapUv),
                                        e.push(t.emissiveMapUv),
                                        e.push(t.metalnessMapUv),
                                        e.push(t.roughnessMapUv),
                                        e.push(t.anisotropyMapUv),
                                        e.push(t.clearcoatMapUv),
                                        e.push(t.clearcoatNormalMapUv),
                                        e.push(t.clearcoatRoughnessMapUv),
                                        e.push(t.iridescenceMapUv),
                                        e.push(t.iridescenceThicknessMapUv),
                                        e.push(t.sheenColorMapUv),
                                        e.push(t.sheenRoughnessMapUv),
                                        e.push(t.specularMapUv),
                                        e.push(t.specularColorMapUv),
                                        e.push(t.specularIntensityMapUv),
                                        e.push(t.transmissionMapUv),
                                        e.push(t.thicknessMapUv),
                                        e.push(t.combine),
                                        e.push(t.fogExp2),
                                        e.push(t.sizeAttenuation),
                                        e.push(t.morphTargetsCount),
                                        e.push(t.morphAttributeCount),
                                        e.push(t.numDirLights),
                                        e.push(t.numPointLights),
                                        e.push(t.numSpotLights),
                                        e.push(t.numSpotLightMaps),
                                        e.push(t.numHemiLights),
                                        e.push(t.numRectAreaLights),
                                        e.push(t.numDirLightShadows),
                                        e.push(t.numPointLightShadows),
                                        e.push(t.numSpotLightShadows),
                                        e.push(t.numSpotLightShadowsWithMaps),
                                        e.push(t.numLightProbes),
                                        e.push(t.shadowMapType),
                                        e.push(t.toneMapping),
                                        e.push(t.numClippingPlanes),
                                        e.push(t.numClipIntersection),
                                        e.push(t.depthPacking)
                                }(n, t),
                                    function(e, t) {
                                        o.disableAll(),
                                        t.supportsVertexTextures && o.enable(0);
                                        t.instancing && o.enable(1);
                                        t.instancingColor && o.enable(2);
                                        t.instancingMorph && o.enable(3);
                                        t.matcap && o.enable(4);
                                        t.envMap && o.enable(5);
                                        t.normalMapObjectSpace && o.enable(6);
                                        t.normalMapTangentSpace && o.enable(7);
                                        t.clearcoat && o.enable(8);
                                        t.iridescence && o.enable(9);
                                        t.alphaTest && o.enable(10);
                                        t.vertexColors && o.enable(11);
                                        t.vertexAlphas && o.enable(12);
                                        t.vertexUv1s && o.enable(13);
                                        t.vertexUv2s && o.enable(14);
                                        t.vertexUv3s && o.enable(15);
                                        t.vertexTangents && o.enable(16);
                                        t.anisotropy && o.enable(17);
                                        t.alphaHash && o.enable(18);
                                        t.batching && o.enable(19);
                                        t.dispersion && o.enable(20);
                                        t.batchingColor && o.enable(21);
                                        e.push(o.mask),
                                            o.disableAll(),
                                        t.fog && o.enable(0);
                                        t.useFog && o.enable(1);
                                        t.flatShading && o.enable(2);
                                        t.logarithmicDepthBuffer && o.enable(3);
                                        t.reverseDepthBuffer && o.enable(4);
                                        t.skinning && o.enable(5);
                                        t.morphTargets && o.enable(6);
                                        t.morphNormals && o.enable(7);
                                        t.morphColors && o.enable(8);
                                        t.premultipliedAlpha && o.enable(9);
                                        t.shadowMapEnabled && o.enable(10);
                                        t.doubleSided && o.enable(11);
                                        t.flipSided && o.enable(12);
                                        t.useDepthPacking && o.enable(13);
                                        t.dithering && o.enable(14);
                                        t.transmission && o.enable(15);
                                        t.sheen && o.enable(16);
                                        t.opaque && o.enable(17);
                                        t.pointsUvs && o.enable(18);
                                        t.decodeVideoTexture && o.enable(19);
                                        t.decodeVideoTextureEmissive && o.enable(20);
                                        t.alphaToCoverage && o.enable(21);
                                        e.push(o.mask)
                                    }(n, t),
                                    n.push(e.outputColorSpace)),
                                    n.push(t.customProgramCacheKey),
                                    n.join()
                            },
                            getUniforms: function(e) {
                                const t = f[e.type];
                                let n;
                                if (t) {
                                    const e = vc[t];
                                    n = Er.clone(e.uniforms)
                                } else
                                    n = e.uniforms;
                                return n
                            },
                            acquireProgram: function(t, n) {
                                let i;
                                for (let e = 0, t = h.length; e < t; e++) {
                                    const t = h[e];
                                    if (t.cacheKey === n) {
                                        i = t,
                                            ++i.usedTimes;
                                        break
                                    }
                                }
                                return void 0 === i && (i = new xd(e,n,t,a),
                                    h.push(i)),
                                    i
                            },
                            releaseProgram: function(e) {
                                if (0 == --e.usedTimes) {
                                    const t = h.indexOf(e);
                                    h[t] = h[h.length - 1],
                                        h.pop(),
                                        e.destroy()
                                }
                            },
                            releaseShaderCache: function(e) {
                                l.remove(e)
                            },
                            programs: h,
                            dispose: function() {
                                l.dispose()
                            }
                        }
                    }
                    function Td() {
                        let e = new WeakMap;
                        return {
                            has: function(t) {
                                return e.has(t)
                            },
                            get: function(t) {
                                let n = e.get(t);
                                return void 0 === n && (n = {},
                                    e.set(t, n)),
                                    n
                            },
                            remove: function(t) {
                                e.delete(t)
                            },
                            update: function(t, n, i) {
                                e.get(t)[n] = i
                            },
                            dispose: function() {
                                e = new WeakMap
                            }
                        }
                    }
                    function Cd(e, t) {
                        return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
                    }
                    function _d(e, t) {
                        return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
                    }
                    function Id() {
                        const e = [];
                        let t = 0;
                        const n = []
                            , i = []
                            , r = [];
                        function a(n, i, r, a, s, o) {
                            let l = e[t];
                            return void 0 === l ? (l = {
                                id: n.id,
                                object: n,
                                geometry: i,
                                material: r,
                                groupOrder: a,
                                renderOrder: n.renderOrder,
                                z: s,
                                group: o
                            },
                                e[t] = l) : (l.id = n.id,
                                l.object = n,
                                l.geometry = i,
                                l.material = r,
                                l.groupOrder = a,
                                l.renderOrder = n.renderOrder,
                                l.z = s,
                                l.group = o),
                                t++,
                                l
                        }
                        return {
                            opaque: n,
                            transmissive: i,
                            transparent: r,
                            init: function() {
                                t = 0,
                                    n.length = 0,
                                    i.length = 0,
                                    r.length = 0
                            },
                            push: function(e, t, s, o, l, c) {
                                const h = a(e, t, s, o, l, c);
                                s.transmission > 0 ? i.push(h) : !0 === s.transparent ? r.push(h) : n.push(h)
                            },
                            unshift: function(e, t, s, o, l, c) {
                                const h = a(e, t, s, o, l, c);
                                s.transmission > 0 ? i.unshift(h) : !0 === s.transparent ? r.unshift(h) : n.unshift(h)
                            },
                            finish: function() {
                                for (let n = t, i = e.length; n < i; n++) {
                                    const t = e[n];
                                    if (null === t.id)
                                        break;
                                    t.id = null,
                                        t.object = null,
                                        t.geometry = null,
                                        t.material = null,
                                        t.group = null
                                }
                            },
                            sort: function(e, t) {
                                n.length > 1 && n.sort(e || Cd),
                                i.length > 1 && i.sort(t || _d),
                                r.length > 1 && r.sort(t || _d)
                            }
                        }
                    }
                    function Pd() {
                        let e = new WeakMap;
                        return {
                            get: function(t, n) {
                                const i = e.get(t);
                                let r;
                                return void 0 === i ? (r = new Id,
                                    e.set(t, [r])) : n >= i.length ? (r = new Id,
                                    i.push(r)) : r = i[n],
                                    r
                            },
                            dispose: function() {
                                e = new WeakMap
                            }
                        }
                    }
                    function Rd() {
                        const e = {};
                        return {
                            get: function(t) {
                                if (void 0 !== e[t.id])
                                    return e[t.id];
                                let n;
                                switch (t.type) {
                                    case "DirectionalLight":
                                        n = {
                                            direction: new An,
                                            color: new Wi
                                        };
                                        break;
                                    case "SpotLight":
                                        n = {
                                            position: new An,
                                            direction: new An,
                                            color: new Wi,
                                            distance: 0,
                                            coneCos: 0,
                                            penumbraCos: 0,
                                            decay: 0
                                        };
                                        break;
                                    case "PointLight":
                                        n = {
                                            position: new An,
                                            color: new Wi,
                                            distance: 0,
                                            decay: 0
                                        };
                                        break;
                                    case "HemisphereLight":
                                        n = {
                                            direction: new An,
                                            skyColor: new Wi,
                                            groundColor: new Wi
                                        };
                                        break;
                                    case "RectAreaLight":
                                        n = {
                                            color: new Wi,
                                            position: new An,
                                            halfWidth: new An,
                                            halfHeight: new An
                                        }
                                }
                                return e[t.id] = n,
                                    n
                            }
                        }
                    }
                    let Ld = 0;
                    function Nd(e, t) {
                        return (t.castShadow ? 2 : 0) - (e.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (e.map ? 1 : 0)
                    }
                    function Dd(e) {
                        const t = new Rd
                            , n = function() {
                            const e = {};
                            return {
                                get: function(t) {
                                    if (void 0 !== e[t.id])
                                        return e[t.id];
                                    let n;
                                    switch (t.type) {
                                        case "DirectionalLight":
                                        case "SpotLight":
                                            n = {
                                                shadowIntensity: 1,
                                                shadowBias: 0,
                                                shadowNormalBias: 0,
                                                shadowRadius: 1,
                                                shadowMapSize: new jt
                                            };
                                            break;
                                        case "PointLight":
                                            n = {
                                                shadowIntensity: 1,
                                                shadowBias: 0,
                                                shadowNormalBias: 0,
                                                shadowRadius: 1,
                                                shadowMapSize: new jt,
                                                shadowCameraNear: 1,
                                                shadowCameraFar: 1e3
                                            }
                                    }
                                    return e[t.id] = n,
                                        n
                                }
                            }
                        }()
                            , i = {
                            version: 0,
                            hash: {
                                directionalLength: -1,
                                pointLength: -1,
                                spotLength: -1,
                                rectAreaLength: -1,
                                hemiLength: -1,
                                numDirectionalShadows: -1,
                                numPointShadows: -1,
                                numSpotShadows: -1,
                                numSpotMaps: -1,
                                numLightProbes: -1
                            },
                            ambient: [0, 0, 0],
                            probe: [],
                            directional: [],
                            directionalShadow: [],
                            directionalShadowMap: [],
                            directionalShadowMatrix: [],
                            spot: [],
                            spotLightMap: [],
                            spotShadow: [],
                            spotShadowMap: [],
                            spotLightMatrix: [],
                            rectArea: [],
                            rectAreaLTC1: null,
                            rectAreaLTC2: null,
                            point: [],
                            pointShadow: [],
                            pointShadowMap: [],
                            pointShadowMatrix: [],
                            hemi: [],
                            numSpotLightShadowsWithMaps: 0,
                            numLightProbes: 0
                        };
                        for (let e = 0; e < 9; e++)
                            i.probe.push(new An);
                        const r = new An
                            , a = new Kn
                            , s = new Kn;
                        return {
                            setup: function(r) {
                                let a = 0
                                    , s = 0
                                    , o = 0;
                                for (let e = 0; e < 9; e++)
                                    i.probe[e].set(0, 0, 0);
                                let l = 0
                                    , c = 0
                                    , h = 0
                                    , d = 0
                                    , u = 0
                                    , p = 0
                                    , f = 0
                                    , m = 0
                                    , g = 0
                                    , v = 0
                                    , w = 0;
                                r.sort(Nd);
                                for (let e = 0, A = r.length; e < A; e++) {
                                    const A = r[e]
                                        , y = A.color
                                        , b = A.intensity
                                        , x = A.distance
                                        , k = A.shadow && A.shadow.map ? A.shadow.map.texture : null;
                                    if (A.isAmbientLight)
                                        a += y.r * b,
                                            s += y.g * b,
                                            o += y.b * b;
                                    else if (A.isLightProbe) {
                                        for (let e = 0; e < 9; e++)
                                            i.probe[e].addScaledVector(A.sh.coefficients[e], b);
                                        w++
                                    } else if (A.isDirectionalLight) {
                                        const e = t.get(A);
                                        if (e.color.copy(A.color).multiplyScalar(A.intensity),
                                            A.castShadow) {
                                            const e = A.shadow
                                                , t = n.get(A);
                                            t.shadowIntensity = e.intensity,
                                                t.shadowBias = e.bias,
                                                t.shadowNormalBias = e.normalBias,
                                                t.shadowRadius = e.radius,
                                                t.shadowMapSize = e.mapSize,
                                                i.directionalShadow[l] = t,
                                                i.directionalShadowMap[l] = k,
                                                i.directionalShadowMatrix[l] = A.shadow.matrix,
                                                p++
                                        }
                                        i.directional[l] = e,
                                            l++
                                    } else if (A.isSpotLight) {
                                        const e = t.get(A);
                                        e.position.setFromMatrixPosition(A.matrixWorld),
                                            e.color.copy(y).multiplyScalar(b),
                                            e.distance = x,
                                            e.coneCos = Math.cos(A.angle),
                                            e.penumbraCos = Math.cos(A.angle * (1 - A.penumbra)),
                                            e.decay = A.decay,
                                            i.spot[h] = e;
                                        const r = A.shadow;
                                        if (A.map && (i.spotLightMap[g] = A.map,
                                            g++,
                                            r.updateMatrices(A),
                                        A.castShadow && v++),
                                            i.spotLightMatrix[h] = r.matrix,
                                            A.castShadow) {
                                            const e = n.get(A);
                                            e.shadowIntensity = r.intensity,
                                                e.shadowBias = r.bias,
                                                e.shadowNormalBias = r.normalBias,
                                                e.shadowRadius = r.radius,
                                                e.shadowMapSize = r.mapSize,
                                                i.spotShadow[h] = e,
                                                i.spotShadowMap[h] = k,
                                                m++
                                        }
                                        h++
                                    } else if (A.isRectAreaLight) {
                                        const e = t.get(A);
                                        e.color.copy(y).multiplyScalar(b),
                                            e.halfWidth.set(.5 * A.width, 0, 0),
                                            e.halfHeight.set(0, .5 * A.height, 0),
                                            i.rectArea[d] = e,
                                            d++
                                    } else if (A.isPointLight) {
                                        const e = t.get(A);
                                        if (e.color.copy(A.color).multiplyScalar(A.intensity),
                                            e.distance = A.distance,
                                            e.decay = A.decay,
                                            A.castShadow) {
                                            const e = A.shadow
                                                , t = n.get(A);
                                            t.shadowIntensity = e.intensity,
                                                t.shadowBias = e.bias,
                                                t.shadowNormalBias = e.normalBias,
                                                t.shadowRadius = e.radius,
                                                t.shadowMapSize = e.mapSize,
                                                t.shadowCameraNear = e.camera.near,
                                                t.shadowCameraFar = e.camera.far,
                                                i.pointShadow[c] = t,
                                                i.pointShadowMap[c] = k,
                                                i.pointShadowMatrix[c] = A.shadow.matrix,
                                                f++
                                        }
                                        i.point[c] = e,
                                            c++
                                    } else if (A.isHemisphereLight) {
                                        const e = t.get(A);
                                        e.skyColor.copy(A.color).multiplyScalar(b),
                                            e.groundColor.copy(A.groundColor).multiplyScalar(b),
                                            i.hemi[u] = e,
                                            u++
                                    }
                                }
                                d > 0 && (!0 === e.has("OES_texture_float_linear") ? (i.rectAreaLTC1 = gc.LTC_FLOAT_1,
                                    i.rectAreaLTC2 = gc.LTC_FLOAT_2) : (i.rectAreaLTC1 = gc.LTC_HALF_1,
                                    i.rectAreaLTC2 = gc.LTC_HALF_2)),
                                    i.ambient[0] = a,
                                    i.ambient[1] = s,
                                    i.ambient[2] = o;
                                const A = i.hash;
                                A.directionalLength === l && A.pointLength === c && A.spotLength === h && A.rectAreaLength === d && A.hemiLength === u && A.numDirectionalShadows === p && A.numPointShadows === f && A.numSpotShadows === m && A.numSpotMaps === g && A.numLightProbes === w || (i.directional.length = l,
                                    i.spot.length = h,
                                    i.rectArea.length = d,
                                    i.point.length = c,
                                    i.hemi.length = u,
                                    i.directionalShadow.length = p,
                                    i.directionalShadowMap.length = p,
                                    i.pointShadow.length = f,
                                    i.pointShadowMap.length = f,
                                    i.spotShadow.length = m,
                                    i.spotShadowMap.length = m,
                                    i.directionalShadowMatrix.length = p,
                                    i.pointShadowMatrix.length = f,
                                    i.spotLightMatrix.length = m + g - v,
                                    i.spotLightMap.length = g,
                                    i.numSpotLightShadowsWithMaps = v,
                                    i.numLightProbes = w,
                                    A.directionalLength = l,
                                    A.pointLength = c,
                                    A.spotLength = h,
                                    A.rectAreaLength = d,
                                    A.hemiLength = u,
                                    A.numDirectionalShadows = p,
                                    A.numPointShadows = f,
                                    A.numSpotShadows = m,
                                    A.numSpotMaps = g,
                                    A.numLightProbes = w,
                                    i.version = Ld++)
                            },
                            setupView: function(e, t) {
                                let n = 0
                                    , o = 0
                                    , l = 0
                                    , c = 0
                                    , h = 0;
                                const d = t.matrixWorldInverse;
                                for (let t = 0, u = e.length; t < u; t++) {
                                    const u = e[t];
                                    if (u.isDirectionalLight) {
                                        const e = i.directional[n];
                                        e.direction.setFromMatrixPosition(u.matrixWorld),
                                            r.setFromMatrixPosition(u.target.matrixWorld),
                                            e.direction.sub(r),
                                            e.direction.transformDirection(d),
                                            n++
                                    } else if (u.isSpotLight) {
                                        const e = i.spot[l];
                                        e.position.setFromMatrixPosition(u.matrixWorld),
                                            e.position.applyMatrix4(d),
                                            e.direction.setFromMatrixPosition(u.matrixWorld),
                                            r.setFromMatrixPosition(u.target.matrixWorld),
                                            e.direction.sub(r),
                                            e.direction.transformDirection(d),
                                            l++
                                    } else if (u.isRectAreaLight) {
                                        const e = i.rectArea[c];
                                        e.position.setFromMatrixPosition(u.matrixWorld),
                                            e.position.applyMatrix4(d),
                                            s.identity(),
                                            a.copy(u.matrixWorld),
                                            a.premultiply(d),
                                            s.extractRotation(a),
                                            e.halfWidth.set(.5 * u.width, 0, 0),
                                            e.halfHeight.set(0, .5 * u.height, 0),
                                            e.halfWidth.applyMatrix4(s),
                                            e.halfHeight.applyMatrix4(s),
                                            c++
                                    } else if (u.isPointLight) {
                                        const e = i.point[o];
                                        e.position.setFromMatrixPosition(u.matrixWorld),
                                            e.position.applyMatrix4(d),
                                            o++
                                    } else if (u.isHemisphereLight) {
                                        const e = i.hemi[h];
                                        e.direction.setFromMatrixPosition(u.matrixWorld),
                                            e.direction.transformDirection(d),
                                            h++
                                    }
                                }
                            },
                            state: i
                        }
                    }
                    function Bd(e) {
                        const t = new Dd(e)
                            , n = []
                            , i = [];
                        const r = {
                            lightsArray: n,
                            shadowsArray: i,
                            camera: null,
                            lights: t,
                            transmissionRenderTarget: {}
                        };
                        return {
                            init: function(e) {
                                r.camera = e,
                                    n.length = 0,
                                    i.length = 0
                            },
                            state: r,
                            setupLights: function() {
                                t.setup(n)
                            },
                            setupLightsView: function(e) {
                                t.setupView(n, e)
                            },
                            pushLight: function(e) {
                                n.push(e)
                            },
                            pushShadow: function(e) {
                                i.push(e)
                            }
                        }
                    }
                    function Ud(e) {
                        let t = new WeakMap;
                        return {
                            get: function(n, i=0) {
                                const r = t.get(n);
                                let a;
                                return void 0 === r ? (a = new Bd(e),
                                    t.set(n, [a])) : i >= r.length ? (a = new Bd(e),
                                    r.push(a)) : a = r[i],
                                    a
                            },
                            dispose: function() {
                                t = new WeakMap
                            }
                        }
                    }
                    function zd(e, t, n) {
                        let i = new Aa;
                        const r = new jt
                            , a = new jt
                            , s = new pn
                            , o = new Ws({
                            depthPacking: 3201
                        })
                            , l = new Hs
                            , c = {}
                            , h = n.maxTextureSize
                            , d = {
                            [k]: 1,
                            [E]: 0,
                            [S]: 2
                        }
                            , u = new Sr({
                            defines: {
                                VSM_SAMPLES: 8
                            },
                            uniforms: {
                                shadow_pass: {
                                    value: null
                                },
                                resolution: {
                                    value: new jt
                                },
                                radius: {
                                    value: 4
                                }
                            },
                            vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                            fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
                        })
                            , p = u.clone();
                        p.defines.HORIZONTAL_PASS = 1;
                        const f = new sr;
                        f.setAttribute("position", new Ki(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
                        const m = new wr(f,u)
                            , g = this;
                        this.enabled = !1,
                            this.autoUpdate = !0,
                            this.needsUpdate = !1,
                            this.type = 1;
                        let v = this.type;
                        function w(n, i) {
                            const a = t.update(m);
                            u.defines.VSM_SAMPLES !== n.blurSamples && (u.defines.VSM_SAMPLES = n.blurSamples,
                                p.defines.VSM_SAMPLES = n.blurSamples,
                                u.needsUpdate = !0,
                                p.needsUpdate = !0),
                            null === n.mapPass && (n.mapPass = new mn(r.x,r.y)),
                                u.uniforms.shadow_pass.value = n.map.texture,
                                u.uniforms.resolution.value = n.mapSize,
                                u.uniforms.radius.value = n.radius,
                                e.setRenderTarget(n.mapPass),
                                e.clear(),
                                e.renderBufferDirect(i, null, a, u, m, null),
                                p.uniforms.shadow_pass.value = n.mapPass.texture,
                                p.uniforms.resolution.value = n.mapSize,
                                p.uniforms.radius.value = n.radius,
                                e.setRenderTarget(n.map),
                                e.clear(),
                                e.renderBufferDirect(i, null, a, p, m, null)
                        }
                        function A(t, n, i, r) {
                            let a = null;
                            const s = !0 === i.isPointLight ? t.customDistanceMaterial : t.customDepthMaterial;
                            if (void 0 !== s)
                                a = s;
                            else if (a = !0 === i.isPointLight ? l : o,
                            e.localClippingEnabled && !0 === n.clipShadows && Array.isArray(n.clippingPlanes) && 0 !== n.clippingPlanes.length || n.displacementMap && 0 !== n.displacementScale || n.alphaMap && n.alphaTest > 0 || n.map && n.alphaTest > 0) {
                                const e = a.uuid
                                    , t = n.uuid;
                                let i = c[e];
                                void 0 === i && (i = {},
                                    c[e] = i);
                                let r = i[t];
                                void 0 === r && (r = a.clone(),
                                    i[t] = r,
                                    n.addEventListener("dispose", b)),
                                    a = r
                            }
                            if (a.visible = n.visible,
                                a.wireframe = n.wireframe,
                                a.side = 3 === r ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : d[n.side],
                                a.alphaMap = n.alphaMap,
                                a.alphaTest = n.alphaTest,
                                a.map = n.map,
                                a.clipShadows = n.clipShadows,
                                a.clippingPlanes = n.clippingPlanes,
                                a.clipIntersection = n.clipIntersection,
                                a.displacementMap = n.displacementMap,
                                a.displacementScale = n.displacementScale,
                                a.displacementBias = n.displacementBias,
                                a.wireframeLinewidth = n.wireframeLinewidth,
                                a.linewidth = n.linewidth,
                            !0 === i.isPointLight && !0 === a.isMeshDistanceMaterial) {
                                e.properties.get(a).light = i
                            }
                            return a
                        }
                        function y(n, r, a, s, o) {
                            if (!1 === n.visible)
                                return;
                            if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === o) && (!n.frustumCulled || i.intersectsObject(n))) {
                                n.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, n.matrixWorld);
                                const i = t.update(n)
                                    , l = n.material;
                                if (Array.isArray(l)) {
                                    const t = i.groups;
                                    for (let c = 0, h = t.length; c < h; c++) {
                                        const h = t[c]
                                            , d = l[h.materialIndex];
                                        if (d && d.visible) {
                                            const t = A(n, d, s, o);
                                            n.onBeforeShadow(e, n, r, a, i, t, h),
                                                e.renderBufferDirect(a, null, i, t, n, h),
                                                n.onAfterShadow(e, n, r, a, i, t, h)
                                        }
                                    }
                                } else if (l.visible) {
                                    const t = A(n, l, s, o);
                                    n.onBeforeShadow(e, n, r, a, i, t, null),
                                        e.renderBufferDirect(a, null, i, t, n, null),
                                        n.onAfterShadow(e, n, r, a, i, t, null)
                                }
                            }
                            const l = n.children;
                            for (let e = 0, t = l.length; e < t; e++)
                                y(l[e], r, a, s, o)
                        }
                        function b(e) {
                            e.target.removeEventListener("dispose", b);
                            for (const t in c) {
                                const n = c[t]
                                    , i = e.target.uuid;
                                if (i in n) {
                                    n[i].dispose(),
                                        delete n[i]
                                }
                            }
                        }
                        this.render = function(t, n, o) {
                            if (!1 === g.enabled)
                                return;
                            if (!1 === g.autoUpdate && !1 === g.needsUpdate)
                                return;
                            if (0 === t.length)
                                return;
                            const l = e.getRenderTarget()
                                , c = e.getActiveCubeFace()
                                , d = e.getActiveMipmapLevel()
                                , u = e.state;
                            u.setBlending(0),
                                u.buffers.color.setClear(1, 1, 1, 1),
                                u.buffers.depth.setTest(!0),
                                u.setScissorTest(!1);
                            const p = 3 !== v && 3 === this.type
                                , f = 3 === v && 3 !== this.type;
                            for (let l = 0, c = t.length; l < c; l++) {
                                const c = t[l]
                                    , d = c.shadow;
                                if (void 0 === d) {
                                    console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
                                    continue
                                }
                                if (!1 === d.autoUpdate && !1 === d.needsUpdate)
                                    continue;
                                r.copy(d.mapSize);
                                const m = d.getFrameExtents();
                                if (r.multiply(m),
                                    a.copy(d.mapSize),
                                (r.x > h || r.y > h) && (r.x > h && (a.x = Math.floor(h / m.x),
                                    r.x = a.x * m.x,
                                    d.mapSize.x = a.x),
                                r.y > h && (a.y = Math.floor(h / m.y),
                                    r.y = a.y * m.y,
                                    d.mapSize.y = a.y)),
                                null === d.map || !0 === p || !0 === f) {
                                    const e = 3 !== this.type ? {
                                        minFilter: oe,
                                        magFilter: oe
                                    } : {};
                                    null !== d.map && d.map.dispose(),
                                        d.map = new mn(r.x,r.y,e),
                                        d.map.texture.name = c.name + ".shadowMap",
                                        d.camera.updateProjectionMatrix()
                                }
                                e.setRenderTarget(d.map),
                                    e.clear();
                                const g = d.getViewportCount();
                                for (let e = 0; e < g; e++) {
                                    const t = d.getViewport(e);
                                    s.set(a.x * t.x, a.y * t.y, a.x * t.z, a.y * t.w),
                                        u.viewport(s),
                                        d.updateMatrices(c, e),
                                        i = d.getFrustum(),
                                        y(n, o, d.camera, c, this.type)
                                }
                                !0 !== d.isPointLightShadow && 3 === this.type && w(d, o),
                                    d.needsUpdate = !1
                            }
                            v = this.type,
                                g.needsUpdate = !1,
                                e.setRenderTarget(l, c, d)
                        }
                    }
                    const Od = {
                        [G]: 1,
                        [Q]: 6,
                        [q]: 7,
                        [Y]: 5,
                        [j]: 0,
                        [X]: 2,
                        [Z]: 4,
                        [K]: 3
                    };
                    function Fd(e, t) {
                        const n = new function() {
                            let t = !1;
                            const n = new pn;
                            let i = null;
                            const r = new pn(0,0,0,0);
                            return {
                                setMask: function(n) {
                                    i === n || t || (e.colorMask(n, n, n, n),
                                        i = n)
                                },
                                setLocked: function(e) {
                                    t = e
                                },
                                setClear: function(t, i, a, s, o) {
                                    !0 === o && (t *= s,
                                        i *= s,
                                        a *= s),
                                        n.set(t, i, a, s),
                                    !1 === r.equals(n) && (e.clearColor(t, i, a, s),
                                        r.copy(n))
                                },
                                reset: function() {
                                    t = !1,
                                        i = null,
                                        r.set(-1, 0, 0, 0)
                                }
                            }
                        }
                            , i = new function() {
                            let n = !1
                                , i = !1
                                , r = null
                                , a = null
                                , s = null;
                            return {
                                setReversed: function(e) {
                                    if (i !== e) {
                                        const e = t.get("EXT_clip_control");
                                        i ? e.clipControlEXT(e.LOWER_LEFT_EXT, e.ZERO_TO_ONE_EXT) : e.clipControlEXT(e.LOWER_LEFT_EXT, e.NEGATIVE_ONE_TO_ONE_EXT);
                                        const n = s;
                                        s = null,
                                            this.setClear(n)
                                    }
                                    i = e
                                },
                                getReversed: function() {
                                    return i
                                },
                                setTest: function(t) {
                                    t ? re(e.DEPTH_TEST) : ae(e.DEPTH_TEST)
                                },
                                setMask: function(t) {
                                    r === t || n || (e.depthMask(t),
                                        r = t)
                                },
                                setFunc: function(t) {
                                    if (i && (t = Od[t]),
                                    a !== t) {
                                        switch (t) {
                                            case 0:
                                                e.depthFunc(e.NEVER);
                                                break;
                                            case 1:
                                                e.depthFunc(e.ALWAYS);
                                                break;
                                            case 2:
                                                e.depthFunc(e.LESS);
                                                break;
                                            case 3:
                                            default:
                                                e.depthFunc(e.LEQUAL);
                                                break;
                                            case 4:
                                                e.depthFunc(e.EQUAL);
                                                break;
                                            case 5:
                                                e.depthFunc(e.GEQUAL);
                                                break;
                                            case 6:
                                                e.depthFunc(e.GREATER);
                                                break;
                                            case 7:
                                                e.depthFunc(e.NOTEQUAL)
                                        }
                                        a = t
                                    }
                                },
                                setLocked: function(e) {
                                    n = e
                                },
                                setClear: function(t) {
                                    s !== t && (i && (t = 1 - t),
                                        e.clearDepth(t),
                                        s = t)
                                },
                                reset: function() {
                                    n = !1,
                                        r = null,
                                        a = null,
                                        s = null,
                                        i = !1
                                }
                            }
                        }
                            , r = new function() {
                            let t = !1
                                , n = null
                                , i = null
                                , r = null
                                , a = null
                                , s = null
                                , o = null
                                , l = null
                                , c = null;
                            return {
                                setTest: function(n) {
                                    t || (n ? re(e.STENCIL_TEST) : ae(e.STENCIL_TEST))
                                },
                                setMask: function(i) {
                                    n === i || t || (e.stencilMask(i),
                                        n = i)
                                },
                                setFunc: function(t, n, s) {
                                    i === t && r === n && a === s || (e.stencilFunc(t, n, s),
                                        i = t,
                                        r = n,
                                        a = s)
                                },
                                setOp: function(t, n, i) {
                                    s === t && o === n && l === i || (e.stencilOp(t, n, i),
                                        s = t,
                                        o = n,
                                        l = i)
                                },
                                setLocked: function(e) {
                                    t = e
                                },
                                setClear: function(t) {
                                    c !== t && (e.clearStencil(t),
                                        c = t)
                                },
                                reset: function() {
                                    t = !1,
                                        n = null,
                                        i = null,
                                        r = null,
                                        a = null,
                                        s = null,
                                        o = null,
                                        l = null,
                                        c = null
                                }
                            }
                        }
                            , a = new WeakMap
                            , s = new WeakMap;
                        let o = {}
                            , l = {}
                            , c = new WeakMap
                            , h = []
                            , d = null
                            , u = !1
                            , p = null
                            , f = null
                            , m = null
                            , g = null
                            , v = null
                            , w = null
                            , A = null
                            , y = new Wi(0,0,0)
                            , b = 0
                            , x = !1
                            , k = null
                            , E = null
                            , S = null
                            , G = null
                            , j = null;
                        const Q = e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
                        let Y = !1
                            , q = 0;
                        const K = e.getParameter(e.VERSION);
                        -1 !== K.indexOf("WebGL") ? (q = parseFloat(/^WebGL (\d)/.exec(K)[1]),
                            Y = q >= 1) : -1 !== K.indexOf("OpenGL ES") && (q = parseFloat(/^OpenGL ES (\d)/.exec(K)[1]),
                            Y = q >= 2);
                        let X = null
                            , Z = {};
                        const J = e.getParameter(e.SCISSOR_BOX)
                            , $ = e.getParameter(e.VIEWPORT)
                            , ee = (new pn).fromArray(J)
                            , te = (new pn).fromArray($);
                        function ne(t, n, i, r) {
                            const a = new Uint8Array(4)
                                , s = e.createTexture();
                            e.bindTexture(t, s),
                                e.texParameteri(t, e.TEXTURE_MIN_FILTER, e.NEAREST),
                                e.texParameteri(t, e.TEXTURE_MAG_FILTER, e.NEAREST);
                            for (let s = 0; s < i; s++)
                                t === e.TEXTURE_3D || t === e.TEXTURE_2D_ARRAY ? e.texImage3D(n, 0, e.RGBA, 1, 1, r, 0, e.RGBA, e.UNSIGNED_BYTE, a) : e.texImage2D(n + s, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, a);
                            return s
                        }
                        const ie = {};
                        function re(t) {
                            !0 !== o[t] && (e.enable(t),
                                o[t] = !0)
                        }
                        function ae(t) {
                            !1 !== o[t] && (e.disable(t),
                                o[t] = !1)
                        }
                        ie[e.TEXTURE_2D] = ne(e.TEXTURE_2D, e.TEXTURE_2D, 1),
                            ie[e.TEXTURE_CUBE_MAP] = ne(e.TEXTURE_CUBE_MAP, e.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
                            ie[e.TEXTURE_2D_ARRAY] = ne(e.TEXTURE_2D_ARRAY, e.TEXTURE_2D_ARRAY, 1, 1),
                            ie[e.TEXTURE_3D] = ne(e.TEXTURE_3D, e.TEXTURE_3D, 1, 1),
                            n.setClear(0, 0, 0, 1),
                            i.setClear(1),
                            r.setClear(0),
                            re(e.DEPTH_TEST),
                            i.setFunc(3),
                            ce(!1),
                            he(1),
                            re(e.CULL_FACE),
                            le(0);
                        const se = {
                            [M]: e.FUNC_ADD,
                            [T]: e.FUNC_SUBTRACT,
                            [C]: e.FUNC_REVERSE_SUBTRACT
                        };
                        se[103] = e.MIN,
                            se[104] = e.MAX;
                        const oe = {
                            [_]: e.ZERO,
                            [I]: e.ONE,
                            [P]: e.SRC_COLOR,
                            [L]: e.SRC_ALPHA,
                            [O]: e.SRC_ALPHA_SATURATE,
                            [U]: e.DST_COLOR,
                            [D]: e.DST_ALPHA,
                            [R]: e.ONE_MINUS_SRC_COLOR,
                            [N]: e.ONE_MINUS_SRC_ALPHA,
                            [z]: e.ONE_MINUS_DST_COLOR,
                            [B]: e.ONE_MINUS_DST_ALPHA,
                            [F]: e.CONSTANT_COLOR,
                            [W]: e.ONE_MINUS_CONSTANT_COLOR,
                            [H]: e.CONSTANT_ALPHA,
                            [V]: e.ONE_MINUS_CONSTANT_ALPHA
                        };
                        function le(t, n, i, r, a, s, o, l, c, h) {
                            if (0 !== t) {
                                if (!1 === u && (re(e.BLEND),
                                    u = !0),
                                5 === t)
                                    a = a || n,
                                        s = s || i,
                                        o = o || r,
                                    n === f && a === v || (e.blendEquationSeparate(se[n], se[a]),
                                        f = n,
                                        v = a),
                                    i === m && r === g && s === w && o === A || (e.blendFuncSeparate(oe[i], oe[r], oe[s], oe[o]),
                                        m = i,
                                        g = r,
                                        w = s,
                                        A = o),
                                    !1 !== l.equals(y) && c === b || (e.blendColor(l.r, l.g, l.b, c),
                                        y.copy(l),
                                        b = c),
                                        p = t,
                                        x = !1;
                                else if (t !== p || h !== x) {
                                    if (f === M && v === M || (e.blendEquation(e.FUNC_ADD),
                                        f = M,
                                        v = M),
                                        h)
                                        switch (t) {
                                            case 1:
                                                e.blendFuncSeparate(e.ONE, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA);
                                                break;
                                            case 2:
                                                e.blendFunc(e.ONE, e.ONE);
                                                break;
                                            case 3:
                                                e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE);
                                                break;
                                            case 4:
                                                e.blendFuncSeparate(e.ZERO, e.SRC_COLOR, e.ZERO, e.SRC_ALPHA);
                                                break;
                                            default:
                                                console.error("THREE.WebGLState: Invalid blending: ", t)
                                        }
                                    else
                                        switch (t) {
                                            case 1:
                                                e.blendFuncSeparate(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA);
                                                break;
                                            case 2:
                                                e.blendFunc(e.SRC_ALPHA, e.ONE);
                                                break;
                                            case 3:
                                                e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE);
                                                break;
                                            case 4:
                                                e.blendFunc(e.ZERO, e.SRC_COLOR);
                                                break;
                                            default:
                                                console.error("THREE.WebGLState: Invalid blending: ", t)
                                        }
                                    m = null,
                                        g = null,
                                        w = null,
                                        A = null,
                                        y.set(0, 0, 0),
                                        b = 0,
                                        p = t,
                                        x = h
                                }
                            } else
                                !0 === u && (ae(e.BLEND),
                                    u = !1)
                        }
                        function ce(t) {
                            k !== t && (t ? e.frontFace(e.CW) : e.frontFace(e.CCW),
                                k = t)
                        }
                        function he(t) {
                            0 !== t ? (re(e.CULL_FACE),
                            t !== E && (1 === t ? e.cullFace(e.BACK) : 2 === t ? e.cullFace(e.FRONT) : e.cullFace(e.FRONT_AND_BACK))) : ae(e.CULL_FACE),
                                E = t
                        }
                        function de(t, n, i) {
                            t ? (re(e.POLYGON_OFFSET_FILL),
                            G === n && j === i || (e.polygonOffset(n, i),
                                G = n,
                                j = i)) : ae(e.POLYGON_OFFSET_FILL)
                        }
                        return {
                            buffers: {
                                color: n,
                                depth: i,
                                stencil: r
                            },
                            enable: re,
                            disable: ae,
                            bindFramebuffer: function(t, n) {
                                return l[t] !== n && (e.bindFramebuffer(t, n),
                                    l[t] = n,
                                t === e.DRAW_FRAMEBUFFER && (l[e.FRAMEBUFFER] = n),
                                t === e.FRAMEBUFFER && (l[e.DRAW_FRAMEBUFFER] = n),
                                    !0)
                            },
                            drawBuffers: function(t, n) {
                                let i = h
                                    , r = !1;
                                if (t) {
                                    i = c.get(n),
                                    void 0 === i && (i = [],
                                        c.set(n, i));
                                    const a = t.textures;
                                    if (i.length !== a.length || i[0] !== e.COLOR_ATTACHMENT0) {
                                        for (let t = 0, n = a.length; t < n; t++)
                                            i[t] = e.COLOR_ATTACHMENT0 + t;
                                        i.length = a.length,
                                            r = !0
                                    }
                                } else
                                    i[0] !== e.BACK && (i[0] = e.BACK,
                                        r = !0);
                                r && e.drawBuffers(i)
                            },
                            useProgram: function(t) {
                                return d !== t && (e.useProgram(t),
                                    d = t,
                                    !0)
                            },
                            setBlending: le,
                            setMaterial: function(t, a) {
                                2 === t.side ? ae(e.CULL_FACE) : re(e.CULL_FACE);
                                let s = 1 === t.side;
                                a && (s = !s),
                                    ce(s),
                                    1 === t.blending && !1 === t.transparent ? le(0) : le(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.blendColor, t.blendAlpha, t.premultipliedAlpha),
                                    i.setFunc(t.depthFunc),
                                    i.setTest(t.depthTest),
                                    i.setMask(t.depthWrite),
                                    n.setMask(t.colorWrite);
                                const o = t.stencilWrite;
                                r.setTest(o),
                                o && (r.setMask(t.stencilWriteMask),
                                    r.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask),
                                    r.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),
                                    de(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits),
                                    !0 === t.alphaToCoverage ? re(e.SAMPLE_ALPHA_TO_COVERAGE) : ae(e.SAMPLE_ALPHA_TO_COVERAGE)
                            },
                            setFlipSided: ce,
                            setCullFace: he,
                            setLineWidth: function(t) {
                                t !== S && (Y && e.lineWidth(t),
                                    S = t)
                            },
                            setPolygonOffset: de,
                            setScissorTest: function(t) {
                                t ? re(e.SCISSOR_TEST) : ae(e.SCISSOR_TEST)
                            },
                            activeTexture: function(t) {
                                void 0 === t && (t = e.TEXTURE0 + Q - 1),
                                X !== t && (e.activeTexture(t),
                                    X = t)
                            },
                            bindTexture: function(t, n, i) {
                                void 0 === i && (i = null === X ? e.TEXTURE0 + Q - 1 : X);
                                let r = Z[i];
                                void 0 === r && (r = {
                                    type: void 0,
                                    texture: void 0
                                },
                                    Z[i] = r),
                                r.type === t && r.texture === n || (X !== i && (e.activeTexture(i),
                                    X = i),
                                    e.bindTexture(t, n || ie[t]),
                                    r.type = t,
                                    r.texture = n)
                            },
                            unbindTexture: function() {
                                const t = Z[X];
                                void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null),
                                    t.type = void 0,
                                    t.texture = void 0)
                            },
                            compressedTexImage2D: function() {
                                try {
                                    e.compressedTexImage2D(...arguments)
                                } catch (e) {
                                    console.error("THREE.WebGLState:", e)
                                }
                            },
                            compressedTexImage3D: function() {
                                try {
                                    e.compressedTexImage3D(...arguments)
                                } catch (e) {
                                    console.error("THREE.WebGLState:", e)
                                }
                            },
                            texImage2D: function() {
                                try {
                                    e.texImage2D(...arguments)
                                } catch (e) {
                                    console.error("THREE.WebGLState:", e)
                                }
                            },
                            texImage3D: function() {
                                try {
                                    e.texImage3D(...arguments)
                                } catch (e) {
                                    console.error("THREE.WebGLState:", e)
                                }
                            },
                            updateUBOMapping: function(t, n) {
                                let i = s.get(n);
                                void 0 === i && (i = new WeakMap,
                                    s.set(n, i));
                                let r = i.get(t);
                                void 0 === r && (r = e.getUniformBlockIndex(n, t.name),
                                    i.set(t, r))
                            },
                            uniformBlockBinding: function(t, n) {
                                const i = s.get(n).get(t);
                                a.get(n) !== i && (e.uniformBlockBinding(n, i, t.__bindingPointIndex),
                                    a.set(n, i))
                            },
                            texStorage2D: function() {
                                try {
                                    e.texStorage2D(...arguments)
                                } catch (e) {
                                    console.error("THREE.WebGLState:", e)
                                }
                            },
                            texStorage3D: function() {
                                try {
                                    e.texStorage3D(...arguments)
                                } catch (e) {
                                    console.error("THREE.WebGLState:", e)
                                }
                            },
                            texSubImage2D: function() {
                                try {
                                    e.texSubImage2D(...arguments)
                                } catch (e) {
                                    console.error("THREE.WebGLState:", e)
                                }
                            },
                            texSubImage3D: function() {
                                try {
                                    e.texSubImage3D(...arguments)
                                } catch (e) {
                                    console.error("THREE.WebGLState:", e)
                                }
                            },
                            compressedTexSubImage2D: function() {
                                try {
                                    e.compressedTexSubImage2D(...arguments)
                                } catch (e) {
                                    console.error("THREE.WebGLState:", e)
                                }
                            },
                            compressedTexSubImage3D: function() {
                                try {
                                    e.compressedTexSubImage3D(...arguments)
                                } catch (e) {
                                    console.error("THREE.WebGLState:", e)
                                }
                            },
                            scissor: function(t) {
                                !1 === ee.equals(t) && (e.scissor(t.x, t.y, t.z, t.w),
                                    ee.copy(t))
                            },
                            viewport: function(t) {
                                !1 === te.equals(t) && (e.viewport(t.x, t.y, t.z, t.w),
                                    te.copy(t))
                            },
                            reset: function() {
                                e.disable(e.BLEND),
                                    e.disable(e.CULL_FACE),
                                    e.disable(e.DEPTH_TEST),
                                    e.disable(e.POLYGON_OFFSET_FILL),
                                    e.disable(e.SCISSOR_TEST),
                                    e.disable(e.STENCIL_TEST),
                                    e.disable(e.SAMPLE_ALPHA_TO_COVERAGE),
                                    e.blendEquation(e.FUNC_ADD),
                                    e.blendFunc(e.ONE, e.ZERO),
                                    e.blendFuncSeparate(e.ONE, e.ZERO, e.ONE, e.ZERO),
                                    e.blendColor(0, 0, 0, 0),
                                    e.colorMask(!0, !0, !0, !0),
                                    e.clearColor(0, 0, 0, 0),
                                    e.depthMask(!0),
                                    e.depthFunc(e.LESS),
                                    i.setReversed(!1),
                                    e.clearDepth(1),
                                    e.stencilMask(4294967295),
                                    e.stencilFunc(e.ALWAYS, 0, 4294967295),
                                    e.stencilOp(e.KEEP, e.KEEP, e.KEEP),
                                    e.clearStencil(0),
                                    e.cullFace(e.BACK),
                                    e.frontFace(e.CCW),
                                    e.polygonOffset(0, 0),
                                    e.activeTexture(e.TEXTURE0),
                                    e.bindFramebuffer(e.FRAMEBUFFER, null),
                                    e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
                                    e.bindFramebuffer(e.READ_FRAMEBUFFER, null),
                                    e.useProgram(null),
                                    e.lineWidth(1),
                                    e.scissor(0, 0, e.canvas.width, e.canvas.height),
                                    e.viewport(0, 0, e.canvas.width, e.canvas.height),
                                    o = {},
                                    X = null,
                                    Z = {},
                                    l = {},
                                    c = new WeakMap,
                                    h = [],
                                    d = null,
                                    u = !1,
                                    p = null,
                                    f = null,
                                    m = null,
                                    g = null,
                                    v = null,
                                    w = null,
                                    A = null,
                                    y = new Wi(0,0,0),
                                    b = 0,
                                    x = !1,
                                    k = null,
                                    E = null,
                                    S = null,
                                    G = null,
                                    j = null,
                                    ee.set(0, 0, e.canvas.width, e.canvas.height),
                                    te.set(0, 0, e.canvas.width, e.canvas.height),
                                    n.reset(),
                                    i.reset(),
                                    r.reset()
                            }
                        }
                    }
                    function Wd(e, t, n, i, r, a, s) {
                        const o = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null
                            , l = "undefined" != typeof navigator && /OculusBrowser/g.test(navigator.userAgent)
                            , c = new jt
                            , h = new WeakMap;
                        let d;
                        const u = new WeakMap;
                        let p = !1;
                        try {
                            p = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1,1).getContext("2d")
                        } catch (e) {}
                        function f(e, t) {
                            return p ? new OffscreenCanvas(e,t) : Kt("canvas")
                        }
                        function m(e, t, n) {
                            let i = 1;
                            const r = W(e);
                            if ((r.width > n || r.height > n) && (i = n / Math.max(r.width, r.height)),
                            i < 1) {
                                if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap || "undefined" != typeof VideoFrame && e instanceof VideoFrame) {
                                    const n = Math.floor(i * r.width)
                                        , a = Math.floor(i * r.height);
                                    void 0 === d && (d = f(n, a));
                                    const s = t ? f(n, a) : d;
                                    s.width = n,
                                        s.height = a;
                                    return s.getContext("2d").drawImage(e, 0, 0, n, a),
                                        console.warn("THREE.WebGLRenderer: Texture has been resized from (" + r.width + "x" + r.height + ") to (" + n + "x" + a + ")."),
                                        s
                                }
                                return "data"in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + r.width + "x" + r.height + ")."),
                                    e
                            }
                            return e
                        }
                        function g(e) {
                            return e.generateMipmaps
                        }
                        function v(t) {
                            e.generateMipmap(t)
                        }
                        function w(t) {
                            return t.isWebGLCubeRenderTarget ? e.TEXTURE_CUBE_MAP : t.isWebGL3DRenderTarget ? e.TEXTURE_3D : t.isWebGLArrayRenderTarget || t.isCompressedArrayTexture ? e.TEXTURE_2D_ARRAY : e.TEXTURE_2D
                        }
                        function A(n, i, r, a, s=!1) {
                            if (null !== n) {
                                if (void 0 !== e[n])
                                    return e[n];
                                console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                            }
                            let o = i;
                            if (i === e.RED && (r === e.FLOAT && (o = e.R32F),
                            r === e.HALF_FLOAT && (o = e.R16F),
                            r === e.UNSIGNED_BYTE && (o = e.R8)),
                            i === e.RED_INTEGER && (r === e.UNSIGNED_BYTE && (o = e.R8UI),
                            r === e.UNSIGNED_SHORT && (o = e.R16UI),
                            r === e.UNSIGNED_INT && (o = e.R32UI),
                            r === e.BYTE && (o = e.R8I),
                            r === e.SHORT && (o = e.R16I),
                            r === e.INT && (o = e.R32I)),
                            i === e.RG && (r === e.FLOAT && (o = e.RG32F),
                            r === e.HALF_FLOAT && (o = e.RG16F),
                            r === e.UNSIGNED_BYTE && (o = e.RG8)),
                            i === e.RG_INTEGER && (r === e.UNSIGNED_BYTE && (o = e.RG8UI),
                            r === e.UNSIGNED_SHORT && (o = e.RG16UI),
                            r === e.UNSIGNED_INT && (o = e.RG32UI),
                            r === e.BYTE && (o = e.RG8I),
                            r === e.SHORT && (o = e.RG16I),
                            r === e.INT && (o = e.RG32I)),
                            i === e.RGB_INTEGER && (r === e.UNSIGNED_BYTE && (o = e.RGB8UI),
                            r === e.UNSIGNED_SHORT && (o = e.RGB16UI),
                            r === e.UNSIGNED_INT && (o = e.RGB32UI),
                            r === e.BYTE && (o = e.RGB8I),
                            r === e.SHORT && (o = e.RGB16I),
                            r === e.INT && (o = e.RGB32I)),
                            i === e.RGBA_INTEGER && (r === e.UNSIGNED_BYTE && (o = e.RGBA8UI),
                            r === e.UNSIGNED_SHORT && (o = e.RGBA16UI),
                            r === e.UNSIGNED_INT && (o = e.RGBA32UI),
                            r === e.BYTE && (o = e.RGBA8I),
                            r === e.SHORT && (o = e.RGBA16I),
                            r === e.INT && (o = e.RGBA32I)),
                            i === e.RGB && r === e.UNSIGNED_INT_5_9_9_9_REV && (o = e.RGB9_E5),
                            i === e.RGBA) {
                                const t = s ? wt : nn.getTransfer(a);
                                r === e.FLOAT && (o = e.RGBA32F),
                                r === e.HALF_FLOAT && (o = e.RGBA16F),
                                r === e.UNSIGNED_BYTE && (o = t === At ? e.SRGB8_ALPHA8 : e.RGBA8),
                                r === e.UNSIGNED_SHORT_4_4_4_4 && (o = e.RGBA4),
                                r === e.UNSIGNED_SHORT_5_5_5_1 && (o = e.RGB5_A1)
                            }
                            return o !== e.R16F && o !== e.R32F && o !== e.RG16F && o !== e.RG32F && o !== e.RGBA16F && o !== e.RGBA32F || t.get("EXT_color_buffer_float"),
                                o
                        }
                        function y(t, n) {
                            let i;
                            return t ? null === n || n === we || n === ke ? i = e.DEPTH24_STENCIL8 : n === Ae ? i = e.DEPTH32F_STENCIL8 : n === ge && (i = e.DEPTH24_STENCIL8,
                                console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : null === n || n === we || n === ke ? i = e.DEPTH_COMPONENT24 : n === Ae ? i = e.DEPTH_COMPONENT32F : n === ge && (i = e.DEPTH_COMPONENT16),
                                i
                        }
                        function b(e, t) {
                            return !0 === g(e) || e.isFramebufferTexture && e.minFilter !== oe && e.minFilter !== he ? Math.log2(Math.max(t.width, t.height)) + 1 : void 0 !== e.mipmaps && e.mipmaps.length > 0 ? e.mipmaps.length : e.isCompressedTexture && Array.isArray(e.image) ? t.mipmaps.length : 1
                        }
                        function x(e) {
                            const t = e.target;
                            t.removeEventListener("dispose", x),
                                function(e) {
                                    const t = i.get(e);
                                    if (void 0 === t.__webglInit)
                                        return;
                                    const n = e.source
                                        , r = u.get(n);
                                    if (r) {
                                        const i = r[t.__cacheKey];
                                        i.usedTimes--,
                                        0 === i.usedTimes && E(e),
                                        0 === Object.keys(r).length && u.delete(n)
                                    }
                                    i.remove(e)
                                }(t),
                            t.isVideoTexture && h.delete(t)
                        }
                        function k(t) {
                            const n = t.target;
                            n.removeEventListener("dispose", k),
                                function(t) {
                                    const n = i.get(t);
                                    t.depthTexture && (t.depthTexture.dispose(),
                                        i.remove(t.depthTexture));
                                    if (t.isWebGLCubeRenderTarget)
                                        for (let t = 0; t < 6; t++) {
                                            if (Array.isArray(n.__webglFramebuffer[t]))
                                                for (let i = 0; i < n.__webglFramebuffer[t].length; i++)
                                                    e.deleteFramebuffer(n.__webglFramebuffer[t][i]);
                                            else
                                                e.deleteFramebuffer(n.__webglFramebuffer[t]);
                                            n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer[t])
                                        }
                                    else {
                                        if (Array.isArray(n.__webglFramebuffer))
                                            for (let t = 0; t < n.__webglFramebuffer.length; t++)
                                                e.deleteFramebuffer(n.__webglFramebuffer[t]);
                                        else
                                            e.deleteFramebuffer(n.__webglFramebuffer);
                                        if (n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer),
                                        n.__webglMultisampledFramebuffer && e.deleteFramebuffer(n.__webglMultisampledFramebuffer),
                                            n.__webglColorRenderbuffer)
                                            for (let t = 0; t < n.__webglColorRenderbuffer.length; t++)
                                                n.__webglColorRenderbuffer[t] && e.deleteRenderbuffer(n.__webglColorRenderbuffer[t]);
                                        n.__webglDepthRenderbuffer && e.deleteRenderbuffer(n.__webglDepthRenderbuffer)
                                    }
                                    const r = t.textures;
                                    for (let t = 0, n = r.length; t < n; t++) {
                                        const n = i.get(r[t]);
                                        n.__webglTexture && (e.deleteTexture(n.__webglTexture),
                                            s.memory.textures--),
                                            i.remove(r[t])
                                    }
                                    i.remove(t)
                                }(n)
                        }
                        function E(t) {
                            const n = i.get(t);
                            e.deleteTexture(n.__webglTexture);
                            const r = t.source;
                            delete u.get(r)[n.__cacheKey],
                                s.memory.textures--
                        }
                        let S = 0;
                        function M(t, r) {
                            const a = i.get(t);
                            if (t.isVideoTexture && function(e) {
                                const t = s.render.frame;
                                h.get(e) !== t && (h.set(e, t),
                                    e.update())
                            }(t),
                            !1 === t.isRenderTargetTexture && t.version > 0 && a.__version !== t.version) {
                                const e = t.image;
                                if (null === e)
                                    console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
                                else {
                                    if (!1 !== e.complete)
                                        return void R(a, t, r);
                                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                                }
                            }
                            n.bindTexture(e.TEXTURE_2D, a.__webglTexture, e.TEXTURE0 + r)
                        }
                        const T = {
                            [re]: e.REPEAT,
                            [ae]: e.CLAMP_TO_EDGE,
                            [se]: e.MIRRORED_REPEAT
                        }
                            , C = {
                            [oe]: e.NEAREST,
                            [le]: e.NEAREST_MIPMAP_NEAREST,
                            [ce]: e.NEAREST_MIPMAP_LINEAR,
                            [he]: e.LINEAR,
                            [de]: e.LINEAR_MIPMAP_NEAREST,
                            [ue]: e.LINEAR_MIPMAP_LINEAR
                        }
                            , _ = {
                            [bt]: e.NEVER,
                            [Ct]: e.ALWAYS,
                            [xt]: e.LESS,
                            [Et]: e.LEQUAL,
                            [kt]: e.EQUAL,
                            [Tt]: e.GEQUAL,
                            [St]: e.GREATER,
                            [Mt]: e.NOTEQUAL
                        };
                        function I(n, a) {
                            if (a.type !== Ae || !1 !== t.has("OES_texture_float_linear") || a.magFilter !== he && a.magFilter !== de && a.magFilter !== ce && a.magFilter !== ue && a.minFilter !== he && a.minFilter !== de && a.minFilter !== ce && a.minFilter !== ue || console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),
                                e.texParameteri(n, e.TEXTURE_WRAP_S, T[a.wrapS]),
                                e.texParameteri(n, e.TEXTURE_WRAP_T, T[a.wrapT]),
                            n !== e.TEXTURE_3D && n !== e.TEXTURE_2D_ARRAY || e.texParameteri(n, e.TEXTURE_WRAP_R, T[a.wrapR]),
                                e.texParameteri(n, e.TEXTURE_MAG_FILTER, C[a.magFilter]),
                                e.texParameteri(n, e.TEXTURE_MIN_FILTER, C[a.minFilter]),
                            a.compareFunction && (e.texParameteri(n, e.TEXTURE_COMPARE_MODE, e.COMPARE_REF_TO_TEXTURE),
                                e.texParameteri(n, e.TEXTURE_COMPARE_FUNC, _[a.compareFunction])),
                            !0 === t.has("EXT_texture_filter_anisotropic")) {
                                if (a.magFilter === oe)
                                    return;
                                if (a.minFilter !== ce && a.minFilter !== ue)
                                    return;
                                if (a.type === Ae && !1 === t.has("OES_texture_float_linear"))
                                    return;
                                if (a.anisotropy > 1 || i.get(a).__currentAnisotropy) {
                                    const s = t.get("EXT_texture_filter_anisotropic");
                                    e.texParameterf(n, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, r.getMaxAnisotropy())),
                                        i.get(a).__currentAnisotropy = a.anisotropy
                                }
                            }
                        }
                        function P(t, n) {
                            let i = !1;
                            void 0 === t.__webglInit && (t.__webglInit = !0,
                                n.addEventListener("dispose", x));
                            const r = n.source;
                            let a = u.get(r);
                            void 0 === a && (a = {},
                                u.set(r, a));
                            const o = function(e) {
                                const t = [];
                                return t.push(e.wrapS),
                                    t.push(e.wrapT),
                                    t.push(e.wrapR || 0),
                                    t.push(e.magFilter),
                                    t.push(e.minFilter),
                                    t.push(e.anisotropy),
                                    t.push(e.internalFormat),
                                    t.push(e.format),
                                    t.push(e.type),
                                    t.push(e.generateMipmaps),
                                    t.push(e.premultiplyAlpha),
                                    t.push(e.flipY),
                                    t.push(e.unpackAlignment),
                                    t.push(e.colorSpace),
                                    t.join()
                            }(n);
                            if (o !== t.__cacheKey) {
                                void 0 === a[o] && (a[o] = {
                                    texture: e.createTexture(),
                                    usedTimes: 0
                                },
                                    s.memory.textures++,
                                    i = !0),
                                    a[o].usedTimes++;
                                const r = a[t.__cacheKey];
                                void 0 !== r && (a[t.__cacheKey].usedTimes--,
                                0 === r.usedTimes && E(n)),
                                    t.__cacheKey = o,
                                    t.__webglTexture = a[o].texture
                            }
                            return i
                        }
                        function R(t, s, o) {
                            let l = e.TEXTURE_2D;
                            (s.isDataArrayTexture || s.isCompressedArrayTexture) && (l = e.TEXTURE_2D_ARRAY),
                            s.isData3DTexture && (l = e.TEXTURE_3D);
                            const c = P(t, s)
                                , h = s.source;
                            n.bindTexture(l, t.__webglTexture, e.TEXTURE0 + o);
                            const d = i.get(h);
                            if (h.version !== d.__version || !0 === c) {
                                n.activeTexture(e.TEXTURE0 + o);
                                const t = nn.getPrimaries(nn.workingColorSpace)
                                    , i = s.colorSpace === mt ? null : nn.getPrimaries(s.colorSpace)
                                    , u = s.colorSpace === mt || t === i ? e.NONE : e.BROWSER_DEFAULT_WEBGL;
                                e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, s.flipY),
                                    e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, s.premultiplyAlpha),
                                    e.pixelStorei(e.UNPACK_ALIGNMENT, s.unpackAlignment),
                                    e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, u);
                                let p = m(s.image, !1, r.maxTextureSize);
                                p = F(s, p);
                                const f = a.convert(s.format, s.colorSpace)
                                    , w = a.convert(s.type);
                                let x, k = A(s.internalFormat, f, w, s.colorSpace, s.isVideoTexture);
                                I(l, s);
                                const E = s.mipmaps
                                    , S = !0 !== s.isVideoTexture
                                    , M = void 0 === d.__version || !0 === c
                                    , T = h.dataReady
                                    , C = b(s, p);
                                if (s.isDepthTexture)
                                    k = y(s.format === Te, s.type),
                                    M && (S ? n.texStorage2D(e.TEXTURE_2D, 1, k, p.width, p.height) : n.texImage2D(e.TEXTURE_2D, 0, k, p.width, p.height, 0, f, w, null));
                                else if (s.isDataTexture)
                                    if (E.length > 0) {
                                        S && M && n.texStorage2D(e.TEXTURE_2D, C, k, E[0].width, E[0].height);
                                        for (let t = 0, i = E.length; t < i; t++)
                                            x = E[t],
                                                S ? T && n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, x.width, x.height, f, w, x.data) : n.texImage2D(e.TEXTURE_2D, t, k, x.width, x.height, 0, f, w, x.data);
                                        s.generateMipmaps = !1
                                    } else
                                        S ? (M && n.texStorage2D(e.TEXTURE_2D, C, k, p.width, p.height),
                                        T && n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, p.width, p.height, f, w, p.data)) : n.texImage2D(e.TEXTURE_2D, 0, k, p.width, p.height, 0, f, w, p.data);
                                else if (s.isCompressedTexture)
                                    if (s.isCompressedArrayTexture) {
                                        S && M && n.texStorage3D(e.TEXTURE_2D_ARRAY, C, k, E[0].width, E[0].height, p.depth);
                                        for (let t = 0, i = E.length; t < i; t++)
                                            if (x = E[t],
                                            s.format !== Se)
                                                if (null !== f)
                                                    if (S) {
                                                        if (T)
                                                            if (s.layerUpdates.size > 0) {
                                                                const i = Xo(x.width, x.height, s.format, s.type);
                                                                for (const r of s.layerUpdates) {
                                                                    const a = x.data.subarray(r * i / x.data.BYTES_PER_ELEMENT, (r + 1) * i / x.data.BYTES_PER_ELEMENT);
                                                                    n.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY, t, 0, 0, r, x.width, x.height, 1, f, a)
                                                                }
                                                                s.clearLayerUpdates()
                                                            } else
                                                                n.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY, t, 0, 0, 0, x.width, x.height, p.depth, f, x.data)
                                                    } else
                                                        n.compressedTexImage3D(e.TEXTURE_2D_ARRAY, t, k, x.width, x.height, p.depth, 0, x.data, 0, 0);
                                                else
                                                    console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                                            else
                                                S ? T && n.texSubImage3D(e.TEXTURE_2D_ARRAY, t, 0, 0, 0, x.width, x.height, p.depth, f, w, x.data) : n.texImage3D(e.TEXTURE_2D_ARRAY, t, k, x.width, x.height, p.depth, 0, f, w, x.data)
                                    } else {
                                        S && M && n.texStorage2D(e.TEXTURE_2D, C, k, E[0].width, E[0].height);
                                        for (let t = 0, i = E.length; t < i; t++)
                                            x = E[t],
                                                s.format !== Se ? null !== f ? S ? T && n.compressedTexSubImage2D(e.TEXTURE_2D, t, 0, 0, x.width, x.height, f, x.data) : n.compressedTexImage2D(e.TEXTURE_2D, t, k, x.width, x.height, 0, x.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : S ? T && n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, x.width, x.height, f, w, x.data) : n.texImage2D(e.TEXTURE_2D, t, k, x.width, x.height, 0, f, w, x.data)
                                    }
                                else if (s.isDataArrayTexture)
                                    if (S) {
                                        if (M && n.texStorage3D(e.TEXTURE_2D_ARRAY, C, k, p.width, p.height, p.depth),
                                            T)
                                            if (s.layerUpdates.size > 0) {
                                                const t = Xo(p.width, p.height, s.format, s.type);
                                                for (const i of s.layerUpdates) {
                                                    const r = p.data.subarray(i * t / p.data.BYTES_PER_ELEMENT, (i + 1) * t / p.data.BYTES_PER_ELEMENT);
                                                    n.texSubImage3D(e.TEXTURE_2D_ARRAY, 0, 0, 0, i, p.width, p.height, 1, f, w, r)
                                                }
                                                s.clearLayerUpdates()
                                            } else
                                                n.texSubImage3D(e.TEXTURE_2D_ARRAY, 0, 0, 0, 0, p.width, p.height, p.depth, f, w, p.data)
                                    } else
                                        n.texImage3D(e.TEXTURE_2D_ARRAY, 0, k, p.width, p.height, p.depth, 0, f, w, p.data);
                                else if (s.isData3DTexture)
                                    S ? (M && n.texStorage3D(e.TEXTURE_3D, C, k, p.width, p.height, p.depth),
                                    T && n.texSubImage3D(e.TEXTURE_3D, 0, 0, 0, 0, p.width, p.height, p.depth, f, w, p.data)) : n.texImage3D(e.TEXTURE_3D, 0, k, p.width, p.height, p.depth, 0, f, w, p.data);
                                else if (s.isFramebufferTexture) {
                                    if (M)
                                        if (S)
                                            n.texStorage2D(e.TEXTURE_2D, C, k, p.width, p.height);
                                        else {
                                            let t = p.width
                                                , i = p.height;
                                            for (let r = 0; r < C; r++)
                                                n.texImage2D(e.TEXTURE_2D, r, k, t, i, 0, f, w, null),
                                                    t >>= 1,
                                                    i >>= 1
                                        }
                                } else if (E.length > 0) {
                                    if (S && M) {
                                        const t = W(E[0]);
                                        n.texStorage2D(e.TEXTURE_2D, C, k, t.width, t.height)
                                    }
                                    for (let t = 0, i = E.length; t < i; t++)
                                        x = E[t],
                                            S ? T && n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, f, w, x) : n.texImage2D(e.TEXTURE_2D, t, k, f, w, x);
                                    s.generateMipmaps = !1
                                } else if (S) {
                                    if (M) {
                                        const t = W(p);
                                        n.texStorage2D(e.TEXTURE_2D, C, k, t.width, t.height)
                                    }
                                    T && n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, f, w, p)
                                } else
                                    n.texImage2D(e.TEXTURE_2D, 0, k, f, w, p);
                                g(s) && v(l),
                                    d.__version = h.version,
                                s.onUpdate && s.onUpdate(s)
                            }
                            t.__version = s.version
                        }
                        function L(t, r, s, l, c, h) {
                            const d = a.convert(s.format, s.colorSpace)
                                , u = a.convert(s.type)
                                , p = A(s.internalFormat, d, u, s.colorSpace)
                                , f = i.get(r)
                                , m = i.get(s);
                            if (m.__renderTarget = r,
                                !f.__hasExternalTextures) {
                                const t = Math.max(1, r.width >> h)
                                    , i = Math.max(1, r.height >> h);
                                c === e.TEXTURE_3D || c === e.TEXTURE_2D_ARRAY ? n.texImage3D(c, h, p, t, i, r.depth, 0, d, u, null) : n.texImage2D(c, h, p, t, i, 0, d, u, null)
                            }
                            n.bindFramebuffer(e.FRAMEBUFFER, t),
                                O(r) ? o.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, l, c, m.__webglTexture, 0, z(r)) : (c === e.TEXTURE_2D || c >= e.TEXTURE_CUBE_MAP_POSITIVE_X && c <= e.TEXTURE_CUBE_MAP_NEGATIVE_Z) && e.framebufferTexture2D(e.FRAMEBUFFER, l, c, m.__webglTexture, h),
                                n.bindFramebuffer(e.FRAMEBUFFER, null)
                        }
                        function N(t, n, i) {
                            if (e.bindRenderbuffer(e.RENDERBUFFER, t),
                                n.depthBuffer) {
                                const r = n.depthTexture
                                    , a = r && r.isDepthTexture ? r.type : null
                                    , s = y(n.stencilBuffer, a)
                                    , l = n.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT
                                    , c = z(n);
                                O(n) ? o.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, c, s, n.width, n.height) : i ? e.renderbufferStorageMultisample(e.RENDERBUFFER, c, s, n.width, n.height) : e.renderbufferStorage(e.RENDERBUFFER, s, n.width, n.height),
                                    e.framebufferRenderbuffer(e.FRAMEBUFFER, l, e.RENDERBUFFER, t)
                            } else {
                                const t = n.textures;
                                for (let r = 0; r < t.length; r++) {
                                    const s = t[r]
                                        , l = a.convert(s.format, s.colorSpace)
                                        , c = a.convert(s.type)
                                        , h = A(s.internalFormat, l, c, s.colorSpace)
                                        , d = z(n);
                                    i && !1 === O(n) ? e.renderbufferStorageMultisample(e.RENDERBUFFER, d, h, n.width, n.height) : O(n) ? o.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, d, h, n.width, n.height) : e.renderbufferStorage(e.RENDERBUFFER, h, n.width, n.height)
                                }
                            }
                            e.bindRenderbuffer(e.RENDERBUFFER, null)
                        }
                        function D(t) {
                            const r = i.get(t)
                                , a = !0 === t.isWebGLCubeRenderTarget;
                            if (r.__boundDepthTexture !== t.depthTexture) {
                                const e = t.depthTexture;
                                if (r.__depthDisposeCallback && r.__depthDisposeCallback(),
                                    e) {
                                    const t = () => {
                                            delete r.__boundDepthTexture,
                                                delete r.__depthDisposeCallback,
                                                e.removeEventListener("dispose", t)
                                        }
                                    ;
                                    e.addEventListener("dispose", t),
                                        r.__depthDisposeCallback = t
                                }
                                r.__boundDepthTexture = e
                            }
                            if (t.depthTexture && !r.__autoAllocateDepthBuffer) {
                                if (a)
                                    throw new Error("target.depthTexture not supported in Cube render targets");
                                !function(t, r) {
                                    if (r && r.isWebGLCubeRenderTarget)
                                        throw new Error("Depth Texture with cube render targets is not supported");
                                    if (n.bindFramebuffer(e.FRAMEBUFFER, t),
                                    !r.depthTexture || !r.depthTexture.isDepthTexture)
                                        throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                                    const a = i.get(r.depthTexture);
                                    a.__renderTarget = r,
                                    a.__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width,
                                        r.depthTexture.image.height = r.height,
                                        r.depthTexture.needsUpdate = !0),
                                        M(r.depthTexture, 0);
                                    const s = a.__webglTexture
                                        , l = z(r);
                                    if (r.depthTexture.format === Me)
                                        O(r) ? o.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, s, 0, l) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, s, 0);
                                    else {
                                        if (r.depthTexture.format !== Te)
                                            throw new Error("Unknown depthTexture format");
                                        O(r) ? o.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, s, 0, l) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, s, 0)
                                    }
                                }(r.__webglFramebuffer, t)
                            } else if (a) {
                                r.__webglDepthbuffer = [];
                                for (let i = 0; i < 6; i++)
                                    if (n.bindFramebuffer(e.FRAMEBUFFER, r.__webglFramebuffer[i]),
                                    void 0 === r.__webglDepthbuffer[i])
                                        r.__webglDepthbuffer[i] = e.createRenderbuffer(),
                                            N(r.__webglDepthbuffer[i], t, !1);
                                    else {
                                        const n = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT
                                            , a = r.__webglDepthbuffer[i];
                                        e.bindRenderbuffer(e.RENDERBUFFER, a),
                                            e.framebufferRenderbuffer(e.FRAMEBUFFER, n, e.RENDERBUFFER, a)
                                    }
                            } else if (n.bindFramebuffer(e.FRAMEBUFFER, r.__webglFramebuffer),
                            void 0 === r.__webglDepthbuffer)
                                r.__webglDepthbuffer = e.createRenderbuffer(),
                                    N(r.__webglDepthbuffer, t, !1);
                            else {
                                const n = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT
                                    , i = r.__webglDepthbuffer;
                                e.bindRenderbuffer(e.RENDERBUFFER, i),
                                    e.framebufferRenderbuffer(e.FRAMEBUFFER, n, e.RENDERBUFFER, i)
                            }
                            n.bindFramebuffer(e.FRAMEBUFFER, null)
                        }
                        const B = []
                            , U = [];
                        function z(e) {
                            return Math.min(r.maxSamples, e.samples)
                        }
                        function O(e) {
                            const n = i.get(e);
                            return e.samples > 0 && !0 === t.has("WEBGL_multisampled_render_to_texture") && !1 !== n.__useRenderToTexture
                        }
                        function F(e, t) {
                            const n = e.colorSpace
                                , i = e.format
                                , r = e.type;
                            return !0 === e.isCompressedTexture || !0 === e.isVideoTexture || n !== vt && n !== mt && (nn.getTransfer(n) === At ? i === Se && r === pe || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", n)),
                                t
                        }
                        function W(e) {
                            return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement ? (c.width = e.naturalWidth || e.width,
                                c.height = e.naturalHeight || e.height) : "undefined" != typeof VideoFrame && e instanceof VideoFrame ? (c.width = e.displayWidth,
                                c.height = e.displayHeight) : (c.width = e.width,
                                c.height = e.height),
                                c
                        }
                        this.allocateTextureUnit = function() {
                            const e = S;
                            return e >= r.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + r.maxTextures),
                                S += 1,
                                e
                        }
                            ,
                            this.resetTextureUnits = function() {
                                S = 0
                            }
                            ,
                            this.setTexture2D = M,
                            this.setTexture2DArray = function(t, r) {
                                const a = i.get(t);
                                t.version > 0 && a.__version !== t.version ? R(a, t, r) : n.bindTexture(e.TEXTURE_2D_ARRAY, a.__webglTexture, e.TEXTURE0 + r)
                            }
                            ,
                            this.setTexture3D = function(t, r) {
                                const a = i.get(t);
                                t.version > 0 && a.__version !== t.version ? R(a, t, r) : n.bindTexture(e.TEXTURE_3D, a.__webglTexture, e.TEXTURE0 + r)
                            }
                            ,
                            this.setTextureCube = function(t, s) {
                                const o = i.get(t);
                                t.version > 0 && o.__version !== t.version ? function(t, s, o) {
                                    if (6 !== s.image.length)
                                        return;
                                    const l = P(t, s)
                                        , c = s.source;
                                    n.bindTexture(e.TEXTURE_CUBE_MAP, t.__webglTexture, e.TEXTURE0 + o);
                                    const h = i.get(c);
                                    if (c.version !== h.__version || !0 === l) {
                                        n.activeTexture(e.TEXTURE0 + o);
                                        const t = nn.getPrimaries(nn.workingColorSpace)
                                            , i = s.colorSpace === mt ? null : nn.getPrimaries(s.colorSpace)
                                            , d = s.colorSpace === mt || t === i ? e.NONE : e.BROWSER_DEFAULT_WEBGL;
                                        e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, s.flipY),
                                            e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, s.premultiplyAlpha),
                                            e.pixelStorei(e.UNPACK_ALIGNMENT, s.unpackAlignment),
                                            e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, d);
                                        const u = s.isCompressedTexture || s.image[0].isCompressedTexture
                                            , p = s.image[0] && s.image[0].isDataTexture
                                            , f = [];
                                        for (let e = 0; e < 6; e++)
                                            f[e] = u || p ? p ? s.image[e].image : s.image[e] : m(s.image[e], !0, r.maxCubemapSize),
                                                f[e] = F(s, f[e]);
                                        const w = f[0]
                                            , y = a.convert(s.format, s.colorSpace)
                                            , x = a.convert(s.type)
                                            , k = A(s.internalFormat, y, x, s.colorSpace)
                                            , E = !0 !== s.isVideoTexture
                                            , S = void 0 === h.__version || !0 === l
                                            , M = c.dataReady;
                                        let T, C = b(s, w);
                                        if (I(e.TEXTURE_CUBE_MAP, s),
                                            u) {
                                            E && S && n.texStorage2D(e.TEXTURE_CUBE_MAP, C, k, w.width, w.height);
                                            for (let t = 0; t < 6; t++) {
                                                T = f[t].mipmaps;
                                                for (let i = 0; i < T.length; i++) {
                                                    const r = T[i];
                                                    s.format !== Se ? null !== y ? E ? M && n.compressedTexSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i, 0, 0, r.width, r.height, y, r.data) : n.compressedTexImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i, k, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : E ? M && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i, 0, 0, r.width, r.height, y, x, r.data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i, k, r.width, r.height, 0, y, x, r.data)
                                                }
                                            }
                                        } else {
                                            if (T = s.mipmaps,
                                            E && S) {
                                                T.length > 0 && C++;
                                                const t = W(f[0]);
                                                n.texStorage2D(e.TEXTURE_CUBE_MAP, C, k, t.width, t.height)
                                            }
                                            for (let t = 0; t < 6; t++)
                                                if (p) {
                                                    E ? M && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, 0, 0, f[t].width, f[t].height, y, x, f[t].data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, k, f[t].width, f[t].height, 0, y, x, f[t].data);
                                                    for (let i = 0; i < T.length; i++) {
                                                        const r = T[i].image[t].image;
                                                        E ? M && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, 0, 0, r.width, r.height, y, x, r.data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, k, r.width, r.height, 0, y, x, r.data)
                                                    }
                                                } else {
                                                    E ? M && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, 0, 0, y, x, f[t]) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, k, y, x, f[t]);
                                                    for (let i = 0; i < T.length; i++) {
                                                        const r = T[i];
                                                        E ? M && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, 0, 0, y, x, r.image[t]) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, k, y, x, r.image[t])
                                                    }
                                                }
                                        }
                                        g(s) && v(e.TEXTURE_CUBE_MAP),
                                            h.__version = c.version,
                                        s.onUpdate && s.onUpdate(s)
                                    }
                                    t.__version = s.version
                                }(o, t, s) : n.bindTexture(e.TEXTURE_CUBE_MAP, o.__webglTexture, e.TEXTURE0 + s)
                            }
                            ,
                            this.rebindTextures = function(t, n, r) {
                                const a = i.get(t);
                                void 0 !== n && L(a.__webglFramebuffer, t, t.texture, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, 0),
                                void 0 !== r && D(t)
                            }
                            ,
                            this.setupRenderTarget = function(t) {
                                const r = t.texture
                                    , o = i.get(t)
                                    , l = i.get(r);
                                t.addEventListener("dispose", k);
                                const c = t.textures
                                    , h = !0 === t.isWebGLCubeRenderTarget
                                    , d = c.length > 1;
                                if (d || (void 0 === l.__webglTexture && (l.__webglTexture = e.createTexture()),
                                    l.__version = r.version,
                                    s.memory.textures++),
                                    h) {
                                    o.__webglFramebuffer = [];
                                    for (let t = 0; t < 6; t++)
                                        if (r.mipmaps && r.mipmaps.length > 0) {
                                            o.__webglFramebuffer[t] = [];
                                            for (let n = 0; n < r.mipmaps.length; n++)
                                                o.__webglFramebuffer[t][n] = e.createFramebuffer()
                                        } else
                                            o.__webglFramebuffer[t] = e.createFramebuffer()
                                } else {
                                    if (r.mipmaps && r.mipmaps.length > 0) {
                                        o.__webglFramebuffer = [];
                                        for (let t = 0; t < r.mipmaps.length; t++)
                                            o.__webglFramebuffer[t] = e.createFramebuffer()
                                    } else
                                        o.__webglFramebuffer = e.createFramebuffer();
                                    if (d)
                                        for (let t = 0, n = c.length; t < n; t++) {
                                            const n = i.get(c[t]);
                                            void 0 === n.__webglTexture && (n.__webglTexture = e.createTexture(),
                                                s.memory.textures++)
                                        }
                                    if (t.samples > 0 && !1 === O(t)) {
                                        o.__webglMultisampledFramebuffer = e.createFramebuffer(),
                                            o.__webglColorRenderbuffer = [],
                                            n.bindFramebuffer(e.FRAMEBUFFER, o.__webglMultisampledFramebuffer);
                                        for (let n = 0; n < c.length; n++) {
                                            const i = c[n];
                                            o.__webglColorRenderbuffer[n] = e.createRenderbuffer(),
                                                e.bindRenderbuffer(e.RENDERBUFFER, o.__webglColorRenderbuffer[n]);
                                            const r = a.convert(i.format, i.colorSpace)
                                                , s = a.convert(i.type)
                                                , l = A(i.internalFormat, r, s, i.colorSpace, !0 === t.isXRRenderTarget)
                                                , h = z(t);
                                            e.renderbufferStorageMultisample(e.RENDERBUFFER, h, l, t.width, t.height),
                                                e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + n, e.RENDERBUFFER, o.__webglColorRenderbuffer[n])
                                        }
                                        e.bindRenderbuffer(e.RENDERBUFFER, null),
                                        t.depthBuffer && (o.__webglDepthRenderbuffer = e.createRenderbuffer(),
                                            N(o.__webglDepthRenderbuffer, t, !0)),
                                            n.bindFramebuffer(e.FRAMEBUFFER, null)
                                    }
                                }
                                if (h) {
                                    n.bindTexture(e.TEXTURE_CUBE_MAP, l.__webglTexture),
                                        I(e.TEXTURE_CUBE_MAP, r);
                                    for (let n = 0; n < 6; n++)
                                        if (r.mipmaps && r.mipmaps.length > 0)
                                            for (let i = 0; i < r.mipmaps.length; i++)
                                                L(o.__webglFramebuffer[n][i], t, r, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + n, i);
                                        else
                                            L(o.__webglFramebuffer[n], t, r, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + n, 0);
                                    g(r) && v(e.TEXTURE_CUBE_MAP),
                                        n.unbindTexture()
                                } else if (d) {
                                    for (let r = 0, a = c.length; r < a; r++) {
                                        const a = c[r]
                                            , s = i.get(a);
                                        n.bindTexture(e.TEXTURE_2D, s.__webglTexture),
                                            I(e.TEXTURE_2D, a),
                                            L(o.__webglFramebuffer, t, a, e.COLOR_ATTACHMENT0 + r, e.TEXTURE_2D, 0),
                                        g(a) && v(e.TEXTURE_2D)
                                    }
                                    n.unbindTexture()
                                } else {
                                    let i = e.TEXTURE_2D;
                                    if ((t.isWebGL3DRenderTarget || t.isWebGLArrayRenderTarget) && (i = t.isWebGL3DRenderTarget ? e.TEXTURE_3D : e.TEXTURE_2D_ARRAY),
                                        n.bindTexture(i, l.__webglTexture),
                                        I(i, r),
                                    r.mipmaps && r.mipmaps.length > 0)
                                        for (let n = 0; n < r.mipmaps.length; n++)
                                            L(o.__webglFramebuffer[n], t, r, e.COLOR_ATTACHMENT0, i, n);
                                    else
                                        L(o.__webglFramebuffer, t, r, e.COLOR_ATTACHMENT0, i, 0);
                                    g(r) && v(i),
                                        n.unbindTexture()
                                }
                                t.depthBuffer && D(t)
                            }
                            ,
                            this.updateRenderTargetMipmap = function(e) {
                                const t = e.textures;
                                for (let r = 0, a = t.length; r < a; r++) {
                                    const a = t[r];
                                    if (g(a)) {
                                        const t = w(e)
                                            , r = i.get(a).__webglTexture;
                                        n.bindTexture(t, r),
                                            v(t),
                                            n.unbindTexture()
                                    }
                                }
                            }
                            ,
                            this.updateMultisampleRenderTarget = function(t) {
                                if (t.samples > 0)
                                    if (!1 === O(t)) {
                                        const r = t.textures
                                            , a = t.width
                                            , s = t.height;
                                        let o = e.COLOR_BUFFER_BIT;
                                        const c = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT
                                            , h = i.get(t)
                                            , d = r.length > 1;
                                        if (d)
                                            for (let t = 0; t < r.length; t++)
                                                n.bindFramebuffer(e.FRAMEBUFFER, h.__webglMultisampledFramebuffer),
                                                    e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.RENDERBUFFER, null),
                                                    n.bindFramebuffer(e.FRAMEBUFFER, h.__webglFramebuffer),
                                                    e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.TEXTURE_2D, null, 0);
                                        n.bindFramebuffer(e.READ_FRAMEBUFFER, h.__webglMultisampledFramebuffer),
                                            n.bindFramebuffer(e.DRAW_FRAMEBUFFER, h.__webglFramebuffer);
                                        for (let n = 0; n < r.length; n++) {
                                            if (t.resolveDepthBuffer && (t.depthBuffer && (o |= e.DEPTH_BUFFER_BIT),
                                            t.stencilBuffer && t.resolveStencilBuffer && (o |= e.STENCIL_BUFFER_BIT)),
                                                d) {
                                                e.framebufferRenderbuffer(e.READ_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.RENDERBUFFER, h.__webglColorRenderbuffer[n]);
                                                const t = i.get(r[n]).__webglTexture;
                                                e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0)
                                            }
                                            e.blitFramebuffer(0, 0, a, s, 0, 0, a, s, o, e.NEAREST),
                                            !0 === l && (B.length = 0,
                                                U.length = 0,
                                                B.push(e.COLOR_ATTACHMENT0 + n),
                                            t.depthBuffer && !1 === t.resolveDepthBuffer && (B.push(c),
                                                U.push(c),
                                                e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, U)),
                                                e.invalidateFramebuffer(e.READ_FRAMEBUFFER, B))
                                        }
                                        if (n.bindFramebuffer(e.READ_FRAMEBUFFER, null),
                                            n.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
                                            d)
                                            for (let t = 0; t < r.length; t++) {
                                                n.bindFramebuffer(e.FRAMEBUFFER, h.__webglMultisampledFramebuffer),
                                                    e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.RENDERBUFFER, h.__webglColorRenderbuffer[t]);
                                                const a = i.get(r[t]).__webglTexture;
                                                n.bindFramebuffer(e.FRAMEBUFFER, h.__webglFramebuffer),
                                                    e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.TEXTURE_2D, a, 0)
                                            }
                                        n.bindFramebuffer(e.DRAW_FRAMEBUFFER, h.__webglMultisampledFramebuffer)
                                    } else if (t.depthBuffer && !1 === t.resolveDepthBuffer && l) {
                                        const n = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT;
                                        e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, [n])
                                    }
                            }
                            ,
                            this.setupDepthRenderbuffer = D,
                            this.setupFrameBufferTexture = L,
                            this.useMultisampledRTT = O
                    }
                    function Hd(e, t) {
                        return {
                            convert: function(n, i="") {
                                let r;
                                const a = nn.getTransfer(i);
                                if (n === pe)
                                    return e.UNSIGNED_BYTE;
                                if (n === be)
                                    return e.UNSIGNED_SHORT_4_4_4_4;
                                if (n === xe)
                                    return e.UNSIGNED_SHORT_5_5_5_1;
                                if (n === Ee)
                                    return e.UNSIGNED_INT_5_9_9_9_REV;
                                if (n === fe)
                                    return e.BYTE;
                                if (n === me)
                                    return e.SHORT;
                                if (n === ge)
                                    return e.UNSIGNED_SHORT;
                                if (n === ve)
                                    return e.INT;
                                if (n === we)
                                    return e.UNSIGNED_INT;
                                if (n === Ae)
                                    return e.FLOAT;
                                if (n === ye)
                                    return e.HALF_FLOAT;
                                if (1021 === n)
                                    return e.ALPHA;
                                if (1022 === n)
                                    return e.RGB;
                                if (n === Se)
                                    return e.RGBA;
                                if (1024 === n)
                                    return e.LUMINANCE;
                                if (1025 === n)
                                    return e.LUMINANCE_ALPHA;
                                if (n === Me)
                                    return e.DEPTH_COMPONENT;
                                if (n === Te)
                                    return e.DEPTH_STENCIL;
                                if (n === Ce)
                                    return e.RED;
                                if (n === _e)
                                    return e.RED_INTEGER;
                                if (1030 === n)
                                    return e.RG;
                                if (n === Ie)
                                    return e.RG_INTEGER;
                                if (n === Pe)
                                    return e.RGBA_INTEGER;
                                if (n === Re || n === Le || n === Ne || n === De)
                                    if (a === At) {
                                        if (r = t.get("WEBGL_compressed_texture_s3tc_srgb"),
                                        null === r)
                                            return null;
                                        if (n === Re)
                                            return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                                        if (n === Le)
                                            return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                                        if (n === Ne)
                                            return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                                        if (n === De)
                                            return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                                    } else {
                                        if (r = t.get("WEBGL_compressed_texture_s3tc"),
                                        null === r)
                                            return null;
                                        if (n === Re)
                                            return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
                                        if (n === Le)
                                            return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                                        if (n === Ne)
                                            return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                                        if (n === De)
                                            return r.COMPRESSED_RGBA_S3TC_DXT5_EXT
                                    }
                                if (n === Be || n === Ue || n === ze || n === Oe) {
                                    if (r = t.get("WEBGL_compressed_texture_pvrtc"),
                                    null === r)
                                        return null;
                                    if (n === Be)
                                        return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                                    if (n === Ue)
                                        return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                                    if (n === ze)
                                        return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                                    if (n === Oe)
                                        return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                                }
                                if (n === Fe || n === We || n === He) {
                                    if (r = t.get("WEBGL_compressed_texture_etc"),
                                    null === r)
                                        return null;
                                    if (n === Fe || n === We)
                                        return a === At ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
                                    if (n === He)
                                        return a === At ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC
                                }
                                if (n === Ve || n === Ge || n === je || n === Qe || n === Ye || n === qe || n === Ke || n === Xe || n === Ze || n === Je || n === $e || n === et || n === tt || n === nt) {
                                    if (r = t.get("WEBGL_compressed_texture_astc"),
                                    null === r)
                                        return null;
                                    if (n === Ve)
                                        return a === At ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
                                    if (n === Ge)
                                        return a === At ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
                                    if (n === je)
                                        return a === At ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
                                    if (n === Qe)
                                        return a === At ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
                                    if (n === Ye)
                                        return a === At ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
                                    if (n === qe)
                                        return a === At ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
                                    if (n === Ke)
                                        return a === At ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
                                    if (n === Xe)
                                        return a === At ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
                                    if (n === Ze)
                                        return a === At ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
                                    if (n === Je)
                                        return a === At ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
                                    if (n === $e)
                                        return a === At ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
                                    if (n === et)
                                        return a === At ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
                                    if (n === tt)
                                        return a === At ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
                                    if (n === nt)
                                        return a === At ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR
                                }
                                if (n === it || n === rt || n === at) {
                                    if (r = t.get("EXT_texture_compression_bptc"),
                                    null === r)
                                        return null;
                                    if (n === it)
                                        return a === At ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                                    if (n === rt)
                                        return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                                    if (n === at)
                                        return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
                                }
                                if (36283 === n || n === st || n === ot || n === lt) {
                                    if (r = t.get("EXT_texture_compression_rgtc"),
                                    null === r)
                                        return null;
                                    if (n === it)
                                        return r.COMPRESSED_RED_RGTC1_EXT;
                                    if (n === st)
                                        return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                                    if (n === ot)
                                        return r.COMPRESSED_RED_GREEN_RGTC2_EXT;
                                    if (n === lt)
                                        return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
                                }
                                return n === ke ? e.UNSIGNED_INT_24_8 : void 0 !== e[n] ? e[n] : null
                            }
                        }
                    }
                    class Vd {
                        constructor() {
                            this.texture = null,
                                this.mesh = null,
                                this.depthNear = 0,
                                this.depthFar = 0
                        }
                        init(e, t, n) {
                            if (null === this.texture) {
                                const i = new un;
                                e.properties.get(i).__webglTexture = t.texture,
                                t.depthNear === n.depthNear && t.depthFar === n.depthFar || (this.depthNear = t.depthNear,
                                    this.depthFar = t.depthFar),
                                    this.texture = i
                            }
                        }
                        getMesh(e) {
                            if (null !== this.texture && null === this.mesh) {
                                const t = e.cameras[0].viewport
                                    , n = new Sr({
                                    vertexShader: "\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}",
                                    fragmentShader: "\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n\t}\n\n}",
                                    uniforms: {
                                        depthColor: {
                                            value: this.texture
                                        },
                                        depthWidth: {
                                            value: t.z
                                        },
                                        depthHeight: {
                                            value: t.w
                                        }
                                    }
                                });
                                this.mesh = new wr(new Ds(20,20),n)
                            }
                            return this.mesh
                        }
                        reset() {
                            this.texture = null,
                                this.mesh = null
                        }
                        getDepthTexture() {
                            return this.texture
                        }
                    }
                    class Gd extends Lt {
                        constructor(e, t) {
                            super();
                            const n = this;
                            let i = null
                                , r = 1
                                , a = null
                                , s = "local-floor"
                                , o = 1
                                , l = null
                                , c = null
                                , h = null
                                , d = null
                                , u = null
                                , p = null;
                            const f = new Vd
                                , m = t.getContextAttributes();
                            let g = null
                                , v = null;
                            const w = []
                                , A = []
                                , y = new jt;
                            let b = null;
                            const x = new Ir;
                            x.viewport = new pn;
                            const k = new Ir;
                            k.viewport = new pn;
                            const E = [x, k]
                                , S = new Bo;
                            let M = null
                                , T = null;
                            function C(e) {
                                const t = A.indexOf(e.inputSource);
                                if (-1 === t)
                                    return;
                                const n = w[t];
                                void 0 !== n && (n.update(e.inputSource, e.frame, l || a),
                                    n.dispatchEvent({
                                        type: e.type,
                                        data: e.inputSource
                                    }))
                            }
                            function _() {
                                i.removeEventListener("select", C),
                                    i.removeEventListener("selectstart", C),
                                    i.removeEventListener("selectend", C),
                                    i.removeEventListener("squeeze", C),
                                    i.removeEventListener("squeezestart", C),
                                    i.removeEventListener("squeezeend", C),
                                    i.removeEventListener("end", _),
                                    i.removeEventListener("inputsourceschange", I);
                                for (let e = 0; e < w.length; e++) {
                                    const t = A[e];
                                    null !== t && (A[e] = null,
                                        w[e].disconnect(t))
                                }
                                M = null,
                                    T = null,
                                    f.reset(),
                                    e.setRenderTarget(g),
                                    u = null,
                                    d = null,
                                    h = null,
                                    i = null,
                                    v = null,
                                    D.stop(),
                                    n.isPresenting = !1,
                                    e.setPixelRatio(b),
                                    e.setSize(y.width, y.height, !1),
                                    n.dispatchEvent({
                                        type: "sessionend"
                                    })
                            }
                            function I(e) {
                                for (let t = 0; t < e.removed.length; t++) {
                                    const n = e.removed[t]
                                        , i = A.indexOf(n);
                                    i >= 0 && (A[i] = null,
                                        w[i].disconnect(n))
                                }
                                for (let t = 0; t < e.added.length; t++) {
                                    const n = e.added[t];
                                    let i = A.indexOf(n);
                                    if (-1 === i) {
                                        for (let e = 0; e < w.length; e++) {
                                            if (e >= A.length) {
                                                A.push(n),
                                                    i = e;
                                                break
                                            }
                                            if (null === A[e]) {
                                                A[e] = n,
                                                    i = e;
                                                break
                                            }
                                        }
                                        if (-1 === i)
                                            break
                                    }
                                    const r = w[i];
                                    r && r.connect(n)
                                }
                            }
                            this.cameraAutoUpdate = !0,
                                this.enabled = !1,
                                this.isPresenting = !1,
                                this.getController = function(e) {
                                    let t = w[e];
                                    return void 0 === t && (t = new Ur,
                                        w[e] = t),
                                        t.getTargetRaySpace()
                                }
                                ,
                                this.getControllerGrip = function(e) {
                                    let t = w[e];
                                    return void 0 === t && (t = new Ur,
                                        w[e] = t),
                                        t.getGripSpace()
                                }
                                ,
                                this.getHand = function(e) {
                                    let t = w[e];
                                    return void 0 === t && (t = new Ur,
                                        w[e] = t),
                                        t.getHandSpace()
                                }
                                ,
                                this.setFramebufferScaleFactor = function(e) {
                                    r = e,
                                    !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                                }
                                ,
                                this.setReferenceSpaceType = function(e) {
                                    s = e,
                                    !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                                }
                                ,
                                this.getReferenceSpace = function() {
                                    return l || a
                                }
                                ,
                                this.setReferenceSpace = function(e) {
                                    l = e
                                }
                                ,
                                this.getBaseLayer = function() {
                                    return null !== d ? d : u
                                }
                                ,
                                this.getBinding = function() {
                                    return h
                                }
                                ,
                                this.getFrame = function() {
                                    return p
                                }
                                ,
                                this.getSession = function() {
                                    return i
                                }
                                ,
                                this.setSession = async function(c) {
                                    if (i = c,
                                    null !== i) {
                                        g = e.getRenderTarget(),
                                            i.addEventListener("select", C),
                                            i.addEventListener("selectstart", C),
                                            i.addEventListener("selectend", C),
                                            i.addEventListener("squeeze", C),
                                            i.addEventListener("squeezestart", C),
                                            i.addEventListener("squeezeend", C),
                                            i.addEventListener("end", _),
                                            i.addEventListener("inputsourceschange", I),
                                        !0 !== m.xrCompatible && await t.makeXRCompatible(),
                                            b = e.getPixelRatio(),
                                            e.getSize(y);
                                        if ("undefined" != typeof XRWebGLBinding && "createProjectionLayer"in XRWebGLBinding.prototype) {
                                            let n = null
                                                , a = null
                                                , s = null;
                                            m.depth && (s = m.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24,
                                                n = m.stencil ? Te : Me,
                                                a = m.stencil ? ke : we);
                                            const o = {
                                                colorFormat: t.RGBA8,
                                                depthFormat: s,
                                                scaleFactor: r
                                            };
                                            h = new XRWebGLBinding(i,t),
                                                d = h.createProjectionLayer(o),
                                                i.updateRenderState({
                                                    layers: [d]
                                                }),
                                                e.setPixelRatio(1),
                                                e.setSize(d.textureWidth, d.textureHeight, !1),
                                                v = new mn(d.textureWidth,d.textureHeight,{
                                                    format: Se,
                                                    type: pe,
                                                    depthTexture: new Wa(d.textureWidth,d.textureHeight,a,void 0,void 0,void 0,void 0,void 0,void 0,n),
                                                    stencilBuffer: m.stencil,
                                                    colorSpace: e.outputColorSpace,
                                                    samples: m.antialias ? 4 : 0,
                                                    resolveDepthBuffer: !1 === d.ignoreDepthValues,
                                                    resolveStencilBuffer: !1 === d.ignoreDepthValues
                                                })
                                        } else {
                                            const n = {
                                                antialias: m.antialias,
                                                alpha: !0,
                                                depth: m.depth,
                                                stencil: m.stencil,
                                                framebufferScaleFactor: r
                                            };
                                            u = new XRWebGLLayer(i,t,n),
                                                i.updateRenderState({
                                                    baseLayer: u
                                                }),
                                                e.setPixelRatio(1),
                                                e.setSize(u.framebufferWidth, u.framebufferHeight, !1),
                                                v = new mn(u.framebufferWidth,u.framebufferHeight,{
                                                    format: Se,
                                                    type: pe,
                                                    colorSpace: e.outputColorSpace,
                                                    stencilBuffer: m.stencil,
                                                    resolveDepthBuffer: !1 === u.ignoreDepthValues,
                                                    resolveStencilBuffer: !1 === u.ignoreDepthValues
                                                })
                                        }
                                        v.isXRRenderTarget = !0,
                                            this.setFoveation(o),
                                            l = null,
                                            a = await i.requestReferenceSpace(s),
                                            D.setContext(i),
                                            D.start(),
                                            n.isPresenting = !0,
                                            n.dispatchEvent({
                                                type: "sessionstart"
                                            })
                                    }
                                }
                                ,
                                this.getEnvironmentBlendMode = function() {
                                    if (null !== i)
                                        return i.environmentBlendMode
                                }
                                ,
                                this.getDepthTexture = function() {
                                    return f.getDepthTexture()
                                }
                            ;
                            const P = new An
                                , R = new An;
                            function L(e, t) {
                                null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix),
                                    e.matrixWorldInverse.copy(e.matrixWorld).invert()
                            }
                            this.updateCamera = function(e) {
                                if (null === i)
                                    return;
                                let t = e.near
                                    , n = e.far;
                                null !== f.texture && (f.depthNear > 0 && (t = f.depthNear),
                                f.depthFar > 0 && (n = f.depthFar)),
                                    S.near = k.near = x.near = t,
                                    S.far = k.far = x.far = n,
                                M === S.near && T === S.far || (i.updateRenderState({
                                    depthNear: S.near,
                                    depthFar: S.far
                                }),
                                    M = S.near,
                                    T = S.far),
                                    x.layers.mask = 2 | e.layers.mask,
                                    k.layers.mask = 4 | e.layers.mask,
                                    S.layers.mask = x.layers.mask | k.layers.mask;
                                const r = e.parent
                                    , a = S.cameras;
                                L(S, r);
                                for (let e = 0; e < a.length; e++)
                                    L(a[e], r);
                                2 === a.length ? function(e, t, n) {
                                    P.setFromMatrixPosition(t.matrixWorld),
                                        R.setFromMatrixPosition(n.matrixWorld);
                                    const i = P.distanceTo(R)
                                        , r = t.projectionMatrix.elements
                                        , a = n.projectionMatrix.elements
                                        , s = r[14] / (r[10] - 1)
                                        , o = r[14] / (r[10] + 1)
                                        , l = (r[9] + 1) / r[5]
                                        , c = (r[9] - 1) / r[5]
                                        , h = (r[8] - 1) / r[0]
                                        , d = (a[8] + 1) / a[0]
                                        , u = s * h
                                        , p = s * d
                                        , f = i / (-h + d)
                                        , m = f * -h;
                                    if (t.matrixWorld.decompose(e.position, e.quaternion, e.scale),
                                        e.translateX(m),
                                        e.translateZ(f),
                                        e.matrixWorld.compose(e.position, e.quaternion, e.scale),
                                        e.matrixWorldInverse.copy(e.matrixWorld).invert(),
                                    -1 === r[10])
                                        e.projectionMatrix.copy(t.projectionMatrix),
                                            e.projectionMatrixInverse.copy(t.projectionMatrixInverse);
                                    else {
                                        const t = s + f
                                            , n = o + f
                                            , r = u - m
                                            , a = p + (i - m)
                                            , h = l * o / n * t
                                            , d = c * o / n * t;
                                        e.projectionMatrix.makePerspective(r, a, h, d, t, n),
                                            e.projectionMatrixInverse.copy(e.projectionMatrix).invert()
                                    }
                                }(S, x, k) : S.projectionMatrix.copy(x.projectionMatrix),
                                    function(e, t, n) {
                                        null === n ? e.matrix.copy(t.matrixWorld) : (e.matrix.copy(n.matrixWorld),
                                            e.matrix.invert(),
                                            e.matrix.multiply(t.matrixWorld));
                                        e.matrix.decompose(e.position, e.quaternion, e.scale),
                                            e.updateMatrixWorld(!0),
                                            e.projectionMatrix.copy(t.projectionMatrix),
                                            e.projectionMatrixInverse.copy(t.projectionMatrixInverse),
                                        e.isPerspectiveCamera && (e.fov = 2 * Ut * Math.atan(1 / e.projectionMatrix.elements[5]),
                                            e.zoom = 1)
                                    }(e, S, r)
                            }
                                ,
                                this.getCamera = function() {
                                    return S
                                }
                                ,
                                this.getFoveation = function() {
                                    if (null !== d || null !== u)
                                        return o
                                }
                                ,
                                this.setFoveation = function(e) {
                                    o = e,
                                    null !== d && (d.fixedFoveation = e),
                                    null !== u && void 0 !== u.fixedFoveation && (u.fixedFoveation = e)
                                }
                                ,
                                this.hasDepthSensing = function() {
                                    return null !== f.texture
                                }
                                ,
                                this.getDepthSensingMesh = function() {
                                    return f.getMesh(S)
                                }
                            ;
                            let N = null;
                            const D = new pc;
                            D.setAnimationLoop((function(t, r) {
                                    if (c = r.getViewerPose(l || a),
                                        p = r,
                                    null !== c) {
                                        const t = c.views;
                                        null !== u && (e.setRenderTargetFramebuffer(v, u.framebuffer),
                                            e.setRenderTarget(v));
                                        let n = !1;
                                        t.length !== S.cameras.length && (S.cameras.length = 0,
                                            n = !0);
                                        for (let i = 0; i < t.length; i++) {
                                            const r = t[i];
                                            let a = null;
                                            if (null !== u)
                                                a = u.getViewport(r);
                                            else {
                                                const t = h.getViewSubImage(d, r);
                                                a = t.viewport,
                                                0 === i && (e.setRenderTargetTextures(v, t.colorTexture, d.ignoreDepthValues ? void 0 : t.depthStencilTexture),
                                                    e.setRenderTarget(v))
                                            }
                                            let s = E[i];
                                            void 0 === s && (s = new Ir,
                                                s.layers.enable(i),
                                                s.viewport = new pn,
                                                E[i] = s),
                                                s.matrix.fromArray(r.transform.matrix),
                                                s.matrix.decompose(s.position, s.quaternion, s.scale),
                                                s.projectionMatrix.fromArray(r.projectionMatrix),
                                                s.projectionMatrixInverse.copy(s.projectionMatrix).invert(),
                                                s.viewport.set(a.x, a.y, a.width, a.height),
                                            0 === i && (S.matrix.copy(s.matrix),
                                                S.matrix.decompose(S.position, S.quaternion, S.scale)),
                                            !0 === n && S.cameras.push(s)
                                        }
                                        const r = i.enabledFeatures;
                                        if (r && r.includes("depth-sensing") && "gpu-optimized" == i.depthUsage && h) {
                                            const n = h.getDepthInformation(t[0]);
                                            n && n.isValid && n.texture && f.init(e, n, i.renderState)
                                        }
                                    }
                                    for (let e = 0; e < w.length; e++) {
                                        const t = A[e]
                                            , n = w[e];
                                        null !== t && void 0 !== n && n.update(t, r, l || a)
                                    }
                                    N && N(t, r),
                                    r.detectedPlanes && n.dispatchEvent({
                                        type: "planesdetected",
                                        data: r
                                    }),
                                        p = null
                                }
                            )),
                                this.setAnimationLoop = function(e) {
                                    N = e
                                }
                                ,
                                this.dispose = function() {}
                        }
                    }
                    const jd = new ai
                        , Qd = new Kn;
                    function Yd(e, t) {
                        function n(e, t) {
                            !0 === e.matrixAutoUpdate && e.updateMatrix(),
                                t.value.copy(e.matrix)
                        }
                        function i(e, i) {
                            e.opacity.value = i.opacity,
                            i.color && e.diffuse.value.copy(i.color),
                            i.emissive && e.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity),
                            i.map && (e.map.value = i.map,
                                n(i.map, e.mapTransform)),
                            i.alphaMap && (e.alphaMap.value = i.alphaMap,
                                n(i.alphaMap, e.alphaMapTransform)),
                            i.bumpMap && (e.bumpMap.value = i.bumpMap,
                                n(i.bumpMap, e.bumpMapTransform),
                                e.bumpScale.value = i.bumpScale,
                            1 === i.side && (e.bumpScale.value *= -1)),
                            i.normalMap && (e.normalMap.value = i.normalMap,
                                n(i.normalMap, e.normalMapTransform),
                                e.normalScale.value.copy(i.normalScale),
                            1 === i.side && e.normalScale.value.negate()),
                            i.displacementMap && (e.displacementMap.value = i.displacementMap,
                                n(i.displacementMap, e.displacementMapTransform),
                                e.displacementScale.value = i.displacementScale,
                                e.displacementBias.value = i.displacementBias),
                            i.emissiveMap && (e.emissiveMap.value = i.emissiveMap,
                                n(i.emissiveMap, e.emissiveMapTransform)),
                            i.specularMap && (e.specularMap.value = i.specularMap,
                                n(i.specularMap, e.specularMapTransform)),
                            i.alphaTest > 0 && (e.alphaTest.value = i.alphaTest);
                            const r = t.get(i)
                                , a = r.envMap
                                , s = r.envMapRotation;
                            a && (e.envMap.value = a,
                                jd.copy(s),
                                jd.x *= -1,
                                jd.y *= -1,
                                jd.z *= -1,
                            a.isCubeTexture && !1 === a.isRenderTargetTexture && (jd.y *= -1,
                                jd.z *= -1),
                                e.envMapRotation.value.setFromMatrix4(Qd.makeRotationFromEuler(jd)),
                                e.flipEnvMap.value = a.isCubeTexture && !1 === a.isRenderTargetTexture ? -1 : 1,
                                e.reflectivity.value = i.reflectivity,
                                e.ior.value = i.ior,
                                e.refractionRatio.value = i.refractionRatio),
                            i.lightMap && (e.lightMap.value = i.lightMap,
                                e.lightMapIntensity.value = i.lightMapIntensity,
                                n(i.lightMap, e.lightMapTransform)),
                            i.aoMap && (e.aoMap.value = i.aoMap,
                                e.aoMapIntensity.value = i.aoMapIntensity,
                                n(i.aoMap, e.aoMapTransform))
                        }
                        return {
                            refreshFogUniforms: function(t, n) {
                                n.color.getRGB(t.fogColor.value, kr(e)),
                                    n.isFog ? (t.fogNear.value = n.near,
                                        t.fogFar.value = n.far) : n.isFogExp2 && (t.fogDensity.value = n.density)
                            },
                            refreshMaterialUniforms: function(e, r, a, s, o) {
                                r.isMeshBasicMaterial || r.isMeshLambertMaterial ? i(e, r) : r.isMeshToonMaterial ? (i(e, r),
                                    function(e, t) {
                                        t.gradientMap && (e.gradientMap.value = t.gradientMap)
                                    }(e, r)) : r.isMeshPhongMaterial ? (i(e, r),
                                    function(e, t) {
                                        e.specular.value.copy(t.specular),
                                            e.shininess.value = Math.max(t.shininess, 1e-4)
                                    }(e, r)) : r.isMeshStandardMaterial ? (i(e, r),
                                    function(e, t) {
                                        e.metalness.value = t.metalness,
                                        t.metalnessMap && (e.metalnessMap.value = t.metalnessMap,
                                            n(t.metalnessMap, e.metalnessMapTransform));
                                        e.roughness.value = t.roughness,
                                        t.roughnessMap && (e.roughnessMap.value = t.roughnessMap,
                                            n(t.roughnessMap, e.roughnessMapTransform));
                                        t.envMap && (e.envMapIntensity.value = t.envMapIntensity)
                                    }(e, r),
                                r.isMeshPhysicalMaterial && function(e, t, i) {
                                    e.ior.value = t.ior,
                                    t.sheen > 0 && (e.sheenColor.value.copy(t.sheenColor).multiplyScalar(t.sheen),
                                        e.sheenRoughness.value = t.sheenRoughness,
                                    t.sheenColorMap && (e.sheenColorMap.value = t.sheenColorMap,
                                        n(t.sheenColorMap, e.sheenColorMapTransform)),
                                    t.sheenRoughnessMap && (e.sheenRoughnessMap.value = t.sheenRoughnessMap,
                                        n(t.sheenRoughnessMap, e.sheenRoughnessMapTransform)));
                                    t.clearcoat > 0 && (e.clearcoat.value = t.clearcoat,
                                        e.clearcoatRoughness.value = t.clearcoatRoughness,
                                    t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap,
                                        n(t.clearcoatMap, e.clearcoatMapTransform)),
                                    t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap,
                                        n(t.clearcoatRoughnessMap, e.clearcoatRoughnessMapTransform)),
                                    t.clearcoatNormalMap && (e.clearcoatNormalMap.value = t.clearcoatNormalMap,
                                        n(t.clearcoatNormalMap, e.clearcoatNormalMapTransform),
                                        e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale),
                                    1 === t.side && e.clearcoatNormalScale.value.negate()));
                                    t.dispersion > 0 && (e.dispersion.value = t.dispersion);
                                    t.iridescence > 0 && (e.iridescence.value = t.iridescence,
                                        e.iridescenceIOR.value = t.iridescenceIOR,
                                        e.iridescenceThicknessMinimum.value = t.iridescenceThicknessRange[0],
                                        e.iridescenceThicknessMaximum.value = t.iridescenceThicknessRange[1],
                                    t.iridescenceMap && (e.iridescenceMap.value = t.iridescenceMap,
                                        n(t.iridescenceMap, e.iridescenceMapTransform)),
                                    t.iridescenceThicknessMap && (e.iridescenceThicknessMap.value = t.iridescenceThicknessMap,
                                        n(t.iridescenceThicknessMap, e.iridescenceThicknessMapTransform)));
                                    t.transmission > 0 && (e.transmission.value = t.transmission,
                                        e.transmissionSamplerMap.value = i.texture,
                                        e.transmissionSamplerSize.value.set(i.width, i.height),
                                    t.transmissionMap && (e.transmissionMap.value = t.transmissionMap,
                                        n(t.transmissionMap, e.transmissionMapTransform)),
                                        e.thickness.value = t.thickness,
                                    t.thicknessMap && (e.thicknessMap.value = t.thicknessMap,
                                        n(t.thicknessMap, e.thicknessMapTransform)),
                                        e.attenuationDistance.value = t.attenuationDistance,
                                        e.attenuationColor.value.copy(t.attenuationColor));
                                    t.anisotropy > 0 && (e.anisotropyVector.value.set(t.anisotropy * Math.cos(t.anisotropyRotation), t.anisotropy * Math.sin(t.anisotropyRotation)),
                                    t.anisotropyMap && (e.anisotropyMap.value = t.anisotropyMap,
                                        n(t.anisotropyMap, e.anisotropyMapTransform)));
                                    e.specularIntensity.value = t.specularIntensity,
                                        e.specularColor.value.copy(t.specularColor),
                                    t.specularColorMap && (e.specularColorMap.value = t.specularColorMap,
                                        n(t.specularColorMap, e.specularColorMapTransform));
                                    t.specularIntensityMap && (e.specularIntensityMap.value = t.specularIntensityMap,
                                        n(t.specularIntensityMap, e.specularIntensityMapTransform))
                                }(e, r, o)) : r.isMeshMatcapMaterial ? (i(e, r),
                                    function(e, t) {
                                        t.matcap && (e.matcap.value = t.matcap)
                                    }(e, r)) : r.isMeshDepthMaterial ? i(e, r) : r.isMeshDistanceMaterial ? (i(e, r),
                                    function(e, n) {
                                        const i = t.get(n).light;
                                        e.referencePosition.value.setFromMatrixPosition(i.matrixWorld),
                                            e.nearDistance.value = i.shadow.camera.near,
                                            e.farDistance.value = i.shadow.camera.far
                                    }(e, r)) : r.isMeshNormalMaterial ? i(e, r) : r.isLineBasicMaterial ? (function(e, t) {
                                    e.diffuse.value.copy(t.color),
                                        e.opacity.value = t.opacity,
                                    t.map && (e.map.value = t.map,
                                        n(t.map, e.mapTransform))
                                }(e, r),
                                r.isLineDashedMaterial && function(e, t) {
                                    e.dashSize.value = t.dashSize,
                                        e.totalSize.value = t.dashSize + t.gapSize,
                                        e.scale.value = t.scale
                                }(e, r)) : r.isPointsMaterial ? function(e, t, i, r) {
                                    e.diffuse.value.copy(t.color),
                                        e.opacity.value = t.opacity,
                                        e.size.value = t.size * i,
                                        e.scale.value = .5 * r,
                                    t.map && (e.map.value = t.map,
                                        n(t.map, e.uvTransform));
                                    t.alphaMap && (e.alphaMap.value = t.alphaMap,
                                        n(t.alphaMap, e.alphaMapTransform));
                                    t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest)
                                }(e, r, a, s) : r.isSpriteMaterial ? function(e, t) {
                                    e.diffuse.value.copy(t.color),
                                        e.opacity.value = t.opacity,
                                        e.rotation.value = t.rotation,
                                    t.map && (e.map.value = t.map,
                                        n(t.map, e.mapTransform));
                                    t.alphaMap && (e.alphaMap.value = t.alphaMap,
                                        n(t.alphaMap, e.alphaMapTransform));
                                    t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest)
                                }(e, r) : r.isShadowMaterial ? (e.color.value.copy(r.color),
                                    e.opacity.value = r.opacity) : r.isShaderMaterial && (r.uniformsNeedUpdate = !1)
                            }
                        }
                    }
                    function qd(e, t, n, i) {
                        let r = {}
                            , a = {}
                            , s = [];
                        const o = e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS);
                        function l(e, t, n, i) {
                            const r = e.value
                                , a = t + "_" + n;
                            if (void 0 === i[a])
                                return i[a] = "number" == typeof r || "boolean" == typeof r ? r : r.clone(),
                                    !0;
                            {
                                const e = i[a];
                                if ("number" == typeof r || "boolean" == typeof r) {
                                    if (e !== r)
                                        return i[a] = r,
                                            !0
                                } else if (!1 === e.equals(r))
                                    return e.copy(r),
                                        !0
                            }
                            return !1
                        }
                        function c(e) {
                            const t = {
                                boundary: 0,
                                storage: 0
                            };
                            return "number" == typeof e || "boolean" == typeof e ? (t.boundary = 4,
                                t.storage = 4) : e.isVector2 ? (t.boundary = 8,
                                t.storage = 8) : e.isVector3 || e.isColor ? (t.boundary = 16,
                                t.storage = 12) : e.isVector4 ? (t.boundary = 16,
                                t.storage = 16) : e.isMatrix3 ? (t.boundary = 48,
                                t.storage = 48) : e.isMatrix4 ? (t.boundary = 64,
                                t.storage = 64) : e.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", e),
                                t
                        }
                        function h(t) {
                            const n = t.target;
                            n.removeEventListener("dispose", h);
                            const i = s.indexOf(n.__bindingPointIndex);
                            s.splice(i, 1),
                                e.deleteBuffer(r[n.id]),
                                delete r[n.id],
                                delete a[n.id]
                        }
                        return {
                            bind: function(e, t) {
                                const n = t.program;
                                i.uniformBlockBinding(e, n)
                            },
                            update: function(n, d) {
                                let u = r[n.id];
                                void 0 === u && (!function(e) {
                                    const t = e.uniforms;
                                    let n = 0;
                                    const i = 16;
                                    for (let e = 0, r = t.length; e < r; e++) {
                                        const r = Array.isArray(t[e]) ? t[e] : [t[e]];
                                        for (let e = 0, t = r.length; e < t; e++) {
                                            const t = r[e]
                                                , a = Array.isArray(t.value) ? t.value : [t.value];
                                            for (let e = 0, r = a.length; e < r; e++) {
                                                const r = c(a[e])
                                                    , s = n % i
                                                    , o = s % r.boundary
                                                    , l = s + o;
                                                n += o,
                                                0 !== l && i - l < r.storage && (n += i - l),
                                                    t.__data = new Float32Array(r.storage / Float32Array.BYTES_PER_ELEMENT),
                                                    t.__offset = n,
                                                    n += r.storage
                                            }
                                        }
                                    }
                                    const r = n % i;
                                    r > 0 && (n += i - r);
                                    e.__size = n,
                                        e.__cache = {}
                                }(n),
                                    u = function(t) {
                                        const n = function() {
                                            for (let e = 0; e < o; e++)
                                                if (-1 === s.indexOf(e))
                                                    return s.push(e),
                                                        e;
                                            return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),
                                                0
                                        }();
                                        t.__bindingPointIndex = n;
                                        const i = e.createBuffer()
                                            , r = t.__size
                                            , a = t.usage;
                                        return e.bindBuffer(e.UNIFORM_BUFFER, i),
                                            e.bufferData(e.UNIFORM_BUFFER, r, a),
                                            e.bindBuffer(e.UNIFORM_BUFFER, null),
                                            e.bindBufferBase(e.UNIFORM_BUFFER, n, i),
                                            i
                                    }(n),
                                    r[n.id] = u,
                                    n.addEventListener("dispose", h));
                                const p = d.program;
                                i.updateUBOMapping(n, p);
                                const f = t.render.frame;
                                a[n.id] !== f && (!function(t) {
                                    const n = r[t.id]
                                        , i = t.uniforms
                                        , a = t.__cache;
                                    e.bindBuffer(e.UNIFORM_BUFFER, n);
                                    for (let t = 0, n = i.length; t < n; t++) {
                                        const n = Array.isArray(i[t]) ? i[t] : [i[t]];
                                        for (let i = 0, r = n.length; i < r; i++) {
                                            const r = n[i];
                                            if (!0 === l(r, t, i, a)) {
                                                const t = r.__offset
                                                    , n = Array.isArray(r.value) ? r.value : [r.value];
                                                let i = 0;
                                                for (let a = 0; a < n.length; a++) {
                                                    const s = n[a]
                                                        , o = c(s);
                                                    "number" == typeof s || "boolean" == typeof s ? (r.__data[0] = s,
                                                        e.bufferSubData(e.UNIFORM_BUFFER, t + i, r.__data)) : s.isMatrix3 ? (r.__data[0] = s.elements[0],
                                                        r.__data[1] = s.elements[1],
                                                        r.__data[2] = s.elements[2],
                                                        r.__data[3] = 0,
                                                        r.__data[4] = s.elements[3],
                                                        r.__data[5] = s.elements[4],
                                                        r.__data[6] = s.elements[5],
                                                        r.__data[7] = 0,
                                                        r.__data[8] = s.elements[6],
                                                        r.__data[9] = s.elements[7],
                                                        r.__data[10] = s.elements[8],
                                                        r.__data[11] = 0) : (s.toArray(r.__data, i),
                                                        i += o.storage / Float32Array.BYTES_PER_ELEMENT)
                                                }
                                                e.bufferSubData(e.UNIFORM_BUFFER, t, r.__data)
                                            }
                                        }
                                    }
                                    e.bindBuffer(e.UNIFORM_BUFFER, null)
                                }(n),
                                    a[n.id] = f)
                            },
                            dispose: function() {
                                for (const t in r)
                                    e.deleteBuffer(r[t]);
                                s = [],
                                    r = {},
                                    a = {}
                            }
                        }
                    }
                    class Kd {
                        constructor(e={}) {
                            const {canvas: t=Xt(), context: n=null, depth: i=!0, stencil: r=!1, alpha: a=!1, antialias: s=!1, premultipliedAlpha: o=!0, preserveDrawingBuffer: l=!1, powerPreference: c="default", failIfMajorPerformanceCaveat: h=!1, reverseDepthBuffer: d=!1} = e;
                            let u;
                            if (this.isWebGLRenderer = !0,
                            null !== n) {
                                if ("undefined" != typeof WebGLRenderingContext && n instanceof WebGLRenderingContext)
                                    throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
                                u = n.getContextAttributes().alpha
                            } else
                                u = a;
                            const p = new Uint32Array(4)
                                , f = new Int32Array(4);
                            let g = null
                                , v = null;
                            const w = []
                                , A = [];
                            this.domElement = t,
                                this.debug = {
                                    checkShaderErrors: !0,
                                    onShaderError: null
                                },
                                this.autoClear = !0,
                                this.autoClearColor = !0,
                                this.autoClearDepth = !0,
                                this.autoClearStencil = !0,
                                this.sortObjects = !0,
                                this.clippingPlanes = [],
                                this.localClippingEnabled = !1,
                                this._outputColorSpace = gt,
                                this.toneMapping = 0,
                                this.toneMappingExposure = 1;
                            const y = this;
                            let b = !1
                                , x = 0
                                , k = 0
                                , E = null
                                , S = -1
                                , M = null;
                            const T = new pn
                                , C = new pn;
                            let _ = null;
                            const I = new Wi(0);
                            let P = 0
                                , R = t.width
                                , L = t.height
                                , N = 1
                                , D = null
                                , B = null;
                            const U = new pn(0,0,R,L)
                                , z = new pn(0,0,R,L);
                            let O = !1;
                            const F = new Aa;
                            let W = !1
                                , H = !1;
                            this.transmissionResolutionScale = 1;
                            const V = new Kn
                                , G = new Kn
                                , j = new An
                                , Q = new pn
                                , Y = {
                                background: null,
                                fog: null,
                                environment: null,
                                overrideMaterial: null,
                                isScene: !0
                            };
                            let q = !1;
                            function K() {
                                return null === E ? N : 1
                            }
                            let X, Z, J, $, ee, te, ne, ie, re, ae, se, oe, le, ce, he, de, fe, me, ve, Ae, Ee, Se, Me, Te, Ce = n;
                            function Re(e, n) {
                                return t.getContext(e, n)
                            }
                            try {
                                const e = {
                                    alpha: !0,
                                    depth: i,
                                    stencil: r,
                                    antialias: s,
                                    premultipliedAlpha: o,
                                    preserveDrawingBuffer: l,
                                    powerPreference: c,
                                    failIfMajorPerformanceCaveat: h
                                };
                                if ("setAttribute"in t && t.setAttribute("data-engine", `three.js r${m}`),
                                    t.addEventListener("webglcontextlost", De, !1),
                                    t.addEventListener("webglcontextrestored", Be, !1),
                                    t.addEventListener("webglcontextcreationerror", Ue, !1),
                                null === Ce) {
                                    const t = "webgl2";
                                    if (Ce = Re(t, e),
                                    null === Ce)
                                        throw Re(t) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                                }
                            } catch (e) {
                                throw console.error("THREE.WebGLRenderer: " + e.message),
                                    e
                            }
                            function Le() {
                                X = new Qc(Ce),
                                    X.init(),
                                    Se = new Hd(Ce,X),
                                    Z = new Ec(Ce,X,e,Se),
                                    J = new Fd(Ce,X),
                                Z.reverseDepthBuffer && d && J.buffers.depth.setReversed(!0),
                                    $ = new Kc(Ce),
                                    ee = new Td,
                                    te = new Wd(Ce,X,J,ee,Z,Se,$),
                                    ne = new Mc(y),
                                    ie = new jc(y),
                                    re = new fc(Ce),
                                    Me = new xc(Ce,re),
                                    ae = new Yc(Ce,re,$,Me),
                                    se = new Zc(Ce,ae,re,$),
                                    ve = new Xc(Ce,Z,te),
                                    de = new Sc(ee),
                                    oe = new Md(y,ne,ie,X,Z,Me,de),
                                    le = new Yd(y,ee),
                                    ce = new Pd,
                                    he = new Ud(X),
                                    me = new bc(y,ne,ie,J,se,u,o),
                                    fe = new zd(y,se,Z),
                                    Te = new qd(Ce,$,Z,J),
                                    Ae = new kc(Ce,X,$),
                                    Ee = new qc(Ce,X,$),
                                    $.programs = oe.programs,
                                    y.capabilities = Z,
                                    y.extensions = X,
                                    y.properties = ee,
                                    y.renderLists = ce,
                                    y.shadowMap = fe,
                                    y.state = J,
                                    y.info = $
                            }
                            Le();
                            const Ne = new Gd(y,Ce);
                            function De(e) {
                                e.preventDefault(),
                                    console.log("THREE.WebGLRenderer: Context Lost."),
                                    b = !0
                            }
                            function Be() {
                                console.log("THREE.WebGLRenderer: Context Restored."),
                                    b = !1;
                                const e = $.autoReset
                                    , t = fe.enabled
                                    , n = fe.autoUpdate
                                    , i = fe.needsUpdate
                                    , r = fe.type;
                                Le(),
                                    $.autoReset = e,
                                    fe.enabled = t,
                                    fe.autoUpdate = n,
                                    fe.needsUpdate = i,
                                    fe.type = r
                            }
                            function Ue(e) {
                                console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", e.statusMessage)
                            }
                            function ze(e) {
                                const t = e.target;
                                t.removeEventListener("dispose", ze),
                                    function(e) {
                                        (function(e) {
                                                const t = ee.get(e).programs;
                                                void 0 !== t && (t.forEach((function(e) {
                                                        oe.releaseProgram(e)
                                                    }
                                                )),
                                                e.isShaderMaterial && oe.releaseShaderCache(e))
                                            }
                                        )(e),
                                            ee.remove(e)
                                    }(t)
                            }
                            function Oe(e, t, n) {
                                !0 === e.transparent && 2 === e.side && !1 === e.forceSinglePass ? (e.side = 1,
                                    e.needsUpdate = !0,
                                    Ke(e, t, n),
                                    e.side = 0,
                                    e.needsUpdate = !0,
                                    Ke(e, t, n),
                                    e.side = 2) : Ke(e, t, n)
                            }
                            this.xr = Ne,
                                this.getContext = function() {
                                    return Ce
                                }
                                ,
                                this.getContextAttributes = function() {
                                    return Ce.getContextAttributes()
                                }
                                ,
                                this.forceContextLoss = function() {
                                    const e = X.get("WEBGL_lose_context");
                                    e && e.loseContext()
                                }
                                ,
                                this.forceContextRestore = function() {
                                    const e = X.get("WEBGL_lose_context");
                                    e && e.restoreContext()
                                }
                                ,
                                this.getPixelRatio = function() {
                                    return N
                                }
                                ,
                                this.setPixelRatio = function(e) {
                                    void 0 !== e && (N = e,
                                        this.setSize(R, L, !1))
                                }
                                ,
                                this.getSize = function(e) {
                                    return e.set(R, L)
                                }
                                ,
                                this.setSize = function(e, n, i=!0) {
                                    Ne.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (R = e,
                                        L = n,
                                        t.width = Math.floor(e * N),
                                        t.height = Math.floor(n * N),
                                    !0 === i && (t.style.width = e + "px",
                                        t.style.height = n + "px"),
                                        this.setViewport(0, 0, e, n))
                                }
                                ,
                                this.getDrawingBufferSize = function(e) {
                                    return e.set(R * N, L * N).floor()
                                }
                                ,
                                this.setDrawingBufferSize = function(e, n, i) {
                                    R = e,
                                        L = n,
                                        N = i,
                                        t.width = Math.floor(e * i),
                                        t.height = Math.floor(n * i),
                                        this.setViewport(0, 0, e, n)
                                }
                                ,
                                this.getCurrentViewport = function(e) {
                                    return e.copy(T)
                                }
                                ,
                                this.getViewport = function(e) {
                                    return e.copy(U)
                                }
                                ,
                                this.setViewport = function(e, t, n, i) {
                                    e.isVector4 ? U.set(e.x, e.y, e.z, e.w) : U.set(e, t, n, i),
                                        J.viewport(T.copy(U).multiplyScalar(N).round())
                                }
                                ,
                                this.getScissor = function(e) {
                                    return e.copy(z)
                                }
                                ,
                                this.setScissor = function(e, t, n, i) {
                                    e.isVector4 ? z.set(e.x, e.y, e.z, e.w) : z.set(e, t, n, i),
                                        J.scissor(C.copy(z).multiplyScalar(N).round())
                                }
                                ,
                                this.getScissorTest = function() {
                                    return O
                                }
                                ,
                                this.setScissorTest = function(e) {
                                    J.setScissorTest(O = e)
                                }
                                ,
                                this.setOpaqueSort = function(e) {
                                    D = e
                                }
                                ,
                                this.setTransparentSort = function(e) {
                                    B = e
                                }
                                ,
                                this.getClearColor = function(e) {
                                    return e.copy(me.getClearColor())
                                }
                                ,
                                this.setClearColor = function() {
                                    me.setClearColor(...arguments)
                                }
                                ,
                                this.getClearAlpha = function() {
                                    return me.getClearAlpha()
                                }
                                ,
                                this.setClearAlpha = function() {
                                    me.setClearAlpha(...arguments)
                                }
                                ,
                                this.clear = function(e=!0, t=!0, n=!0) {
                                    let i = 0;
                                    if (e) {
                                        let e = !1;
                                        if (null !== E) {
                                            const t = E.texture.format;
                                            e = t === Pe || t === Ie || t === _e
                                        }
                                        if (e) {
                                            const e = E.texture.type
                                                , t = e === pe || e === we || e === ge || e === ke || e === be || e === xe
                                                , n = me.getClearColor()
                                                , i = me.getClearAlpha()
                                                , r = n.r
                                                , a = n.g
                                                , s = n.b;
                                            t ? (p[0] = r,
                                                p[1] = a,
                                                p[2] = s,
                                                p[3] = i,
                                                Ce.clearBufferuiv(Ce.COLOR, 0, p)) : (f[0] = r,
                                                f[1] = a,
                                                f[2] = s,
                                                f[3] = i,
                                                Ce.clearBufferiv(Ce.COLOR, 0, f))
                                        } else
                                            i |= Ce.COLOR_BUFFER_BIT
                                    }
                                    t && (i |= Ce.DEPTH_BUFFER_BIT),
                                    n && (i |= Ce.STENCIL_BUFFER_BIT,
                                        this.state.buffers.stencil.setMask(4294967295)),
                                        Ce.clear(i)
                                }
                                ,
                                this.clearColor = function() {
                                    this.clear(!0, !1, !1)
                                }
                                ,
                                this.clearDepth = function() {
                                    this.clear(!1, !0, !1)
                                }
                                ,
                                this.clearStencil = function() {
                                    this.clear(!1, !1, !0)
                                }
                                ,
                                this.dispose = function() {
                                    t.removeEventListener("webglcontextlost", De, !1),
                                        t.removeEventListener("webglcontextrestored", Be, !1),
                                        t.removeEventListener("webglcontextcreationerror", Ue, !1),
                                        me.dispose(),
                                        ce.dispose(),
                                        he.dispose(),
                                        ee.dispose(),
                                        ne.dispose(),
                                        ie.dispose(),
                                        se.dispose(),
                                        Me.dispose(),
                                        Te.dispose(),
                                        oe.dispose(),
                                        Ne.dispose(),
                                        Ne.removeEventListener("sessionstart", We),
                                        Ne.removeEventListener("sessionend", He),
                                        Ve.stop()
                                }
                                ,
                                this.renderBufferDirect = function(e, t, n, i, r, a) {
                                    null === t && (t = Y);
                                    const s = r.isMesh && r.matrixWorld.determinant() < 0
                                        , o = function(e, t, n, i, r) {
                                        !0 !== t.isScene && (t = Y);
                                        te.resetTextureUnits();
                                        const a = t.fog
                                            , s = i.isMeshStandardMaterial ? t.environment : null
                                            , o = null === E ? y.outputColorSpace : !0 === E.isXRRenderTarget ? E.texture.colorSpace : vt
                                            , l = (i.isMeshStandardMaterial ? ie : ne).get(i.envMap || s)
                                            , c = !0 === i.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize
                                            , h = !!n.attributes.tangent && (!!i.normalMap || i.anisotropy > 0)
                                            , d = !!n.morphAttributes.position
                                            , u = !!n.morphAttributes.normal
                                            , p = !!n.morphAttributes.color;
                                        let f = 0;
                                        i.toneMapped && (null !== E && !0 !== E.isXRRenderTarget || (f = y.toneMapping));
                                        const m = n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color
                                            , g = void 0 !== m ? m.length : 0
                                            , w = ee.get(i)
                                            , A = v.state.lights;
                                        if (!0 === W && (!0 === H || e !== M)) {
                                            const t = e === M && i.id === S;
                                            de.setState(i, e, t)
                                        }
                                        let b = !1;
                                        i.version === w.__version ? w.needsLights && w.lightsStateVersion !== A.state.version || w.outputColorSpace !== o || r.isBatchedMesh && !1 === w.batching ? b = !0 : r.isBatchedMesh || !0 !== w.batching ? r.isBatchedMesh && !0 === w.batchingColor && null === r.colorTexture || r.isBatchedMesh && !1 === w.batchingColor && null !== r.colorTexture || r.isInstancedMesh && !1 === w.instancing ? b = !0 : r.isInstancedMesh || !0 !== w.instancing ? r.isSkinnedMesh && !1 === w.skinning ? b = !0 : r.isSkinnedMesh || !0 !== w.skinning ? r.isInstancedMesh && !0 === w.instancingColor && null === r.instanceColor || r.isInstancedMesh && !1 === w.instancingColor && null !== r.instanceColor || r.isInstancedMesh && !0 === w.instancingMorph && null === r.morphTexture || r.isInstancedMesh && !1 === w.instancingMorph && null !== r.morphTexture || w.envMap !== l || !0 === i.fog && w.fog !== a ? b = !0 : void 0 === w.numClippingPlanes || w.numClippingPlanes === de.numPlanes && w.numIntersection === de.numIntersection ? (w.vertexAlphas !== c || w.vertexTangents !== h || w.morphTargets !== d || w.morphNormals !== u || w.morphColors !== p || w.toneMapping !== f || w.morphTargetsCount !== g) && (b = !0) : b = !0 : b = !0 : b = !0 : b = !0 : (b = !0,
                                            w.__version = i.version);
                                        let x = w.currentProgram;
                                        !0 === b && (x = Ke(i, t, r));
                                        let k = !1
                                            , T = !1
                                            , C = !1;
                                        const _ = x.getUniforms()
                                            , I = w.uniforms;
                                        J.useProgram(x.program) && (k = !0,
                                            T = !0,
                                            C = !0);
                                        i.id !== S && (S = i.id,
                                            T = !0);
                                        if (k || M !== e) {
                                            J.buffers.depth.getReversed() ? (V.copy(e.projectionMatrix),
                                                function(e) {
                                                    const t = e.elements;
                                                    t[2] = .5 * t[2] + .5 * t[3],
                                                        t[6] = .5 * t[6] + .5 * t[7],
                                                        t[10] = .5 * t[10] + .5 * t[11],
                                                        t[14] = .5 * t[14] + .5 * t[15]
                                                }(V),
                                                function(e) {
                                                    const t = e.elements;
                                                    -1 === t[11] ? (t[10] = -t[10] - 1,
                                                        t[14] = -t[14]) : (t[10] = -t[10],
                                                        t[14] = 1 - t[14])
                                                }(V),
                                                _.setValue(Ce, "projectionMatrix", V)) : _.setValue(Ce, "projectionMatrix", e.projectionMatrix),
                                                _.setValue(Ce, "viewMatrix", e.matrixWorldInverse);
                                            const t = _.map.cameraPosition;
                                            void 0 !== t && t.setValue(Ce, j.setFromMatrixPosition(e.matrixWorld)),
                                            Z.logarithmicDepthBuffer && _.setValue(Ce, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)),
                                            (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && _.setValue(Ce, "isOrthographic", !0 === e.isOrthographicCamera),
                                            M !== e && (M = e,
                                                T = !0,
                                                C = !0)
                                        }
                                        if (r.isSkinnedMesh) {
                                            _.setOptional(Ce, r, "bindMatrix"),
                                                _.setOptional(Ce, r, "bindMatrixInverse");
                                            const e = r.skeleton;
                                            e && (null === e.boneTexture && e.computeBoneTexture(),
                                                _.setValue(Ce, "boneTexture", e.boneTexture, te))
                                        }
                                        r.isBatchedMesh && (_.setOptional(Ce, r, "batchingTexture"),
                                            _.setValue(Ce, "batchingTexture", r._matricesTexture, te),
                                            _.setOptional(Ce, r, "batchingIdTexture"),
                                            _.setValue(Ce, "batchingIdTexture", r._indirectTexture, te),
                                            _.setOptional(Ce, r, "batchingColorTexture"),
                                        null !== r._colorsTexture && _.setValue(Ce, "batchingColorTexture", r._colorsTexture, te));
                                        const P = n.morphAttributes;
                                        void 0 === P.position && void 0 === P.normal && void 0 === P.color || ve.update(r, n, x);
                                        (T || w.receiveShadow !== r.receiveShadow) && (w.receiveShadow = r.receiveShadow,
                                            _.setValue(Ce, "receiveShadow", r.receiveShadow));
                                        i.isMeshGouraudMaterial && null !== i.envMap && (I.envMap.value = l,
                                            I.flipEnvMap.value = l.isCubeTexture && !1 === l.isRenderTargetTexture ? -1 : 1);
                                        i.isMeshStandardMaterial && null === i.envMap && null !== t.environment && (I.envMapIntensity.value = t.environmentIntensity);
                                        T && (_.setValue(Ce, "toneMappingExposure", y.toneMappingExposure),
                                        w.needsLights && (D = C,
                                            (R = I).ambientLightColor.needsUpdate = D,
                                            R.lightProbe.needsUpdate = D,
                                            R.directionalLights.needsUpdate = D,
                                            R.directionalLightShadows.needsUpdate = D,
                                            R.pointLights.needsUpdate = D,
                                            R.pointLightShadows.needsUpdate = D,
                                            R.spotLights.needsUpdate = D,
                                            R.spotLightShadows.needsUpdate = D,
                                            R.rectAreaLights.needsUpdate = D,
                                            R.hemisphereLights.needsUpdate = D),
                                        a && !0 === i.fog && le.refreshFogUniforms(I, a),
                                            le.refreshMaterialUniforms(I, i, N, L, v.state.transmissionRenderTarget[e.id]),
                                            nd.upload(Ce, Xe(w), I, te));
                                        var R, D;
                                        i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (nd.upload(Ce, Xe(w), I, te),
                                            i.uniformsNeedUpdate = !1);
                                        i.isSpriteMaterial && _.setValue(Ce, "center", r.center);
                                        if (_.setValue(Ce, "modelViewMatrix", r.modelViewMatrix),
                                            _.setValue(Ce, "normalMatrix", r.normalMatrix),
                                            _.setValue(Ce, "modelMatrix", r.matrixWorld),
                                        i.isShaderMaterial || i.isRawShaderMaterial) {
                                            const e = i.uniformsGroups;
                                            for (let t = 0, n = e.length; t < n; t++) {
                                                const n = e[t];
                                                Te.update(n, x),
                                                    Te.bind(n, x)
                                            }
                                        }
                                        return x
                                    }(e, t, n, i, r);
                                    J.setMaterial(i, s);
                                    let l = n.index
                                        , c = 1;
                                    if (!0 === i.wireframe) {
                                        if (l = ae.getWireframeAttribute(n),
                                        void 0 === l)
                                            return;
                                        c = 2
                                    }
                                    const h = n.drawRange
                                        , d = n.attributes.position;
                                    let u = h.start * c
                                        , p = (h.start + h.count) * c;
                                    null !== a && (u = Math.max(u, a.start * c),
                                        p = Math.min(p, (a.start + a.count) * c)),
                                        null !== l ? (u = Math.max(u, 0),
                                            p = Math.min(p, l.count)) : null != d && (u = Math.max(u, 0),
                                            p = Math.min(p, d.count));
                                    const f = p - u;
                                    if (f < 0 || f === 1 / 0)
                                        return;
                                    let m;
                                    Me.setup(r, i, o, n, l);
                                    let g = Ae;
                                    if (null !== l && (m = re.get(l),
                                        g = Ee,
                                        g.setIndex(m)),
                                        r.isMesh)
                                        !0 === i.wireframe ? (J.setLineWidth(i.wireframeLinewidth * K()),
                                            g.setMode(Ce.LINES)) : g.setMode(Ce.TRIANGLES);
                                    else if (r.isLine) {
                                        let e = i.linewidth;
                                        void 0 === e && (e = 1),
                                            J.setLineWidth(e * K()),
                                            r.isLineSegments ? g.setMode(Ce.LINES) : r.isLineLoop ? g.setMode(Ce.LINE_LOOP) : g.setMode(Ce.LINE_STRIP)
                                    } else
                                        r.isPoints ? g.setMode(Ce.POINTS) : r.isSprite && g.setMode(Ce.TRIANGLES);
                                    if (r.isBatchedMesh)
                                        if (null !== r._multiDrawInstances)
                                            Jt("THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."),
                                                g.renderMultiDrawInstances(r._multiDrawStarts, r._multiDrawCounts, r._multiDrawCount, r._multiDrawInstances);
                                        else if (X.get("WEBGL_multi_draw"))
                                            g.renderMultiDraw(r._multiDrawStarts, r._multiDrawCounts, r._multiDrawCount);
                                        else {
                                            const e = r._multiDrawStarts
                                                , t = r._multiDrawCounts
                                                , n = r._multiDrawCount
                                                , a = l ? re.get(l).bytesPerElement : 1
                                                , s = ee.get(i).currentProgram.getUniforms();
                                            for (let i = 0; i < n; i++)
                                                s.setValue(Ce, "_gl_DrawID", i),
                                                    g.render(e[i] / a, t[i])
                                        }
                                    else if (r.isInstancedMesh)
                                        g.renderInstances(u, f, r.count);
                                    else if (n.isInstancedBufferGeometry) {
                                        const e = void 0 !== n._maxInstanceCount ? n._maxInstanceCount : 1 / 0
                                            , t = Math.min(n.instanceCount, e);
                                        g.renderInstances(u, f, t)
                                    } else
                                        g.render(u, f)
                                }
                                ,
                                this.compile = function(e, t, n=null) {
                                    null === n && (n = e),
                                        v = he.get(n),
                                        v.init(t),
                                        A.push(v),
                                        n.traverseVisible((function(e) {
                                                e.isLight && e.layers.test(t.layers) && (v.pushLight(e),
                                                e.castShadow && v.pushShadow(e))
                                            }
                                        )),
                                    e !== n && e.traverseVisible((function(e) {
                                            e.isLight && e.layers.test(t.layers) && (v.pushLight(e),
                                            e.castShadow && v.pushShadow(e))
                                        }
                                    )),
                                        v.setupLights();
                                    const i = new Set;
                                    return e.traverse((function(e) {
                                            if (!(e.isMesh || e.isPoints || e.isLine || e.isSprite))
                                                return;
                                            const t = e.material;
                                            if (t)
                                                if (Array.isArray(t))
                                                    for (let r = 0; r < t.length; r++) {
                                                        const a = t[r];
                                                        Oe(a, n, e),
                                                            i.add(a)
                                                    }
                                                else
                                                    Oe(t, n, e),
                                                        i.add(t)
                                        }
                                    )),
                                        v = A.pop(),
                                        i
                                }
                                ,
                                this.compileAsync = function(e, t, n=null) {
                                    const i = this.compile(e, t, n);
                                    return new Promise((t => {
                                            function n() {
                                                i.forEach((function(e) {
                                                        ee.get(e).currentProgram.isReady() && i.delete(e)
                                                    }
                                                )),
                                                    0 !== i.size ? setTimeout(n, 10) : t(e)
                                            }
                                            null !== X.get("KHR_parallel_shader_compile") ? n() : setTimeout(n, 10)
                                        }
                                    ))
                                }
                            ;
                            let Fe = null;
                            function We() {
                                Ve.stop()
                            }
                            function He() {
                                Ve.start()
                            }
                            const Ve = new pc;
                            function Ge(e, t, n, i) {
                                if (!1 === e.visible)
                                    return;
                                if (e.layers.test(t.layers))
                                    if (e.isGroup)
                                        n = e.renderOrder;
                                    else if (e.isLOD)
                                        !0 === e.autoUpdate && e.update(t);
                                    else if (e.isLight)
                                        v.pushLight(e),
                                        e.castShadow && v.pushShadow(e);
                                    else if (e.isSprite) {
                                        if (!e.frustumCulled || F.intersectsSprite(e)) {
                                            i && Q.setFromMatrixPosition(e.matrixWorld).applyMatrix4(G);
                                            const t = se.update(e)
                                                , r = e.material;
                                            r.visible && g.push(e, t, r, n, Q.z, null)
                                        }
                                    } else if ((e.isMesh || e.isLine || e.isPoints) && (!e.frustumCulled || F.intersectsObject(e))) {
                                        const t = se.update(e)
                                            , r = e.material;
                                        if (i && (void 0 !== e.boundingSphere ? (null === e.boundingSphere && e.computeBoundingSphere(),
                                            Q.copy(e.boundingSphere.center)) : (null === t.boundingSphere && t.computeBoundingSphere(),
                                            Q.copy(t.boundingSphere.center)),
                                            Q.applyMatrix4(e.matrixWorld).applyMatrix4(G)),
                                            Array.isArray(r)) {
                                            const i = t.groups;
                                            for (let a = 0, s = i.length; a < s; a++) {
                                                const s = i[a]
                                                    , o = r[s.materialIndex];
                                                o && o.visible && g.push(e, t, o, n, Q.z, s)
                                            }
                                        } else
                                            r.visible && g.push(e, t, r, n, Q.z, null)
                                    }
                                const r = e.children;
                                for (let e = 0, a = r.length; e < a; e++)
                                    Ge(r[e], t, n, i)
                            }
                            function je(e, t, n, i) {
                                const r = e.opaque
                                    , a = e.transmissive
                                    , s = e.transparent;
                                v.setupLightsView(n),
                                !0 === W && de.setGlobalState(y.clippingPlanes, n),
                                i && J.viewport(T.copy(i)),
                                r.length > 0 && Ye(r, t, n),
                                a.length > 0 && Ye(a, t, n),
                                s.length > 0 && Ye(s, t, n),
                                    J.buffers.depth.setTest(!0),
                                    J.buffers.depth.setMask(!0),
                                    J.buffers.color.setMask(!0),
                                    J.setPolygonOffset(!1)
                            }
                            function Qe(e, t, n, i) {
                                if (null !== (!0 === n.isScene ? n.overrideMaterial : null))
                                    return;
                                void 0 === v.state.transmissionRenderTarget[i.id] && (v.state.transmissionRenderTarget[i.id] = new mn(1,1,{
                                    generateMipmaps: !0,
                                    type: X.has("EXT_color_buffer_half_float") || X.has("EXT_color_buffer_float") ? ye : pe,
                                    minFilter: ue,
                                    samples: 4,
                                    stencilBuffer: r,
                                    resolveDepthBuffer: !1,
                                    resolveStencilBuffer: !1,
                                    colorSpace: nn.workingColorSpace
                                }));
                                const a = v.state.transmissionRenderTarget[i.id]
                                    , s = i.viewport || T;
                                a.setSize(s.z * y.transmissionResolutionScale, s.w * y.transmissionResolutionScale);
                                const o = y.getRenderTarget();
                                y.setRenderTarget(a),
                                    y.getClearColor(I),
                                    P = y.getClearAlpha(),
                                P < 1 && y.setClearColor(16777215, .5),
                                    y.clear(),
                                q && me.render(n);
                                const l = y.toneMapping;
                                y.toneMapping = 0;
                                const c = i.viewport;
                                if (void 0 !== i.viewport && (i.viewport = void 0),
                                    v.setupLightsView(i),
                                !0 === W && de.setGlobalState(y.clippingPlanes, i),
                                    Ye(e, n, i),
                                    te.updateMultisampleRenderTarget(a),
                                    te.updateRenderTargetMipmap(a),
                                !1 === X.has("WEBGL_multisampled_render_to_texture")) {
                                    let e = !1;
                                    for (let r = 0, a = t.length; r < a; r++) {
                                        const a = t[r]
                                            , s = a.object
                                            , o = a.geometry
                                            , l = a.material
                                            , c = a.group;
                                        if (2 === l.side && s.layers.test(i.layers)) {
                                            const t = l.side;
                                            l.side = 1,
                                                l.needsUpdate = !0,
                                                qe(s, n, i, o, l, c),
                                                l.side = t,
                                                l.needsUpdate = !0,
                                                e = !0
                                        }
                                    }
                                    !0 === e && (te.updateMultisampleRenderTarget(a),
                                        te.updateRenderTargetMipmap(a))
                                }
                                y.setRenderTarget(o),
                                    y.setClearColor(I, P),
                                void 0 !== c && (i.viewport = c),
                                    y.toneMapping = l
                            }
                            function Ye(e, t, n) {
                                const i = !0 === t.isScene ? t.overrideMaterial : null;
                                for (let r = 0, a = e.length; r < a; r++) {
                                    const a = e[r]
                                        , s = a.object
                                        , o = a.geometry
                                        , l = null === i ? a.material : i
                                        , c = a.group;
                                    s.layers.test(n.layers) && qe(s, t, n, o, l, c)
                                }
                            }
                            function qe(e, t, n, i, r, a) {
                                e.onBeforeRender(y, t, n, i, r, a),
                                    e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld),
                                    e.normalMatrix.getNormalMatrix(e.modelViewMatrix),
                                    r.onBeforeRender(y, t, n, i, e, a),
                                    !0 === r.transparent && 2 === r.side && !1 === r.forceSinglePass ? (r.side = 1,
                                        r.needsUpdate = !0,
                                        y.renderBufferDirect(n, t, i, r, e, a),
                                        r.side = 0,
                                        r.needsUpdate = !0,
                                        y.renderBufferDirect(n, t, i, r, e, a),
                                        r.side = 2) : y.renderBufferDirect(n, t, i, r, e, a),
                                    e.onAfterRender(y, t, n, i, r, a)
                            }
                            function Ke(e, t, n) {
                                !0 !== t.isScene && (t = Y);
                                const i = ee.get(e)
                                    , r = v.state.lights
                                    , a = v.state.shadowsArray
                                    , s = r.state.version
                                    , o = oe.getParameters(e, r.state, a, t, n)
                                    , l = oe.getProgramCacheKey(o);
                                let c = i.programs;
                                i.environment = e.isMeshStandardMaterial ? t.environment : null,
                                    i.fog = t.fog,
                                    i.envMap = (e.isMeshStandardMaterial ? ie : ne).get(e.envMap || i.environment),
                                    i.envMapRotation = null !== i.environment && null === e.envMap ? t.environmentRotation : e.envMapRotation,
                                void 0 === c && (e.addEventListener("dispose", ze),
                                    c = new Map,
                                    i.programs = c);
                                let h = c.get(l);
                                if (void 0 !== h) {
                                    if (i.currentProgram === h && i.lightsStateVersion === s)
                                        return Ze(e, o),
                                            h
                                } else
                                    o.uniforms = oe.getUniforms(e),
                                        e.onBeforeCompile(o, y),
                                        h = oe.acquireProgram(o, l),
                                        c.set(l, h),
                                        i.uniforms = o.uniforms;
                                const d = i.uniforms;
                                return (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (d.clippingPlanes = de.uniform),
                                    Ze(e, o),
                                    i.needsLights = function(e) {
                                        return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights
                                    }(e),
                                    i.lightsStateVersion = s,
                                i.needsLights && (d.ambientLightColor.value = r.state.ambient,
                                    d.lightProbe.value = r.state.probe,
                                    d.directionalLights.value = r.state.directional,
                                    d.directionalLightShadows.value = r.state.directionalShadow,
                                    d.spotLights.value = r.state.spot,
                                    d.spotLightShadows.value = r.state.spotShadow,
                                    d.rectAreaLights.value = r.state.rectArea,
                                    d.ltc_1.value = r.state.rectAreaLTC1,
                                    d.ltc_2.value = r.state.rectAreaLTC2,
                                    d.pointLights.value = r.state.point,
                                    d.pointLightShadows.value = r.state.pointShadow,
                                    d.hemisphereLights.value = r.state.hemi,
                                    d.directionalShadowMap.value = r.state.directionalShadowMap,
                                    d.directionalShadowMatrix.value = r.state.directionalShadowMatrix,
                                    d.spotShadowMap.value = r.state.spotShadowMap,
                                    d.spotLightMatrix.value = r.state.spotLightMatrix,
                                    d.spotLightMap.value = r.state.spotLightMap,
                                    d.pointShadowMap.value = r.state.pointShadowMap,
                                    d.pointShadowMatrix.value = r.state.pointShadowMatrix),
                                    i.currentProgram = h,
                                    i.uniformsList = null,
                                    h
                            }
                            function Xe(e) {
                                if (null === e.uniformsList) {
                                    const t = e.currentProgram.getUniforms();
                                    e.uniformsList = nd.seqWithValue(t.seq, e.uniforms)
                                }
                                return e.uniformsList
                            }
                            function Ze(e, t) {
                                const n = ee.get(e);
                                n.outputColorSpace = t.outputColorSpace,
                                    n.batching = t.batching,
                                    n.batchingColor = t.batchingColor,
                                    n.instancing = t.instancing,
                                    n.instancingColor = t.instancingColor,
                                    n.instancingMorph = t.instancingMorph,
                                    n.skinning = t.skinning,
                                    n.morphTargets = t.morphTargets,
                                    n.morphNormals = t.morphNormals,
                                    n.morphColors = t.morphColors,
                                    n.morphTargetsCount = t.morphTargetsCount,
                                    n.numClippingPlanes = t.numClippingPlanes,
                                    n.numIntersection = t.numClipIntersection,
                                    n.vertexAlphas = t.vertexAlphas,
                                    n.vertexTangents = t.vertexTangents,
                                    n.toneMapping = t.toneMapping
                            }
                            Ve.setAnimationLoop((function(e) {
                                    Fe && Fe(e)
                                }
                            )),
                            "undefined" != typeof self && Ve.setContext(self),
                                this.setAnimationLoop = function(e) {
                                    Fe = e,
                                        Ne.setAnimationLoop(e),
                                        null === e ? Ve.stop() : Ve.start()
                                }
                                ,
                                Ne.addEventListener("sessionstart", We),
                                Ne.addEventListener("sessionend", He),
                                this.render = function(e, t) {
                                    if (void 0 !== t && !0 !== t.isCamera)
                                        return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                                    if (!0 === b)
                                        return;
                                    if (!0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(),
                                    null === t.parent && !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(),
                                    !0 === Ne.enabled && !0 === Ne.isPresenting && (!0 === Ne.cameraAutoUpdate && Ne.updateCamera(t),
                                        t = Ne.getCamera()),
                                    !0 === e.isScene && e.onBeforeRender(y, e, t, E),
                                        v = he.get(e, A.length),
                                        v.init(t),
                                        A.push(v),
                                        G.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
                                        F.setFromProjectionMatrix(G),
                                        H = this.localClippingEnabled,
                                        W = de.init(this.clippingPlanes, H),
                                        g = ce.get(e, w.length),
                                        g.init(),
                                        w.push(g),
                                    !0 === Ne.enabled && !0 === Ne.isPresenting) {
                                        const e = y.xr.getDepthSensingMesh();
                                        null !== e && Ge(e, t, -1 / 0, y.sortObjects)
                                    }
                                    Ge(e, t, 0, y.sortObjects),
                                        g.finish(),
                                    !0 === y.sortObjects && g.sort(D, B),
                                        q = !1 === Ne.enabled || !1 === Ne.isPresenting || !1 === Ne.hasDepthSensing(),
                                    q && me.addToRenderList(g, e),
                                        this.info.render.frame++,
                                    !0 === W && de.beginShadows();
                                    const n = v.state.shadowsArray;
                                    fe.render(n, e, t),
                                    !0 === W && de.endShadows(),
                                    !0 === this.info.autoReset && this.info.reset();
                                    const i = g.opaque
                                        , r = g.transmissive;
                                    if (v.setupLights(),
                                        t.isArrayCamera) {
                                        const n = t.cameras;
                                        if (r.length > 0)
                                            for (let t = 0, a = n.length; t < a; t++) {
                                                Qe(i, r, e, n[t])
                                            }
                                        q && me.render(e);
                                        for (let t = 0, i = n.length; t < i; t++) {
                                            const i = n[t];
                                            je(g, e, i, i.viewport)
                                        }
                                    } else
                                        r.length > 0 && Qe(i, r, e, t),
                                        q && me.render(e),
                                            je(g, e, t);
                                    null !== E && 0 === k && (te.updateMultisampleRenderTarget(E),
                                        te.updateRenderTargetMipmap(E)),
                                    !0 === e.isScene && e.onAfterRender(y, e, t),
                                        Me.resetDefaultState(),
                                        S = -1,
                                        M = null,
                                        A.pop(),
                                        A.length > 0 ? (v = A[A.length - 1],
                                        !0 === W && de.setGlobalState(y.clippingPlanes, v.state.camera)) : v = null,
                                        w.pop(),
                                        g = w.length > 0 ? w[w.length - 1] : null
                                }
                                ,
                                this.getActiveCubeFace = function() {
                                    return x
                                }
                                ,
                                this.getActiveMipmapLevel = function() {
                                    return k
                                }
                                ,
                                this.getRenderTarget = function() {
                                    return E
                                }
                                ,
                                this.setRenderTargetTextures = function(e, t, n) {
                                    ee.get(e.texture).__webglTexture = t,
                                        ee.get(e.depthTexture).__webglTexture = n;
                                    const i = ee.get(e);
                                    i.__hasExternalTextures = !0,
                                        i.__autoAllocateDepthBuffer = void 0 === n,
                                    i.__autoAllocateDepthBuffer || !0 === X.has("WEBGL_multisampled_render_to_texture") && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),
                                        i.__useRenderToTexture = !1)
                                }
                                ,
                                this.setRenderTargetFramebuffer = function(e, t) {
                                    const n = ee.get(e);
                                    n.__webglFramebuffer = t,
                                        n.__useDefaultFramebuffer = void 0 === t
                                }
                            ;
                            const Je = Ce.createFramebuffer();
                            this.setRenderTarget = function(e, t=0, n=0) {
                                E = e,
                                    x = t,
                                    k = n;
                                let i = !0
                                    , r = null
                                    , a = !1
                                    , s = !1;
                                if (e) {
                                    const o = ee.get(e);
                                    if (void 0 !== o.__useDefaultFramebuffer)
                                        J.bindFramebuffer(Ce.FRAMEBUFFER, null),
                                            i = !1;
                                    else if (void 0 === o.__webglFramebuffer)
                                        te.setupRenderTarget(e);
                                    else if (o.__hasExternalTextures)
                                        te.rebindTextures(e, ee.get(e.texture).__webglTexture, ee.get(e.depthTexture).__webglTexture);
                                    else if (e.depthBuffer) {
                                        const t = e.depthTexture;
                                        if (o.__boundDepthTexture !== t) {
                                            if (null !== t && ee.has(t) && (e.width !== t.image.width || e.height !== t.image.height))
                                                throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
                                            te.setupDepthRenderbuffer(e)
                                        }
                                    }
                                    const l = e.texture;
                                    (l.isData3DTexture || l.isDataArrayTexture || l.isCompressedArrayTexture) && (s = !0);
                                    const c = ee.get(e).__webglFramebuffer;
                                    e.isWebGLCubeRenderTarget ? (r = Array.isArray(c[t]) ? c[t][n] : c[t],
                                        a = !0) : r = e.samples > 0 && !1 === te.useMultisampledRTT(e) ? ee.get(e).__webglMultisampledFramebuffer : Array.isArray(c) ? c[n] : c,
                                        T.copy(e.viewport),
                                        C.copy(e.scissor),
                                        _ = e.scissorTest
                                } else
                                    T.copy(U).multiplyScalar(N).floor(),
                                        C.copy(z).multiplyScalar(N).floor(),
                                        _ = O;
                                0 !== n && (r = Je);
                                if (J.bindFramebuffer(Ce.FRAMEBUFFER, r) && i && J.drawBuffers(e, r),
                                    J.viewport(T),
                                    J.scissor(C),
                                    J.setScissorTest(_),
                                    a) {
                                    const i = ee.get(e.texture);
                                    Ce.framebufferTexture2D(Ce.FRAMEBUFFER, Ce.COLOR_ATTACHMENT0, Ce.TEXTURE_CUBE_MAP_POSITIVE_X + t, i.__webglTexture, n)
                                } else if (s) {
                                    const i = ee.get(e.texture)
                                        , r = t;
                                    Ce.framebufferTextureLayer(Ce.FRAMEBUFFER, Ce.COLOR_ATTACHMENT0, i.__webglTexture, n, r)
                                } else if (null !== e && 0 !== n) {
                                    const t = ee.get(e.texture);
                                    Ce.framebufferTexture2D(Ce.FRAMEBUFFER, Ce.COLOR_ATTACHMENT0, Ce.TEXTURE_2D, t.__webglTexture, n)
                                }
                                S = -1
                            }
                                ,
                                this.readRenderTargetPixels = function(e, t, n, i, r, a, s) {
                                    if (!e || !e.isWebGLRenderTarget)
                                        return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                                    let o = ee.get(e).__webglFramebuffer;
                                    if (e.isWebGLCubeRenderTarget && void 0 !== s && (o = o[s]),
                                        o) {
                                        J.bindFramebuffer(Ce.FRAMEBUFFER, o);
                                        try {
                                            const s = e.texture
                                                , o = s.format
                                                , l = s.type;
                                            if (!Z.textureFormatReadable(o))
                                                return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                                            if (!Z.textureTypeReadable(l))
                                                return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                                            t >= 0 && t <= e.width - i && n >= 0 && n <= e.height - r && Ce.readPixels(t, n, i, r, Se.convert(o), Se.convert(l), a)
                                        } finally {
                                            const e = null !== E ? ee.get(E).__webglFramebuffer : null;
                                            J.bindFramebuffer(Ce.FRAMEBUFFER, e)
                                        }
                                    }
                                }
                                ,
                                this.readRenderTargetPixelsAsync = async function(e, t, n, i, r, a, s) {
                                    if (!e || !e.isWebGLRenderTarget)
                                        throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                                    let o = ee.get(e).__webglFramebuffer;
                                    if (e.isWebGLCubeRenderTarget && void 0 !== s && (o = o[s]),
                                        o) {
                                        const s = e.texture
                                            , l = s.format
                                            , c = s.type;
                                        if (!Z.textureFormatReadable(l))
                                            throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
                                        if (!Z.textureTypeReadable(c))
                                            throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
                                        if (t >= 0 && t <= e.width - i && n >= 0 && n <= e.height - r) {
                                            J.bindFramebuffer(Ce.FRAMEBUFFER, o);
                                            const e = Ce.createBuffer();
                                            Ce.bindBuffer(Ce.PIXEL_PACK_BUFFER, e),
                                                Ce.bufferData(Ce.PIXEL_PACK_BUFFER, a.byteLength, Ce.STREAM_READ),
                                                Ce.readPixels(t, n, i, r, Se.convert(l), Se.convert(c), 0);
                                            const s = null !== E ? ee.get(E).__webglFramebuffer : null;
                                            J.bindFramebuffer(Ce.FRAMEBUFFER, s);
                                            const h = Ce.fenceSync(Ce.SYNC_GPU_COMMANDS_COMPLETE, 0);
                                            return Ce.flush(),
                                                await function(e, t, n) {
                                                    return new Promise((function(i, r) {
                                                            setTimeout((function a() {
                                                                    switch (e.clientWaitSync(t, e.SYNC_FLUSH_COMMANDS_BIT, 0)) {
                                                                        case e.WAIT_FAILED:
                                                                            r();
                                                                            break;
                                                                        case e.TIMEOUT_EXPIRED:
                                                                            setTimeout(a, n);
                                                                            break;
                                                                        default:
                                                                            i()
                                                                    }
                                                                }
                                                            ), n)
                                                        }
                                                    ))
                                                }(Ce, h, 4),
                                                Ce.bindBuffer(Ce.PIXEL_PACK_BUFFER, e),
                                                Ce.getBufferSubData(Ce.PIXEL_PACK_BUFFER, 0, a),
                                                Ce.deleteBuffer(e),
                                                Ce.deleteSync(h),
                                                a
                                        }
                                        throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")
                                    }
                                }
                                ,
                                this.copyFramebufferToTexture = function(e, t=null, n=0) {
                                    !0 !== e.isTexture && (Jt("WebGLRenderer: copyFramebufferToTexture function signature has changed."),
                                        t = arguments[0] || null,
                                        e = arguments[1]);
                                    const i = Math.pow(2, -n)
                                        , r = Math.floor(e.image.width * i)
                                        , a = Math.floor(e.image.height * i)
                                        , s = null !== t ? t.x : 0
                                        , o = null !== t ? t.y : 0;
                                    te.setTexture2D(e, 0),
                                        Ce.copyTexSubImage2D(Ce.TEXTURE_2D, n, 0, 0, s, o, r, a),
                                        J.unbindTexture()
                                }
                            ;
                            const $e = Ce.createFramebuffer()
                                , et = Ce.createFramebuffer();
                            this.copyTextureToTexture = function(e, t, n=null, i=null, r=0, a=null) {
                                let s, o, l, c, h, d, u, p, f;
                                !0 !== e.isTexture && (Jt("WebGLRenderer: copyTextureToTexture function signature has changed."),
                                    i = arguments[0] || null,
                                    e = arguments[1],
                                    t = arguments[2],
                                    a = arguments[3] || 0,
                                    n = null),
                                null === a && (0 !== r ? (Jt("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."),
                                    a = r,
                                    r = 0) : a = 0);
                                const m = e.isCompressedTexture ? e.mipmaps[a] : e.image;
                                if (null !== n)
                                    s = n.max.x - n.min.x,
                                        o = n.max.y - n.min.y,
                                        l = n.isBox3 ? n.max.z - n.min.z : 1,
                                        c = n.min.x,
                                        h = n.min.y,
                                        d = n.isBox3 ? n.min.z : 0;
                                else {
                                    const t = Math.pow(2, -r);
                                    s = Math.floor(m.width * t),
                                        o = Math.floor(m.height * t),
                                        l = e.isDataArrayTexture ? m.depth : e.isData3DTexture ? Math.floor(m.depth * t) : 1,
                                        c = 0,
                                        h = 0,
                                        d = 0
                                }
                                null !== i ? (u = i.x,
                                    p = i.y,
                                    f = i.z) : (u = 0,
                                    p = 0,
                                    f = 0);
                                const g = Se.convert(t.format)
                                    , v = Se.convert(t.type);
                                let w;
                                t.isData3DTexture ? (te.setTexture3D(t, 0),
                                    w = Ce.TEXTURE_3D) : t.isDataArrayTexture || t.isCompressedArrayTexture ? (te.setTexture2DArray(t, 0),
                                    w = Ce.TEXTURE_2D_ARRAY) : (te.setTexture2D(t, 0),
                                    w = Ce.TEXTURE_2D),
                                    Ce.pixelStorei(Ce.UNPACK_FLIP_Y_WEBGL, t.flipY),
                                    Ce.pixelStorei(Ce.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultiplyAlpha),
                                    Ce.pixelStorei(Ce.UNPACK_ALIGNMENT, t.unpackAlignment);
                                const A = Ce.getParameter(Ce.UNPACK_ROW_LENGTH)
                                    , y = Ce.getParameter(Ce.UNPACK_IMAGE_HEIGHT)
                                    , b = Ce.getParameter(Ce.UNPACK_SKIP_PIXELS)
                                    , x = Ce.getParameter(Ce.UNPACK_SKIP_ROWS)
                                    , k = Ce.getParameter(Ce.UNPACK_SKIP_IMAGES);
                                Ce.pixelStorei(Ce.UNPACK_ROW_LENGTH, m.width),
                                    Ce.pixelStorei(Ce.UNPACK_IMAGE_HEIGHT, m.height),
                                    Ce.pixelStorei(Ce.UNPACK_SKIP_PIXELS, c),
                                    Ce.pixelStorei(Ce.UNPACK_SKIP_ROWS, h),
                                    Ce.pixelStorei(Ce.UNPACK_SKIP_IMAGES, d);
                                const E = e.isDataArrayTexture || e.isData3DTexture
                                    , S = t.isDataArrayTexture || t.isData3DTexture;
                                if (e.isDepthTexture) {
                                    const n = ee.get(e)
                                        , i = ee.get(t)
                                        , m = ee.get(n.__renderTarget)
                                        , g = ee.get(i.__renderTarget);
                                    J.bindFramebuffer(Ce.READ_FRAMEBUFFER, m.__webglFramebuffer),
                                        J.bindFramebuffer(Ce.DRAW_FRAMEBUFFER, g.__webglFramebuffer);
                                    for (let n = 0; n < l; n++)
                                        E && (Ce.framebufferTextureLayer(Ce.READ_FRAMEBUFFER, Ce.COLOR_ATTACHMENT0, ee.get(e).__webglTexture, r, d + n),
                                            Ce.framebufferTextureLayer(Ce.DRAW_FRAMEBUFFER, Ce.COLOR_ATTACHMENT0, ee.get(t).__webglTexture, a, f + n)),
                                            Ce.blitFramebuffer(c, h, s, o, u, p, s, o, Ce.DEPTH_BUFFER_BIT, Ce.NEAREST);
                                    J.bindFramebuffer(Ce.READ_FRAMEBUFFER, null),
                                        J.bindFramebuffer(Ce.DRAW_FRAMEBUFFER, null)
                                } else if (0 !== r || e.isRenderTargetTexture || ee.has(e)) {
                                    const n = ee.get(e)
                                        , i = ee.get(t);
                                    J.bindFramebuffer(Ce.READ_FRAMEBUFFER, $e),
                                        J.bindFramebuffer(Ce.DRAW_FRAMEBUFFER, et);
                                    for (let e = 0; e < l; e++)
                                        E ? Ce.framebufferTextureLayer(Ce.READ_FRAMEBUFFER, Ce.COLOR_ATTACHMENT0, n.__webglTexture, r, d + e) : Ce.framebufferTexture2D(Ce.READ_FRAMEBUFFER, Ce.COLOR_ATTACHMENT0, Ce.TEXTURE_2D, n.__webglTexture, r),
                                            S ? Ce.framebufferTextureLayer(Ce.DRAW_FRAMEBUFFER, Ce.COLOR_ATTACHMENT0, i.__webglTexture, a, f + e) : Ce.framebufferTexture2D(Ce.DRAW_FRAMEBUFFER, Ce.COLOR_ATTACHMENT0, Ce.TEXTURE_2D, i.__webglTexture, a),
                                            0 !== r ? Ce.blitFramebuffer(c, h, s, o, u, p, s, o, Ce.COLOR_BUFFER_BIT, Ce.NEAREST) : S ? Ce.copyTexSubImage3D(w, a, u, p, f + e, c, h, s, o) : Ce.copyTexSubImage2D(w, a, u, p, c, h, s, o);
                                    J.bindFramebuffer(Ce.READ_FRAMEBUFFER, null),
                                        J.bindFramebuffer(Ce.DRAW_FRAMEBUFFER, null)
                                } else
                                    S ? e.isDataTexture || e.isData3DTexture ? Ce.texSubImage3D(w, a, u, p, f, s, o, l, g, v, m.data) : t.isCompressedArrayTexture ? Ce.compressedTexSubImage3D(w, a, u, p, f, s, o, l, g, m.data) : Ce.texSubImage3D(w, a, u, p, f, s, o, l, g, v, m) : e.isDataTexture ? Ce.texSubImage2D(Ce.TEXTURE_2D, a, u, p, s, o, g, v, m.data) : e.isCompressedTexture ? Ce.compressedTexSubImage2D(Ce.TEXTURE_2D, a, u, p, m.width, m.height, g, m.data) : Ce.texSubImage2D(Ce.TEXTURE_2D, a, u, p, s, o, g, v, m);
                                Ce.pixelStorei(Ce.UNPACK_ROW_LENGTH, A),
                                    Ce.pixelStorei(Ce.UNPACK_IMAGE_HEIGHT, y),
                                    Ce.pixelStorei(Ce.UNPACK_SKIP_PIXELS, b),
                                    Ce.pixelStorei(Ce.UNPACK_SKIP_ROWS, x),
                                    Ce.pixelStorei(Ce.UNPACK_SKIP_IMAGES, k),
                                0 === a && t.generateMipmaps && Ce.generateMipmap(w),
                                    J.unbindTexture()
                            }
                                ,
                                this.copyTextureToTexture3D = function(e, t, n=null, i=null, r=0) {
                                    return !0 !== e.isTexture && (Jt("WebGLRenderer: copyTextureToTexture3D function signature has changed."),
                                        n = arguments[0] || null,
                                        i = arguments[1] || null,
                                        e = arguments[2],
                                        t = arguments[3],
                                        r = arguments[4] || 0),
                                        Jt('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'),
                                        this.copyTextureToTexture(e, t, n, i, r)
                                }
                                ,
                                this.initRenderTarget = function(e) {
                                    void 0 === ee.get(e).__webglFramebuffer && te.setupRenderTarget(e)
                                }
                                ,
                                this.initTexture = function(e) {
                                    e.isCubeTexture ? te.setTextureCube(e, 0) : e.isData3DTexture ? te.setTexture3D(e, 0) : e.isDataArrayTexture || e.isCompressedArrayTexture ? te.setTexture2DArray(e, 0) : te.setTexture2D(e, 0),
                                        J.unbindTexture()
                                }
                                ,
                                this.resetState = function() {
                                    x = 0,
                                        k = 0,
                                        E = null,
                                        J.reset(),
                                        Me.reset()
                                }
                                ,
                            "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                                detail: this
                            }))
                        }
                        get coordinateSystem() {
                            return Pt
                        }
                        get outputColorSpace() {
                            return this._outputColorSpace
                        }
                        set outputColorSpace(e) {
                            this._outputColorSpace = e;
                            const t = this.getContext();
                            t.drawingBufferColorspace = nn._getDrawingBufferColorSpace(e),
                                t.unpackColorSpace = nn._getUnpackColorSpace()
                        }
                    }
                    const Xd = JSON.parse('{"rE":"0.5.0","l$":{"r":3,"M":3}}');
                    const Zd = "kodub"
                        , Jd = !1
                        , $d = "https://vps.kodub.com:43274/"
                        , eu = Xd.l$.r;
                    if (!Number.isSafeInteger(eu) || eu < 1)
                        throw new Error("package.json beta version property must be a positive integer");
                    let tu = "";
                    tu = "-beta" + eu.toString();
                    const nu = Xd.rE + tu
                        , iu = Xd.l$.M;
                    if (!Number.isSafeInteger(iu) || iu < 1)
                        throw new Error("package.json beta physicsVersion property must be a positive integer");
                    const ru = iu;
                    var au, su, ou, lu, cu, hu, du, uu, pu, fu, mu, gu = function(e, t, n, i) {
                        return new (n || (n = Promise))((function(r, a) {
                                function s(e) {
                                    try {
                                        l(i.next(e))
                                    } catch (e) {
                                        a(e)
                                    }
                                }
                                function o(e) {
                                    try {
                                        l(i.throw(e))
                                    } catch (e) {
                                        a(e)
                                    }
                                }
                                function l(e) {
                                    var t;
                                    e.done ? r(e.value) : (t = e.value,
                                        t instanceof n ? t : new n((function(e) {
                                                e(t)
                                            }
                                        ))).then(s, o)
                                }
                                l((i = i.apply(e, t || [])).next())
                            }
                        ))
                    }, vu = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, wu = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    class Au {
                        constructor(e, t, n=!0, i=!1) {
                            var r;
                            au.add(this),
                                su.set(this, void 0),
                                ou.set(this, void 0),
                                lu.set(this, void 0),
                                cu.set(this, void 0),
                                hu.set(this, new Ir),
                                du.set(this, void 0),
                                uu.set(this, new An(8,10,10)),
                                pu.set(this, []),
                                vu(this, su, e, "f"),
                                vu(this, ou, t, "f"),
                                vu(this, lu, new Kd({
                                    antialias: null === (r = null == t ? void 0 : t.getSettingBoolean(Jo.Antialiasing)) || void 0 === r || r,
                                    powerPreference: "high-performance",
                                    canvas: e,
                                    alpha: i
                                }), "f"),
                                wu(this, lu, "f").outputColorSpace = vt,
                                wu(this, lu, "f").shadowMap.enabled = !0,
                                wu(this, lu, "f").debug.checkShaderErrors = Jd,
                                vu(this, cu, new Or, "f"),
                            n && (wu(this, cu, "f").fog = new zr(10211839,0,Au.maxViewDistance)),
                                wu(this, cu, "f").add(new Ao(3891597,11714755,4.7)),
                                vu(this, du, new Lo(16777215,4.7), "f"),
                                wu(this, du, "f").position.copy(wu(this, uu, "f")),
                                wu(this, du, "f").castShadow = !0,
                                wu(this, du, "f").shadow.camera.top = 10,
                                wu(this, du, "f").shadow.camera.right = 10,
                                wu(this, du, "f").shadow.camera.bottom = -10,
                                wu(this, du, "f").shadow.camera.left = -10,
                                wu(this, du, "f").shadow.camera.near = 1,
                                wu(this, du, "f").shadow.camera.far = 50,
                                wu(this, du, "f").shadow.mapSize.width = 2048,
                                wu(this, du, "f").shadow.mapSize.height = 2048,
                                wu(this, cu, "f").add(wu(this, du, "f")),
                                wu(this, cu, "f").add(wu(this, du, "f").target),
                                document.addEventListener("fullscreenchange", ( () => {
                                        wu(this, au, "m", mu).call(this)
                                    }
                                )),
                            null != window.electron && window.electron.addFullscreenChangeListener(( () => {
                                    wu(this, au, "m", mu).call(this)
                                }
                            ))
                        }
                        clear() {
                            wu(this, lu, "f").clear()
                        }
                        update(e, t) {
                            var n, i, r;
                            const a = null !== (i = null === (n = wu(this, ou, "f")) || void 0 === n ? void 0 : n.getSettingInteger(Jo.CarShadowQuality)) && void 0 !== i ? i : 0;
                            if (!Number.isFinite(a) || a <= 0)
                                wu(this, du, "f").castShadow = !1;
                            else {
                                wu(this, du, "f").castShadow = !0;
                                const e = Math.min(a, wu(this, lu, "f").capabilities.maxTextureSize);
                                wu(this, du, "f").shadow.mapSize.width == e && wu(this, du, "f").shadow.mapSize.height == e || (wu(this, du, "f").shadow.mapSize.setScalar(e),
                                null === (r = wu(this, du, "f").shadow.map) || void 0 === r || r.dispose(),
                                    wu(this, du, "f").shadow.map = null)
                            }
                            wu(this, uu, "f").copy(t.getSunPosition()),
                                wu(this, du, "f").position.addVectors(e, wu(this, uu, "f").multiplyScalar(12.5)),
                                wu(this, du, "f").target.position.copy(e),
                                wu(this, au, "m", fu).call(this),
                                wu(this, lu, "f").render(wu(this, cu, "f"), wu(this, hu, "f"))
                        }
                        getShadowDirection() {
                            return (new An).subVectors(wu(this, du, "f").position, wu(this, du, "f").target.position).normalize()
                        }
                        getLightTarget() {
                            return wu(this, du, "f").target.position
                        }
                        getMaxAnisotropy() {
                            return wu(this, lu, "f").capabilities.getMaxAnisotropy()
                        }
                        get isFullscreen() {
                            return null != window.electron ? window.electron.isFullscreen() : null != document.fullscreenElement
                        }
                        toggleFullscreen() {
                            return gu(this, void 0, void 0, (function*() {
                                    this.isFullscreen ? null != window.electron ? window.electron.setFullscreen(!1) : yield document.exitFullscreen() : null != window.electron ? window.electron.setFullscreen(!0) : yield document.body.requestFullscreen()
                                }
                            ))
                        }
                        addFullscreenChangeListener(e) {
                            wu(this, pu, "f").push(e)
                        }
                        removeFullscreenChangeListener(e) {
                            const t = wu(this, pu, "f").indexOf(e);
                            t >= 0 && wu(this, pu, "f").splice(t, 1)
                        }
                        setCamera(e) {
                            vu(this, hu, e, "f")
                        }
                        get camera() {
                            return wu(this, hu, "f")
                        }
                        get canvas() {
                            return wu(this, su, "f")
                        }
                        setAnimationLoop(e) {
                            wu(this, lu, "f").setAnimationLoop(e)
                        }
                        get scene() {
                            return wu(this, cu, "f")
                        }
                    }
                    su = new WeakMap,
                        ou = new WeakMap,
                        lu = new WeakMap,
                        cu = new WeakMap,
                        hu = new WeakMap,
                        du = new WeakMap,
                        uu = new WeakMap,
                        pu = new WeakMap,
                        au = new WeakSet,
                        fu = function() {
                            var e, t;
                            let n = null !== (t = null === (e = wu(this, ou, "f")) || void 0 === e ? void 0 : e.getSettingFloat(Jo.RenderScale)) && void 0 !== t ? t : 1;
                            n = Number.isFinite(n) ? Math.min(Math.max(n, .25), 2) : 1;
                            const i = window.devicePixelRatio * n;
                            if (wu(this, lu, "f").getPixelRatio() != i && wu(this, lu, "f").setPixelRatio(i),
                            wu(this, hu, "f")instanceof Ir) {
                                const e = window.innerWidth / window.innerHeight
                                    , t = new jt;
                                wu(this, lu, "f").getSize(t),
                                t.width == window.innerWidth && t.height == window.innerHeight && wu(this, hu, "f").aspect == e || (wu(this, lu, "f").setSize(window.innerWidth, window.innerHeight),
                                    wu(this, hu, "f").aspect = e,
                                    wu(this, hu, "f").updateProjectionMatrix())
                            }
                        }
                        ,
                        mu = function() {
                            for (const e of wu(this, pu, "f"))
                                e()
                        }
                        ,
                        Au.maxViewDistance = 1e4;
                    const yu = Au;
                    var bu, xu, ku, Eu, Su, Mu = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    class Tu {
                        constructor() {
                            bu.add(this),
                                Eu.set(this, new Ir(Mu(xu, xu, "f", ku),1,.5,yu.maxViewDistance))
                        }
                        reset(e, t, n) {
                            this.update(e, t, 0),
                                Mu(this, Eu, "f").fov = Mu(this, bu, "m", Su).call(this, null != n ? n : 0),
                                Mu(this, Eu, "f").updateProjectionMatrix()
                        }
                        update(e, t, n) {
                            Mu(this, Eu, "f").fov = Mu(this, bu, "m", Su).call(this, n),
                                Mu(this, Eu, "f").updateProjectionMatrix();
                            const i = new An(0,1.1,.4);
                            Mu(this, Eu, "f").position.addVectors(e, i.applyQuaternion(t)),
                                Mu(this, Eu, "f").quaternion.copy(t),
                                Mu(this, Eu, "f").quaternion.multiply((new wn).setFromEuler(new ai(0,Math.PI,0))),
                                Mu(this, Eu, "f").updateMatrix()
                        }
                        get camera() {
                            return Mu(this, Eu, "f")
                        }
                    }
                    xu = Tu,
                        Eu = new WeakMap,
                        bu = new WeakSet,
                        Su = function(e) {
                            const t = Math.min(1, Math.abs(e) / 400);
                            return Mu(xu, xu, "f", ku) + (80 - Mu(xu, xu, "f", ku)) * Math.pow(t, 1) / (Math.pow(t, 1) + Math.pow(1 - t, 1))
                        }
                        ,
                        ku = {
                            value: 70
                        };
                    const Cu = Tu;
                    class _u {
                        constructor(e, t, n, i) {
                            this.primary = e,
                                this.secondary = t,
                                this.frame = n,
                                this.rims = i
                        }
                        static random() {
                            const e = 360 * Math.random()
                                , t = 100 * (1 - Math.pow(Math.random(), 2))
                                , n = 100 * (.05 + .25 * (1 - Math.pow(Math.random(), 2)));
                            return new _u(new Wi("hsl(" + e.toString() + "," + t.toString() + "%," + n.toString() + "%)"),new Wi("#ffffff"),new Wi("#131313"),new Wi("#666666"))
                        }
                        serialize() {
                            return this.primary.getHexString() + this.secondary.getHexString() + this.frame.getHexString() + this.rims.getHexString()
                        }
                        static deserialize(e) {
                            const t = [];
                            for (let n = 0; n < 4; n++) {
                                const i = e.substring(6 * n, 6 * (n + 1));
                                /^[0-9a-f]{6}$/i.test(i) ? t.push(new Wi("#" + i)) : t.push(new Wi("#555"))
                            }
                            return new _u(t[0],t[1],t[2],t[3])
                        }
                    }
                    const Iu = _u;
                    var Pu, Ru, Lu, Nu, Du, Bu, Uu, zu = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, Ou = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    class Fu {
                        constructor() {
                            Pu.add(this),
                                Nu.set(this, new Ir(Ou(Ru, Ru, "f", Lu),1,.5,1e4)),
                                Du.set(this, new An),
                                Bu.set(this, new An(0,1,0))
                        }
                        reset(e, t, n) {
                            zu(this, Du, new An(1e-5,0,-1), "f"),
                                Ou(this, Du, "f").applyQuaternion(t),
                                Ou(this, Du, "f").add(e),
                                zu(this, Bu, new An(0,1,0), "f"),
                                Ou(this, Bu, "f").applyQuaternion(t),
                                this.update(e, t, 0),
                                Ou(this, Nu, "f").fov = Ou(this, Pu, "m", Uu).call(this, null != n ? n : 0),
                                Ou(this, Nu, "f").updateProjectionMatrix()
                        }
                        update(e, t, n) {
                            Ou(this, Nu, "f").fov = Ou(this, Pu, "m", Uu).call(this, n),
                                Ou(this, Nu, "f").updateProjectionMatrix();
                            const i = new An(0,1,0);
                            i.applyQuaternion(t);
                            const r = .005;
                            Ou(this, Bu, "f").set(r * i.x + (1 - r) * Ou(this, Bu, "f").x, r * i.y + (1 - r) * Ou(this, Bu, "f").y, r * i.z + (1 - r) * Ou(this, Bu, "f").z);
                            const a = (new An).subVectors(e, Ou(this, Du, "f"));
                            a.normalize();
                            const s = 5.5;
                            Ou(this, Nu, "f").position.x = e.x - a.x * s + 2 * Ou(this, Bu, "f").x,
                                Ou(this, Nu, "f").position.y = Math.max(.25, e.y - a.y * s + 2 * Ou(this, Bu, "f").y),
                                Ou(this, Nu, "f").position.z = e.z - a.z * s + 2 * Ou(this, Bu, "f").z,
                                Ou(this, Nu, "f").lookAt(e.x + 2 * Ou(this, Bu, "f").x * .9, e.y + 2 * Ou(this, Bu, "f").y * .9, e.z + 2 * Ou(this, Bu, "f").z * .9),
                                Ou(this, Nu, "f").updateMatrix(),
                                Ou(this, Du, "f").set(e.x - a.x * s, e.y - a.y * s, e.z - a.z * s)
                        }
                        get camera() {
                            return Ou(this, Nu, "f")
                        }
                    }
                    Ru = Fu,
                        Nu = new WeakMap,
                        Du = new WeakMap,
                        Bu = new WeakMap,
                        Pu = new WeakSet,
                        Uu = function(e) {
                            const t = Math.abs(e) / 400;
                            return Ou(Ru, Ru, "f", Lu) + (100 - Ou(Ru, Ru, "f", Lu)) * Math.pow(t, 1) / (Math.pow(t, 1) + Math.pow(1 - t, 1))
                        }
                        ,
                        Lu = {
                            value: 70
                        };
                    const Wu = Fu;
                    var Hu, Vu, Gu, ju, Qu, Yu, qu, Ku, Xu = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, Zu = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    class Ju {
                        constructor(e) {
                            Vu.set(this, void 0),
                                Gu.set(this, void 0),
                                ju.set(this, []),
                                Qu.set(this, (new Kn).makeScale(0, 0, 0)),
                                Yu.set(this, new An(0,1,0)),
                                Xu(this, Vu, e, "f"),
                                Xu(this, Gu, new ua(Zu(Hu, Hu, "f", qu),Zu(Hu, Hu, "f", Ku),256), "f"),
                                Zu(this, Gu, "f").frustumCulled = !1,
                                e.scene.add(Zu(this, Gu, "f")),
                                this.clear()
                        }
                        dispose() {
                            Zu(this, Gu, "f").dispose(),
                                Zu(this, Vu, "f").scene.remove(Zu(this, Gu, "f"))
                        }
                        clear() {
                            Zu(this, ju, "f").length = 0;
                            for (let e = 0; e < Zu(this, Gu, "f").count; ++e)
                                Zu(this, Gu, "f").setMatrixAt(e, Zu(this, Qu, "f"))
                        }
                        spawn(e, t, n) {
                            Zu(this, ju, "f").push({
                                x: e + .25 * (Math.random() - .5),
                                y: t + .25 * (Math.random() - .5),
                                z: n + .25 * (Math.random() - .5),
                                vx: .5 * (Math.random() - .5),
                                vy: .5 * (Math.random() - .5),
                                vz: .5 * (Math.random() - .5),
                                rotation: Math.random() * Math.PI * 2,
                                lifetime: .5
                            })
                        }
                        update(e) {
                            for (let t = Zu(this, ju, "f").length - 1; t >= 0; --t) {
                                const n = Zu(this, ju, "f")[t];
                                n.vy += 15 * e,
                                    n.x += n.vx * e,
                                    n.y += n.vy * e,
                                    n.z += n.vz * e,
                                    n.lifetime -= e,
                                n.lifetime <= 0 && Zu(this, ju, "f").splice(t, 1)
                            }
                            for (let e = 0; e < Zu(this, Gu, "f").count; ++e)
                                if (e < Zu(this, ju, "f").length) {
                                    const t = Zu(this, ju, "f")[Zu(this, ju, "f").length - 1 - e]
                                        , n = new Kn;
                                    n.lookAt(new An(t.x,t.y,t.z), Zu(this, Vu, "f").camera.position, Zu(this, Yu, "f")),
                                        n.setPosition(t.x, t.y, t.z),
                                        n.multiply((new Kn).makeRotationZ(t.rotation));
                                    const i = .5 + 2 * (.5 - t.lifetime);
                                    n.scale(new An(i,i,i)),
                                        Zu(this, Gu, "f").setMatrixAt(e, n)
                                } else
                                    Zu(this, Gu, "f").setMatrixAt(e, Zu(this, Qu, "f"));
                            Zu(this, Gu, "f").instanceMatrix.needsUpdate = !0
                        }
                        static initResources(e) {
                            e.addResource();
                            const t = (new vo).load("images/smoke.png", ( () => {
                                    e.loadedResource()
                                }
                            ));
                            Zu(this, Hu, "f", Ku).map = t
                        }
                    }
                    Hu = Ju,
                        Vu = new WeakMap,
                        Gu = new WeakMap,
                        ju = new WeakMap,
                        Qu = new WeakMap,
                        Yu = new WeakMap,
                        qu = {
                            value: ( () => {
                                    const e = new Ds;
                                    return e.rotateX(Math.PI),
                                        e
                                }
                            )()
                        },
                        Ku = {
                            value: new ji({
                                opacity: .3,
                                depthWrite: !1,
                                transparent: !0
                            })
                        };
                    const $u = Ju;
                    var ep, tp, np, ip, rp, ap, sp, op, lp, cp, hp, dp, up, pp, fp = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, mp = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    class gp {
                        constructor(e, t, n) {
                            ep.add(this),
                                np.set(this, void 0),
                                ip.set(this, void 0),
                                rp.set(this, void 0),
                                ap.set(this, void 0),
                                sp.set(this, void 0),
                                op.set(this, void 0),
                                lp.set(this, 1e3),
                                cp.set(this, 0),
                                hp.set(this, null),
                                dp.set(this, null),
                                fp(this, np, e, "f"),
                                fp(this, ip, t, "f"),
                                fp(this, rp, n, "f");
                            const i = new sr;
                            fp(this, sp, new Float32Array(6 * mp(this, lp, "f") * 3), "f"),
                                fp(this, op, new Ki(mp(this, sp, "f"),3), "f"),
                                i.setAttribute("position", mp(this, op, "f")),
                                fp(this, ap, new wr(i,mp(tp, tp, "f", up)), "f"),
                                mp(this, ap, "f").frustumCulled = !1,
                                mp(this, np, "f").scene.add(mp(this, ap, "f"))
                        }
                        dispose() {
                            mp(this, ap, "f").geometry.dispose(),
                                mp(this, np, "f").scene.remove(mp(this, ap, "f"))
                        }
                        clear() {
                            for (let e = 0; e < mp(this, sp, "f").length; ++e)
                                mp(this, sp, "f")[e] = 0;
                            mp(this, op, "f").needsUpdate = !0,
                                fp(this, cp, 0, "f"),
                                this.break()
                        }
                        break() {
                            fp(this, hp, null, "f"),
                                fp(this, dp, null, "f")
                        }
                        spawn(e, t, n, i) {
                            var r, a;
                            const s = mp(this, hp, "f")
                                , o = mp(this, dp, "f");
                            let l = new An(e,t,n).add(new An(.172,-.3,0).applyQuaternion(i))
                                , c = new An(e,t,n).add(new An(-.172,-.3,0).applyQuaternion(i));
                            const h = new An(0,-1,0).applyQuaternion(i)
                                , d = mp(this, ep, "m", pp).call(this, l, h, 0, .05)
                                , u = mp(this, ep, "m", pp).call(this, c, h, 0, .05);
                            if (null != d && null != u) {
                                if (l = d.point,
                                    c = u.point,
                                null != s && null != o) {
                                    const e = (fp(this, cp, (a = mp(this, cp, "f"),
                                        r = a++,
                                        a), "f"),
                                        r);
                                    mp(this, sp, "f")[6 * e * 3 + 0] = l.x,
                                        mp(this, sp, "f")[6 * e * 3 + 1] = l.y,
                                        mp(this, sp, "f")[6 * e * 3 + 2] = l.z,
                                        mp(this, sp, "f")[6 * e * 3 + 3] = s.x,
                                        mp(this, sp, "f")[6 * e * 3 + 4] = s.y,
                                        mp(this, sp, "f")[6 * e * 3 + 5] = s.z,
                                        mp(this, sp, "f")[6 * e * 3 + 6] = c.x,
                                        mp(this, sp, "f")[6 * e * 3 + 7] = c.y,
                                        mp(this, sp, "f")[6 * e * 3 + 8] = c.z,
                                        mp(this, sp, "f")[6 * e * 3 + 9] = c.x,
                                        mp(this, sp, "f")[6 * e * 3 + 10] = c.y,
                                        mp(this, sp, "f")[6 * e * 3 + 11] = c.z,
                                        mp(this, sp, "f")[6 * e * 3 + 12] = s.x,
                                        mp(this, sp, "f")[6 * e * 3 + 13] = s.y,
                                        mp(this, sp, "f")[6 * e * 3 + 14] = s.z,
                                        mp(this, sp, "f")[6 * e * 3 + 15] = o.x,
                                        mp(this, sp, "f")[6 * e * 3 + 16] = o.y,
                                        mp(this, sp, "f")[6 * e * 3 + 17] = o.z,
                                        mp(this, op, "f").needsUpdate = !0,
                                    mp(this, cp, "f") >= mp(this, lp, "f") - 1 && fp(this, cp, 0, "f")
                                }
                                fp(this, hp, l, "f"),
                                    fp(this, dp, c, "f")
                            } else
                                this.break()
                        }
                    }
                    tp = gp,
                        np = new WeakMap,
                        ip = new WeakMap,
                        rp = new WeakMap,
                        ap = new WeakMap,
                        sp = new WeakMap,
                        op = new WeakMap,
                        lp = new WeakMap,
                        cp = new WeakMap,
                        hp = new WeakMap,
                        dp = new WeakMap,
                        ep = new WeakSet,
                        pp = function(e, t, n, i) {
                            const r = new jo(e,t,n,i)
                                , a = mp(this, rp, "f").shortRaycast(r);
                            if (null != a)
                                return a;
                            const s = mp(this, ip, "f").raycast(r);
                            return null != s ? s : null
                        }
                        ,
                        up = {
                            value: new ji({
                                color: 1118481,
                                side: 2,
                                polygonOffset: !0,
                                polygonOffsetFactor: -1,
                                polygonOffsetUnits: 0
                            })
                        };
                    const vp = gp;
                    var wp, Ap = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, yp = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    class bp {
                        constructor(e) {
                            if (wp.set(this, 0),
                            null != e) {
                                if (!Number.isSafeInteger(e))
                                    throw new Error("Frames is not a safe integer");
                                Ap(this, wp, e, "f")
                            }
                        }
                        get numberOfFrames() {
                            return yp(this, wp, "f")
                        }
                        get time() {
                            return yp(this, wp, "f") / 1e3
                        }
                        increment() {
                            var e;
                            Ap(this, wp, (e = yp(this, wp, "f"),
                                ++e), "f")
                        }
                        difference(e) {
                            return new bp(yp(this, wp, "f") - yp(e, wp, "f"))
                        }
                        lessThan(e) {
                            return yp(this, wp, "f") < yp(e, wp, "f")
                        }
                        greaterThan(e) {
                            return yp(this, wp, "f") > yp(e, wp, "f")
                        }
                        lessOrEqual(e) {
                            return yp(this, wp, "f") <= yp(e, wp, "f")
                        }
                        greaterOrEqual(e) {
                            return yp(this, wp, "f") >= yp(e, wp, "f")
                        }
                        equals(e) {
                            return yp(this, wp, "f") == yp(e, wp, "f")
                        }
                        isNegative() {
                            return yp(this, wp, "f") < 0
                        }
                        clone() {
                            const e = new bp;
                            return Ap(e, wp, yp(this, wp, "f"), "f"),
                                e
                        }
                    }
                    wp = new WeakMap;
                    const xp = bp;
                    function kp(e) {
                        let t = e.length;
                        for (; --t >= 0; )
                            e[t] = 0
                    }
                    const Ep = 256
                        , Sp = 286
                        , Mp = 30
                        , Tp = 15
                        , Cp = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
                        , _p = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
                        , Ip = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
                        , Pp = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
                        , Rp = new Array(576);
                    kp(Rp);
                    const Lp = new Array(60);
                    kp(Lp);
                    const Np = new Array(512);
                    kp(Np);
                    const Dp = new Array(256);
                    kp(Dp);
                    const Bp = new Array(29);
                    kp(Bp);
                    const Up = new Array(Mp);
                    function zp(e, t, n, i, r) {
                        this.static_tree = e,
                            this.extra_bits = t,
                            this.extra_base = n,
                            this.elems = i,
                            this.max_length = r,
                            this.has_stree = e && e.length
                    }
                    let Op, Fp, Wp;
                    function Hp(e, t) {
                        this.dyn_tree = e,
                            this.max_code = 0,
                            this.stat_desc = t
                    }
                    kp(Up);
                    const Vp = e => e < 256 ? Np[e] : Np[256 + (e >>> 7)]
                        , Gp = (e, t) => {
                            e.pending_buf[e.pending++] = 255 & t,
                                e.pending_buf[e.pending++] = t >>> 8 & 255
                        }
                        , jp = (e, t, n) => {
                            e.bi_valid > 16 - n ? (e.bi_buf |= t << e.bi_valid & 65535,
                                Gp(e, e.bi_buf),
                                e.bi_buf = t >> 16 - e.bi_valid,
                                e.bi_valid += n - 16) : (e.bi_buf |= t << e.bi_valid & 65535,
                                e.bi_valid += n)
                        }
                        , Qp = (e, t, n) => {
                            jp(e, n[2 * t], n[2 * t + 1])
                        }
                        , Yp = (e, t) => {
                            let n = 0;
                            do {
                                n |= 1 & e,
                                    e >>>= 1,
                                    n <<= 1
                            } while (--t > 0);
                            return n >>> 1
                        }
                        , qp = (e, t, n) => {
                            const i = new Array(16);
                            let r, a, s = 0;
                            for (r = 1; r <= Tp; r++)
                                s = s + n[r - 1] << 1,
                                    i[r] = s;
                            for (a = 0; a <= t; a++) {
                                let t = e[2 * a + 1];
                                0 !== t && (e[2 * a] = Yp(i[t]++, t))
                            }
                        }
                        , Kp = e => {
                            let t;
                            for (t = 0; t < Sp; t++)
                                e.dyn_ltree[2 * t] = 0;
                            for (t = 0; t < Mp; t++)
                                e.dyn_dtree[2 * t] = 0;
                            for (t = 0; t < 19; t++)
                                e.bl_tree[2 * t] = 0;
                            e.dyn_ltree[512] = 1,
                                e.opt_len = e.static_len = 0,
                                e.sym_next = e.matches = 0
                        }
                        , Xp = e => {
                            e.bi_valid > 8 ? Gp(e, e.bi_buf) : e.bi_valid > 0 && (e.pending_buf[e.pending++] = e.bi_buf),
                                e.bi_buf = 0,
                                e.bi_valid = 0
                        }
                        , Zp = (e, t, n, i) => {
                            const r = 2 * t
                                , a = 2 * n;
                            return e[r] < e[a] || e[r] === e[a] && i[t] <= i[n]
                        }
                        , Jp = (e, t, n) => {
                            const i = e.heap[n];
                            let r = n << 1;
                            for (; r <= e.heap_len && (r < e.heap_len && Zp(t, e.heap[r + 1], e.heap[r], e.depth) && r++,
                                !Zp(t, i, e.heap[r], e.depth)); )
                                e.heap[n] = e.heap[r],
                                    n = r,
                                    r <<= 1;
                            e.heap[n] = i
                        }
                        , $p = (e, t, n) => {
                            let i, r, a, s, o = 0;
                            if (0 !== e.sym_next)
                                do {
                                    i = 255 & e.pending_buf[e.sym_buf + o++],
                                        i += (255 & e.pending_buf[e.sym_buf + o++]) << 8,
                                        r = e.pending_buf[e.sym_buf + o++],
                                        0 === i ? Qp(e, r, t) : (a = Dp[r],
                                            Qp(e, a + Ep + 1, t),
                                            s = Cp[a],
                                        0 !== s && (r -= Bp[a],
                                            jp(e, r, s)),
                                            i--,
                                            a = Vp(i),
                                            Qp(e, a, n),
                                            s = _p[a],
                                        0 !== s && (i -= Up[a],
                                            jp(e, i, s)))
                                } while (o < e.sym_next);
                            Qp(e, 256, t)
                        }
                        , ef = (e, t) => {
                            const n = t.dyn_tree
                                , i = t.stat_desc.static_tree
                                , r = t.stat_desc.has_stree
                                , a = t.stat_desc.elems;
                            let s, o, l, c = -1;
                            for (e.heap_len = 0,
                                     e.heap_max = 573,
                                     s = 0; s < a; s++)
                                0 !== n[2 * s] ? (e.heap[++e.heap_len] = c = s,
                                    e.depth[s] = 0) : n[2 * s + 1] = 0;
                            for (; e.heap_len < 2; )
                                l = e.heap[++e.heap_len] = c < 2 ? ++c : 0,
                                    n[2 * l] = 1,
                                    e.depth[l] = 0,
                                    e.opt_len--,
                                r && (e.static_len -= i[2 * l + 1]);
                            for (t.max_code = c,
                                     s = e.heap_len >> 1; s >= 1; s--)
                                Jp(e, n, s);
                            l = a;
                            do {
                                s = e.heap[1],
                                    e.heap[1] = e.heap[e.heap_len--],
                                    Jp(e, n, 1),
                                    o = e.heap[1],
                                    e.heap[--e.heap_max] = s,
                                    e.heap[--e.heap_max] = o,
                                    n[2 * l] = n[2 * s] + n[2 * o],
                                    e.depth[l] = (e.depth[s] >= e.depth[o] ? e.depth[s] : e.depth[o]) + 1,
                                    n[2 * s + 1] = n[2 * o + 1] = l,
                                    e.heap[1] = l++,
                                    Jp(e, n, 1)
                            } while (e.heap_len >= 2);
                            e.heap[--e.heap_max] = e.heap[1],
                                ( (e, t) => {
                                        const n = t.dyn_tree
                                            , i = t.max_code
                                            , r = t.stat_desc.static_tree
                                            , a = t.stat_desc.has_stree
                                            , s = t.stat_desc.extra_bits
                                            , o = t.stat_desc.extra_base
                                            , l = t.stat_desc.max_length;
                                        let c, h, d, u, p, f, m = 0;
                                        for (u = 0; u <= Tp; u++)
                                            e.bl_count[u] = 0;
                                        for (n[2 * e.heap[e.heap_max] + 1] = 0,
                                                 c = e.heap_max + 1; c < 573; c++)
                                            h = e.heap[c],
                                                u = n[2 * n[2 * h + 1] + 1] + 1,
                                            u > l && (u = l,
                                                m++),
                                                n[2 * h + 1] = u,
                                            h > i || (e.bl_count[u]++,
                                                p = 0,
                                            h >= o && (p = s[h - o]),
                                                f = n[2 * h],
                                                e.opt_len += f * (u + p),
                                            a && (e.static_len += f * (r[2 * h + 1] + p)));
                                        if (0 !== m) {
                                            do {
                                                for (u = l - 1; 0 === e.bl_count[u]; )
                                                    u--;
                                                e.bl_count[u]--,
                                                    e.bl_count[u + 1] += 2,
                                                    e.bl_count[l]--,
                                                    m -= 2
                                            } while (m > 0);
                                            for (u = l; 0 !== u; u--)
                                                for (h = e.bl_count[u]; 0 !== h; )
                                                    d = e.heap[--c],
                                                    d > i || (n[2 * d + 1] !== u && (e.opt_len += (u - n[2 * d + 1]) * n[2 * d],
                                                        n[2 * d + 1] = u),
                                                        h--)
                                        }
                                    }
                                )(e, t),
                                qp(n, c, e.bl_count)
                        }
                        , tf = (e, t, n) => {
                            let i, r, a = -1, s = t[1], o = 0, l = 7, c = 4;
                            for (0 === s && (l = 138,
                                c = 3),
                                     t[2 * (n + 1) + 1] = 65535,
                                     i = 0; i <= n; i++)
                                r = s,
                                    s = t[2 * (i + 1) + 1],
                                ++o < l && r === s || (o < c ? e.bl_tree[2 * r] += o : 0 !== r ? (r !== a && e.bl_tree[2 * r]++,
                                    e.bl_tree[32]++) : o <= 10 ? e.bl_tree[34]++ : e.bl_tree[36]++,
                                    o = 0,
                                    a = r,
                                    0 === s ? (l = 138,
                                        c = 3) : r === s ? (l = 6,
                                        c = 3) : (l = 7,
                                        c = 4))
                        }
                        , nf = (e, t, n) => {
                            let i, r, a = -1, s = t[1], o = 0, l = 7, c = 4;
                            for (0 === s && (l = 138,
                                c = 3),
                                     i = 0; i <= n; i++)
                                if (r = s,
                                    s = t[2 * (i + 1) + 1],
                                    !(++o < l && r === s)) {
                                    if (o < c)
                                        do {
                                            Qp(e, r, e.bl_tree)
                                        } while (0 != --o);
                                    else
                                        0 !== r ? (r !== a && (Qp(e, r, e.bl_tree),
                                            o--),
                                            Qp(e, 16, e.bl_tree),
                                            jp(e, o - 3, 2)) : o <= 10 ? (Qp(e, 17, e.bl_tree),
                                            jp(e, o - 3, 3)) : (Qp(e, 18, e.bl_tree),
                                            jp(e, o - 11, 7));
                                    o = 0,
                                        a = r,
                                        0 === s ? (l = 138,
                                            c = 3) : r === s ? (l = 6,
                                            c = 3) : (l = 7,
                                            c = 4)
                                }
                        }
                    ;
                    let rf = !1;
                    const af = (e, t, n, i) => {
                            jp(e, 0 + (i ? 1 : 0), 3),
                                Xp(e),
                                Gp(e, n),
                                Gp(e, ~n),
                            n && e.pending_buf.set(e.window.subarray(t, t + n), e.pending),
                                e.pending += n
                        }
                    ;
                    var sf = (e, t, n, i) => {
                        let r, a, s = 0;
                        e.level > 0 ? (2 === e.strm.data_type && (e.strm.data_type = (e => {
                                let t, n = 4093624447;
                                for (t = 0; t <= 31; t++,
                                    n >>>= 1)
                                    if (1 & n && 0 !== e.dyn_ltree[2 * t])
                                        return 0;
                                if (0 !== e.dyn_ltree[18] || 0 !== e.dyn_ltree[20] || 0 !== e.dyn_ltree[26])
                                    return 1;
                                for (t = 32; t < Ep; t++)
                                    if (0 !== e.dyn_ltree[2 * t])
                                        return 1;
                                return 0
                            }
                        )(e)),
                            ef(e, e.l_desc),
                            ef(e, e.d_desc),
                            s = (e => {
                                    let t;
                                    for (tf(e, e.dyn_ltree, e.l_desc.max_code),
                                             tf(e, e.dyn_dtree, e.d_desc.max_code),
                                             ef(e, e.bl_desc),
                                             t = 18; t >= 3 && 0 === e.bl_tree[2 * Pp[t] + 1]; t--)
                                        ;
                                    return e.opt_len += 3 * (t + 1) + 5 + 5 + 4,
                                        t
                                }
                            )(e),
                            r = e.opt_len + 3 + 7 >>> 3,
                            a = e.static_len + 3 + 7 >>> 3,
                        a <= r && (r = a)) : r = a = n + 5,
                            n + 4 <= r && -1 !== t ? af(e, t, n, i) : 4 === e.strategy || a === r ? (jp(e, 2 + (i ? 1 : 0), 3),
                                $p(e, Rp, Lp)) : (jp(e, 4 + (i ? 1 : 0), 3),
                                ( (e, t, n, i) => {
                                        let r;
                                        for (jp(e, t - 257, 5),
                                                 jp(e, n - 1, 5),
                                                 jp(e, i - 4, 4),
                                                 r = 0; r < i; r++)
                                            jp(e, e.bl_tree[2 * Pp[r] + 1], 3);
                                        nf(e, e.dyn_ltree, t - 1),
                                            nf(e, e.dyn_dtree, n - 1)
                                    }
                                )(e, e.l_desc.max_code + 1, e.d_desc.max_code + 1, s + 1),
                                $p(e, e.dyn_ltree, e.dyn_dtree)),
                            Kp(e),
                        i && Xp(e)
                    }
                        , of = {
                        _tr_init: e => {
                            rf || (( () => {
                                    let e, t, n, i, r;
                                    const a = new Array(16);
                                    for (n = 0,
                                             i = 0; i < 28; i++)
                                        for (Bp[i] = n,
                                                 e = 0; e < 1 << Cp[i]; e++)
                                            Dp[n++] = i;
                                    for (Dp[n - 1] = i,
                                             r = 0,
                                             i = 0; i < 16; i++)
                                        for (Up[i] = r,
                                                 e = 0; e < 1 << _p[i]; e++)
                                            Np[r++] = i;
                                    for (r >>= 7; i < Mp; i++)
                                        for (Up[i] = r << 7,
                                                 e = 0; e < 1 << _p[i] - 7; e++)
                                            Np[256 + r++] = i;
                                    for (t = 0; t <= Tp; t++)
                                        a[t] = 0;
                                    for (e = 0; e <= 143; )
                                        Rp[2 * e + 1] = 8,
                                            e++,
                                            a[8]++;
                                    for (; e <= 255; )
                                        Rp[2 * e + 1] = 9,
                                            e++,
                                            a[9]++;
                                    for (; e <= 279; )
                                        Rp[2 * e + 1] = 7,
                                            e++,
                                            a[7]++;
                                    for (; e <= 287; )
                                        Rp[2 * e + 1] = 8,
                                            e++,
                                            a[8]++;
                                    for (qp(Rp, 287, a),
                                             e = 0; e < Mp; e++)
                                        Lp[2 * e + 1] = 5,
                                            Lp[2 * e] = Yp(e, 5);
                                    Op = new zp(Rp,Cp,257,Sp,Tp),
                                        Fp = new zp(Lp,_p,0,Mp,Tp),
                                        Wp = new zp(new Array(0),Ip,0,19,7)
                                }
                            )(),
                                rf = !0),
                                e.l_desc = new Hp(e.dyn_ltree,Op),
                                e.d_desc = new Hp(e.dyn_dtree,Fp),
                                e.bl_desc = new Hp(e.bl_tree,Wp),
                                e.bi_buf = 0,
                                e.bi_valid = 0,
                                Kp(e)
                        }
                        ,
                        _tr_stored_block: af,
                        _tr_flush_block: sf,
                        _tr_tally: (e, t, n) => (e.pending_buf[e.sym_buf + e.sym_next++] = t,
                            e.pending_buf[e.sym_buf + e.sym_next++] = t >> 8,
                            e.pending_buf[e.sym_buf + e.sym_next++] = n,
                            0 === t ? e.dyn_ltree[2 * n]++ : (e.matches++,
                                t--,
                                e.dyn_ltree[2 * (Dp[n] + Ep + 1)]++,
                                e.dyn_dtree[2 * Vp(t)]++),
                        e.sym_next === e.sym_end),
                        _tr_align: e => {
                            jp(e, 2, 3),
                                Qp(e, 256, Rp),
                                (e => {
                                        16 === e.bi_valid ? (Gp(e, e.bi_buf),
                                            e.bi_buf = 0,
                                            e.bi_valid = 0) : e.bi_valid >= 8 && (e.pending_buf[e.pending++] = 255 & e.bi_buf,
                                            e.bi_buf >>= 8,
                                            e.bi_valid -= 8)
                                    }
                                )(e)
                        }
                    };
                    var lf = (e, t, n, i) => {
                            let r = 65535 & e
                                , a = e >>> 16 & 65535
                                , s = 0;
                            for (; 0 !== n; ) {
                                s = n > 2e3 ? 2e3 : n,
                                    n -= s;
                                do {
                                    r = r + t[i++] | 0,
                                        a = a + r | 0
                                } while (--s);
                                r %= 65521,
                                    a %= 65521
                            }
                            return r | a << 16
                        }
                    ;
                    const cf = new Uint32Array(( () => {
                            let e, t = [];
                            for (var n = 0; n < 256; n++) {
                                e = n;
                                for (var i = 0; i < 8; i++)
                                    e = 1 & e ? 3988292384 ^ e >>> 1 : e >>> 1;
                                t[n] = e
                            }
                            return t
                        }
                    )());
                    var hf = (e, t, n, i) => {
                        const r = cf
                            , a = i + n;
                        e ^= -1;
                        for (let n = i; n < a; n++)
                            e = e >>> 8 ^ r[255 & (e ^ t[n])];
                        return ~e
                    }
                        , df = {
                        2: "need dictionary",
                        1: "stream end",
                        0: "",
                        "-1": "file error",
                        "-2": "stream error",
                        "-3": "data error",
                        "-4": "insufficient memory",
                        "-5": "buffer error",
                        "-6": "incompatible version"
                    }
                        , uf = {
                        Z_NO_FLUSH: 0,
                        Z_PARTIAL_FLUSH: 1,
                        Z_SYNC_FLUSH: 2,
                        Z_FULL_FLUSH: 3,
                        Z_FINISH: 4,
                        Z_BLOCK: 5,
                        Z_TREES: 6,
                        Z_OK: 0,
                        Z_STREAM_END: 1,
                        Z_NEED_DICT: 2,
                        Z_ERRNO: -1,
                        Z_STREAM_ERROR: -2,
                        Z_DATA_ERROR: -3,
                        Z_MEM_ERROR: -4,
                        Z_BUF_ERROR: -5,
                        Z_NO_COMPRESSION: 0,
                        Z_BEST_SPEED: 1,
                        Z_BEST_COMPRESSION: 9,
                        Z_DEFAULT_COMPRESSION: -1,
                        Z_FILTERED: 1,
                        Z_HUFFMAN_ONLY: 2,
                        Z_RLE: 3,
                        Z_FIXED: 4,
                        Z_DEFAULT_STRATEGY: 0,
                        Z_BINARY: 0,
                        Z_TEXT: 1,
                        Z_UNKNOWN: 2,
                        Z_DEFLATED: 8
                    };
                    const {_tr_init: pf, _tr_stored_block: ff, _tr_flush_block: mf, _tr_tally: gf, _tr_align: vf} = of
                        , {Z_NO_FLUSH: wf, Z_PARTIAL_FLUSH: Af, Z_FULL_FLUSH: yf, Z_FINISH: bf, Z_BLOCK: xf, Z_OK: kf, Z_STREAM_END: Ef, Z_STREAM_ERROR: Sf, Z_DATA_ERROR: Mf, Z_BUF_ERROR: Tf, Z_DEFAULT_COMPRESSION: Cf, Z_FILTERED: _f, Z_HUFFMAN_ONLY: If, Z_RLE: Pf, Z_FIXED: Rf, Z_DEFAULT_STRATEGY: Lf, Z_UNKNOWN: Nf, Z_DEFLATED: Df} = uf
                        , Bf = 258
                        , Uf = 262
                        , zf = 42
                        , Of = 113
                        , Ff = 666
                        , Wf = (e, t) => (e.msg = df[t],
                            t)
                        , Hf = e => 2 * e - (e > 4 ? 9 : 0)
                        , Vf = e => {
                            let t = e.length;
                            for (; --t >= 0; )
                                e[t] = 0
                        }
                        , Gf = e => {
                            let t, n, i, r = e.w_size;
                            t = e.hash_size,
                                i = t;
                            do {
                                n = e.head[--i],
                                    e.head[i] = n >= r ? n - r : 0
                            } while (--t);
                            t = r,
                                i = t;
                            do {
                                n = e.prev[--i],
                                    e.prev[i] = n >= r ? n - r : 0
                            } while (--t)
                        }
                    ;
                    let jf = (e, t, n) => (t << e.hash_shift ^ n) & e.hash_mask;
                    const Qf = e => {
                            const t = e.state;
                            let n = t.pending;
                            n > e.avail_out && (n = e.avail_out),
                            0 !== n && (e.output.set(t.pending_buf.subarray(t.pending_out, t.pending_out + n), e.next_out),
                                e.next_out += n,
                                t.pending_out += n,
                                e.total_out += n,
                                e.avail_out -= n,
                                t.pending -= n,
                            0 === t.pending && (t.pending_out = 0))
                        }
                        , Yf = (e, t) => {
                            mf(e, e.block_start >= 0 ? e.block_start : -1, e.strstart - e.block_start, t),
                                e.block_start = e.strstart,
                                Qf(e.strm)
                        }
                        , qf = (e, t) => {
                            e.pending_buf[e.pending++] = t
                        }
                        , Kf = (e, t) => {
                            e.pending_buf[e.pending++] = t >>> 8 & 255,
                                e.pending_buf[e.pending++] = 255 & t
                        }
                        , Xf = (e, t, n, i) => {
                            let r = e.avail_in;
                            return r > i && (r = i),
                                0 === r ? 0 : (e.avail_in -= r,
                                    t.set(e.input.subarray(e.next_in, e.next_in + r), n),
                                    1 === e.state.wrap ? e.adler = lf(e.adler, t, r, n) : 2 === e.state.wrap && (e.adler = hf(e.adler, t, r, n)),
                                    e.next_in += r,
                                    e.total_in += r,
                                    r)
                        }
                        , Zf = (e, t) => {
                            let n, i, r = e.max_chain_length, a = e.strstart, s = e.prev_length, o = e.nice_match;
                            const l = e.strstart > e.w_size - Uf ? e.strstart - (e.w_size - Uf) : 0
                                , c = e.window
                                , h = e.w_mask
                                , d = e.prev
                                , u = e.strstart + Bf;
                            let p = c[a + s - 1]
                                , f = c[a + s];
                            e.prev_length >= e.good_match && (r >>= 2),
                            o > e.lookahead && (o = e.lookahead);
                            do {
                                if (n = t,
                                c[n + s] === f && c[n + s - 1] === p && c[n] === c[a] && c[++n] === c[a + 1]) {
                                    a += 2,
                                        n++;
                                    do {} while (c[++a] === c[++n] && c[++a] === c[++n] && c[++a] === c[++n] && c[++a] === c[++n] && c[++a] === c[++n] && c[++a] === c[++n] && c[++a] === c[++n] && c[++a] === c[++n] && a < u);
                                    if (i = Bf - (u - a),
                                        a = u - Bf,
                                    i > s) {
                                        if (e.match_start = t,
                                            s = i,
                                        i >= o)
                                            break;
                                        p = c[a + s - 1],
                                            f = c[a + s]
                                    }
                                }
                            } while ((t = d[t & h]) > l && 0 != --r);
                            return s <= e.lookahead ? s : e.lookahead
                        }
                        , Jf = e => {
                            const t = e.w_size;
                            let n, i, r;
                            do {
                                if (i = e.window_size - e.lookahead - e.strstart,
                                e.strstart >= t + (t - Uf) && (e.window.set(e.window.subarray(t, t + t - i), 0),
                                    e.match_start -= t,
                                    e.strstart -= t,
                                    e.block_start -= t,
                                e.insert > e.strstart && (e.insert = e.strstart),
                                    Gf(e),
                                    i += t),
                                0 === e.strm.avail_in)
                                    break;
                                if (n = Xf(e.strm, e.window, e.strstart + e.lookahead, i),
                                    e.lookahead += n,
                                e.lookahead + e.insert >= 3)
                                    for (r = e.strstart - e.insert,
                                             e.ins_h = e.window[r],
                                             e.ins_h = jf(e, e.ins_h, e.window[r + 1]); e.insert && (e.ins_h = jf(e, e.ins_h, e.window[r + 3 - 1]),
                                        e.prev[r & e.w_mask] = e.head[e.ins_h],
                                        e.head[e.ins_h] = r,
                                        r++,
                                        e.insert--,
                                        !(e.lookahead + e.insert < 3)); )
                                        ;
                            } while (e.lookahead < Uf && 0 !== e.strm.avail_in)
                        }
                        , $f = (e, t) => {
                            let n, i, r, a = e.pending_buf_size - 5 > e.w_size ? e.w_size : e.pending_buf_size - 5, s = 0, o = e.strm.avail_in;
                            do {
                                if (n = 65535,
                                    r = e.bi_valid + 42 >> 3,
                                e.strm.avail_out < r)
                                    break;
                                if (r = e.strm.avail_out - r,
                                    i = e.strstart - e.block_start,
                                n > i + e.strm.avail_in && (n = i + e.strm.avail_in),
                                n > r && (n = r),
                                n < a && (0 === n && t !== bf || t === wf || n !== i + e.strm.avail_in))
                                    break;
                                s = t === bf && n === i + e.strm.avail_in ? 1 : 0,
                                    ff(e, 0, 0, s),
                                    e.pending_buf[e.pending - 4] = n,
                                    e.pending_buf[e.pending - 3] = n >> 8,
                                    e.pending_buf[e.pending - 2] = ~n,
                                    e.pending_buf[e.pending - 1] = ~n >> 8,
                                    Qf(e.strm),
                                i && (i > n && (i = n),
                                    e.strm.output.set(e.window.subarray(e.block_start, e.block_start + i), e.strm.next_out),
                                    e.strm.next_out += i,
                                    e.strm.avail_out -= i,
                                    e.strm.total_out += i,
                                    e.block_start += i,
                                    n -= i),
                                n && (Xf(e.strm, e.strm.output, e.strm.next_out, n),
                                    e.strm.next_out += n,
                                    e.strm.avail_out -= n,
                                    e.strm.total_out += n)
                            } while (0 === s);
                            return o -= e.strm.avail_in,
                            o && (o >= e.w_size ? (e.matches = 2,
                                e.window.set(e.strm.input.subarray(e.strm.next_in - e.w_size, e.strm.next_in), 0),
                                e.strstart = e.w_size,
                                e.insert = e.strstart) : (e.window_size - e.strstart <= o && (e.strstart -= e.w_size,
                                e.window.set(e.window.subarray(e.w_size, e.w_size + e.strstart), 0),
                            e.matches < 2 && e.matches++,
                            e.insert > e.strstart && (e.insert = e.strstart)),
                                e.window.set(e.strm.input.subarray(e.strm.next_in - o, e.strm.next_in), e.strstart),
                                e.strstart += o,
                                e.insert += o > e.w_size - e.insert ? e.w_size - e.insert : o),
                                e.block_start = e.strstart),
                            e.high_water < e.strstart && (e.high_water = e.strstart),
                                s ? 4 : t !== wf && t !== bf && 0 === e.strm.avail_in && e.strstart === e.block_start ? 2 : (r = e.window_size - e.strstart,
                                e.strm.avail_in > r && e.block_start >= e.w_size && (e.block_start -= e.w_size,
                                    e.strstart -= e.w_size,
                                    e.window.set(e.window.subarray(e.w_size, e.w_size + e.strstart), 0),
                                e.matches < 2 && e.matches++,
                                    r += e.w_size,
                                e.insert > e.strstart && (e.insert = e.strstart)),
                                r > e.strm.avail_in && (r = e.strm.avail_in),
                                r && (Xf(e.strm, e.window, e.strstart, r),
                                    e.strstart += r,
                                    e.insert += r > e.w_size - e.insert ? e.w_size - e.insert : r),
                                e.high_water < e.strstart && (e.high_water = e.strstart),
                                    r = e.bi_valid + 42 >> 3,
                                    r = e.pending_buf_size - r > 65535 ? 65535 : e.pending_buf_size - r,
                                    a = r > e.w_size ? e.w_size : r,
                                    i = e.strstart - e.block_start,
                                (i >= a || (i || t === bf) && t !== wf && 0 === e.strm.avail_in && i <= r) && (n = i > r ? r : i,
                                    s = t === bf && 0 === e.strm.avail_in && n === i ? 1 : 0,
                                    ff(e, e.block_start, n, s),
                                    e.block_start += n,
                                    Qf(e.strm)),
                                    s ? 3 : 1)
                        }
                        , em = (e, t) => {
                            let n, i;
                            for (; ; ) {
                                if (e.lookahead < Uf) {
                                    if (Jf(e),
                                    e.lookahead < Uf && t === wf)
                                        return 1;
                                    if (0 === e.lookahead)
                                        break
                                }
                                if (n = 0,
                                e.lookahead >= 3 && (e.ins_h = jf(e, e.ins_h, e.window[e.strstart + 3 - 1]),
                                    n = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h],
                                    e.head[e.ins_h] = e.strstart),
                                0 !== n && e.strstart - n <= e.w_size - Uf && (e.match_length = Zf(e, n)),
                                e.match_length >= 3)
                                    if (i = gf(e, e.strstart - e.match_start, e.match_length - 3),
                                        e.lookahead -= e.match_length,
                                    e.match_length <= e.max_lazy_match && e.lookahead >= 3) {
                                        e.match_length--;
                                        do {
                                            e.strstart++,
                                                e.ins_h = jf(e, e.ins_h, e.window[e.strstart + 3 - 1]),
                                                n = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h],
                                                e.head[e.ins_h] = e.strstart
                                        } while (0 != --e.match_length);
                                        e.strstart++
                                    } else
                                        e.strstart += e.match_length,
                                            e.match_length = 0,
                                            e.ins_h = e.window[e.strstart],
                                            e.ins_h = jf(e, e.ins_h, e.window[e.strstart + 1]);
                                else
                                    i = gf(e, 0, e.window[e.strstart]),
                                        e.lookahead--,
                                        e.strstart++;
                                if (i && (Yf(e, !1),
                                0 === e.strm.avail_out))
                                    return 1
                            }
                            return e.insert = e.strstart < 2 ? e.strstart : 2,
                                t === bf ? (Yf(e, !0),
                                    0 === e.strm.avail_out ? 3 : 4) : e.sym_next && (Yf(e, !1),
                                0 === e.strm.avail_out) ? 1 : 2
                        }
                        , tm = (e, t) => {
                            let n, i, r;
                            for (; ; ) {
                                if (e.lookahead < Uf) {
                                    if (Jf(e),
                                    e.lookahead < Uf && t === wf)
                                        return 1;
                                    if (0 === e.lookahead)
                                        break
                                }
                                if (n = 0,
                                e.lookahead >= 3 && (e.ins_h = jf(e, e.ins_h, e.window[e.strstart + 3 - 1]),
                                    n = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h],
                                    e.head[e.ins_h] = e.strstart),
                                    e.prev_length = e.match_length,
                                    e.prev_match = e.match_start,
                                    e.match_length = 2,
                                0 !== n && e.prev_length < e.max_lazy_match && e.strstart - n <= e.w_size - Uf && (e.match_length = Zf(e, n),
                                e.match_length <= 5 && (e.strategy === _f || 3 === e.match_length && e.strstart - e.match_start > 4096) && (e.match_length = 2)),
                                e.prev_length >= 3 && e.match_length <= e.prev_length) {
                                    r = e.strstart + e.lookahead - 3,
                                        i = gf(e, e.strstart - 1 - e.prev_match, e.prev_length - 3),
                                        e.lookahead -= e.prev_length - 1,
                                        e.prev_length -= 2;
                                    do {
                                        ++e.strstart <= r && (e.ins_h = jf(e, e.ins_h, e.window[e.strstart + 3 - 1]),
                                            n = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h],
                                            e.head[e.ins_h] = e.strstart)
                                    } while (0 != --e.prev_length);
                                    if (e.match_available = 0,
                                        e.match_length = 2,
                                        e.strstart++,
                                    i && (Yf(e, !1),
                                    0 === e.strm.avail_out))
                                        return 1
                                } else if (e.match_available) {
                                    if (i = gf(e, 0, e.window[e.strstart - 1]),
                                    i && Yf(e, !1),
                                        e.strstart++,
                                        e.lookahead--,
                                    0 === e.strm.avail_out)
                                        return 1
                                } else
                                    e.match_available = 1,
                                        e.strstart++,
                                        e.lookahead--
                            }
                            return e.match_available && (i = gf(e, 0, e.window[e.strstart - 1]),
                                e.match_available = 0),
                                e.insert = e.strstart < 2 ? e.strstart : 2,
                                t === bf ? (Yf(e, !0),
                                    0 === e.strm.avail_out ? 3 : 4) : e.sym_next && (Yf(e, !1),
                                0 === e.strm.avail_out) ? 1 : 2
                        }
                    ;
                    function nm(e, t, n, i, r) {
                        this.good_length = e,
                            this.max_lazy = t,
                            this.nice_length = n,
                            this.max_chain = i,
                            this.func = r
                    }
                    const im = [new nm(0,0,0,0,$f), new nm(4,4,8,4,em), new nm(4,5,16,8,em), new nm(4,6,32,32,em), new nm(4,4,16,16,tm), new nm(8,16,32,32,tm), new nm(8,16,128,128,tm), new nm(8,32,128,256,tm), new nm(32,128,258,1024,tm), new nm(32,258,258,4096,tm)];
                    function rm() {
                        this.strm = null,
                            this.status = 0,
                            this.pending_buf = null,
                            this.pending_buf_size = 0,
                            this.pending_out = 0,
                            this.pending = 0,
                            this.wrap = 0,
                            this.gzhead = null,
                            this.gzindex = 0,
                            this.method = Df,
                            this.last_flush = -1,
                            this.w_size = 0,
                            this.w_bits = 0,
                            this.w_mask = 0,
                            this.window = null,
                            this.window_size = 0,
                            this.prev = null,
                            this.head = null,
                            this.ins_h = 0,
                            this.hash_size = 0,
                            this.hash_bits = 0,
                            this.hash_mask = 0,
                            this.hash_shift = 0,
                            this.block_start = 0,
                            this.match_length = 0,
                            this.prev_match = 0,
                            this.match_available = 0,
                            this.strstart = 0,
                            this.match_start = 0,
                            this.lookahead = 0,
                            this.prev_length = 0,
                            this.max_chain_length = 0,
                            this.max_lazy_match = 0,
                            this.level = 0,
                            this.strategy = 0,
                            this.good_match = 0,
                            this.nice_match = 0,
                            this.dyn_ltree = new Uint16Array(1146),
                            this.dyn_dtree = new Uint16Array(122),
                            this.bl_tree = new Uint16Array(78),
                            Vf(this.dyn_ltree),
                            Vf(this.dyn_dtree),
                            Vf(this.bl_tree),
                            this.l_desc = null,
                            this.d_desc = null,
                            this.bl_desc = null,
                            this.bl_count = new Uint16Array(16),
                            this.heap = new Uint16Array(573),
                            Vf(this.heap),
                            this.heap_len = 0,
                            this.heap_max = 0,
                            this.depth = new Uint16Array(573),
                            Vf(this.depth),
                            this.sym_buf = 0,
                            this.lit_bufsize = 0,
                            this.sym_next = 0,
                            this.sym_end = 0,
                            this.opt_len = 0,
                            this.static_len = 0,
                            this.matches = 0,
                            this.insert = 0,
                            this.bi_buf = 0,
                            this.bi_valid = 0
                    }
                    const am = e => {
                            if (!e)
                                return 1;
                            const t = e.state;
                            return !t || t.strm !== e || t.status !== zf && 57 !== t.status && 69 !== t.status && 73 !== t.status && 91 !== t.status && 103 !== t.status && t.status !== Of && t.status !== Ff ? 1 : 0
                        }
                        , sm = e => {
                            if (am(e))
                                return Wf(e, Sf);
                            e.total_in = e.total_out = 0,
                                e.data_type = Nf;
                            const t = e.state;
                            return t.pending = 0,
                                t.pending_out = 0,
                            t.wrap < 0 && (t.wrap = -t.wrap),
                                t.status = 2 === t.wrap ? 57 : t.wrap ? zf : Of,
                                e.adler = 2 === t.wrap ? 0 : 1,
                                t.last_flush = -2,
                                pf(t),
                                kf
                        }
                        , om = e => {
                            const t = sm(e);
                            var n;
                            return t === kf && ((n = e.state).window_size = 2 * n.w_size,
                                Vf(n.head),
                                n.max_lazy_match = im[n.level].max_lazy,
                                n.good_match = im[n.level].good_length,
                                n.nice_match = im[n.level].nice_length,
                                n.max_chain_length = im[n.level].max_chain,
                                n.strstart = 0,
                                n.block_start = 0,
                                n.lookahead = 0,
                                n.insert = 0,
                                n.match_length = n.prev_length = 2,
                                n.match_available = 0,
                                n.ins_h = 0),
                                t
                        }
                        , lm = (e, t, n, i, r, a) => {
                            if (!e)
                                return Sf;
                            let s = 1;
                            if (t === Cf && (t = 6),
                                i < 0 ? (s = 0,
                                    i = -i) : i > 15 && (s = 2,
                                    i -= 16),
                            r < 1 || r > 9 || n !== Df || i < 8 || i > 15 || t < 0 || t > 9 || a < 0 || a > Rf || 8 === i && 1 !== s)
                                return Wf(e, Sf);
                            8 === i && (i = 9);
                            const o = new rm;
                            return e.state = o,
                                o.strm = e,
                                o.status = zf,
                                o.wrap = s,
                                o.gzhead = null,
                                o.w_bits = i,
                                o.w_size = 1 << o.w_bits,
                                o.w_mask = o.w_size - 1,
                                o.hash_bits = r + 7,
                                o.hash_size = 1 << o.hash_bits,
                                o.hash_mask = o.hash_size - 1,
                                o.hash_shift = ~~((o.hash_bits + 3 - 1) / 3),
                                o.window = new Uint8Array(2 * o.w_size),
                                o.head = new Uint16Array(o.hash_size),
                                o.prev = new Uint16Array(o.w_size),
                                o.lit_bufsize = 1 << r + 6,
                                o.pending_buf_size = 4 * o.lit_bufsize,
                                o.pending_buf = new Uint8Array(o.pending_buf_size),
                                o.sym_buf = o.lit_bufsize,
                                o.sym_end = 3 * (o.lit_bufsize - 1),
                                o.level = t,
                                o.strategy = a,
                                o.method = n,
                                om(e)
                        }
                    ;
                    var cm = {
                        deflateInit: (e, t) => lm(e, t, Df, 15, 8, Lf),
                        deflateInit2: lm,
                        deflateReset: om,
                        deflateResetKeep: sm,
                        deflateSetHeader: (e, t) => am(e) || 2 !== e.state.wrap ? Sf : (e.state.gzhead = t,
                            kf),
                        deflate: (e, t) => {
                            if (am(e) || t > xf || t < 0)
                                return e ? Wf(e, Sf) : Sf;
                            const n = e.state;
                            if (!e.output || 0 !== e.avail_in && !e.input || n.status === Ff && t !== bf)
                                return Wf(e, 0 === e.avail_out ? Tf : Sf);
                            const i = n.last_flush;
                            if (n.last_flush = t,
                            0 !== n.pending) {
                                if (Qf(e),
                                0 === e.avail_out)
                                    return n.last_flush = -1,
                                        kf
                            } else if (0 === e.avail_in && Hf(t) <= Hf(i) && t !== bf)
                                return Wf(e, Tf);
                            if (n.status === Ff && 0 !== e.avail_in)
                                return Wf(e, Tf);
                            if (n.status === zf && 0 === n.wrap && (n.status = Of),
                            n.status === zf) {
                                let t = Df + (n.w_bits - 8 << 4) << 8
                                    , i = -1;
                                if (i = n.strategy >= If || n.level < 2 ? 0 : n.level < 6 ? 1 : 6 === n.level ? 2 : 3,
                                    t |= i << 6,
                                0 !== n.strstart && (t |= 32),
                                    t += 31 - t % 31,
                                    Kf(n, t),
                                0 !== n.strstart && (Kf(n, e.adler >>> 16),
                                    Kf(n, 65535 & e.adler)),
                                    e.adler = 1,
                                    n.status = Of,
                                    Qf(e),
                                0 !== n.pending)
                                    return n.last_flush = -1,
                                        kf
                            }
                            if (57 === n.status)
                                if (e.adler = 0,
                                    qf(n, 31),
                                    qf(n, 139),
                                    qf(n, 8),
                                    n.gzhead)
                                    qf(n, (n.gzhead.text ? 1 : 0) + (n.gzhead.hcrc ? 2 : 0) + (n.gzhead.extra ? 4 : 0) + (n.gzhead.name ? 8 : 0) + (n.gzhead.comment ? 16 : 0)),
                                        qf(n, 255 & n.gzhead.time),
                                        qf(n, n.gzhead.time >> 8 & 255),
                                        qf(n, n.gzhead.time >> 16 & 255),
                                        qf(n, n.gzhead.time >> 24 & 255),
                                        qf(n, 9 === n.level ? 2 : n.strategy >= If || n.level < 2 ? 4 : 0),
                                        qf(n, 255 & n.gzhead.os),
                                    n.gzhead.extra && n.gzhead.extra.length && (qf(n, 255 & n.gzhead.extra.length),
                                        qf(n, n.gzhead.extra.length >> 8 & 255)),
                                    n.gzhead.hcrc && (e.adler = hf(e.adler, n.pending_buf, n.pending, 0)),
                                        n.gzindex = 0,
                                        n.status = 69;
                                else if (qf(n, 0),
                                    qf(n, 0),
                                    qf(n, 0),
                                    qf(n, 0),
                                    qf(n, 0),
                                    qf(n, 9 === n.level ? 2 : n.strategy >= If || n.level < 2 ? 4 : 0),
                                    qf(n, 3),
                                    n.status = Of,
                                    Qf(e),
                                0 !== n.pending)
                                    return n.last_flush = -1,
                                        kf;
                            if (69 === n.status) {
                                if (n.gzhead.extra) {
                                    let t = n.pending
                                        , i = (65535 & n.gzhead.extra.length) - n.gzindex;
                                    for (; n.pending + i > n.pending_buf_size; ) {
                                        let r = n.pending_buf_size - n.pending;
                                        if (n.pending_buf.set(n.gzhead.extra.subarray(n.gzindex, n.gzindex + r), n.pending),
                                            n.pending = n.pending_buf_size,
                                        n.gzhead.hcrc && n.pending > t && (e.adler = hf(e.adler, n.pending_buf, n.pending - t, t)),
                                            n.gzindex += r,
                                            Qf(e),
                                        0 !== n.pending)
                                            return n.last_flush = -1,
                                                kf;
                                        t = 0,
                                            i -= r
                                    }
                                    let r = new Uint8Array(n.gzhead.extra);
                                    n.pending_buf.set(r.subarray(n.gzindex, n.gzindex + i), n.pending),
                                        n.pending += i,
                                    n.gzhead.hcrc && n.pending > t && (e.adler = hf(e.adler, n.pending_buf, n.pending - t, t)),
                                        n.gzindex = 0
                                }
                                n.status = 73
                            }
                            if (73 === n.status) {
                                if (n.gzhead.name) {
                                    let t, i = n.pending;
                                    do {
                                        if (n.pending === n.pending_buf_size) {
                                            if (n.gzhead.hcrc && n.pending > i && (e.adler = hf(e.adler, n.pending_buf, n.pending - i, i)),
                                                Qf(e),
                                            0 !== n.pending)
                                                return n.last_flush = -1,
                                                    kf;
                                            i = 0
                                        }
                                        t = n.gzindex < n.gzhead.name.length ? 255 & n.gzhead.name.charCodeAt(n.gzindex++) : 0,
                                            qf(n, t)
                                    } while (0 !== t);
                                    n.gzhead.hcrc && n.pending > i && (e.adler = hf(e.adler, n.pending_buf, n.pending - i, i)),
                                        n.gzindex = 0
                                }
                                n.status = 91
                            }
                            if (91 === n.status) {
                                if (n.gzhead.comment) {
                                    let t, i = n.pending;
                                    do {
                                        if (n.pending === n.pending_buf_size) {
                                            if (n.gzhead.hcrc && n.pending > i && (e.adler = hf(e.adler, n.pending_buf, n.pending - i, i)),
                                                Qf(e),
                                            0 !== n.pending)
                                                return n.last_flush = -1,
                                                    kf;
                                            i = 0
                                        }
                                        t = n.gzindex < n.gzhead.comment.length ? 255 & n.gzhead.comment.charCodeAt(n.gzindex++) : 0,
                                            qf(n, t)
                                    } while (0 !== t);
                                    n.gzhead.hcrc && n.pending > i && (e.adler = hf(e.adler, n.pending_buf, n.pending - i, i))
                                }
                                n.status = 103
                            }
                            if (103 === n.status) {
                                if (n.gzhead.hcrc) {
                                    if (n.pending + 2 > n.pending_buf_size && (Qf(e),
                                    0 !== n.pending))
                                        return n.last_flush = -1,
                                            kf;
                                    qf(n, 255 & e.adler),
                                        qf(n, e.adler >> 8 & 255),
                                        e.adler = 0
                                }
                                if (n.status = Of,
                                    Qf(e),
                                0 !== n.pending)
                                    return n.last_flush = -1,
                                        kf
                            }
                            if (0 !== e.avail_in || 0 !== n.lookahead || t !== wf && n.status !== Ff) {
                                let i = 0 === n.level ? $f(n, t) : n.strategy === If ? ( (e, t) => {
                                        let n;
                                        for (; ; ) {
                                            if (0 === e.lookahead && (Jf(e),
                                            0 === e.lookahead)) {
                                                if (t === wf)
                                                    return 1;
                                                break
                                            }
                                            if (e.match_length = 0,
                                                n = gf(e, 0, e.window[e.strstart]),
                                                e.lookahead--,
                                                e.strstart++,
                                            n && (Yf(e, !1),
                                            0 === e.strm.avail_out))
                                                return 1
                                        }
                                        return e.insert = 0,
                                            t === bf ? (Yf(e, !0),
                                                0 === e.strm.avail_out ? 3 : 4) : e.sym_next && (Yf(e, !1),
                                            0 === e.strm.avail_out) ? 1 : 2
                                    }
                                )(n, t) : n.strategy === Pf ? ( (e, t) => {
                                        let n, i, r, a;
                                        const s = e.window;
                                        for (; ; ) {
                                            if (e.lookahead <= Bf) {
                                                if (Jf(e),
                                                e.lookahead <= Bf && t === wf)
                                                    return 1;
                                                if (0 === e.lookahead)
                                                    break
                                            }
                                            if (e.match_length = 0,
                                            e.lookahead >= 3 && e.strstart > 0 && (r = e.strstart - 1,
                                                i = s[r],
                                            i === s[++r] && i === s[++r] && i === s[++r])) {
                                                a = e.strstart + Bf;
                                                do {} while (i === s[++r] && i === s[++r] && i === s[++r] && i === s[++r] && i === s[++r] && i === s[++r] && i === s[++r] && i === s[++r] && r < a);
                                                e.match_length = Bf - (a - r),
                                                e.match_length > e.lookahead && (e.match_length = e.lookahead)
                                            }
                                            if (e.match_length >= 3 ? (n = gf(e, 1, e.match_length - 3),
                                                e.lookahead -= e.match_length,
                                                e.strstart += e.match_length,
                                                e.match_length = 0) : (n = gf(e, 0, e.window[e.strstart]),
                                                e.lookahead--,
                                                e.strstart++),
                                            n && (Yf(e, !1),
                                            0 === e.strm.avail_out))
                                                return 1
                                        }
                                        return e.insert = 0,
                                            t === bf ? (Yf(e, !0),
                                                0 === e.strm.avail_out ? 3 : 4) : e.sym_next && (Yf(e, !1),
                                            0 === e.strm.avail_out) ? 1 : 2
                                    }
                                )(n, t) : im[n.level].func(n, t);
                                if (3 !== i && 4 !== i || (n.status = Ff),
                                1 === i || 3 === i)
                                    return 0 === e.avail_out && (n.last_flush = -1),
                                        kf;
                                if (2 === i && (t === Af ? vf(n) : t !== xf && (ff(n, 0, 0, !1),
                                t === yf && (Vf(n.head),
                                0 === n.lookahead && (n.strstart = 0,
                                    n.block_start = 0,
                                    n.insert = 0))),
                                    Qf(e),
                                0 === e.avail_out))
                                    return n.last_flush = -1,
                                        kf
                            }
                            return t !== bf ? kf : n.wrap <= 0 ? Ef : (2 === n.wrap ? (qf(n, 255 & e.adler),
                                qf(n, e.adler >> 8 & 255),
                                qf(n, e.adler >> 16 & 255),
                                qf(n, e.adler >> 24 & 255),
                                qf(n, 255 & e.total_in),
                                qf(n, e.total_in >> 8 & 255),
                                qf(n, e.total_in >> 16 & 255),
                                qf(n, e.total_in >> 24 & 255)) : (Kf(n, e.adler >>> 16),
                                Kf(n, 65535 & e.adler)),
                                Qf(e),
                            n.wrap > 0 && (n.wrap = -n.wrap),
                                0 !== n.pending ? kf : Ef)
                        }
                        ,
                        deflateEnd: e => {
                            if (am(e))
                                return Sf;
                            const t = e.state.status;
                            return e.state = null,
                                t === Of ? Wf(e, Mf) : kf
                        }
                        ,
                        deflateSetDictionary: (e, t) => {
                            let n = t.length;
                            if (am(e))
                                return Sf;
                            const i = e.state
                                , r = i.wrap;
                            if (2 === r || 1 === r && i.status !== zf || i.lookahead)
                                return Sf;
                            if (1 === r && (e.adler = lf(e.adler, t, n, 0)),
                                i.wrap = 0,
                            n >= i.w_size) {
                                0 === r && (Vf(i.head),
                                    i.strstart = 0,
                                    i.block_start = 0,
                                    i.insert = 0);
                                let e = new Uint8Array(i.w_size);
                                e.set(t.subarray(n - i.w_size, n), 0),
                                    t = e,
                                    n = i.w_size
                            }
                            const a = e.avail_in
                                , s = e.next_in
                                , o = e.input;
                            for (e.avail_in = n,
                                     e.next_in = 0,
                                     e.input = t,
                                     Jf(i); i.lookahead >= 3; ) {
                                let e = i.strstart
                                    , t = i.lookahead - 2;
                                do {
                                    i.ins_h = jf(i, i.ins_h, i.window[e + 3 - 1]),
                                        i.prev[e & i.w_mask] = i.head[i.ins_h],
                                        i.head[i.ins_h] = e,
                                        e++
                                } while (--t);
                                i.strstart = e,
                                    i.lookahead = 2,
                                    Jf(i)
                            }
                            return i.strstart += i.lookahead,
                                i.block_start = i.strstart,
                                i.insert = i.lookahead,
                                i.lookahead = 0,
                                i.match_length = i.prev_length = 2,
                                i.match_available = 0,
                                e.next_in = s,
                                e.input = o,
                                e.avail_in = a,
                                i.wrap = r,
                                kf
                        }
                        ,
                        deflateInfo: "pako deflate (from Nodeca project)"
                    };
                    const hm = (e, t) => Object.prototype.hasOwnProperty.call(e, t);
                    var dm = function(e) {
                            const t = Array.prototype.slice.call(arguments, 1);
                            for (; t.length; ) {
                                const n = t.shift();
                                if (n) {
                                    if ("object" != typeof n)
                                        throw new TypeError(n + "must be non-object");
                                    for (const t in n)
                                        hm(n, t) && (e[t] = n[t])
                                }
                            }
                            return e
                        }
                        , um = e => {
                            let t = 0;
                            for (let n = 0, i = e.length; n < i; n++)
                                t += e[n].length;
                            const n = new Uint8Array(t);
                            for (let t = 0, i = 0, r = e.length; t < r; t++) {
                                let r = e[t];
                                n.set(r, i),
                                    i += r.length
                            }
                            return n
                        }
                    ;
                    let pm = !0;
                    try {
                        String.fromCharCode.apply(null, new Uint8Array(1))
                    } catch (e) {
                        pm = !1
                    }
                    const fm = new Uint8Array(256);
                    for (let e = 0; e < 256; e++)
                        fm[e] = e >= 252 ? 6 : e >= 248 ? 5 : e >= 240 ? 4 : e >= 224 ? 3 : e >= 192 ? 2 : 1;
                    fm[254] = fm[254] = 1;
                    var mm = e => {
                            if ("function" == typeof TextEncoder && TextEncoder.prototype.encode)
                                return (new TextEncoder).encode(e);
                            let t, n, i, r, a, s = e.length, o = 0;
                            for (r = 0; r < s; r++)
                                n = e.charCodeAt(r),
                                55296 == (64512 & n) && r + 1 < s && (i = e.charCodeAt(r + 1),
                                56320 == (64512 & i) && (n = 65536 + (n - 55296 << 10) + (i - 56320),
                                    r++)),
                                    o += n < 128 ? 1 : n < 2048 ? 2 : n < 65536 ? 3 : 4;
                            for (t = new Uint8Array(o),
                                     a = 0,
                                     r = 0; a < o; r++)
                                n = e.charCodeAt(r),
                                55296 == (64512 & n) && r + 1 < s && (i = e.charCodeAt(r + 1),
                                56320 == (64512 & i) && (n = 65536 + (n - 55296 << 10) + (i - 56320),
                                    r++)),
                                    n < 128 ? t[a++] = n : n < 2048 ? (t[a++] = 192 | n >>> 6,
                                        t[a++] = 128 | 63 & n) : n < 65536 ? (t[a++] = 224 | n >>> 12,
                                        t[a++] = 128 | n >>> 6 & 63,
                                        t[a++] = 128 | 63 & n) : (t[a++] = 240 | n >>> 18,
                                        t[a++] = 128 | n >>> 12 & 63,
                                        t[a++] = 128 | n >>> 6 & 63,
                                        t[a++] = 128 | 63 & n);
                            return t
                        }
                        , gm = (e, t) => {
                            const n = t || e.length;
                            if ("function" == typeof TextDecoder && TextDecoder.prototype.decode)
                                return (new TextDecoder).decode(e.subarray(0, t));
                            let i, r;
                            const a = new Array(2 * n);
                            for (r = 0,
                                     i = 0; i < n; ) {
                                let t = e[i++];
                                if (t < 128) {
                                    a[r++] = t;
                                    continue
                                }
                                let s = fm[t];
                                if (s > 4)
                                    a[r++] = 65533,
                                        i += s - 1;
                                else {
                                    for (t &= 2 === s ? 31 : 3 === s ? 15 : 7; s > 1 && i < n; )
                                        t = t << 6 | 63 & e[i++],
                                            s--;
                                    s > 1 ? a[r++] = 65533 : t < 65536 ? a[r++] = t : (t -= 65536,
                                        a[r++] = 55296 | t >> 10 & 1023,
                                        a[r++] = 56320 | 1023 & t)
                                }
                            }
                            return ( (e, t) => {
                                    if (t < 65534 && e.subarray && pm)
                                        return String.fromCharCode.apply(null, e.length === t ? e : e.subarray(0, t));
                                    let n = "";
                                    for (let i = 0; i < t; i++)
                                        n += String.fromCharCode(e[i]);
                                    return n
                                }
                            )(a, r)
                        }
                        , vm = (e, t) => {
                            (t = t || e.length) > e.length && (t = e.length);
                            let n = t - 1;
                            for (; n >= 0 && 128 == (192 & e[n]); )
                                n--;
                            return n < 0 || 0 === n ? t : n + fm[e[n]] > t ? n : t
                        }
                    ;
                    var wm = function() {
                        this.input = null,
                            this.next_in = 0,
                            this.avail_in = 0,
                            this.total_in = 0,
                            this.output = null,
                            this.next_out = 0,
                            this.avail_out = 0,
                            this.total_out = 0,
                            this.msg = "",
                            this.state = null,
                            this.data_type = 2,
                            this.adler = 0
                    };
                    const Am = Object.prototype.toString
                        , {Z_NO_FLUSH: ym, Z_SYNC_FLUSH: bm, Z_FULL_FLUSH: xm, Z_FINISH: km, Z_OK: Em, Z_STREAM_END: Sm, Z_DEFAULT_COMPRESSION: Mm, Z_DEFAULT_STRATEGY: Tm, Z_DEFLATED: Cm} = uf;
                    function _m(e) {
                        this.options = dm({
                            level: Mm,
                            method: Cm,
                            chunkSize: 16384,
                            windowBits: 15,
                            memLevel: 8,
                            strategy: Tm
                        }, e || {});
                        let t = this.options;
                        t.raw && t.windowBits > 0 ? t.windowBits = -t.windowBits : t.gzip && t.windowBits > 0 && t.windowBits < 16 && (t.windowBits += 16),
                            this.err = 0,
                            this.msg = "",
                            this.ended = !1,
                            this.chunks = [],
                            this.strm = new wm,
                            this.strm.avail_out = 0;
                        let n = cm.deflateInit2(this.strm, t.level, t.method, t.windowBits, t.memLevel, t.strategy);
                        if (n !== Em)
                            throw new Error(df[n]);
                        if (t.header && cm.deflateSetHeader(this.strm, t.header),
                            t.dictionary) {
                            let e;
                            if (e = "string" == typeof t.dictionary ? mm(t.dictionary) : "[object ArrayBuffer]" === Am.call(t.dictionary) ? new Uint8Array(t.dictionary) : t.dictionary,
                                n = cm.deflateSetDictionary(this.strm, e),
                            n !== Em)
                                throw new Error(df[n]);
                            this._dict_set = !0
                        }
                    }
                    function Im(e, t) {
                        const n = new _m(t);
                        if (n.push(e, !0),
                            n.err)
                            throw n.msg || df[n.err];
                        return n.result
                    }
                    _m.prototype.push = function(e, t) {
                        const n = this.strm
                            , i = this.options.chunkSize;
                        let r, a;
                        if (this.ended)
                            return !1;
                        for (a = t === ~~t ? t : !0 === t ? km : ym,
                                 "string" == typeof e ? n.input = mm(e) : "[object ArrayBuffer]" === Am.call(e) ? n.input = new Uint8Array(e) : n.input = e,
                                 n.next_in = 0,
                                 n.avail_in = n.input.length; ; )
                            if (0 === n.avail_out && (n.output = new Uint8Array(i),
                                n.next_out = 0,
                                n.avail_out = i),
                            (a === bm || a === xm) && n.avail_out <= 6)
                                this.onData(n.output.subarray(0, n.next_out)),
                                    n.avail_out = 0;
                            else {
                                if (r = cm.deflate(n, a),
                                r === Sm)
                                    return n.next_out > 0 && this.onData(n.output.subarray(0, n.next_out)),
                                        r = cm.deflateEnd(this.strm),
                                        this.onEnd(r),
                                        this.ended = !0,
                                    r === Em;
                                if (0 !== n.avail_out) {
                                    if (a > 0 && n.next_out > 0)
                                        this.onData(n.output.subarray(0, n.next_out)),
                                            n.avail_out = 0;
                                    else if (0 === n.avail_in)
                                        break
                                } else
                                    this.onData(n.output)
                            }
                        return !0
                    }
                        ,
                        _m.prototype.onData = function(e) {
                            this.chunks.push(e)
                        }
                        ,
                        _m.prototype.onEnd = function(e) {
                            e === Em && (this.result = um(this.chunks)),
                                this.chunks = [],
                                this.err = e,
                                this.msg = this.strm.msg
                        }
                    ;
                    var Pm = function(e, t) {
                        return (t = t || {}).raw = !0,
                            Im(e, t)
                    }
                        , Rm = function(e, t) {
                        return (t = t || {}).gzip = !0,
                            Im(e, t)
                    }
                        , Lm = {
                        Deflate: _m,
                        deflate: Im,
                        deflateRaw: Pm,
                        gzip: Rm,
                        constants: uf
                    };
                    const Nm = 16209;
                    var Dm = function(e, t) {
                        let n, i, r, a, s, o, l, c, h, d, u, p, f, m, g, v, w, A, y, b, x, k, E, S;
                        const M = e.state;
                        n = e.next_in,
                            E = e.input,
                            i = n + (e.avail_in - 5),
                            r = e.next_out,
                            S = e.output,
                            a = r - (t - e.avail_out),
                            s = r + (e.avail_out - 257),
                            o = M.dmax,
                            l = M.wsize,
                            c = M.whave,
                            h = M.wnext,
                            d = M.window,
                            u = M.hold,
                            p = M.bits,
                            f = M.lencode,
                            m = M.distcode,
                            g = (1 << M.lenbits) - 1,
                            v = (1 << M.distbits) - 1;
                        e: do {
                            p < 15 && (u += E[n++] << p,
                                p += 8,
                                u += E[n++] << p,
                                p += 8),
                                w = f[u & g];
                            t: for (; ; ) {
                                if (A = w >>> 24,
                                    u >>>= A,
                                    p -= A,
                                    A = w >>> 16 & 255,
                                0 === A)
                                    S[r++] = 65535 & w;
                                else {
                                    if (!(16 & A)) {
                                        if (64 & A) {
                                            if (32 & A) {
                                                M.mode = 16191;
                                                break e
                                            }
                                            e.msg = "invalid literal/length code",
                                                M.mode = Nm;
                                            break e
                                        }
                                        w = f[(65535 & w) + (u & (1 << A) - 1)];
                                        continue t
                                    }
                                    for (y = 65535 & w,
                                             A &= 15,
                                         A && (p < A && (u += E[n++] << p,
                                             p += 8),
                                             y += u & (1 << A) - 1,
                                             u >>>= A,
                                             p -= A),
                                         p < 15 && (u += E[n++] << p,
                                             p += 8,
                                             u += E[n++] << p,
                                             p += 8),
                                             w = m[u & v]; ; ) {
                                        if (A = w >>> 24,
                                            u >>>= A,
                                            p -= A,
                                            A = w >>> 16 & 255,
                                        16 & A) {
                                            if (b = 65535 & w,
                                                A &= 15,
                                            p < A && (u += E[n++] << p,
                                                p += 8,
                                            p < A && (u += E[n++] << p,
                                                p += 8)),
                                                b += u & (1 << A) - 1,
                                            b > o) {
                                                e.msg = "invalid distance too far back",
                                                    M.mode = Nm;
                                                break e
                                            }
                                            if (u >>>= A,
                                                p -= A,
                                                A = r - a,
                                            b > A) {
                                                if (A = b - A,
                                                A > c && M.sane) {
                                                    e.msg = "invalid distance too far back",
                                                        M.mode = Nm;
                                                    break e
                                                }
                                                if (x = 0,
                                                    k = d,
                                                0 === h) {
                                                    if (x += l - A,
                                                    A < y) {
                                                        y -= A;
                                                        do {
                                                            S[r++] = d[x++]
                                                        } while (--A);
                                                        x = r - b,
                                                            k = S
                                                    }
                                                } else if (h < A) {
                                                    if (x += l + h - A,
                                                        A -= h,
                                                    A < y) {
                                                        y -= A;
                                                        do {
                                                            S[r++] = d[x++]
                                                        } while (--A);
                                                        if (x = 0,
                                                        h < y) {
                                                            A = h,
                                                                y -= A;
                                                            do {
                                                                S[r++] = d[x++]
                                                            } while (--A);
                                                            x = r - b,
                                                                k = S
                                                        }
                                                    }
                                                } else if (x += h - A,
                                                A < y) {
                                                    y -= A;
                                                    do {
                                                        S[r++] = d[x++]
                                                    } while (--A);
                                                    x = r - b,
                                                        k = S
                                                }
                                                for (; y > 2; )
                                                    S[r++] = k[x++],
                                                        S[r++] = k[x++],
                                                        S[r++] = k[x++],
                                                        y -= 3;
                                                y && (S[r++] = k[x++],
                                                y > 1 && (S[r++] = k[x++]))
                                            } else {
                                                x = r - b;
                                                do {
                                                    S[r++] = S[x++],
                                                        S[r++] = S[x++],
                                                        S[r++] = S[x++],
                                                        y -= 3
                                                } while (y > 2);
                                                y && (S[r++] = S[x++],
                                                y > 1 && (S[r++] = S[x++]))
                                            }
                                            break
                                        }
                                        if (64 & A) {
                                            e.msg = "invalid distance code",
                                                M.mode = Nm;
                                            break e
                                        }
                                        w = m[(65535 & w) + (u & (1 << A) - 1)]
                                    }
                                }
                                break
                            }
                        } while (n < i && r < s);
                        y = p >> 3,
                            n -= y,
                            p -= y << 3,
                            u &= (1 << p) - 1,
                            e.next_in = n,
                            e.next_out = r,
                            e.avail_in = n < i ? i - n + 5 : 5 - (n - i),
                            e.avail_out = r < s ? s - r + 257 : 257 - (r - s),
                            M.hold = u,
                            M.bits = p
                    };
                    const Bm = 15
                        , Um = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0])
                        , zm = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78])
                        , Om = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0])
                        , Fm = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]);
                    var Wm = (e, t, n, i, r, a, s, o) => {
                            const l = o.bits;
                            let c, h, d, u, p, f, m = 0, g = 0, v = 0, w = 0, A = 0, y = 0, b = 0, x = 0, k = 0, E = 0, S = null;
                            const M = new Uint16Array(16)
                                , T = new Uint16Array(16);
                            let C, _, I, P = null;
                            for (m = 0; m <= Bm; m++)
                                M[m] = 0;
                            for (g = 0; g < i; g++)
                                M[t[n + g]]++;
                            for (A = l,
                                     w = Bm; w >= 1 && 0 === M[w]; w--)
                                ;
                            if (A > w && (A = w),
                            0 === w)
                                return r[a++] = 20971520,
                                    r[a++] = 20971520,
                                    o.bits = 1,
                                    0;
                            for (v = 1; v < w && 0 === M[v]; v++)
                                ;
                            for (A < v && (A = v),
                                     x = 1,
                                     m = 1; m <= Bm; m++)
                                if (x <<= 1,
                                    x -= M[m],
                                x < 0)
                                    return -1;
                            if (x > 0 && (0 === e || 1 !== w))
                                return -1;
                            for (T[1] = 0,
                                     m = 1; m < Bm; m++)
                                T[m + 1] = T[m] + M[m];
                            for (g = 0; g < i; g++)
                                0 !== t[n + g] && (s[T[t[n + g]]++] = g);
                            if (0 === e ? (S = P = s,
                                f = 20) : 1 === e ? (S = Um,
                                P = zm,
                                f = 257) : (S = Om,
                                P = Fm,
                                f = 0),
                                E = 0,
                                g = 0,
                                m = v,
                                p = a,
                                y = A,
                                b = 0,
                                d = -1,
                                k = 1 << A,
                                u = k - 1,
                            1 === e && k > 852 || 2 === e && k > 592)
                                return 1;
                            for (; ; ) {
                                C = m - b,
                                    s[g] + 1 < f ? (_ = 0,
                                        I = s[g]) : s[g] >= f ? (_ = P[s[g] - f],
                                        I = S[s[g] - f]) : (_ = 96,
                                        I = 0),
                                    c = 1 << m - b,
                                    h = 1 << y,
                                    v = h;
                                do {
                                    h -= c,
                                        r[p + (E >> b) + h] = C << 24 | _ << 16 | I
                                } while (0 !== h);
                                for (c = 1 << m - 1; E & c; )
                                    c >>= 1;
                                if (0 !== c ? (E &= c - 1,
                                    E += c) : E = 0,
                                    g++,
                                0 == --M[m]) {
                                    if (m === w)
                                        break;
                                    m = t[n + s[g]]
                                }
                                if (m > A && (E & u) !== d) {
                                    for (0 === b && (b = A),
                                             p += v,
                                             y = m - b,
                                             x = 1 << y; y + b < w && (x -= M[y + b],
                                        !(x <= 0)); )
                                        y++,
                                            x <<= 1;
                                    if (k += 1 << y,
                                    1 === e && k > 852 || 2 === e && k > 592)
                                        return 1;
                                    d = E & u,
                                        r[d] = A << 24 | y << 16 | p - a
                                }
                            }
                            return 0 !== E && (r[p + E] = m - b << 24 | 64 << 16),
                                o.bits = A,
                                0
                        }
                    ;
                    const {Z_FINISH: Hm, Z_BLOCK: Vm, Z_TREES: Gm, Z_OK: jm, Z_STREAM_END: Qm, Z_NEED_DICT: Ym, Z_STREAM_ERROR: qm, Z_DATA_ERROR: Km, Z_MEM_ERROR: Xm, Z_BUF_ERROR: Zm, Z_DEFLATED: Jm} = uf
                        , $m = 16180
                        , eg = 16190
                        , tg = 16191
                        , ng = 16192
                        , ig = 16194
                        , rg = 16199
                        , ag = 16200
                        , sg = 16206
                        , og = 16209
                        , lg = e => (e >>> 24 & 255) + (e >>> 8 & 65280) + ((65280 & e) << 8) + ((255 & e) << 24);
                    function cg() {
                        this.strm = null,
                            this.mode = 0,
                            this.last = !1,
                            this.wrap = 0,
                            this.havedict = !1,
                            this.flags = 0,
                            this.dmax = 0,
                            this.check = 0,
                            this.total = 0,
                            this.head = null,
                            this.wbits = 0,
                            this.wsize = 0,
                            this.whave = 0,
                            this.wnext = 0,
                            this.window = null,
                            this.hold = 0,
                            this.bits = 0,
                            this.length = 0,
                            this.offset = 0,
                            this.extra = 0,
                            this.lencode = null,
                            this.distcode = null,
                            this.lenbits = 0,
                            this.distbits = 0,
                            this.ncode = 0,
                            this.nlen = 0,
                            this.ndist = 0,
                            this.have = 0,
                            this.next = null,
                            this.lens = new Uint16Array(320),
                            this.work = new Uint16Array(288),
                            this.lendyn = null,
                            this.distdyn = null,
                            this.sane = 0,
                            this.back = 0,
                            this.was = 0
                    }
                    const hg = e => {
                            if (!e)
                                return 1;
                            const t = e.state;
                            return !t || t.strm !== e || t.mode < $m || t.mode > 16211 ? 1 : 0
                        }
                        , dg = e => {
                            if (hg(e))
                                return qm;
                            const t = e.state;
                            return e.total_in = e.total_out = t.total = 0,
                                e.msg = "",
                            t.wrap && (e.adler = 1 & t.wrap),
                                t.mode = $m,
                                t.last = 0,
                                t.havedict = 0,
                                t.flags = -1,
                                t.dmax = 32768,
                                t.head = null,
                                t.hold = 0,
                                t.bits = 0,
                                t.lencode = t.lendyn = new Int32Array(852),
                                t.distcode = t.distdyn = new Int32Array(592),
                                t.sane = 1,
                                t.back = -1,
                                jm
                        }
                        , ug = e => {
                            if (hg(e))
                                return qm;
                            const t = e.state;
                            return t.wsize = 0,
                                t.whave = 0,
                                t.wnext = 0,
                                dg(e)
                        }
                        , pg = (e, t) => {
                            let n;
                            if (hg(e))
                                return qm;
                            const i = e.state;
                            return t < 0 ? (n = 0,
                                t = -t) : (n = 5 + (t >> 4),
                            t < 48 && (t &= 15)),
                                t && (t < 8 || t > 15) ? qm : (null !== i.window && i.wbits !== t && (i.window = null),
                                    i.wrap = n,
                                    i.wbits = t,
                                    ug(e))
                        }
                        , fg = (e, t) => {
                            if (!e)
                                return qm;
                            const n = new cg;
                            e.state = n,
                                n.strm = e,
                                n.window = null,
                                n.mode = $m;
                            const i = pg(e, t);
                            return i !== jm && (e.state = null),
                                i
                        }
                    ;
                    let mg, gg, vg = !0;
                    const wg = e => {
                            if (vg) {
                                mg = new Int32Array(512),
                                    gg = new Int32Array(32);
                                let t = 0;
                                for (; t < 144; )
                                    e.lens[t++] = 8;
                                for (; t < 256; )
                                    e.lens[t++] = 9;
                                for (; t < 280; )
                                    e.lens[t++] = 7;
                                for (; t < 288; )
                                    e.lens[t++] = 8;
                                for (Wm(1, e.lens, 0, 288, mg, 0, e.work, {
                                    bits: 9
                                }),
                                         t = 0; t < 32; )
                                    e.lens[t++] = 5;
                                Wm(2, e.lens, 0, 32, gg, 0, e.work, {
                                    bits: 5
                                }),
                                    vg = !1
                            }
                            e.lencode = mg,
                                e.lenbits = 9,
                                e.distcode = gg,
                                e.distbits = 5
                        }
                        , Ag = (e, t, n, i) => {
                            let r;
                            const a = e.state;
                            return null === a.window && (a.wsize = 1 << a.wbits,
                                a.wnext = 0,
                                a.whave = 0,
                                a.window = new Uint8Array(a.wsize)),
                                i >= a.wsize ? (a.window.set(t.subarray(n - a.wsize, n), 0),
                                    a.wnext = 0,
                                    a.whave = a.wsize) : (r = a.wsize - a.wnext,
                                r > i && (r = i),
                                    a.window.set(t.subarray(n - i, n - i + r), a.wnext),
                                    (i -= r) ? (a.window.set(t.subarray(n - i, n), 0),
                                        a.wnext = i,
                                        a.whave = a.wsize) : (a.wnext += r,
                                    a.wnext === a.wsize && (a.wnext = 0),
                                    a.whave < a.wsize && (a.whave += r))),
                                0
                        }
                    ;
                    var yg = (e, t) => {
                        let n, i, r, a, s, o, l, c, h, d, u, p, f, m, g, v, w, A, y, b, x, k, E = 0;
                        const S = new Uint8Array(4);
                        let M, T;
                        const C = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
                        if (hg(e) || !e.output || !e.input && 0 !== e.avail_in)
                            return qm;
                        n = e.state,
                        n.mode === tg && (n.mode = ng),
                            s = e.next_out,
                            r = e.output,
                            l = e.avail_out,
                            a = e.next_in,
                            i = e.input,
                            o = e.avail_in,
                            c = n.hold,
                            h = n.bits,
                            d = o,
                            u = l,
                            k = jm;
                        e: for (; ; )
                            switch (n.mode) {
                                case $m:
                                    if (0 === n.wrap) {
                                        n.mode = ng;
                                        break
                                    }
                                    for (; h < 16; ) {
                                        if (0 === o)
                                            break e;
                                        o--,
                                            c += i[a++] << h,
                                            h += 8
                                    }
                                    if (2 & n.wrap && 35615 === c) {
                                        0 === n.wbits && (n.wbits = 15),
                                            n.check = 0,
                                            S[0] = 255 & c,
                                            S[1] = c >>> 8 & 255,
                                            n.check = hf(n.check, S, 2, 0),
                                            c = 0,
                                            h = 0,
                                            n.mode = 16181;
                                        break
                                    }
                                    if (n.head && (n.head.done = !1),
                                    !(1 & n.wrap) || (((255 & c) << 8) + (c >> 8)) % 31) {
                                        e.msg = "incorrect header check",
                                            n.mode = og;
                                        break
                                    }
                                    if ((15 & c) !== Jm) {
                                        e.msg = "unknown compression method",
                                            n.mode = og;
                                        break
                                    }
                                    if (c >>>= 4,
                                        h -= 4,
                                        x = 8 + (15 & c),
                                    0 === n.wbits && (n.wbits = x),
                                    x > 15 || x > n.wbits) {
                                        e.msg = "invalid window size",
                                            n.mode = og;
                                        break
                                    }
                                    n.dmax = 1 << n.wbits,
                                        n.flags = 0,
                                        e.adler = n.check = 1,
                                        n.mode = 512 & c ? 16189 : tg,
                                        c = 0,
                                        h = 0;
                                    break;
                                case 16181:
                                    for (; h < 16; ) {
                                        if (0 === o)
                                            break e;
                                        o--,
                                            c += i[a++] << h,
                                            h += 8
                                    }
                                    if (n.flags = c,
                                    (255 & n.flags) !== Jm) {
                                        e.msg = "unknown compression method",
                                            n.mode = og;
                                        break
                                    }
                                    if (57344 & n.flags) {
                                        e.msg = "unknown header flags set",
                                            n.mode = og;
                                        break
                                    }
                                    n.head && (n.head.text = c >> 8 & 1),
                                    512 & n.flags && 4 & n.wrap && (S[0] = 255 & c,
                                        S[1] = c >>> 8 & 255,
                                        n.check = hf(n.check, S, 2, 0)),
                                        c = 0,
                                        h = 0,
                                        n.mode = 16182;
                                case 16182:
                                    for (; h < 32; ) {
                                        if (0 === o)
                                            break e;
                                        o--,
                                            c += i[a++] << h,
                                            h += 8
                                    }
                                    n.head && (n.head.time = c),
                                    512 & n.flags && 4 & n.wrap && (S[0] = 255 & c,
                                        S[1] = c >>> 8 & 255,
                                        S[2] = c >>> 16 & 255,
                                        S[3] = c >>> 24 & 255,
                                        n.check = hf(n.check, S, 4, 0)),
                                        c = 0,
                                        h = 0,
                                        n.mode = 16183;
                                case 16183:
                                    for (; h < 16; ) {
                                        if (0 === o)
                                            break e;
                                        o--,
                                            c += i[a++] << h,
                                            h += 8
                                    }
                                    n.head && (n.head.xflags = 255 & c,
                                        n.head.os = c >> 8),
                                    512 & n.flags && 4 & n.wrap && (S[0] = 255 & c,
                                        S[1] = c >>> 8 & 255,
                                        n.check = hf(n.check, S, 2, 0)),
                                        c = 0,
                                        h = 0,
                                        n.mode = 16184;
                                case 16184:
                                    if (1024 & n.flags) {
                                        for (; h < 16; ) {
                                            if (0 === o)
                                                break e;
                                            o--,
                                                c += i[a++] << h,
                                                h += 8
                                        }
                                        n.length = c,
                                        n.head && (n.head.extra_len = c),
                                        512 & n.flags && 4 & n.wrap && (S[0] = 255 & c,
                                            S[1] = c >>> 8 & 255,
                                            n.check = hf(n.check, S, 2, 0)),
                                            c = 0,
                                            h = 0
                                    } else
                                        n.head && (n.head.extra = null);
                                    n.mode = 16185;
                                case 16185:
                                    if (1024 & n.flags && (p = n.length,
                                    p > o && (p = o),
                                    p && (n.head && (x = n.head.extra_len - n.length,
                                    n.head.extra || (n.head.extra = new Uint8Array(n.head.extra_len)),
                                        n.head.extra.set(i.subarray(a, a + p), x)),
                                    512 & n.flags && 4 & n.wrap && (n.check = hf(n.check, i, p, a)),
                                        o -= p,
                                        a += p,
                                        n.length -= p),
                                        n.length))
                                        break e;
                                    n.length = 0,
                                        n.mode = 16186;
                                case 16186:
                                    if (2048 & n.flags) {
                                        if (0 === o)
                                            break e;
                                        p = 0;
                                        do {
                                            x = i[a + p++],
                                            n.head && x && n.length < 65536 && (n.head.name += String.fromCharCode(x))
                                        } while (x && p < o);
                                        if (512 & n.flags && 4 & n.wrap && (n.check = hf(n.check, i, p, a)),
                                            o -= p,
                                            a += p,
                                            x)
                                            break e
                                    } else
                                        n.head && (n.head.name = null);
                                    n.length = 0,
                                        n.mode = 16187;
                                case 16187:
                                    if (4096 & n.flags) {
                                        if (0 === o)
                                            break e;
                                        p = 0;
                                        do {
                                            x = i[a + p++],
                                            n.head && x && n.length < 65536 && (n.head.comment += String.fromCharCode(x))
                                        } while (x && p < o);
                                        if (512 & n.flags && 4 & n.wrap && (n.check = hf(n.check, i, p, a)),
                                            o -= p,
                                            a += p,
                                            x)
                                            break e
                                    } else
                                        n.head && (n.head.comment = null);
                                    n.mode = 16188;
                                case 16188:
                                    if (512 & n.flags) {
                                        for (; h < 16; ) {
                                            if (0 === o)
                                                break e;
                                            o--,
                                                c += i[a++] << h,
                                                h += 8
                                        }
                                        if (4 & n.wrap && c !== (65535 & n.check)) {
                                            e.msg = "header crc mismatch",
                                                n.mode = og;
                                            break
                                        }
                                        c = 0,
                                            h = 0
                                    }
                                    n.head && (n.head.hcrc = n.flags >> 9 & 1,
                                        n.head.done = !0),
                                        e.adler = n.check = 0,
                                        n.mode = tg;
                                    break;
                                case 16189:
                                    for (; h < 32; ) {
                                        if (0 === o)
                                            break e;
                                        o--,
                                            c += i[a++] << h,
                                            h += 8
                                    }
                                    e.adler = n.check = lg(c),
                                        c = 0,
                                        h = 0,
                                        n.mode = eg;
                                case eg:
                                    if (0 === n.havedict)
                                        return e.next_out = s,
                                            e.avail_out = l,
                                            e.next_in = a,
                                            e.avail_in = o,
                                            n.hold = c,
                                            n.bits = h,
                                            Ym;
                                    e.adler = n.check = 1,
                                        n.mode = tg;
                                case tg:
                                    if (t === Vm || t === Gm)
                                        break e;
                                case ng:
                                    if (n.last) {
                                        c >>>= 7 & h,
                                            h -= 7 & h,
                                            n.mode = sg;
                                        break
                                    }
                                    for (; h < 3; ) {
                                        if (0 === o)
                                            break e;
                                        o--,
                                            c += i[a++] << h,
                                            h += 8
                                    }
                                    switch (n.last = 1 & c,
                                        c >>>= 1,
                                        h -= 1,
                                    3 & c) {
                                        case 0:
                                            n.mode = 16193;
                                            break;
                                        case 1:
                                            if (wg(n),
                                                n.mode = rg,
                                            t === Gm) {
                                                c >>>= 2,
                                                    h -= 2;
                                                break e
                                            }
                                            break;
                                        case 2:
                                            n.mode = 16196;
                                            break;
                                        case 3:
                                            e.msg = "invalid block type",
                                                n.mode = og
                                    }
                                    c >>>= 2,
                                        h -= 2;
                                    break;
                                case 16193:
                                    for (c >>>= 7 & h,
                                             h -= 7 & h; h < 32; ) {
                                        if (0 === o)
                                            break e;
                                        o--,
                                            c += i[a++] << h,
                                            h += 8
                                    }
                                    if ((65535 & c) != (c >>> 16 ^ 65535)) {
                                        e.msg = "invalid stored block lengths",
                                            n.mode = og;
                                        break
                                    }
                                    if (n.length = 65535 & c,
                                        c = 0,
                                        h = 0,
                                        n.mode = ig,
                                    t === Gm)
                                        break e;
                                case ig:
                                    n.mode = 16195;
                                case 16195:
                                    if (p = n.length,
                                        p) {
                                        if (p > o && (p = o),
                                        p > l && (p = l),
                                        0 === p)
                                            break e;
                                        r.set(i.subarray(a, a + p), s),
                                            o -= p,
                                            a += p,
                                            l -= p,
                                            s += p,
                                            n.length -= p;
                                        break
                                    }
                                    n.mode = tg;
                                    break;
                                case 16196:
                                    for (; h < 14; ) {
                                        if (0 === o)
                                            break e;
                                        o--,
                                            c += i[a++] << h,
                                            h += 8
                                    }
                                    if (n.nlen = 257 + (31 & c),
                                        c >>>= 5,
                                        h -= 5,
                                        n.ndist = 1 + (31 & c),
                                        c >>>= 5,
                                        h -= 5,
                                        n.ncode = 4 + (15 & c),
                                        c >>>= 4,
                                        h -= 4,
                                    n.nlen > 286 || n.ndist > 30) {
                                        e.msg = "too many length or distance symbols",
                                            n.mode = og;
                                        break
                                    }
                                    n.have = 0,
                                        n.mode = 16197;
                                case 16197:
                                    for (; n.have < n.ncode; ) {
                                        for (; h < 3; ) {
                                            if (0 === o)
                                                break e;
                                            o--,
                                                c += i[a++] << h,
                                                h += 8
                                        }
                                        n.lens[C[n.have++]] = 7 & c,
                                            c >>>= 3,
                                            h -= 3
                                    }
                                    for (; n.have < 19; )
                                        n.lens[C[n.have++]] = 0;
                                    if (n.lencode = n.lendyn,
                                        n.lenbits = 7,
                                        M = {
                                            bits: n.lenbits
                                        },
                                        k = Wm(0, n.lens, 0, 19, n.lencode, 0, n.work, M),
                                        n.lenbits = M.bits,
                                        k) {
                                        e.msg = "invalid code lengths set",
                                            n.mode = og;
                                        break
                                    }
                                    n.have = 0,
                                        n.mode = 16198;
                                case 16198:
                                    for (; n.have < n.nlen + n.ndist; ) {
                                        for (; E = n.lencode[c & (1 << n.lenbits) - 1],
                                                   g = E >>> 24,
                                                   v = E >>> 16 & 255,
                                                   w = 65535 & E,
                                                   !(g <= h); ) {
                                            if (0 === o)
                                                break e;
                                            o--,
                                                c += i[a++] << h,
                                                h += 8
                                        }
                                        if (w < 16)
                                            c >>>= g,
                                                h -= g,
                                                n.lens[n.have++] = w;
                                        else {
                                            if (16 === w) {
                                                for (T = g + 2; h < T; ) {
                                                    if (0 === o)
                                                        break e;
                                                    o--,
                                                        c += i[a++] << h,
                                                        h += 8
                                                }
                                                if (c >>>= g,
                                                    h -= g,
                                                0 === n.have) {
                                                    e.msg = "invalid bit length repeat",
                                                        n.mode = og;
                                                    break
                                                }
                                                x = n.lens[n.have - 1],
                                                    p = 3 + (3 & c),
                                                    c >>>= 2,
                                                    h -= 2
                                            } else if (17 === w) {
                                                for (T = g + 3; h < T; ) {
                                                    if (0 === o)
                                                        break e;
                                                    o--,
                                                        c += i[a++] << h,
                                                        h += 8
                                                }
                                                c >>>= g,
                                                    h -= g,
                                                    x = 0,
                                                    p = 3 + (7 & c),
                                                    c >>>= 3,
                                                    h -= 3
                                            } else {
                                                for (T = g + 7; h < T; ) {
                                                    if (0 === o)
                                                        break e;
                                                    o--,
                                                        c += i[a++] << h,
                                                        h += 8
                                                }
                                                c >>>= g,
                                                    h -= g,
                                                    x = 0,
                                                    p = 11 + (127 & c),
                                                    c >>>= 7,
                                                    h -= 7
                                            }
                                            if (n.have + p > n.nlen + n.ndist) {
                                                e.msg = "invalid bit length repeat",
                                                    n.mode = og;
                                                break
                                            }
                                            for (; p--; )
                                                n.lens[n.have++] = x
                                        }
                                    }
                                    if (n.mode === og)
                                        break;
                                    if (0 === n.lens[256]) {
                                        e.msg = "invalid code -- missing end-of-block",
                                            n.mode = og;
                                        break
                                    }
                                    if (n.lenbits = 9,
                                        M = {
                                            bits: n.lenbits
                                        },
                                        k = Wm(1, n.lens, 0, n.nlen, n.lencode, 0, n.work, M),
                                        n.lenbits = M.bits,
                                        k) {
                                        e.msg = "invalid literal/lengths set",
                                            n.mode = og;
                                        break
                                    }
                                    if (n.distbits = 6,
                                        n.distcode = n.distdyn,
                                        M = {
                                            bits: n.distbits
                                        },
                                        k = Wm(2, n.lens, n.nlen, n.ndist, n.distcode, 0, n.work, M),
                                        n.distbits = M.bits,
                                        k) {
                                        e.msg = "invalid distances set",
                                            n.mode = og;
                                        break
                                    }
                                    if (n.mode = rg,
                                    t === Gm)
                                        break e;
                                case rg:
                                    n.mode = ag;
                                case ag:
                                    if (o >= 6 && l >= 258) {
                                        e.next_out = s,
                                            e.avail_out = l,
                                            e.next_in = a,
                                            e.avail_in = o,
                                            n.hold = c,
                                            n.bits = h,
                                            Dm(e, u),
                                            s = e.next_out,
                                            r = e.output,
                                            l = e.avail_out,
                                            a = e.next_in,
                                            i = e.input,
                                            o = e.avail_in,
                                            c = n.hold,
                                            h = n.bits,
                                        n.mode === tg && (n.back = -1);
                                        break
                                    }
                                    for (n.back = 0; E = n.lencode[c & (1 << n.lenbits) - 1],
                                        g = E >>> 24,
                                        v = E >>> 16 & 255,
                                        w = 65535 & E,
                                        !(g <= h); ) {
                                        if (0 === o)
                                            break e;
                                        o--,
                                            c += i[a++] << h,
                                            h += 8
                                    }
                                    if (v && !(240 & v)) {
                                        for (A = g,
                                                 y = v,
                                                 b = w; E = n.lencode[b + ((c & (1 << A + y) - 1) >> A)],
                                                 g = E >>> 24,
                                                 v = E >>> 16 & 255,
                                                 w = 65535 & E,
                                                 !(A + g <= h); ) {
                                            if (0 === o)
                                                break e;
                                            o--,
                                                c += i[a++] << h,
                                                h += 8
                                        }
                                        c >>>= A,
                                            h -= A,
                                            n.back += A
                                    }
                                    if (c >>>= g,
                                        h -= g,
                                        n.back += g,
                                        n.length = w,
                                    0 === v) {
                                        n.mode = 16205;
                                        break
                                    }
                                    if (32 & v) {
                                        n.back = -1,
                                            n.mode = tg;
                                        break
                                    }
                                    if (64 & v) {
                                        e.msg = "invalid literal/length code",
                                            n.mode = og;
                                        break
                                    }
                                    n.extra = 15 & v,
                                        n.mode = 16201;
                                case 16201:
                                    if (n.extra) {
                                        for (T = n.extra; h < T; ) {
                                            if (0 === o)
                                                break e;
                                            o--,
                                                c += i[a++] << h,
                                                h += 8
                                        }
                                        n.length += c & (1 << n.extra) - 1,
                                            c >>>= n.extra,
                                            h -= n.extra,
                                            n.back += n.extra
                                    }
                                    n.was = n.length,
                                        n.mode = 16202;
                                case 16202:
                                    for (; E = n.distcode[c & (1 << n.distbits) - 1],
                                               g = E >>> 24,
                                               v = E >>> 16 & 255,
                                               w = 65535 & E,
                                               !(g <= h); ) {
                                        if (0 === o)
                                            break e;
                                        o--,
                                            c += i[a++] << h,
                                            h += 8
                                    }
                                    if (!(240 & v)) {
                                        for (A = g,
                                                 y = v,
                                                 b = w; E = n.distcode[b + ((c & (1 << A + y) - 1) >> A)],
                                                 g = E >>> 24,
                                                 v = E >>> 16 & 255,
                                                 w = 65535 & E,
                                                 !(A + g <= h); ) {
                                            if (0 === o)
                                                break e;
                                            o--,
                                                c += i[a++] << h,
                                                h += 8
                                        }
                                        c >>>= A,
                                            h -= A,
                                            n.back += A
                                    }
                                    if (c >>>= g,
                                        h -= g,
                                        n.back += g,
                                    64 & v) {
                                        e.msg = "invalid distance code",
                                            n.mode = og;
                                        break
                                    }
                                    n.offset = w,
                                        n.extra = 15 & v,
                                        n.mode = 16203;
                                case 16203:
                                    if (n.extra) {
                                        for (T = n.extra; h < T; ) {
                                            if (0 === o)
                                                break e;
                                            o--,
                                                c += i[a++] << h,
                                                h += 8
                                        }
                                        n.offset += c & (1 << n.extra) - 1,
                                            c >>>= n.extra,
                                            h -= n.extra,
                                            n.back += n.extra
                                    }
                                    if (n.offset > n.dmax) {
                                        e.msg = "invalid distance too far back",
                                            n.mode = og;
                                        break
                                    }
                                    n.mode = 16204;
                                case 16204:
                                    if (0 === l)
                                        break e;
                                    if (p = u - l,
                                    n.offset > p) {
                                        if (p = n.offset - p,
                                        p > n.whave && n.sane) {
                                            e.msg = "invalid distance too far back",
                                                n.mode = og;
                                            break
                                        }
                                        p > n.wnext ? (p -= n.wnext,
                                            f = n.wsize - p) : f = n.wnext - p,
                                        p > n.length && (p = n.length),
                                            m = n.window
                                    } else
                                        m = r,
                                            f = s - n.offset,
                                            p = n.length;
                                    p > l && (p = l),
                                        l -= p,
                                        n.length -= p;
                                    do {
                                        r[s++] = m[f++]
                                    } while (--p);
                                    0 === n.length && (n.mode = ag);
                                    break;
                                case 16205:
                                    if (0 === l)
                                        break e;
                                    r[s++] = n.length,
                                        l--,
                                        n.mode = ag;
                                    break;
                                case sg:
                                    if (n.wrap) {
                                        for (; h < 32; ) {
                                            if (0 === o)
                                                break e;
                                            o--,
                                                c |= i[a++] << h,
                                                h += 8
                                        }
                                        if (u -= l,
                                            e.total_out += u,
                                            n.total += u,
                                        4 & n.wrap && u && (e.adler = n.check = n.flags ? hf(n.check, r, u, s - u) : lf(n.check, r, u, s - u)),
                                            u = l,
                                        4 & n.wrap && (n.flags ? c : lg(c)) !== n.check) {
                                            e.msg = "incorrect data check",
                                                n.mode = og;
                                            break
                                        }
                                        c = 0,
                                            h = 0
                                    }
                                    n.mode = 16207;
                                case 16207:
                                    if (n.wrap && n.flags) {
                                        for (; h < 32; ) {
                                            if (0 === o)
                                                break e;
                                            o--,
                                                c += i[a++] << h,
                                                h += 8
                                        }
                                        if (4 & n.wrap && c !== (4294967295 & n.total)) {
                                            e.msg = "incorrect length check",
                                                n.mode = og;
                                            break
                                        }
                                        c = 0,
                                            h = 0
                                    }
                                    n.mode = 16208;
                                case 16208:
                                    k = Qm;
                                    break e;
                                case og:
                                    k = Km;
                                    break e;
                                case 16210:
                                    return Xm;
                                default:
                                    return qm
                            }
                        return e.next_out = s,
                            e.avail_out = l,
                            e.next_in = a,
                            e.avail_in = o,
                            n.hold = c,
                            n.bits = h,
                        (n.wsize || u !== e.avail_out && n.mode < og && (n.mode < sg || t !== Hm)) && Ag(e, e.output, e.next_out, u - e.avail_out),
                            d -= e.avail_in,
                            u -= e.avail_out,
                            e.total_in += d,
                            e.total_out += u,
                            n.total += u,
                        4 & n.wrap && u && (e.adler = n.check = n.flags ? hf(n.check, r, u, e.next_out - u) : lf(n.check, r, u, e.next_out - u)),
                            e.data_type = n.bits + (n.last ? 64 : 0) + (n.mode === tg ? 128 : 0) + (n.mode === rg || n.mode === ig ? 256 : 0),
                        (0 === d && 0 === u || t === Hm) && k === jm && (k = Zm),
                            k
                    }
                        , bg = e => {
                        if (hg(e))
                            return qm;
                        let t = e.state;
                        return t.window && (t.window = null),
                            e.state = null,
                            jm
                    }
                        , xg = (e, t) => {
                        if (hg(e))
                            return qm;
                        const n = e.state;
                        return 2 & n.wrap ? (n.head = t,
                            t.done = !1,
                            jm) : qm
                    }
                        , kg = (e, t) => {
                        const n = t.length;
                        let i, r, a;
                        return hg(e) ? qm : (i = e.state,
                            0 !== i.wrap && i.mode !== eg ? qm : i.mode === eg && (r = 1,
                                r = lf(r, t, n, 0),
                            r !== i.check) ? Km : (a = Ag(e, t, n, n),
                                a ? (i.mode = 16210,
                                    Xm) : (i.havedict = 1,
                                    jm)))
                    }
                        , Eg = {
                        inflateReset: ug,
                        inflateReset2: pg,
                        inflateResetKeep: dg,
                        inflateInit: e => fg(e, 15),
                        inflateInit2: fg,
                        inflate: yg,
                        inflateEnd: bg,
                        inflateGetHeader: xg,
                        inflateSetDictionary: kg,
                        inflateInfo: "pako inflate (from Nodeca project)"
                    };
                    var Sg = function() {
                        this.text = 0,
                            this.time = 0,
                            this.xflags = 0,
                            this.os = 0,
                            this.extra = null,
                            this.extra_len = 0,
                            this.name = "",
                            this.comment = "",
                            this.hcrc = 0,
                            this.done = !1
                    };
                    const Mg = Object.prototype.toString
                        , {Z_NO_FLUSH: Tg, Z_FINISH: Cg, Z_OK: _g, Z_STREAM_END: Ig, Z_NEED_DICT: Pg, Z_STREAM_ERROR: Rg, Z_DATA_ERROR: Lg, Z_MEM_ERROR: Ng} = uf;
                    function Dg(e) {
                        this.options = dm({
                            chunkSize: 65536,
                            windowBits: 15,
                            to: ""
                        }, e || {});
                        const t = this.options;
                        t.raw && t.windowBits >= 0 && t.windowBits < 16 && (t.windowBits = -t.windowBits,
                        0 === t.windowBits && (t.windowBits = -15)),
                        !(t.windowBits >= 0 && t.windowBits < 16) || e && e.windowBits || (t.windowBits += 32),
                        t.windowBits > 15 && t.windowBits < 48 && (15 & t.windowBits || (t.windowBits |= 15)),
                            this.err = 0,
                            this.msg = "",
                            this.ended = !1,
                            this.chunks = [],
                            this.strm = new wm,
                            this.strm.avail_out = 0;
                        let n = Eg.inflateInit2(this.strm, t.windowBits);
                        if (n !== _g)
                            throw new Error(df[n]);
                        if (this.header = new Sg,
                            Eg.inflateGetHeader(this.strm, this.header),
                        t.dictionary && ("string" == typeof t.dictionary ? t.dictionary = mm(t.dictionary) : "[object ArrayBuffer]" === Mg.call(t.dictionary) && (t.dictionary = new Uint8Array(t.dictionary)),
                        t.raw && (n = Eg.inflateSetDictionary(this.strm, t.dictionary),
                        n !== _g)))
                            throw new Error(df[n])
                    }
                    function Bg(e, t) {
                        const n = new Dg(t);
                        if (n.push(e),
                            n.err)
                            throw n.msg || df[n.err];
                        return n.result
                    }
                    Dg.prototype.push = function(e, t) {
                        const n = this.strm
                            , i = this.options.chunkSize
                            , r = this.options.dictionary;
                        let a, s, o;
                        if (this.ended)
                            return !1;
                        for (s = t === ~~t ? t : !0 === t ? Cg : Tg,
                                 "[object ArrayBuffer]" === Mg.call(e) ? n.input = new Uint8Array(e) : n.input = e,
                                 n.next_in = 0,
                                 n.avail_in = n.input.length; ; ) {
                            for (0 === n.avail_out && (n.output = new Uint8Array(i),
                                n.next_out = 0,
                                n.avail_out = i),
                                     a = Eg.inflate(n, s),
                                 a === Pg && r && (a = Eg.inflateSetDictionary(n, r),
                                     a === _g ? a = Eg.inflate(n, s) : a === Lg && (a = Pg)); n.avail_in > 0 && a === Ig && n.state.wrap > 0 && 0 !== e[n.next_in]; )
                                Eg.inflateReset(n),
                                    a = Eg.inflate(n, s);
                            switch (a) {
                                case Rg:
                                case Lg:
                                case Pg:
                                case Ng:
                                    return this.onEnd(a),
                                        this.ended = !0,
                                        !1
                            }
                            if (o = n.avail_out,
                            n.next_out && (0 === n.avail_out || a === Ig))
                                if ("string" === this.options.to) {
                                    let e = vm(n.output, n.next_out)
                                        , t = n.next_out - e
                                        , r = gm(n.output, e);
                                    n.next_out = t,
                                        n.avail_out = i - t,
                                    t && n.output.set(n.output.subarray(e, e + t), 0),
                                        this.onData(r)
                                } else
                                    this.onData(n.output.length === n.next_out ? n.output : n.output.subarray(0, n.next_out));
                            if (a !== _g || 0 !== o) {
                                if (a === Ig)
                                    return a = Eg.inflateEnd(this.strm),
                                        this.onEnd(a),
                                        this.ended = !0,
                                        !0;
                                if (0 === n.avail_in)
                                    break
                            }
                        }
                        return !0
                    }
                        ,
                        Dg.prototype.onData = function(e) {
                            this.chunks.push(e)
                        }
                        ,
                        Dg.prototype.onEnd = function(e) {
                            e === _g && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = um(this.chunks)),
                                this.chunks = [],
                                this.err = e,
                                this.msg = this.strm.msg
                        }
                    ;
                    var Ug = function(e, t) {
                        return (t = t || {}).raw = !0,
                            Bg(e, t)
                    }
                        , zg = {
                        Inflate: Dg,
                        inflate: Bg,
                        inflateRaw: Ug,
                        ungzip: Bg,
                        constants: uf
                    };
                    const {Deflate: Og, deflate: Fg, deflateRaw: Wg, gzip: Hg} = Lm
                        , {Inflate: Vg, inflate: Gg, inflateRaw: jg, ungzip: Qg} = zg;
                    var Yg = {
                        Deflate: Og,
                        deflate: Fg,
                        deflateRaw: Wg,
                        gzip: Hg,
                        Inflate: Vg,
                        inflate: Gg,
                        inflateRaw: jg,
                        ungzip: Qg,
                        constants: uf
                    };
                    function qg(e) {
                        let t;
                        e = (e = e.replace(/-/g, "+")).replace(/_/g, "/");
                        try {
                            t = atob(e)
                        } catch (e) {
                            return null
                        }
                        const n = new Uint8Array(t.length);
                        for (let e = 0; e < t.length; ++e) {
                            const i = t.charCodeAt(e);
                            if (i > 255)
                                return null;
                            n[e] = i
                        }
                        return n
                    }
                    var Kg, Xg, Zg, Jg, $g, ev, tv, nv, iv, rv, av, sv = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, ov = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    class lv {
                        constructor(e) {
                            Kg.add(this),
                                Zg.set(this, []),
                                Jg.set(this, []),
                                $g.set(this, []),
                                ev.set(this, []),
                                tv.set(this, []),
                                nv.set(this, null),
                            null != e && (sv(this, Zg, e.up, "f"),
                                sv(this, Jg, e.right, "f"),
                                sv(this, $g, e.down, "f"),
                                sv(this, ev, e.left, "f"),
                                sv(this, tv, e.reset, "f"))
                        }
                        recordFrame(e, t) {
                            if (e > Xg.maxFrames)
                                throw new Error("Frame number exceeds maximum frame count.");
                            if (null != ov(this, nv, "f") && e <= ov(this, nv, "f"))
                                throw new Error("Frame number must be greater than the previous recorded frame.");
                            sv(this, nv, e, "f");
                            const n = ov(this, Zg, "f").length % 2 != 0
                                , i = ov(this, Jg, "f").length % 2 != 0
                                , r = ov(this, $g, "f").length % 2 != 0
                                , a = ov(this, ev, "f").length % 2 != 0
                                , s = ov(this, tv, "f").length % 2 != 0;
                            t.up != n && ov(this, Zg, "f").push(e),
                            t.right != i && ov(this, Jg, "f").push(e),
                            t.down != r && ov(this, $g, "f").push(e),
                            t.left != a && ov(this, ev, "f").push(e),
                            t.reset != s && ov(this, tv, "f").push(e)
                        }
                        getFrame(e) {
                            return {
                                up: (ov(this, Kg, "m", iv).call(this, e, ov(this, Zg, "f")) + 1) % 2 != 0,
                                right: (ov(this, Kg, "m", iv).call(this, e, ov(this, Jg, "f")) + 1) % 2 != 0,
                                down: (ov(this, Kg, "m", iv).call(this, e, ov(this, $g, "f")) + 1) % 2 != 0,
                                left: (ov(this, Kg, "m", iv).call(this, e, ov(this, ev, "f")) + 1) % 2 != 0,
                                reset: (ov(this, Kg, "m", iv).call(this, e, ov(this, tv, "f")) + 1) % 2 != 0
                            }
                        }
                        serialize() {
                            const e = new Uint8Array(3 + 3 * ov(this, Zg, "f").length + 3 + 3 * ov(this, Jg, "f").length + 3 + 3 * ov(this, $g, "f").length + 3 + 3 * ov(this, ev, "f").length + 3 + 3 * ov(this, tv, "f").length);
                            ov(this, Kg, "m", rv).call(this, ov(this, Zg, "f"), e.subarray(0, 3 + 3 * ov(this, Zg, "f").length)),
                                ov(this, Kg, "m", rv).call(this, ov(this, Jg, "f"), e.subarray(3 + 3 * ov(this, Zg, "f").length, 3 + 3 * ov(this, Zg, "f").length + 3 + 3 * ov(this, Jg, "f").length)),
                                ov(this, Kg, "m", rv).call(this, ov(this, $g, "f"), e.subarray(3 + 3 * ov(this, Zg, "f").length + 3 + 3 * ov(this, Jg, "f").length, 3 + 3 * ov(this, Zg, "f").length + 3 + 3 * ov(this, Jg, "f").length + 3 + 3 * ov(this, $g, "f").length)),
                                ov(this, Kg, "m", rv).call(this, ov(this, ev, "f"), e.subarray(3 + 3 * ov(this, Zg, "f").length + 3 + 3 * ov(this, Jg, "f").length + 3 + 3 * ov(this, $g, "f").length, 3 + 3 * ov(this, Zg, "f").length + 3 + 3 * ov(this, Jg, "f").length + 3 + 3 * ov(this, $g, "f").length + 3 + 3 * ov(this, ev, "f").length)),
                                ov(this, Kg, "m", rv).call(this, ov(this, tv, "f"), e.subarray(3 + 3 * ov(this, Zg, "f").length + 3 + 3 * ov(this, Jg, "f").length + 3 + 3 * ov(this, $g, "f").length + 3 + 3 * ov(this, ev, "f").length, 3 + 3 * ov(this, Zg, "f").length + 3 + 3 * ov(this, Jg, "f").length + 3 + 3 * ov(this, $g, "f").length + 3 + 3 * ov(this, ev, "f").length + 3 + 3 * ov(this, tv, "f").length));
                            const t = new Yg.Deflate({
                                level: 9
                            });
                            return t.push(new Uint8Array(e), !0),
                                function(e) {
                                    let t = "";
                                    for (const n of e)
                                        t += String.fromCharCode(n);
                                    let n = btoa(t);
                                    return n = n.replace(/\+/g, "-"),
                                        n = n.replace(/\//g, "_"),
                                        n = n.replace(/=/g, ""),
                                        n
                                }(t.result)
                        }
                        static deserialize(e) {
                            const t = qg(e);
                            if (null == t)
                                return null;
                            const n = new Yg.Inflate;
                            if (n.push(t, !0),
                                n.err)
                                return null;
                            const i = n.result;
                            if (!(i instanceof Uint8Array))
                                return null;
                            const r = ov(Xg, Xg, "m", av).call(Xg, i);
                            if (null == r)
                                return null;
                            const a = ov(Xg, Xg, "m", av).call(Xg, i.subarray(3 + 3 * r.length));
                            if (null == a)
                                return null;
                            const s = ov(Xg, Xg, "m", av).call(Xg, i.subarray(3 + 3 * r.length + 3 + 3 * a.length));
                            if (null == s)
                                return null;
                            const o = ov(Xg, Xg, "m", av).call(Xg, i.subarray(3 + 3 * r.length + 3 + 3 * a.length + 3 + 3 * s.length));
                            if (null == o)
                                return null;
                            const l = ov(Xg, Xg, "m", av).call(Xg, i.subarray(3 + 3 * r.length + 3 + 3 * a.length + 3 + 3 * s.length + 3 + 3 * o.length));
                            return null == l ? null : new Xg({
                                up: r,
                                right: a,
                                down: s,
                                left: o,
                                reset: l
                            })
                        }
                    }
                    Xg = lv,
                        Zg = new WeakMap,
                        Jg = new WeakMap,
                        $g = new WeakMap,
                        ev = new WeakMap,
                        tv = new WeakMap,
                        nv = new WeakMap,
                        Kg = new WeakSet,
                        iv = function(e, t) {
                            let n = -1;
                            for (let i = 0; i < t.length; ++i) {
                                const r = t[i];
                                if (r == e) {
                                    n = i;
                                    break
                                }
                                if (r > e)
                                    break;
                                n = i
                            }
                            return n
                        }
                        ,
                        rv = function(e, t) {
                            t[0] = 255 & e.length,
                                t[1] = e.length >>> 8 & 255,
                                t[2] = e.length >>> 16 & 255;
                            for (let n = 0; n < e.length; ++n) {
                                let i;
                                i = 0 == n ? e[n] : e[n] - e[n - 1],
                                    t[3 + 3 * n] = 255 & i,
                                    t[3 + 3 * n + 1] = i >>> 8 & 255,
                                    t[3 + 3 * n + 2] = i >>> 16 & 255
                            }
                        }
                        ,
                        av = function(e) {
                            if (e.length < 3)
                                return null;
                            const t = e[0] | e[1] << 8 | e[2] << 16;
                            if (e.length < 3 + 3 * t)
                                return null;
                            const n = [];
                            for (let i = 0; i < t; ++i) {
                                const t = e[3 + 3 * i] | e[3 + 3 * i + 1] << 8 | e[3 + 3 * i + 2] << 16;
                                0 == i ? n.push(t) : n.push(n[i - 1] + t)
                            }
                            return n
                        }
                        ,
                        lv.maxFrames = 5999999;
                    const cv = lv;
                    var hv, dv, uv, pv, fv, mv, gv, vv, wv, Av, yv, bv, xv, kv, Ev, Sv, Mv, Tv, Cv, _v, Iv, Pv, Rv, Lv, Nv, Dv, Bv, Uv, zv, Ov, Fv, Wv, Hv, Vv, Gv, jv, Qv, Yv, qv, Kv, Xv, Zv, Jv, $v, ew, tw, nw, iw, rw, aw, sw, ow, lw, cw, hw, dw, uw, pw, fw, mw, gw = function(e, t, n, i) {
                        return new (n || (n = Promise))((function(r, a) {
                                function s(e) {
                                    try {
                                        l(i.next(e))
                                    } catch (e) {
                                        a(e)
                                    }
                                }
                                function o(e) {
                                    try {
                                        l(i.throw(e))
                                    } catch (e) {
                                        a(e)
                                    }
                                }
                                function l(e) {
                                    var t;
                                    e.done ? r(e.value) : (t = e.value,
                                        t instanceof n ? t : new n((function(e) {
                                                e(t)
                                            }
                                        ))).then(s, o)
                                }
                                l((i = i.apply(e, t || [])).next())
                            }
                        ))
                    }, vw = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, ww = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    class Aw {
                        constructor(e, t, n, i, r, a, s, o, l) {
                            var c;
                            if (hv.add(this),
                                uv.set(this, void 0),
                                pv.set(this, null),
                                fv.set(this, 1),
                                mv.set(this, null),
                                gv.set(this, []),
                                vv.set(this, null),
                                wv.set(this, null),
                                Av.set(this, null),
                                yv.set(this, []),
                                this.notificationAudioEnabled = !1,
                                bv.set(this, void 0),
                                xv.set(this, void 0),
                                kv.set(this, void 0),
                                Ev.set(this, !1),
                                Sv.set(this, void 0),
                                Mv.set(this, void 0),
                                Tv.set(this, void 0),
                                Cv.set(this, void 0),
                                _v.set(this, []),
                                Iv.set(this, []),
                                Pv.set(this, []),
                                Rv.set(this, [0, 0, 0, 0]),
                                Lv.set(this, [0, 0, 0, 0]),
                                Nv.set(this, [0, 0, 0, 0]),
                                Dv.set(this, void 0),
                                Bv.set(this, void 0),
                                Uv.set(this, null),
                                zv.set(this, null),
                                Ov.set(this, []),
                                Fv.set(this, null),
                                Wv.set(this, void 0),
                                Hv.set(this, void 0),
                                Vv.set(this, void 0),
                                Gv.set(this, void 0),
                                jv.set(this, void 0),
                                Qv.set(this, void 0),
                                Yv.set(this, void 0),
                                qv.set(this, []),
                                Kv.set(this, null),
                                Xv.set(this, [.075, .075, .075, .075]),
                                Zv.set(this, void 0),
                                Jv.set(this, null),
                                $v.set(this, !1),
                                vw(this, uv, a, "f"),
                                vw(this, Dv, r, "f"),
                                vw(this, jv, s, "f"),
                                vw(this, Qv, o, "f"),
                                vw(this, Yv, l, "f"),
                                vw(this, kv, e, "f"),
                                (null == l ? void 0 : l.getSettingBoolean(Jo.ParticlesEnabled)) ? vw(this, Zv, new $u(r), "f") : vw(this, Zv, null, "f"),
                            null != ww(this, jv, "f") && null != ww(this, Qv, "f") && vw(this, qv, [new vp(ww(this, Dv, "f"),ww(this, jv, "f"),ww(this, Qv, "f")), new vp(ww(this, Dv, "f"),ww(this, jv, "f"),ww(this, Qv, "f")), new vp(ww(this, Dv, "f"),ww(this, jv, "f"),ww(this, Qv, "f")), new vp(ww(this, Dv, "f"),ww(this, jv, "f"),ww(this, Qv, "f"))], "f"),
                                vw(this, bv, new Wu, "f"),
                                ww(this, bv, "f").reset(t.position, t.quaternion),
                                r.scene.add(ww(this, bv, "f").camera),
                                vw(this, xv, new Cu, "f"),
                                ww(this, xv, "f").reset(t.position, t.quaternion),
                                r.scene.add(ww(this, xv, "f").camera),
                            null == dv.models)
                                throw new Error("Car model isn't loaded yet");
                            if (null != ww(this, kv, "f") && null != ww(this, jv, "f") && null != ww(this, Qv, "f"))
                                vw(this, Sv, ww(this, kv, "f").createCar(t, ww(this, jv, "f").getMountainVertices(), ww(this, jv, "f").getMountainOffset(), ww(this, Qv, "f").getTrackData(), n, (e => {
                                        this.setCarState(e)
                                    }
                                )), "f");
                            else {
                                const e = [new An(.627909,.27 - dv.suspensionResetLengthFront,1.3478).applyQuaternion(t.quaternion).add(t.position), new An(-.627909,.27 - dv.suspensionResetLengthFront,1.3478).applyQuaternion(t.quaternion).add(t.position), new An(.720832,.27 - dv.suspensionResetLengthRear,-1.52686).applyQuaternion(t.quaternion).add(t.position), new An(-.720832,.27 - dv.suspensionResetLengthRear,-1.52686).applyQuaternion(t.quaternion).add(t.position)]
                                    , n = [(new wn).setFromEuler((new ai).set(0, Math.PI, 0)).multiply(t.quaternion), (new wn).setFromEuler((new ai).set(0, Math.PI, 0)).multiply(t.quaternion), (new wn).setFromEuler((new ai).set(0, Math.PI, 0)).multiply(t.quaternion), (new wn).setFromEuler((new ai).set(0, Math.PI, 0)).multiply(t.quaternion)];
                                vw(this, Sv, {
                                    id: 0,
                                    frames: 0,
                                    speedKmh: 0,
                                    hasStarted: !1,
                                    finishFrames: null,
                                    nextCheckpointIndex: 0,
                                    hasCheckpointToRespawnAt: !1,
                                    position: {
                                        x: t.position.x,
                                        y: t.position.y,
                                        z: t.position.z
                                    },
                                    quaternion: {
                                        x: t.quaternion.x,
                                        y: t.quaternion.y,
                                        z: t.quaternion.z,
                                        w: t.quaternion.w
                                    },
                                    collisionImpulses: [],
                                    wheelInContact: [!1, !1, !1, !1],
                                    wheelSuspensionLength: [dv.suspensionResetLengthFront, dv.suspensionResetLengthFront, dv.suspensionResetLengthRear, dv.suspensionResetLengthRear],
                                    wheelSuspensionVelocity: [0, 0, 0, 0],
                                    wheelRotation: [0, 0, 0, 0],
                                    wheelDeltaRotation: [0, 0, 0, 0],
                                    wheelSkidInfo: [0, 0, 0, 0],
                                    wheelPosition: e,
                                    wheelQuaternion: n,
                                    brakeLightEnabled: !1,
                                    controls: {
                                        up: !1,
                                        right: !1,
                                        down: !1,
                                        left: !1,
                                        reset: !1
                                    }
                                }, "f")
                            }
                            if (vw(this, Mv, i, "f"),
                            null == n)
                                vw(this, Tv, null != ww(this, Mv, "f"), "f"),
                                    vw(this, Cv, new cv, "f");
                            else {
                                if (null != ww(this, Mv, "f"))
                                    throw new Error("Can't control car when recording is set");
                                vw(this, Tv, !1, "f"),
                                    vw(this, Cv, n, "f")
                            }
                            vw(this, Bv, new Dr, "f"),
                                ww(this, Bv, "f").add(dv.models.chassis.clone()),
                                ww(this, Bv, "f").add(dv.models.suspension.clone()),
                                ww(this, Bv, "f").add(dv.models.wheelFL.clone()),
                                ww(this, Bv, "f").add(dv.models.wheelFR.clone()),
                                ww(this, Bv, "f").add(dv.models.wheelBL.clone()),
                                ww(this, Bv, "f").add(dv.models.wheelBR.clone());
                            for (const e of ww(this, Bv, "f").children) {
                                const t = e;
                                Array.isArray(t.material) ? t.material = t.material.map((e => e.clone())) : t.material = t.material.clone(),
                                    t.castShadow = !0,
                                    t.receiveShadow = !0,
                                    t.frustumCulled = !1
                            }
                            ww(this, Dv, "f").scene.add(ww(this, Bv, "f")),
                                vw(this, Uv, ww(this, Bv, "f").getObjectByName("Body"), "f"),
                                vw(this, zv, ww(this, Bv, "f").getObjectByName("Suspension"), "f");
                            {
                                const e = document.createElement("canvas");
                                e.width = 2048,
                                    e.height = 2048;
                                const t = e.getContext("2d");
                                if (null == t)
                                    throw new Error("Failed to get context for car texture");
                                const n = new un(e);
                                let i;
                                n.flipY = !1,
                                    n.anisotropy = ww(this, Dv, "f").getMaxAnisotropy(),
                                    n.needsUpdate = !0,
                                    vw(this, Wv, t, "f"),
                                    vw(this, Hv, n, "f"),
                                    vw(this, Gv, Iu.random(), "f"),
                                    ww(this, hv, "m", tw).call(this),
                                    vw(this, Vv, {
                                        value: new An(0,0,0)
                                    }, "f"),
                                    i = Array.isArray(ww(this, Uv, "f").material) ? ww(this, Uv, "f").material : [ww(this, Uv, "f").material];
                                for (const e of i)
                                    "Main" == e.name ? e.onBeforeCompile = e => {
                                            e.fragmentShader = "uniform sampler2D carColorPattern;\nuniform vec3 carColorSecondary;\n" + e.fragmentShader,
                                                e.fragmentShader = e.fragmentShader.replace("vec4 diffuseColor = vec4( diffuse, opacity );", "float colorSource = texture(carColorPattern, vUv).a;\nvec4 diffuseColor = vec4( carColorSecondary * colorSource + diffuse * (1.0 - colorSource), opacity );"),
                                                e.uniforms.carColorPattern = {
                                                    value: n
                                                },
                                                e.uniforms.carColorSecondary = ww(this, Vv, "f"),
                                            null == e.defines && (e.defines = {}),
                                                e.defines.USE_UV = !0
                                        }
                                        : "Metal" == e.name ? e.needsUpdate = !0 : "BrakeLight" == e.name && vw(this, Fv, e, "f")
                            }
                            ww(this, zv, "f").geometry.morphAttributes.position = [];
                            const h = ww(this, zv, "f")
                                , d = dv.models.suspensionFL
                                , u = dv.models.suspensionFR
                                , p = dv.models.suspensionBL
                                , f = dv.models.suspensionBR;
                            for (const e of ww(this, Bv, "f").children)
                                if (e != ww(this, Uv, "f") && e != ww(this, zv, "f")) {
                                    const t = e;
                                    if (!(d.geometry.attributes.position instanceof Ki && u.geometry.attributes.position instanceof Ki && p.geometry.attributes.position instanceof Ki && f.geometry.attributes.position instanceof Ki))
                                        throw new Error("Vertices must use BufferAttribute");
                                    const n = d.geometry.attributes.position.array
                                        , i = u.geometry.attributes.position.array
                                        , r = p.geometry.attributes.position.array
                                        , a = f.geometry.attributes.position.array
                                        , s = h.geometry.morphAttributes.position;
                                    if ("WheelFL" == t.name)
                                        s.push(new Ki(n,3));
                                    else if ("WheelFR" == t.name)
                                        s.push(new Ki(i,3));
                                    else if ("WheelBL" == t.name)
                                        s.push(new Ki(r,3));
                                    else {
                                        if ("WheelBR" != t.name)
                                            throw new Error("Unidentified wheel");
                                        s.push(new Ki(a,3))
                                    }
                                    ww(this, Ov, "f").push(t)
                                }
                            ww(this, zv, "f").updateMorphTargets(),
                            null != ww(this, Mv, "f") && (null === (c = ww(this, kv, "f")) || void 0 === c || c.controlCar(ww(this, Sv, "f").id, ww(this, Mv, "f").up, ww(this, Mv, "f").right, ww(this, Mv, "f").down, ww(this, Mv, "f").left, ww(this, Mv, "f").reset),
                                ww(this, Mv, "f").addChangeCallback(vw(this, Jv, (e => {
                                        var t;
                                        null === (t = ww(this, kv, "f")) || void 0 === t || t.controlCar(ww(this, Sv, "f").id, e.up, e.right, e.down, e.left, e.reset)
                                    }
                                ), "f")))
                        }
                        dispose() {
                            var e, t, n;
                            vw(this, $v, !0, "f"),
                                ww(this, hv, "m", ew).call(this),
                                ww(this, Dv, "f").scene.remove(ww(this, bv, "f").camera),
                                ww(this, Dv, "f").scene.remove(ww(this, xv, "f").camera),
                            null === (e = ww(this, Zv, "f")) || void 0 === e || e.dispose();
                            for (const e of ww(this, qv, "f"))
                                e.dispose();
                            ww(this, qv, "f").length = 0,
                                ww(this, Dv, "f").scene.remove(ww(this, Bv, "f")),
                                ww(this, Hv, "f").dispose(),
                            null === (t = ww(this, kv, "f")) || void 0 === t || t.deleteCar(ww(this, Sv, "f").id),
                            null != ww(this, Jv, "f") && (null === (n = ww(this, Mv, "f")) || void 0 === n || n.removeChangeCallback(ww(this, Jv, "f")))
                        }
                        addResetCallback(e) {
                            ww(this, _v, "f").push(e)
                        }
                        addCheckpointCallback(e) {
                            ww(this, Iv, "f").push(e)
                        }
                        addFinishCallback(e) {
                            ww(this, Pv, "f").push(e)
                        }
                        getChassisMatrix() {
                            return null != ww(this, Uv, "f") ? ww(this, Uv, "f").matrix : null
                        }
                        getSpeedKmh() {
                            return ww(this, Sv, "f").speedKmh
                        }
                        start() {
                            var e;
                            null === (e = ww(this, kv, "f")) || void 0 === e || e.startCar(ww(this, Sv, "f").id, null)
                        }
                        hasStarted() {
                            return ww(this, Sv, "f").hasStarted
                        }
                        hasFinished() {
                            return null != ww(this, Sv, "f").finishFrames
                        }
                        getFinishTime() {
                            return null == ww(this, Sv, "f").finishFrames ? null : new xp(ww(this, Sv, "f").finishFrames)
                        }
                        getRecording() {
                            return ww(this, Cv, "f")
                        }
                        getTime() {
                            return new xp(ww(this, Sv, "f").frames)
                        }
                        getNextCheckpointIndex() {
                            return ww(this, Sv, "f").nextCheckpointIndex
                        }
                        hasCheckpointToRespawnAt() {
                            return ww(this, Sv, "f").hasCheckpointToRespawnAt
                        }
                        getPosition() {
                            return new An(ww(this, Sv, "f").position.x,ww(this, Sv, "f").position.y,ww(this, Sv, "f").position.z)
                        }
                        getQuaternion() {
                            return new wn(ww(this, Sv, "f").quaternion.x,ww(this, Sv, "f").quaternion.y,ww(this, Sv, "f").quaternion.z,ww(this, Sv, "f").quaternion.w)
                        }
                        getMatrix4() {
                            const e = this.getPosition()
                                , t = this.getQuaternion()
                                , n = (new Kn).makeRotationFromQuaternion(t);
                            return n.setPosition(e),
                                n
                        }
                        get isPaused() {
                            return ww(this, Ev, "f")
                        }
                        set isPaused(e) {
                            var t;
                            ww(this, Ev, "f") != e && (null === (t = ww(this, kv, "f")) || void 0 === t || t.pauseCar(ww(this, Sv, "f").id, e),
                                vw(this, Ev, e, "f"))
                        }
                        getControls() {
                            return null != ww(this, Mv, "f") ? ww(this, Mv, "f").getControls() : ww(this, Sv, "f").controls
                        }
                        getColors() {
                            return ww(this, Gv, "f")
                        }
                        setColors(e) {
                            if (ww(this, Vv, "f").value = (new An).setFromColor(e.secondary),
                            null != ww(this, Uv, "f") && Array.isArray(ww(this, Uv, "f").material))
                                for (const t of ww(this, Uv, "f").material)
                                    "Main" == t.name ? t.color.set(e.primary) : "Metal" == t.name && t.color.set(e.frame);
                            if (null != ww(this, zv, "f") && !Array.isArray(ww(this, zv, "f").material)) {
                                const t = ww(this, zv, "f").material;
                                "Metal" == t.name && t.color.set(e.frame)
                            }
                            for (const t of ww(this, Ov, "f"))
                                if (Array.isArray(t.material))
                                    for (const n of t.material)
                                        "Metal" == n.name ? n.color.set(e.frame) : "Rim" == n.name && n.color.set(e.rims);
                            vw(this, Gv, e, "f")
                        }
                        setOpacity(e) {
                            for (const t of ww(this, Bv, "f").children) {
                                const n = t;
                                let i;
                                i = Array.isArray(n.material) ? n.material : [n.material];
                                for (const t of i) {
                                    t.opacity = e;
                                    const n = e < 1;
                                    t.needsUpdate = n != t.transparent,
                                        t.transparent = n
                                }
                            }
                        }
                        setVisible(e) {
                            ww(this, Bv, "f").visible = e
                        }
                        setCarState(e) {
                            var t;
                            if (ww(this, $v, "f"))
                                return;
                            const n = ww(this, Sv, "f");
                            vw(this, Sv, e, "f");
                            const i = ww(this, Sv, "f").frames != n.frames && ww(this, Sv, "f").frames != n.frames + 1;
                            if (ww(this, Sv, "f").nextCheckpointIndex > n.nextCheckpointIndex) {
                                this.notificationAudioEnabled && ww(this, hv, "m", iw).call(this);
                                for (const e of ww(this, Iv, "f"))
                                    e(n.nextCheckpointIndex)
                            }
                            if (null != ww(this, Sv, "f").finishFrames && null == n.finishFrames) {
                                this.notificationAudioEnabled && ww(this, hv, "m", rw).call(this);
                                for (const e of ww(this, Pv, "f"))
                                    e(this)
                            }
                            const r = .001;
                            if (i) {
                                null === (t = ww(this, Zv, "f")) || void 0 === t || t.clear();
                                for (const e of ww(this, qv, "f"))
                                    e.clear()
                            }
                            if (this.getTime().numberOfFrames % 10 == 0 && ww(this, hv, "m", aw).call(this, .01),
                            i || !n.controls.reset && ww(this, Sv, "f").controls.reset) {
                                ww(this, bv, "f").reset(this.getPosition(), this.getQuaternion(), this.getSpeedKmh()),
                                    ww(this, xv, "f").reset(this.getPosition(), this.getQuaternion(), this.getSpeedKmh());
                                for (const e of ww(this, _v, "f"))
                                    e()
                            }
                            null == ww(this, Sv, "f").finishFrames && (ww(this, bv, "f").update(this.getPosition(), this.getQuaternion(), this.getSpeedKmh()),
                                ww(this, xv, "f").update(this.getPosition(), this.getQuaternion(), this.getSpeedKmh())),
                                ww(this, hv, "m", lw).call(this, r),
                                ww(this, hv, "m", hw).call(this, r),
                            ww(this, Tv, "f") && ww(this, Sv, "f").hasStarted && null == ww(this, Sv, "f").finishFrames && ww(this, Cv, "f").recordFrame(n.frames, ww(this, Sv, "f").controls)
                        }
                        update(e) {
                            var t, n;
                            if (null != ww(this, Uv, "f") && null != ww(this, zv, "f")) {
                                ww(this, hv, "m", sw).call(this),
                                null === (t = ww(this, Zv, "f")) || void 0 === t || t.update(e);
                                const i = this.getMatrix4()
                                    , r = this.getQuaternion();
                                ww(this, Uv, "f").matrixAutoUpdate = !1,
                                    ww(this, Uv, "f").matrix.copy(i),
                                    ww(this, Uv, "f").matrix.multiply((new Kn).makeTranslation(0, dv.massOffset, 0)),
                                    ww(this, zv, "f").matrixAutoUpdate = !1,
                                    ww(this, zv, "f").matrix.copy(ww(this, Uv, "f").matrix);
                                const a = 4;
                                for (let t = 0; t < a; t++) {
                                    const i = ww(this, Sv, "f").wheelInContact[t]
                                        , a = ww(this, Sv, "f").wheelDeltaRotation[t];
                                    if (this.hasStarted()) {
                                        if (i)
                                            ww(this, Rv, "f")[t] = 1e3 * a,
                                                ww(this, Lv, "f")[t] = 1e3 * a;
                                        else {
                                            const {up: n, down: i} = this.getControls()
                                                , r = 2 == t || 3 == t;
                                            i ? ww(this, Sv, "f").brakeLightEnabled ? ww(this, Lv, "f")[t] > 0 ? ww(this, Lv, "f")[t] = Math.max(0, ww(this, Lv, "f")[t] - 50 * e) : ww(this, Lv, "f")[t] < 0 && (ww(this, Lv, "f")[t] = Math.min(0, ww(this, Lv, "f")[t] + 50 * e)) : r && (ww(this, Rv, "f")[t] -= 25 * e,
                                                ww(this, Lv, "f")[t] -= 25 * e) : n && r && (ww(this, Rv, "f")[t] += 25 * e,
                                                ww(this, Lv, "f")[t] += 50 * e),
                                                ww(this, Rv, "f")[t] *= Math.max(0, 1 - e),
                                                ww(this, Lv, "f")[t] *= Math.max(0, 1 - e)
                                        }
                                        ww(this, Nv, "f")[t] += ww(this, Lv, "f")[t] * e
                                    }
                                    const s = ww(this, Sv, "f").wheelPosition[t]
                                        , o = new wn(ww(this, Sv, "f").wheelQuaternion[t].x,ww(this, Sv, "f").wheelQuaternion[t].y,ww(this, Sv, "f").wheelQuaternion[t].z,ww(this, Sv, "f").wheelQuaternion[t].w)
                                        , l = ww(this, Sv, "f").wheelRotation[t];
                                    o.multiply((new wn).setFromAxisAngle(new An(-1,0,0), ww(this, Nv, "f")[t] - l)),
                                        ww(this, Ov, "f")[t].position.set(s.x, s.y, s.z),
                                        ww(this, Ov, "f")[t].quaternion.set(o.x, o.y, o.z, o.w);
                                    const c = ww(this, Sv, "f").wheelSuspensionLength[t]
                                        , h = ww(this, Sv, "f").wheelSkidInfo[t];
                                    ww(this, zv, "f").morphTargetInfluences || (ww(this, zv, "f").morphTargetInfluences = []),
                                        ww(this, zv, "f").morphTargetInfluences[t] = 2 * c + .06,
                                    e > 0 && (null === (n = ww(this, Yv, "f")) || void 0 === n ? void 0 : n.getSettingBoolean(Jo.SkidmarksEnabled)) && t < ww(this, qv, "f").length && i && a > .06 && h < .5 && 0 == ww(this, Xv, "f")[t] && ww(this, qv, "f")[t].spawn(s.x, s.y, s.z, r)
                                }
                                ww(this, hv, "m", pw).call(this, ww(this, Sv, "f").brakeLightEnabled)
                            }
                        }
                        get cameraOrbit() {
                            return ww(this, bv, "f").camera
                        }
                        get cameraCockpit() {
                            return ww(this, xv, "f").camera
                        }
                        set audioVolume(e) {
                            vw(this, fv, e, "f"),
                            null != ww(this, pv, "f") && ww(this, pv, "f").gain.setTargetAtTime(ww(this, fv, "f"), 0, .01)
                        }
                        static initResources() {
                            return gw(this, void 0, void 0, (function*() {
                                    const e = yield new Promise(( (e, t) => {
                                            (new gl).load("models/car.glb", (n => {
                                                    function i(e) {
                                                        const t = n.scene.getObjectByName(e);
                                                        if (null == t)
                                                            throw new Error('Mesh "' + e + '" does not exist');
                                                        if (0 == t.children.length) {
                                                            const e = t;
                                                            return e.updateMatrixWorld(!0),
                                                                e.geometry.applyMatrix4(e.matrix.clone()),
                                                                e.matrix.identity(),
                                                                e
                                                        }
                                                        const i = ul(t.children.map((e => e.geometry)), !0);
                                                        t.updateMatrixWorld(!0),
                                                            i.applyMatrix4(t.matrix.clone());
                                                        const r = t.children.map((e => e.material))
                                                            , a = new wr(i,r);
                                                        return a.name = e,
                                                            a
                                                    }
                                                    function r(e) {
                                                        let t;
                                                        t = Array.isArray(e.material) ? e.material : [e.material];
                                                        for (const e of t)
                                                            e.side = 0;
                                                        return e
                                                    }
                                                    dv.models = {
                                                        chassis: r(i("Body")),
                                                        suspension: r(i("Suspension")),
                                                        suspensionFL: r(i("SuspensionFL")),
                                                        suspensionFR: r(i("SuspensionFR")),
                                                        suspensionBL: r(i("SuspensionBL")),
                                                        suspensionBR: r(i("SuspensionBR")),
                                                        wheelFL: r(i("WheelFL")),
                                                        wheelFR: r(i("WheelFR")),
                                                        wheelBL: r(i("WheelBL")),
                                                        wheelBR: r(i("WheelBR")),
                                                        collisionShapeVertices: ww(dv, dv, "m", fw).call(dv, i("Collision"))
                                                    },
                                                        dv.models.wheelFL.geometry.translate(-.627909, .218824, -1.3478),
                                                        dv.models.wheelFR.geometry.translate(.627909, .218824, -1.3478),
                                                        dv.models.wheelBL.geometry.translate(-.720832, .218824, 1.52686),
                                                        dv.models.wheelBR.geometry.translate(.720832, .218824, 1.52686),
                                                        dv.models.wheelFL.geometry.rotateZ(Math.PI),
                                                        dv.models.wheelFR.geometry.rotateZ(Math.PI),
                                                        dv.models.wheelBL.geometry.rotateZ(Math.PI),
                                                        dv.models.wheelBR.geometry.rotateZ(Math.PI),
                                                        ww(dv, dv, "m", mw).call(dv).then((t => {
                                                                e(t)
                                                            }
                                                        )).catch(t)
                                                }
                                            ), void 0, t)
                                        }
                                    ));
                                    return yield new Promise(( (e, t) => {
                                            const n = new Image;
                                            n.addEventListener("load", ( () => {
                                                    e()
                                                }
                                            )),
                                                n.addEventListener("error", ( () => {
                                                        t(new Error("Failed to load image"))
                                                    }
                                                )),
                                                n.src = "images/car_stripe.svg",
                                                dv.images = {
                                                    stripe: n
                                                }
                                        }
                                    )),
                                        e
                                }
                            ))
                        }
                    }
                    dv = Aw,
                        uv = new WeakMap,
                        pv = new WeakMap,
                        fv = new WeakMap,
                        mv = new WeakMap,
                        gv = new WeakMap,
                        vv = new WeakMap,
                        wv = new WeakMap,
                        Av = new WeakMap,
                        yv = new WeakMap,
                        bv = new WeakMap,
                        xv = new WeakMap,
                        kv = new WeakMap,
                        Ev = new WeakMap,
                        Sv = new WeakMap,
                        Mv = new WeakMap,
                        Tv = new WeakMap,
                        Cv = new WeakMap,
                        _v = new WeakMap,
                        Iv = new WeakMap,
                        Pv = new WeakMap,
                        Rv = new WeakMap,
                        Lv = new WeakMap,
                        Nv = new WeakMap,
                        Dv = new WeakMap,
                        Bv = new WeakMap,
                        Uv = new WeakMap,
                        zv = new WeakMap,
                        Ov = new WeakMap,
                        Fv = new WeakMap,
                        Wv = new WeakMap,
                        Hv = new WeakMap,
                        Vv = new WeakMap,
                        Gv = new WeakMap,
                        jv = new WeakMap,
                        Qv = new WeakMap,
                        Yv = new WeakMap,
                        qv = new WeakMap,
                        Kv = new WeakMap,
                        Xv = new WeakMap,
                        Zv = new WeakMap,
                        Jv = new WeakMap,
                        $v = new WeakMap,
                        hv = new WeakSet,
                        ew = function() {
                            ww(this, hv, "m", nw).call(this),
                                setTimeout(( () => {
                                        if (null != ww(this, mv, "f") && (ww(this, mv, "f").source.stop(),
                                            vw(this, mv, null, "f")),
                                        null != ww(this, vv, "f")) {
                                            for (const {source: e} of ww(this, vv, "f"))
                                                e.stop();
                                            vw(this, vv, null, "f")
                                        }
                                    }
                                ), 200)
                        }
                        ,
                        tw = function() {
                            if (null == dv.images)
                                throw new Error("Car images are not loaded yet");
                            ww(this, Wv, "f").clearRect(0, 0, ww(this, Wv, "f").canvas.width, ww(this, Wv, "f").canvas.height),
                                ww(this, Wv, "f").drawImage(dv.images.stripe, 0, 0, ww(this, Wv, "f").canvas.width, ww(this, Wv, "f").canvas.height),
                                ww(this, Hv, "f").needsUpdate = !0
                        }
                        ,
                        nw = function() {
                            if (null != ww(this, mv, "f") && (ww(this, mv, "f").source.playbackRate.setTargetAtTime(.7, 0, .15),
                                ww(this, mv, "f").gain.gain.setTargetAtTime(0, 0, .15)),
                            null != ww(this, vv, "f"))
                                for (const e of ww(this, vv, "f"))
                                    e.source.playbackRate.setTargetAtTime(.3, 0, .15),
                                        e.gain.gain.setTargetAtTime(0, 0, .15);
                            if (null != ww(this, Kv, "f")) {
                                for (const {source: e} of ww(this, Kv, "f"))
                                    e.stop();
                                vw(this, Kv, null, "f")
                            }
                        }
                        ,
                        iw = function() {
                            var e, t;
                            const n = null !== (t = null === (e = ww(this, Yv, "f")) || void 0 === e ? void 0 : e.getSettingFloat(Jo.CheckpointVolume)) && void 0 !== t ? t : 0;
                            let i = Math.min(Math.max(ww(this, fv, "f") * n, 0), 1);
                            if (Number.isNaN(i) && (i = 0),
                            i > 0 && null != ww(this, uv, "f")) {
                                const e = ww(this, uv, "f").getBuffer("checkpoint");
                                if (null != e && null != ww(this, uv, "f").context && null != ww(this, uv, "f").destinationMaster) {
                                    const t = ww(this, uv, "f").context.createBufferSource();
                                    t.buffer = e,
                                        t.playbackRate.value = 1.25;
                                    const n = ww(this, uv, "f").context.createGain();
                                    n.gain.value = .03 * i,
                                        t.connect(n),
                                        n.connect(ww(this, uv, "f").destinationMaster),
                                        t.start(0)
                                }
                            }
                        }
                        ,
                        rw = function() {
                            var e, t;
                            const n = null !== (t = null === (e = ww(this, Yv, "f")) || void 0 === e ? void 0 : e.getSettingFloat(Jo.CheckpointVolume)) && void 0 !== t ? t : 0;
                            let i = Math.min(Math.max(ww(this, fv, "f") * n, 0), 1);
                            if (Number.isNaN(i) && (i = 0),
                            i > 0 && null != ww(this, uv, "f")) {
                                const e = ww(this, uv, "f").getBuffer("finish");
                                if (null != e && null != ww(this, uv, "f").context && null != ww(this, uv, "f").destinationMaster) {
                                    const t = ww(this, uv, "f").context.createBufferSource();
                                    t.buffer = e,
                                        t.playbackRate.value = 1.25;
                                    const n = ww(this, uv, "f").context.createGain();
                                    n.gain.value = .03,
                                        t.connect(n),
                                        n.connect(ww(this, uv, "f").destinationMaster),
                                        t.start(0)
                                }
                            }
                        }
                        ,
                        aw = function(e) {
                            var t;
                            for (let n = 0; n < 4; n++) {
                                const i = ww(this, Sv, "f").wheelPosition[n]
                                    , r = ww(this, Sv, "f").wheelInContact[n]
                                    , a = ww(this, Sv, "f").wheelDeltaRotation[n]
                                    , s = ww(this, Sv, "f").wheelSkidInfo[n];
                                r && a > .06 && s < .5 ? (n < ww(this, qv, "f").length && (ww(this, Xv, "f")[n] = Math.max(0, ww(this, Xv, "f")[n] - e)),
                                0 == ww(this, Xv, "f")[n] && null != ww(this, Zv, "f") && ww(this, Zv, "f").spawn(i.x, i.y, i.z)) : (n < ww(this, qv, "f").length && (null === (t = ww(this, Yv, "f")) || void 0 === t ? void 0 : t.getSettingBoolean(Jo.SkidmarksEnabled)) && ww(this, qv, "f")[n].break(),
                                    ww(this, Xv, "f")[n] = .075)
                            }
                        }
                        ,
                        sw = function() {
                            if (null != ww(this, uv, "f") && null != ww(this, uv, "f").context && null != ww(this, uv, "f").destinationSfx) {
                                null == ww(this, pv, "f") && (vw(this, pv, ww(this, uv, "f").context.createGain(), "f"),
                                    ww(this, pv, "f").gain.value = ww(this, fv, "f"),
                                    ww(this, pv, "f").connect(ww(this, uv, "f").destinationSfx)),
                                null == ww(this, Av, "f") && (vw(this, Av, ww(this, uv, "f").context.createPanner(), "f"),
                                    ww(this, Av, "f").refDistance = 5,
                                    ww(this, Av, "f").connect(ww(this, pv, "f")));
                                const e = this.getPosition();
                                ww(this, Av, "f").positionX.value = e.x,
                                    ww(this, Av, "f").positionY.value = e.y,
                                    ww(this, Av, "f").positionZ.value = e.z;
                                const t = 4;
                                if (ww(this, yv, "f").length < t) {
                                    ww(this, yv, "f").length = 0;
                                    for (let e = 0; e < t; ++e) {
                                        const e = ww(this, uv, "f").context.createPanner();
                                        e.refDistance = 5,
                                            e.connect(ww(this, pv, "f")),
                                            ww(this, yv, "f").push(e)
                                    }
                                }
                                for (let e = 0; e < t; ++e) {
                                    const t = ww(this, yv, "f")[e]
                                        , n = ww(this, Sv, "f").wheelPosition[e];
                                    t.positionX.value = n.x,
                                        t.positionY.value = n.y,
                                        t.positionZ.value = n.z
                                }
                                ww(this, Dv, "f").camera != ww(this, bv, "f").camera && ww(this, Dv, "f").camera != ww(this, xv, "f").camera || ww(this, uv, "f").refreshListener(ww(this, Dv, "f")),
                                    ww(this, hv, "m", ow).call(this),
                                    ww(this, hv, "m", cw).call(this),
                                    ww(this, hv, "m", uw).call(this)
                            }
                        }
                        ,
                        ow = function() {
                            if (null == ww(this, mv, "f") && null != ww(this, Av, "f") && null != ww(this, uv, "f")) {
                                const e = ww(this, uv, "f").getBuffer("engine");
                                if (null != e && null != ww(this, uv, "f").context) {
                                    const t = ww(this, uv, "f").context.createBufferSource();
                                    t.buffer = e,
                                        t.loop = !0,
                                        t.playbackRate.value = .7;
                                    const n = ww(this, uv, "f").context.createGain();
                                    n.gain.value = 0,
                                        t.connect(n),
                                        n.connect(ww(this, Av, "f")),
                                        t.start(0, 2 * Math.random()),
                                        vw(this, mv, {
                                            source: t,
                                            gain: n
                                        }, "f")
                                }
                            }
                            if (null != ww(this, mv, "f")) {
                                const e = (ww(this, Rv, "f")[0] + ww(this, Rv, "f")[1] + ww(this, Rv, "f")[2] + ww(this, Rv, "f")[3]) / 4
                                    , t = .7 + Math.pow(Math.abs(e), 1 / 3) / 3
                                    , n = ww(this, Sv, "f").wheelInContact[0] || ww(this, Sv, "f").wheelInContact[1] || ww(this, Sv, "f").wheelInContact[2] || ww(this, Sv, "f").wheelInContact[3]
                                    , {up: i, down: r} = this.getControls()
                                    , a = this.hasStarted() && !this.hasFinished() && (i && !(r && ww(this, Sv, "f").brakeLightEnabled) || r && !ww(this, Sv, "f").brakeLightEnabled);
                                let s;
                                s = n ? a ? t : Math.max(.7, t / 2) : a ? Math.max(.7, 1.15 * t) : Math.max(.7, t / 2),
                                    ww(this, mv, "f").source.playbackRate.setTargetAtTime(s, 0, .05),
                                    ww(this, mv, "f").gain.gain.setTargetAtTime(Math.min(.285, s / 14), 0, .05)
                            }
                        }
                        ,
                        lw = function(e) {
                            if (ww(this, gv, "f").length < 4) {
                                ww(this, gv, "f").length = 0;
                                for (let e = 0; e < 4; ++e)
                                    ww(this, gv, "f").push(0)
                            }
                            for (let t = 0; t < 4 && t < ww(this, yv, "f").length; t++)
                                if (ww(this, gv, "f")[t] -= e,
                                ww(this, gv, "f")[t] <= 0) {
                                    const e = Math.abs(ww(this, Sv, "f").wheelSuspensionVelocity[t]);
                                    if (e > 4 && null != ww(this, uv, "f")) {
                                        const n = ww(this, uv, "f").getBuffer("suspension");
                                        if (null != n && null != ww(this, uv, "f").context) {
                                            const i = ww(this, uv, "f").context.createBufferSource();
                                            i.buffer = n,
                                                i.playbackRate.value = .7 + .1 * Math.random();
                                            const r = ww(this, uv, "f").context.createGain();
                                            r.gain.value = Math.min(.285, e / 140),
                                                i.connect(r),
                                                r.connect(ww(this, yv, "f")[t]),
                                                i.start(ww(this, uv, "f").context.currentTime + .02 * Math.random()),
                                                ww(this, gv, "f")[t] = .1
                                        }
                                    }
                                }
                        }
                        ,
                        cw = function() {
                            if (null == ww(this, vv, "f") && null != ww(this, uv, "f")) {
                                const e = ww(this, uv, "f").getBuffer("tires");
                                if (null != e && null != ww(this, uv, "f").context) {
                                    vw(this, vv, [], "f");
                                    const t = 4;
                                    for (let n = 0; n < t; n++) {
                                        const i = ww(this, uv, "f").context.createBufferSource();
                                        i.buffer = e,
                                            i.loop = !0,
                                            i.playbackRate.value = .3;
                                        const r = ww(this, uv, "f").context.createGain();
                                        r.gain.value = 0,
                                            i.connect(r),
                                            r.connect(ww(this, yv, "f")[n]),
                                            i.start(0, n / t * 3.5 + .25 * Math.random()),
                                            ww(this, vv, "f").push({
                                                source: i,
                                                gain: r
                                            })
                                    }
                                }
                            }
                            if (null != ww(this, vv, "f"))
                                for (let e = 0; e < ww(this, vv, "f").length; ++e) {
                                    const t = ww(this, vv, "f")[e];
                                    if (ww(this, Sv, "f").wheelInContact[e]) {
                                        const e = Math.min(3, Math.abs(this.getSpeedKmh()) / 110);
                                        t.gain.gain.setTargetAtTime(e / 10.5, 0, .15)
                                    } else
                                        t.gain.gain.setTargetAtTime(0, 0, .15);
                                    const n = .3 + Math.min(.4, Math.abs(this.getSpeedKmh()) / 800);
                                    t.source.playbackRate.setTargetAtTime(n, 0, .15)
                                }
                        }
                        ,
                        hw = function(e) {
                            null != ww(this, wv, "f") && (ww(this, wv, "f").timeout -= e,
                            ww(this, wv, "f").timeout <= 0 && vw(this, wv, null, "f"));
                            const t = ww(this, Sv, "f").collisionImpulses;
                            for (const e of t)
                                ww(this, hv, "m", dw).call(this, e)
                        }
                        ,
                        dw = function(e) {
                            if (e > 25 && null != ww(this, Av, "f") && null != ww(this, uv, "f") && (null == ww(this, wv, "f") || ww(this, wv, "f").impulse + 100 < e)) {
                                vw(this, wv, {
                                    timeout: .2,
                                    impulse: e
                                }, "f");
                                const t = ww(this, uv, "f").getBuffer("collision");
                                if (null != t && null != ww(this, uv, "f").context) {
                                    const n = ww(this, uv, "f").context.createBufferSource();
                                    n.buffer = t,
                                        n.playbackRate.value = .1 + .15 * Math.min(e / 4e3, 1);
                                    const i = ww(this, uv, "f").context.createGain();
                                    i.gain.value = Math.max(.3, Math.min(e / 4e3, 1)) / 2.5,
                                        n.connect(i),
                                        i.connect(ww(this, Av, "f")),
                                        n.start(0)
                                }
                            }
                        }
                        ,
                        uw = function() {
                            if (null == ww(this, Kv, "f") && null != ww(this, uv, "f")) {
                                const e = ww(this, uv, "f").getBuffer("skidding");
                                if (null != e && null != ww(this, uv, "f").context) {
                                    vw(this, Kv, [], "f");
                                    const t = 4;
                                    for (let n = 0; n < t; ++n) {
                                        const i = ww(this, uv, "f").context.createBufferSource();
                                        i.buffer = e,
                                            i.loop = !0,
                                            i.playbackRate.value = .5;
                                        const r = ww(this, uv, "f").context.createGain();
                                        r.gain.value = 0,
                                            i.connect(r),
                                            r.connect(ww(this, yv, "f")[n]),
                                            i.start(0, n / t * 3.5 + .25 * Math.random()),
                                            ww(this, Kv, "f").push({
                                                source: i,
                                                gain: r
                                            })
                                    }
                                }
                            }
                            if (null != ww(this, Kv, "f"))
                                for (let e = 0; e < ww(this, Kv, "f").length; ++e) {
                                    const t = ww(this, Kv, "f")[e];
                                    0 == ww(this, Xv, "f")[e] ? t.gain.gain.setTargetAtTime(.75 / 3.5, 0, .1) : t.gain.gain.setTargetAtTime(0, 0, .1)
                                }
                        }
                        ,
                        pw = function(e) {
                            null != ww(this, Fv, "f") && (e ? ww(this, Fv, "f").emissive.setRGB(1, .4, .3) : ww(this, Fv, "f").emissive.setRGB(0, 0, 0))
                        }
                        ,
                        fw = function(e) {
                            const t = e.geometry.toNonIndexed();
                            if (!(t.attributes.position instanceof Ki))
                                throw new Error("Vertices must use BufferAttribute");
                            return Array.from(t.attributes.position.array)
                        }
                        ,
                        mw = function() {
                            return gw(this, void 0, void 0, (function*() {
                                    if (null == dv.models)
                                        throw new Error("Car models are not loaded yet");
                                    const e = new Float32Array(dv.models.collisionShapeVertices)
                                        , t = yield window.crypto.subtle.digest("SHA-256", e.buffer)
                                        , n = Array.from(new Uint8Array(t)).map((e => e.toString(16).padStart(2, "0"))).join("")
                                        , i = "dd663fb6330ed93725bf865d5eac2cd29ba19f74dbb3f67ae7f695ea1f68aed0";
                                    return n == i || console.error("Car collision model checksum mismatch: " + n + " != " + i),
                                    n == i
                                }
                            ))
                        }
                        ,
                        Aw.massOffset = .6,
                        Aw.detectorBoxCenter = new An(0,.48,-.15),
                        Aw.detectorBoxSize = new An(.89,.22,1.8),
                        Aw.suspensionResetLengthFront = .07809501004219055,
                        Aw.suspensionResetLengthRear = .0781289680480957,
                        Aw.models = null,
                        Aw.images = null;
                    const yw = Aw;
                    var bw = n(5959)
                        , xw = {};
                    xw.styleTagTransform = u(),
                        xw.setAttributes = l(),
                        xw.insert = s().bind(null, "head"),
                        xw.domAPI = r(),
                        xw.insertStyleElement = h();
                    t()(bw.A, xw);
                    bw.A && bw.A.locals && bw.A.locals;
                    const kw = new qn
                        , Ew = new ga
                        , Sw = Math.cos(Math.PI / 180 * 70)
                        , Mw = (e, t) => (e % t + t) % t;
                    class Tw extends Lt {
                        constructor(e, t) {
                            super(),
                                this.enabled = !0,
                                this.target = new An,
                                this.minDistance = 0,
                                this.maxDistance = 1 / 0,
                                this.minZoom = 0,
                                this.maxZoom = 1 / 0,
                                this.minPolarAngle = 0,
                                this.maxPolarAngle = Math.PI,
                                this.minAzimuthAngle = -1 / 0,
                                this.maxAzimuthAngle = 1 / 0,
                                this.enableDamping = !1,
                                this.dampingFactor = .05,
                                this.enableZoom = !0,
                                this.zoomSpeed = 1,
                                this.enableRotate = !0,
                                this.rotateSpeed = 1,
                                this.enablePan = !0,
                                this.panSpeed = 1,
                                this.screenSpacePanning = !0,
                                this.keyPanSpeed = 7,
                                this.zoomToCursor = !1,
                                this.autoRotate = !1,
                                this.autoRotateSpeed = 2,
                                this.reverseOrbit = !1,
                                this.reverseHorizontalOrbit = !1,
                                this.reverseVerticalOrbit = !1,
                                this.keys = {
                                    LEFT: "ArrowLeft",
                                    UP: "ArrowUp",
                                    RIGHT: "ArrowRight",
                                    BOTTOM: "ArrowDown"
                                },
                                this.mouseButtons = {
                                    LEFT: g,
                                    MIDDLE: v,
                                    RIGHT: w
                                },
                                this.touches = {
                                    ONE: A,
                                    TWO: b
                                },
                                this._domElementKeyEvents = null,
                                this.object = e,
                                this.domElement = t,
                                this.target0 = this.target.clone(),
                                this.position0 = this.object.position.clone(),
                                this.zoom0 = this.object.zoom,
                                this.getPolarAngle = () => c.phi,
                                this.getAzimuthalAngle = () => c.theta,
                                this.setPolarAngle = e => {
                                    let t = Mw(e, 2 * Math.PI)
                                        , i = c.phi;
                                    i < 0 && (i += 2 * Math.PI),
                                    t < 0 && (t += 2 * Math.PI);
                                    const r = Math.abs(t - i);
                                    2 * Math.PI - r < r && (t < i ? t += 2 * Math.PI : i += 2 * Math.PI),
                                        h.phi = t - i,
                                        n.update()
                                }
                                ,
                                this.setAzimuthalAngle = e => {
                                    let t = Mw(e, 2 * Math.PI)
                                        , i = c.theta;
                                    i < 0 && (i += 2 * Math.PI),
                                    t < 0 && (t += 2 * Math.PI);
                                    const r = Math.abs(t - i);
                                    2 * Math.PI - r < r && (t < i ? t += 2 * Math.PI : i += 2 * Math.PI),
                                        h.theta = t - i,
                                        n.update()
                                }
                                ,
                                this.getDistance = () => n.object.position.distanceTo(n.target),
                                this.listenToKeyEvents = e => {
                                    e.addEventListener("keydown", ie),
                                        this._domElementKeyEvents = e
                                }
                                ,
                                this.stopListenToKeyEvents = () => {
                                    this._domElementKeyEvents.removeEventListener("keydown", ie),
                                        this._domElementKeyEvents = null
                                }
                                ,
                                this.saveState = () => {
                                    n.target0.copy(n.target),
                                        n.position0.copy(n.object.position),
                                        n.zoom0 = n.object.zoom
                                }
                                ,
                                this.reset = () => {
                                    n.target.copy(n.target0),
                                        n.object.position.copy(n.position0),
                                        n.object.zoom = n.zoom0,
                                        n.object.updateProjectionMatrix(),
                                        n.dispatchEvent(i),
                                        n.update(),
                                        o = s.NONE
                                }
                                ,
                                this.update = ( () => {
                                        const t = new An
                                            , r = new An(0,1,0)
                                            , a = (new wn).setFromUnitVectors(e.up, r)
                                            , p = a.clone().invert()
                                            , f = new An
                                            , m = new wn
                                            , g = 2 * Math.PI;
                                        return function() {
                                            const v = n.object.position;
                                            a.setFromUnitVectors(e.up, r),
                                                p.copy(a).invert(),
                                                t.copy(v).sub(n.target),
                                                t.applyQuaternion(a),
                                                c.setFromVector3(t),
                                            n.autoRotate && o === s.NONE && D(2 * Math.PI / 60 / 60 * n.autoRotateSpeed),
                                                n.enableDamping ? (c.theta += h.theta * n.dampingFactor,
                                                    c.phi += h.phi * n.dampingFactor) : (c.theta += h.theta,
                                                    c.phi += h.phi);
                                            let w = n.minAzimuthAngle
                                                , A = n.maxAzimuthAngle;
                                            isFinite(w) && isFinite(A) && (w < -Math.PI ? w += g : w > Math.PI && (w -= g),
                                                A < -Math.PI ? A += g : A > Math.PI && (A -= g),
                                                c.theta = w <= A ? Math.max(w, Math.min(A, c.theta)) : c.theta > (w + A) / 2 ? Math.max(w, c.theta) : Math.min(A, c.theta)),
                                                c.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, c.phi)),
                                                c.makeSafe(),
                                                !0 === n.enableDamping ? n.target.addScaledVector(u, n.dampingFactor) : n.target.add(u),
                                                n.zoomToCursor && P || n.object.isOrthographicCamera ? c.radius = G(c.radius) : c.radius = G(c.radius * d),
                                                t.setFromSpherical(c),
                                                t.applyQuaternion(p),
                                                v.copy(n.target).add(t),
                                            n.object.matrixAutoUpdate || n.object.updateMatrix(),
                                                n.object.lookAt(n.target),
                                                !0 === n.enableDamping ? (h.theta *= 1 - n.dampingFactor,
                                                    h.phi *= 1 - n.dampingFactor,
                                                    u.multiplyScalar(1 - n.dampingFactor)) : (h.set(0, 0, 0),
                                                    u.set(0, 0, 0));
                                            let y = !1;
                                            if (n.zoomToCursor && P) {
                                                let i = null;
                                                if (n.object instanceof Ir && n.object.isPerspectiveCamera) {
                                                    const e = t.length();
                                                    i = G(e * d);
                                                    const r = e - i;
                                                    n.object.position.addScaledVector(_, r),
                                                        n.object.updateMatrixWorld()
                                                } else if (n.object.isOrthographicCamera) {
                                                    const e = new An(I.x,I.y,0);
                                                    e.unproject(n.object),
                                                        n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / d)),
                                                        n.object.updateProjectionMatrix(),
                                                        y = !0;
                                                    const r = new An(I.x,I.y,0);
                                                    r.unproject(n.object),
                                                        n.object.position.sub(r).add(e),
                                                        n.object.updateMatrixWorld(),
                                                        i = t.length()
                                                } else
                                                    console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),
                                                        n.zoomToCursor = !1;
                                                null !== i && (n.screenSpacePanning ? n.target.set(0, 0, -1).transformDirection(n.object.matrix).multiplyScalar(i).add(n.object.position) : (kw.origin.copy(n.object.position),
                                                    kw.direction.set(0, 0, -1).transformDirection(n.object.matrix),
                                                    Math.abs(n.object.up.dot(kw.direction)) < Sw ? e.lookAt(n.target) : (Ew.setFromNormalAndCoplanarPoint(n.object.up, n.target),
                                                        kw.intersectPlane(Ew, n.target))))
                                            } else
                                                n.object instanceof Po && n.object.isOrthographicCamera && (y = 1 !== d,
                                                y && (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / d)),
                                                    n.object.updateProjectionMatrix()));
                                            return d = 1,
                                                P = !1,
                                            !!(y || f.distanceToSquared(n.object.position) > l || 8 * (1 - m.dot(n.object.quaternion)) > l) && (n.dispatchEvent(i),
                                                f.copy(n.object.position),
                                                m.copy(n.object.quaternion),
                                                y = !1,
                                                !0)
                                        }
                                    }
                                )(),
                                this.connect = e => {
                                    n.domElement = e,
                                        n.domElement.style.touchAction = "none",
                                        n.domElement.addEventListener("contextmenu", ae),
                                        n.domElement.addEventListener("pointerdown", $),
                                        n.domElement.addEventListener("pointercancel", te),
                                        n.domElement.addEventListener("touchstart", se),
                                        n.domElement.addEventListener("wheel", ne)
                                }
                                ,
                                this.dispose = () => {
                                    var e, t, i, r, a, s, o;
                                    n.domElement && (n.domElement.style.touchAction = "auto"),
                                    null === (e = n.domElement) || void 0 === e || e.removeEventListener("contextmenu", ae),
                                    null === (t = n.domElement) || void 0 === t || t.removeEventListener("pointerdown", $),
                                    null === (i = n.domElement) || void 0 === i || i.removeEventListener("pointercancel", te),
                                    null === (r = n.domElement) || void 0 === r || r.removeEventListener("touchstart", se),
                                    null === (a = n.domElement) || void 0 === a || a.removeEventListener("wheel", ne),
                                    null === (s = n.domElement) || void 0 === s || s.ownerDocument.removeEventListener("pointermove", ee),
                                    null === (o = n.domElement) || void 0 === o || o.ownerDocument.removeEventListener("pointerup", te),
                                    null !== n._domElementKeyEvents && n._domElementKeyEvents.removeEventListener("keydown", ie)
                                }
                            ;
                            const n = this
                                , i = {
                                type: "change"
                            }
                                , r = {
                                type: "start"
                            }
                                , a = {
                                type: "end"
                            }
                                , s = {
                                NONE: -1,
                                ROTATE: 0,
                                DOLLY: 1,
                                PAN: 2,
                                TOUCH_ROTATE: 3,
                                TOUCH_PAN: 4,
                                TOUCH_DOLLY_PAN: 5,
                                TOUCH_DOLLY_ROTATE: 6
                            };
                            let o = s.NONE;
                            const l = 1e-6
                                , c = new qo
                                , h = new qo;
                            let d = 1;
                            const u = new An
                                , p = new jt
                                , f = new jt
                                , m = new jt
                                , k = new jt
                                , E = new jt
                                , S = new jt
                                , M = new jt
                                , T = new jt
                                , C = new jt
                                , _ = new An
                                , I = new jt;
                            let P = !1;
                            const R = []
                                , L = {};
                            function N() {
                                return Math.pow(.95, n.zoomSpeed)
                            }
                            function D(e) {
                                n.reverseOrbit || n.reverseHorizontalOrbit ? h.theta += e : h.theta -= e
                            }
                            function B(e) {
                                n.reverseOrbit || n.reverseVerticalOrbit ? h.phi += e : h.phi -= e
                            }
                            const U = ( () => {
                                    const e = new An;
                                    return function(t, n) {
                                        e.setFromMatrixColumn(n, 0),
                                            e.multiplyScalar(-t),
                                            u.add(e)
                                    }
                                }
                            )()
                                , z = ( () => {
                                    const e = new An;
                                    return function(t, i) {
                                        !0 === n.screenSpacePanning ? e.setFromMatrixColumn(i, 1) : (e.setFromMatrixColumn(i, 0),
                                            e.crossVectors(n.object.up, e)),
                                            e.multiplyScalar(t),
                                            u.add(e)
                                    }
                                }
                            )()
                                , O = ( () => {
                                    const e = new An;
                                    return function(t, i) {
                                        const r = n.domElement;
                                        if (r && n.object instanceof Ir && n.object.isPerspectiveCamera) {
                                            const a = n.object.position;
                                            e.copy(a).sub(n.target);
                                            let s = e.length();
                                            s *= Math.tan(n.object.fov / 2 * Math.PI / 180),
                                                U(2 * t * s / r.clientHeight, n.object.matrix),
                                                z(2 * i * s / r.clientHeight, n.object.matrix)
                                        } else
                                            r && n.object instanceof Po && n.object.isOrthographicCamera ? (U(t * (n.object.right - n.object.left) / n.object.zoom / r.clientWidth, n.object.matrix),
                                                z(i * (n.object.top - n.object.bottom) / n.object.zoom / r.clientHeight, n.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),
                                                n.enablePan = !1)
                                    }
                                }
                            )();
                            function F(e) {
                                n.object instanceof Ir && n.object.isPerspectiveCamera || n.object instanceof Po && n.object.isOrthographicCamera ? d = e : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
                                    n.enableZoom = !1)
                            }
                            function W(e) {
                                F(d / e)
                            }
                            function H(e) {
                                F(d * e)
                            }
                            function V(e) {
                                if (!n.zoomToCursor || !n.domElement)
                                    return;
                                P = !0;
                                const t = n.domElement.getBoundingClientRect()
                                    , i = e.clientX - t.left
                                    , r = e.clientY - t.top
                                    , a = t.width
                                    , s = t.height;
                                I.x = i / a * 2 - 1,
                                    I.y = -r / s * 2 + 1,
                                    _.set(I.x, I.y, 1).unproject(n.object).sub(n.object.position).normalize()
                            }
                            function G(e) {
                                return Math.max(n.minDistance, Math.min(n.maxDistance, e))
                            }
                            function j(e) {
                                p.set(e.clientX, e.clientY)
                            }
                            function Q(e) {
                                k.set(e.clientX, e.clientY)
                            }
                            function Y() {
                                if (1 == R.length)
                                    p.set(R[0].pageX, R[0].pageY);
                                else {
                                    const e = .5 * (R[0].pageX + R[1].pageX)
                                        , t = .5 * (R[0].pageY + R[1].pageY);
                                    p.set(e, t)
                                }
                            }
                            function q() {
                                if (1 == R.length)
                                    k.set(R[0].pageX, R[0].pageY);
                                else {
                                    const e = .5 * (R[0].pageX + R[1].pageX)
                                        , t = .5 * (R[0].pageY + R[1].pageY);
                                    k.set(e, t)
                                }
                            }
                            function K() {
                                const e = R[0].pageX - R[1].pageX
                                    , t = R[0].pageY - R[1].pageY
                                    , n = Math.sqrt(e * e + t * t);
                                M.set(0, n)
                            }
                            function X(e) {
                                if (1 == R.length)
                                    f.set(e.pageX, e.pageY);
                                else {
                                    const t = le(e)
                                        , n = .5 * (e.pageX + t.x)
                                        , i = .5 * (e.pageY + t.y);
                                    f.set(n, i)
                                }
                                m.subVectors(f, p).multiplyScalar(n.rotateSpeed);
                                const t = n.domElement;
                                t && (D(2 * Math.PI * m.x / t.clientHeight),
                                    B(2 * Math.PI * m.y / t.clientHeight)),
                                    p.copy(f)
                            }
                            function Z(e) {
                                if (1 == R.length)
                                    E.set(e.pageX, e.pageY);
                                else {
                                    const t = le(e)
                                        , n = .5 * (e.pageX + t.x)
                                        , i = .5 * (e.pageY + t.y);
                                    E.set(n, i)
                                }
                                S.subVectors(E, k).multiplyScalar(n.panSpeed),
                                    O(S.x, S.y),
                                    k.copy(E)
                            }
                            function J(e) {
                                const t = le(e)
                                    , i = e.pageX - t.x
                                    , r = e.pageY - t.y
                                    , a = Math.sqrt(i * i + r * r);
                                T.set(0, a),
                                    C.set(0, Math.pow(T.y / M.y, n.zoomSpeed)),
                                    W(C.y),
                                    M.copy(T)
                            }
                            function $(e) {
                                var t, i;
                                !1 !== n.enabled && (0 === R.length && (null === (t = n.domElement) || void 0 === t || t.ownerDocument.addEventListener("pointermove", ee),
                                null === (i = n.domElement) || void 0 === i || i.ownerDocument.addEventListener("pointerup", te)),
                                    function(e) {
                                        R.push(e)
                                    }(e),
                                    "touch" === e.pointerType ? function(e) {
                                        oe(e),
                                            re(),
                                        o !== s.NONE && n.dispatchEvent(r)
                                    }(e) : function(e) {
                                        let t;
                                        switch (e.button) {
                                            case 0:
                                                t = n.mouseButtons.LEFT;
                                                break;
                                            case 1:
                                                t = n.mouseButtons.MIDDLE;
                                                break;
                                            case 2:
                                                t = n.mouseButtons.RIGHT;
                                                break;
                                            default:
                                                t = -1
                                        }
                                        switch (t) {
                                            case v:
                                                if (!1 === n.enableZoom)
                                                    return;
                                                !function(e) {
                                                    V(e),
                                                        M.set(e.clientX, e.clientY)
                                                }(e),
                                                    o = s.DOLLY;
                                                break;
                                            case g:
                                                if (e.ctrlKey || e.metaKey || e.shiftKey) {
                                                    if (!1 === n.enablePan)
                                                        return;
                                                    Q(e),
                                                        o = s.PAN
                                                } else {
                                                    if (!1 === n.enableRotate)
                                                        return;
                                                    j(e),
                                                        o = s.ROTATE
                                                }
                                                break;
                                            case w:
                                                if (e.ctrlKey || e.metaKey || e.shiftKey) {
                                                    if (!1 === n.enableRotate)
                                                        return;
                                                    j(e),
                                                        o = s.ROTATE
                                                } else {
                                                    if (!1 === n.enablePan)
                                                        return;
                                                    Q(e),
                                                        o = s.PAN
                                                }
                                                break;
                                            default:
                                                o = s.NONE
                                        }
                                        o !== s.NONE && n.dispatchEvent(r)
                                    }(e))
                            }
                            function ee(e) {
                                !1 !== n.enabled && ("touch" === e.pointerType ? function(e) {
                                    switch (oe(e),
                                        o) {
                                        case s.TOUCH_ROTATE:
                                            if (!1 === n.enableRotate)
                                                return;
                                            X(e),
                                                n.update();
                                            break;
                                        case s.TOUCH_PAN:
                                            if (!1 === n.enablePan)
                                                return;
                                            Z(e),
                                                n.update();
                                            break;
                                        case s.TOUCH_DOLLY_PAN:
                                            if (!1 === n.enableZoom && !1 === n.enablePan)
                                                return;
                                            !function(e) {
                                                n.enableZoom && J(e),
                                                n.enablePan && Z(e)
                                            }(e),
                                                n.update();
                                            break;
                                        case s.TOUCH_DOLLY_ROTATE:
                                            if (!1 === n.enableZoom && !1 === n.enableRotate)
                                                return;
                                            !function(e) {
                                                n.enableZoom && J(e),
                                                n.enableRotate && X(e)
                                            }(e),
                                                n.update();
                                            break;
                                        default:
                                            o = s.NONE
                                    }
                                }(e) : function(e) {
                                    if (!1 === n.enabled)
                                        return;
                                    switch (o) {
                                        case s.ROTATE:
                                            if (!1 === n.enableRotate)
                                                return;
                                            !function(e) {
                                                f.set(e.clientX, e.clientY),
                                                    m.subVectors(f, p).multiplyScalar(n.rotateSpeed);
                                                const t = n.domElement;
                                                t && (D(2 * Math.PI * m.x / t.clientHeight),
                                                    B(2 * Math.PI * m.y / t.clientHeight)),
                                                    p.copy(f),
                                                    n.update()
                                            }(e);
                                            break;
                                        case s.DOLLY:
                                            if (!1 === n.enableZoom)
                                                return;
                                            !function(e) {
                                                T.set(e.clientX, e.clientY),
                                                    C.subVectors(T, M),
                                                    C.y > 0 ? W(N()) : C.y < 0 && H(N()),
                                                    M.copy(T),
                                                    n.update()
                                            }(e);
                                            break;
                                        case s.PAN:
                                            if (!1 === n.enablePan)
                                                return;
                                            !function(e) {
                                                E.set(e.clientX, e.clientY),
                                                    S.subVectors(E, k).multiplyScalar(n.panSpeed),
                                                    O(S.x, S.y),
                                                    k.copy(E),
                                                    n.update()
                                            }(e)
                                    }
                                }(e))
                            }
                            function te(e) {
                                var t, i, r;
                                !function(e) {
                                    delete L[e.pointerId];
                                    for (let t = 0; t < R.length; t++)
                                        if (R[t].pointerId == e.pointerId)
                                            return void R.splice(t, 1)
                                }(e),
                                0 === R.length && (null === (t = n.domElement) || void 0 === t || t.releasePointerCapture(e.pointerId),
                                null === (i = n.domElement) || void 0 === i || i.ownerDocument.removeEventListener("pointermove", ee),
                                null === (r = n.domElement) || void 0 === r || r.ownerDocument.removeEventListener("pointerup", te)),
                                    n.dispatchEvent(a),
                                    o = s.NONE
                            }
                            function ne(e) {
                                !1 === n.enabled || !1 === n.enableZoom || o !== s.NONE && o !== s.ROTATE || (e.preventDefault(),
                                    n.dispatchEvent(r),
                                    function(e) {
                                        V(e),
                                            e.deltaY < 0 ? H(N()) : e.deltaY > 0 && W(N()),
                                            n.update()
                                    }(e),
                                    n.dispatchEvent(a))
                            }
                            function ie(e) {
                                !1 !== n.enabled && !1 !== n.enablePan && function(e) {
                                    let t = !1;
                                    switch (e.code) {
                                        case n.keys.UP:
                                            O(0, n.keyPanSpeed),
                                                t = !0;
                                            break;
                                        case n.keys.BOTTOM:
                                            O(0, -n.keyPanSpeed),
                                                t = !0;
                                            break;
                                        case n.keys.LEFT:
                                            O(n.keyPanSpeed, 0),
                                                t = !0;
                                            break;
                                        case n.keys.RIGHT:
                                            O(-n.keyPanSpeed, 0),
                                                t = !0
                                    }
                                    t && (e.preventDefault(),
                                        n.update())
                                }(e)
                            }
                            function re() {
                                switch (R.length) {
                                    case 1:
                                        switch (n.touches.ONE) {
                                            case A:
                                                if (!1 === n.enableRotate)
                                                    return;
                                                Y(),
                                                    o = s.TOUCH_ROTATE;
                                                break;
                                            case y:
                                                if (!1 === n.enablePan)
                                                    return;
                                                q(),
                                                    o = s.TOUCH_PAN;
                                                break;
                                            default:
                                                o = s.NONE
                                        }
                                        break;
                                    case 2:
                                        switch (n.touches.TWO) {
                                            case b:
                                                if (!1 === n.enableZoom && !1 === n.enablePan)
                                                    return;
                                                n.enableZoom && K(),
                                                n.enablePan && q(),
                                                    o = s.TOUCH_DOLLY_PAN;
                                                break;
                                            case x:
                                                if (!1 === n.enableZoom && !1 === n.enableRotate)
                                                    return;
                                                n.enableZoom && K(),
                                                n.enableRotate && Y(),
                                                    o = s.TOUCH_DOLLY_ROTATE;
                                                break;
                                            default:
                                                o = s.NONE
                                        }
                                        break;
                                    default:
                                        o = s.NONE
                                }
                            }
                            function ae(e) {
                                !1 !== n.enabled && e.preventDefault()
                            }
                            function se(e) {
                                const t = new Set(Array.from(e.touches).map((e => e.identifier)))
                                    , n = R.length;
                                for (let e = R.length - 1; e >= 0; e--)
                                    t.has(R[e].pointerId) || R.splice(e, 1);
                                R.length !== n && (console.log("handleTouchStart: invalid pointers detected, corrected"),
                                    re())
                            }
                            function oe(e) {
                                let t = L[e.pointerId];
                                void 0 === t && (t = new jt,
                                    L[e.pointerId] = t),
                                    t.set(e.pageX, e.pageY)
                            }
                            function le(e) {
                                const t = e.pointerId === R[0].pointerId ? R[1] : R[0];
                                return L[t.pointerId]
                            }
                            this.dollyIn = (e=N()) => {
                                H(e),
                                    n.update()
                            }
                                ,
                                this.dollyOut = (e=N()) => {
                                    W(e),
                                        n.update()
                                }
                                ,
                                this.getScale = () => d,
                                this.setScale = e => {
                                    F(e),
                                        n.update()
                                }
                                ,
                                this.getZoomScale = () => N(),
                            void 0 !== t && this.connect(t),
                                this.update()
                        }
                    }
                    class Cw extends Tw {
                        constructor(e, t) {
                            super(e, t),
                                this.screenSpacePanning = !1,
                                this.mouseButtons.LEFT = w,
                                this.mouseButtons.RIGHT = g,
                                this.touches.ONE = y,
                                this.touches.TWO = x
                        }
                    }
                    var _w = n(5848)
                        , Iw = {};
                    Iw.styleTagTransform = u(),
                        Iw.setAttributes = l(),
                        Iw.insert = s().bind(null, "head"),
                        Iw.domAPI = r(),
                        Iw.insertStyleElement = h();
                    t()(_w.A, Iw);
                    _w.A && _w.A.locals && _w.A.locals;
                    var Pw, Rw, Lw, Nw, Dw, Bw, Uw, zw, Ow, Fw, Ww, Hw, Vw, Gw, jw, Qw, Yw, qw, Kw, Xw = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, Zw = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    Rw = new WeakMap,
                        Lw = new WeakMap,
                        Nw = new WeakMap,
                        Dw = new WeakMap,
                        Bw = new WeakMap,
                        Uw = new WeakMap,
                        zw = new WeakMap,
                        Ow = new WeakMap,
                        Fw = new WeakMap,
                        Ww = new WeakMap,
                        Hw = new WeakMap,
                        Vw = new WeakMap,
                        Gw = new WeakMap,
                        jw = new WeakMap,
                        Qw = new WeakMap,
                        Yw = new WeakMap,
                        Pw = new WeakSet,
                        qw = function() {
                            Zw(this, Ow, "f").style.left = "calc(" + (100 * Zw(this, Vw, "f") / 360).toString() + "% - 1px)",
                                Zw(this, Dw, "f").style.backgroundImage = "linear-gradient(transparent, #000), linear-gradient(to right, transparent, hsla(" + Zw(this, Vw, "f").toString() + ", 100%, 50%, 1))"
                        }
                        ,
                        Kw = function() {
                            Zw(this, Bw, "f").style.left = "calc(" + Zw(this, Hw, "f").toString() + "% - 6px)",
                                Zw(this, Bw, "f").style.top = "calc(" + (100 - Zw(this, Ww, "f")).toString() + "% - 6px)"
                        }
                    ;
                    const Jw = class {
                            constructor(e, t) {
                                Pw.add(this),
                                    Rw.set(this, void 0),
                                    Lw.set(this, void 0),
                                    Nw.set(this, void 0),
                                    Dw.set(this, void 0),
                                    Bw.set(this, void 0),
                                    Uw.set(this, !1),
                                    zw.set(this, void 0),
                                    Ow.set(this, void 0),
                                    Fw.set(this, !1),
                                    Ww.set(this, 0),
                                    Hw.set(this, 0),
                                    Vw.set(this, 0),
                                    Gw.set(this, void 0),
                                    jw.set(this, void 0),
                                    Qw.set(this, void 0),
                                    Yw.set(this, void 0),
                                    Xw(this, Rw, e, "f"),
                                    Xw(this, Lw, t, "f"),
                                    Xw(this, Nw, document.createElement("div"), "f"),
                                    Zw(this, Nw, "f").className = "color-picker",
                                    Xw(this, Dw, document.createElement("div"), "f"),
                                    Zw(this, Dw, "f").className = "value-saturation-picker",
                                    Zw(this, Nw, "f").appendChild(Zw(this, Dw, "f")),
                                    Xw(this, Bw, document.createElement("div"), "f"),
                                    Zw(this, Bw, "f").className = "marker",
                                    Zw(this, Dw, "f").appendChild(Zw(this, Bw, "f")),
                                    Xw(this, zw, document.createElement("div"), "f"),
                                    Zw(this, zw, "f").className = "hue-picker",
                                    Zw(this, Nw, "f").appendChild(Zw(this, zw, "f")),
                                    Xw(this, Ow, document.createElement("div"), "f"),
                                    Zw(this, Ow, "f").className = "marker",
                                    Zw(this, zw, "f").appendChild(Zw(this, Ow, "f")),
                                    Zw(this, Rw, "f").appendChild(Zw(this, Nw, "f"));
                                Xw(this, Gw, (e => {
                                        let n = null;
                                        if (e instanceof MouseEvent ? Zw(this, Uw, "f") && (n = e) : e instanceof TouchEvent && e.targetTouches.length > 0 && (n = e.targetTouches[e.targetTouches.length - 1]),
                                        null != n) {
                                            const e = Zw(this, Dw, "f").getBoundingClientRect()
                                                , i = Math.max(0, Math.min(1, (n.clientX - e.left) / e.width))
                                                , r = Math.max(0, Math.min(1, (n.clientY - e.top) / e.height));
                                            Xw(this, Hw, 100 * i, "f"),
                                                Xw(this, Ww, 100 * (1 - r), "f"),
                                                Zw(this, Pw, "m", Kw).call(this),
                                                t(this.color)
                                        }
                                    }
                                ), "f"),
                                    Xw(this, jw, (e => {
                                            0 == e.button && Xw(this, Uw, !1, "f")
                                        }
                                    ), "f"),
                                    Zw(this, Dw, "f").addEventListener("mousedown", (e => {
                                            0 == e.button && Xw(this, Uw, !0, "f"),
                                                Zw(this, Gw, "f").call(this, e)
                                        }
                                    )),
                                    window.addEventListener("mouseup", Zw(this, jw, "f")),
                                    window.addEventListener("mousemove", Zw(this, Gw, "f")),
                                    Zw(this, Dw, "f").addEventListener("touchstart", Zw(this, Gw, "f")),
                                    Zw(this, Dw, "f").addEventListener("touchmove", Zw(this, Gw, "f")),
                                    Xw(this, Qw, (e => {
                                            let n = null;
                                            if (e instanceof MouseEvent ? Zw(this, Fw, "f") && (n = e) : e instanceof TouchEvent && e.targetTouches.length > 0 && (n = e.targetTouches[e.targetTouches.length - 1]),
                                            null != n) {
                                                const e = Zw(this, zw, "f").getBoundingClientRect()
                                                    , i = Math.max(0, Math.min(1, (n.clientX - e.left) / e.width));
                                                Xw(this, Vw, 360 * i, "f"),
                                                    Zw(this, Pw, "m", qw).call(this),
                                                    t(this.color)
                                            }
                                        }
                                    ), "f"),
                                    Xw(this, Yw, (e => {
                                            0 == e.button && Xw(this, Fw, !1, "f")
                                        }
                                    ), "f"),
                                    Zw(this, zw, "f").addEventListener("mousedown", (e => {
                                            0 == e.button && Xw(this, Fw, !0, "f"),
                                                Zw(this, Qw, "f").call(this, e)
                                        }
                                    )),
                                    window.addEventListener("mouseup", Zw(this, Yw, "f")),
                                    window.addEventListener("mousemove", Zw(this, Qw, "f")),
                                    Zw(this, zw, "f").addEventListener("touchstart", Zw(this, Qw, "f")),
                                    Zw(this, zw, "f").addEventListener("touchmove", Zw(this, Qw, "f")),
                                    Zw(this, Pw, "m", qw).call(this),
                                    Zw(this, Pw, "m", Kw).call(this)
                            }
                            dispose() {
                                window.removeEventListener("mouseup", Zw(this, jw, "f")),
                                    window.removeEventListener("mousemove", Zw(this, Gw, "f")),
                                    window.removeEventListener("mouseup", Zw(this, Yw, "f")),
                                    window.removeEventListener("mousemove", Zw(this, Qw, "f"))
                            }
                            get color() {
                                const e = Zw(this, Hw, "f") / 100
                                    , t = Zw(this, Ww, "f") / 100
                                    , n = t - t * e / 2
                                    , i = Math.min(n, 1 - n)
                                    , r = 0 != i ? (t - n) / i : 0;
                                return new Wi("hsl(" + Zw(this, Vw, "f").toString() + "," + (100 * r).toString() + "%," + (100 * n).toString() + "%)")
                            }
                            set color(e) {
                                const {h: t, s: n, l: i} = e.getHSL({
                                    h: 0,
                                    s: 0,
                                    l: 0
                                }, gt)
                                    , r = i + n * Math.min(i, 1 - i)
                                    , a = 0 == r ? 0 : 2 * (1 - i / r);
                                Xw(this, Vw, 360 * t, "f"),
                                    Xw(this, Hw, 100 * a, "f"),
                                    Xw(this, Ww, 100 * r, "f"),
                                    Zw(this, Pw, "m", qw).call(this),
                                    Zw(this, Pw, "m", Kw).call(this),
                                    Zw(this, Lw, "f").call(this, this.color)
                            }
                        }
                    ;
                    var $w, eA, tA, nA, iA, rA, aA, sA, oA, lA, cA, hA, dA, uA, pA, fA, mA, gA, vA, wA, AA, yA, bA, xA, kA, EA = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, SA = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    eA = new WeakMap,
                        tA = new WeakMap,
                        nA = new WeakMap,
                        iA = new WeakMap,
                        rA = new WeakMap,
                        aA = new WeakMap,
                        sA = new WeakMap,
                        oA = new WeakMap,
                        lA = new WeakMap,
                        cA = new WeakMap,
                        hA = new WeakMap,
                        dA = new WeakMap,
                        uA = new WeakMap,
                        pA = new WeakMap,
                        fA = new WeakMap,
                        mA = new WeakMap,
                        gA = new WeakMap,
                        $w = new WeakSet,
                        vA = function(e) {
                            const t = document.createElement("div");
                            t.className = "color",
                                SA(this, pA, "f").appendChild(t);
                            const n = document.createElement("h2");
                            n.textContent = e,
                                t.appendChild(n);
                            const i = document.createElement("input");
                            i.type = "text",
                                i.addEventListener("input", ( () => {
                                        let e = i.value;
                                        /^[0-9A-F]{6}$/i.test(e) && (e = "#" + e),
                                            r.color = new Wi(e),
                                            SA(this, eA, "f").setColors(SA(this, $w, "m", AA).call(this)),
                                            EA(this, mA, !0, "f")
                                    }
                                )),
                                i.addEventListener("blur", ( () => {
                                        i.value = "#" + r.color.getHexString()
                                    }
                                )),
                                t.appendChild(i);
                            const r = new Jw(t,(e => {
                                    document.activeElement != i && (i.value = "#" + e.getHexString()),
                                        SA(this, eA, "f").setColors(SA(this, $w, "m", AA).call(this)),
                                        EA(this, mA, !0, "f")
                                }
                            ));
                            i.value = "#" + r.color.getHexString(),
                                SA(this, fA, "f").push(r)
                        }
                        ,
                        wA = function() {
                            const e = Iu.random();
                            SA(this, fA, "f")[0].color = e.primary.clone(),
                                SA(this, fA, "f")[1].color = e.secondary.clone(),
                                SA(this, fA, "f")[2].color = e.frame.clone(),
                                SA(this, fA, "f")[3].color = e.rims.clone()
                        }
                        ,
                        AA = function() {
                            return new Iu(SA(this, fA, "f")[0].color.clone(),SA(this, fA, "f")[1].color.clone(),SA(this, fA, "f")[2].color.clone(),SA(this, fA, "f")[3].color.clone())
                        }
                        ,
                        yA = function(e) {
                            SA(this, fA, "f")[0].color = e.primary.clone(),
                                SA(this, fA, "f")[1].color = e.secondary.clone(),
                                SA(this, fA, "f")[2].color = e.frame.clone(),
                                SA(this, fA, "f")[3].color = e.rims.clone()
                        }
                        ,
                        bA = function(e) {
                            SA(this, mA, "f") ? SA(this, aA, "f").showConfirm(SA(this, tA, "f").get("Are you sure you want to exit without saving?") + "\n\n" + SA(this, tA, "f").get("All changes will be lost!"), SA(this, tA, "f").get("Cancel"), SA(this, tA, "f").get("Confirm"), null, ( () => {
                                    e()
                                }
                            )) : e()
                        }
                        ,
                        xA = function() {
                            if (SA(this, mA, "f")) {
                                const e = SA(this, $w, "m", AA).call(this);
                                SA(this, rA, "f").setCarColors(e),
                                    EA(this, mA, !1, "f"),
                                    EA(this, gA, !0, "f")
                            }
                            SA(this, $w, "m", kA).call(this)
                        }
                        ,
                        kA = function() {
                            null != SA(this, uA, "f") && (clearTimeout(SA(this, uA, "f")),
                                EA(this, uA, null, "f")),
                                SA(this, dA, "f").classList.remove("show"),
                                SA(this, dA, "f").classList.remove("hide"),
                                EA(this, uA, window.setTimeout(( () => {
                                        SA(this, dA, "f").textContent = SA(this, tA, "f").get("Car saved!"),
                                            SA(this, dA, "f").classList.add("show"),
                                            EA(this, uA, window.setTimeout(( () => {
                                                    SA(this, dA, "f").classList.remove("show"),
                                                        SA(this, dA, "f").classList.add("hide")
                                                }
                                            ), 3e3), "f")
                                    }
                                ), 0), "f")
                        }
                    ;
                    const MA = class {
                            constructor(e, t, n, i, r, a, s, o) {
                                $w.add(this),
                                    eA.set(this, void 0),
                                    tA.set(this, void 0),
                                    nA.set(this, void 0),
                                    iA.set(this, void 0),
                                    rA.set(this, void 0),
                                    aA.set(this, void 0),
                                    sA.set(this, void 0),
                                    oA.set(this, void 0),
                                    lA.set(this, void 0),
                                    cA.set(this, void 0),
                                    hA.set(this, void 0),
                                    dA.set(this, void 0),
                                    uA.set(this, null),
                                    pA.set(this, void 0),
                                    fA.set(this, []),
                                    mA.set(this, !1),
                                    gA.set(this, !1),
                                    EA(this, eA, e, "f"),
                                    EA(this, nA, n, "f"),
                                    EA(this, iA, r, "f"),
                                    EA(this, rA, a, "f"),
                                    EA(this, aA, s, "f"),
                                    EA(this, tA, t, "f"),
                                    EA(this, lA, new Ir(70,1,.1,yu.maxViewDistance), "f"),
                                    SA(this, lA, "f").position.set(4, 3, 4),
                                    n.scene.add(SA(this, lA, "f")),
                                    EA(this, cA, new Tw(SA(this, lA, "f"),n.canvas), "f"),
                                    SA(this, cA, "f").target.set(0, .7, 1.2),
                                    SA(this, cA, "f").update(),
                                    SA(this, cA, "f").mouseButtons = {
                                        LEFT: g,
                                        MIDDLE: g,
                                        RIGHT: g
                                    },
                                    SA(this, cA, "f").enablePan = !1,
                                    SA(this, cA, "f").minDistance = 2.5,
                                    SA(this, cA, "f").maxDistance = 5.8,
                                    SA(this, cA, "f").maxPolarAngle = Math.PI / 2 + .06;
                                const l = document.getElementById("ui");
                                if (null == l)
                                    throw new Error("UI element not found");
                                EA(this, sA, l, "f"),
                                    EA(this, hA, document.createElement("div"), "f"),
                                    SA(this, hA, "f").className = "customization";
                                const c = document.createElement("div");
                                c.className = "top",
                                    SA(this, hA, "f").appendChild(c);
                                const h = document.createElement("button");
                                h.className = "button",
                                    h.innerHTML = '<img class="button-icon" src="images/quit.svg"> ',
                                    h.append(document.createTextNode(t.get("Exit"))),
                                    h.addEventListener("click", ( () => {
                                            i.playUIClick(),
                                                SA(this, $w, "m", bA).call(this, o)
                                        }
                                    )),
                                    c.appendChild(h),
                                    window.addEventListener("keydown", EA(this, oA, (e => {
                                            "Escape" == e.code && (SA(this, $w, "m", bA).call(this, o),
                                                e.preventDefault())
                                        }
                                    ), "f"));
                                const d = document.createElement("button");
                                d.className = "button",
                                    d.innerHTML = '<img class="button-icon" src="images/save.svg"> ',
                                    d.append(document.createTextNode(t.get("Save"))),
                                    d.addEventListener("click", ( () => {
                                            i.playUIClick(),
                                                SA(this, $w, "m", xA).call(this)
                                        }
                                    )),
                                    c.appendChild(d);
                                const u = document.createElement("button");
                                u.className = "button",
                                    u.innerHTML = '<img class="button-icon" src="images/random.svg"> ',
                                    u.append(document.createTextNode(t.get("Random"))),
                                    u.addEventListener("click", ( () => {
                                            i.playUIClick(),
                                                SA(this, $w, "m", wA).call(this)
                                        }
                                    )),
                                    c.appendChild(u),
                                    EA(this, dA, document.createElement("div"), "f"),
                                    SA(this, dA, "f").className = "save-message",
                                    SA(this, hA, "f").appendChild(SA(this, dA, "f")),
                                    EA(this, pA, document.createElement("div"), "f"),
                                    SA(this, pA, "f").className = "colors",
                                    SA(this, hA, "f").appendChild(SA(this, pA, "f")),
                                    SA(this, $w, "m", vA).call(this, t.get("Primary")),
                                    SA(this, $w, "m", vA).call(this, t.get("Secondary")),
                                    SA(this, $w, "m", vA).call(this, t.get("Frame")),
                                    SA(this, $w, "m", vA).call(this, t.get("Rims")),
                                    SA(this, sA, "f").appendChild(SA(this, hA, "f"));
                                const p = SA(this, rA, "f").getCurrentUserProfile().carColors;
                                SA(this, $w, "m", yA).call(this, p),
                                    SA(this, eA, "f").setColors(p),
                                    EA(this, mA, !1, "f")
                            }
                            dispose() {
                                for (const e of SA(this, fA, "f"))
                                    e.dispose();
                                if (SA(this, gA, "f")) {
                                    const {token: e, nickname: t, carColors: n} = SA(this, rA, "f").getCurrentUserProfile();
                                    SA(this, iA, "f").submitUserProfile(e, t, n).catch((e => {
                                            console.warn(e)
                                        }
                                    ))
                                }
                                SA(this, nA, "f").scene.remove(SA(this, lA, "f")),
                                    window.removeEventListener("keydown", SA(this, oA, "f")),
                                    SA(this, sA, "f").removeChild(SA(this, hA, "f")),
                                    SA(this, cA, "f").dispose(),
                                    SA(this, nA, "f").canvas.style.touchAction = ""
                            }
                            get camera() {
                                return SA(this, lA, "f")
                            }
                        }
                    ;
                    var TA;
                    !function(e) {
                        e[e.Default = 0] = "Default",
                            e[e.Summer = 1] = "Summer",
                            e[e.Winter = 2] = "Winter",
                            e[e.Desert = 3] = "Desert",
                            e[e.Custom0 = 32] = "Custom0",
                            e[e.Custom1 = 33] = "Custom1",
                            e[e.Custom2 = 34] = "Custom2",
                            e[e.Custom3 = 35] = "Custom3",
                            e[e.Custom4 = 36] = "Custom4",
                            e[e.Custom5 = 37] = "Custom5",
                            e[e.Custom6 = 38] = "Custom6",
                            e[e.Custom7 = 39] = "Custom7",
                            e[e.Custom8 = 40] = "Custom8"
                    }(TA || (TA = {}));
                    const CA = TA;
                    var _A;
                    !function(e) {
                        e[e.Straight = 0] = "Straight",
                            e[e.TurnSharp = 1] = "TurnSharp",
                            e[e.SlopeUp = 2] = "SlopeUp",
                            e[e.SlopeDown = 3] = "SlopeDown",
                            e[e.Slope = 4] = "Slope",
                            e[e.Start = 5] = "Start",
                            e[e.Finish = 6] = "Finish",
                            e[e.ToWideMiddle = 7] = "ToWideMiddle",
                            e[e.ToWideLeft = 8] = "ToWideLeft",
                            e[e.ToWideRight = 9] = "ToWideRight",
                            e[e.StraightWide = 10] = "StraightWide",
                            e[e.InnerCornerWide = 11] = "InnerCornerWide",
                            e[e.OuterCornerWide = 12] = "OuterCornerWide",
                            e[e.SlopeUpLeftWide = 13] = "SlopeUpLeftWide",
                            e[e.SlopeUpRightWide = 14] = "SlopeUpRightWide",
                            e[e.SlopeDownLeftWide = 15] = "SlopeDownLeftWide",
                            e[e.SlopeDownRightWide = 16] = "SlopeDownRightWide",
                            e[e.SlopeLeftWide = 17] = "SlopeLeftWide",
                            e[e.SlopeRightWide = 18] = "SlopeRightWide",
                            e[e.PillarTop = 19] = "PillarTop",
                            e[e.PillarMiddle = 20] = "PillarMiddle",
                            e[e.PillarBottom = 21] = "PillarBottom",
                            e[e.PillarShort = 22] = "PillarShort",
                            e[e.PlanePillarBottom = 23] = "PlanePillarBottom",
                            e[e.PlanePillarShort = 24] = "PlanePillarShort",
                            e[e.Plane = 25] = "Plane",
                            e[e.PlaneWall = 26] = "PlaneWall",
                            e[e.PlaneWallCorner = 27] = "PlaneWallCorner",
                            e[e.PlaneWallInnerCorner = 28] = "PlaneWallInnerCorner",
                            e[e.Block = 29] = "Block",
                            e[e.WallTrackTop = 30] = "WallTrackTop",
                            e[e.WallTrackMiddle = 31] = "WallTrackMiddle",
                            e[e.WallTrackBottom = 32] = "WallTrackBottom",
                            e[e.PlaneSlopeUp = 33] = "PlaneSlopeUp",
                            e[e.PlaneSlopeDown = 34] = "PlaneSlopeDown",
                            e[e.PlaneSlope = 35] = "PlaneSlope",
                            e[e.TurnShort = 36] = "TurnShort",
                            e[e.TurnLong = 37] = "TurnLong",
                            e[e.SlopeUpLong = 38] = "SlopeUpLong",
                            e[e.SlopeDownLong = 39] = "SlopeDownLong",
                            e[e.SlopePillar = 40] = "SlopePillar",
                            e[e.TurnSLeft = 41] = "TurnSLeft",
                            e[e.TurnSRight = 42] = "TurnSRight",
                            e[e.IntersectionT = 43] = "IntersectionT",
                            e[e.IntersectionCross = 44] = "IntersectionCross",
                            e[e.PillarBranch1 = 45] = "PillarBranch1",
                            e[e.PillarBranch2 = 46] = "PillarBranch2",
                            e[e.PillarBranch3 = 47] = "PillarBranch3",
                            e[e.PillarBranch4 = 48] = "PillarBranch4",
                            e[e.WallTrackBottomCorner = 49] = "WallTrackBottomCorner",
                            e[e.WallTrackMiddleCorner = 50] = "WallTrackMiddleCorner",
                            e[e.WallTrackTopCorner = 51] = "WallTrackTopCorner",
                            e[e.Checkpoint = 52] = "Checkpoint",
                            e[e.HalfBlock = 53] = "HalfBlock",
                            e[e.QuarterBlock = 54] = "QuarterBlock",
                            e[e.HalfPlane = 55] = "HalfPlane",
                            e[e.QuarterPlane = 56] = "QuarterPlane",
                            e[e.PlaneBridge = 57] = "PlaneBridge",
                            e[e.SignArrowLeft = 58] = "SignArrowLeft",
                            e[e.SignArrowRight = 59] = "SignArrowRight",
                            e[e.SignArrowUp = 61] = "SignArrowUp",
                            e[e.SignArrowDown = 62] = "SignArrowDown",
                            e[e.SignWarning = 63] = "SignWarning",
                            e[e.SignWrongWay = 64] = "SignWrongWay",
                            e[e.CheckpointWide = 65] = "CheckpointWide",
                            e[e.WallTrackCeiling = 66] = "WallTrackCeiling",
                            e[e.WallTrackFloor = 67] = "WallTrackFloor",
                            e[e.BlockSlopedDown = 68] = "BlockSlopedDown",
                            e[e.BlockSlopedDownInnerCorner = 69] = "BlockSlopedDownInnerCorner",
                            e[e.BlockSlopedDownOuterCorner = 70] = "BlockSlopedDownOuterCorner",
                            e[e.BlockSlopedUp = 71] = "BlockSlopedUp",
                            e[e.BlockSlopedUpInnerCorner = 72] = "BlockSlopedUpInnerCorner",
                            e[e.BlockSlopedUpOuterCorner = 73] = "BlockSlopedUpOuterCorner",
                            e[e.FinishWide = 74] = "FinishWide",
                            e[e.PlaneCheckpoint = 75] = "PlaneCheckpoint",
                            e[e.PlaneFinish = 76] = "PlaneFinish",
                            e[e.PlaneCheckpointWide = 77] = "PlaneCheckpointWide",
                            e[e.PlaneFinishWide = 78] = "PlaneFinishWide",
                            e[e.WallTrackBottomInnerCorner = 79] = "WallTrackBottomInnerCorner",
                            e[e.WallTrackInnerCorner = 80] = "WallTrackInnerCorner",
                            e[e.WallTrackTopInnerCorner = 81] = "WallTrackTopInnerCorner",
                            e[e.TurnLong2 = 82] = "TurnLong2",
                            e[e.TurnLong3 = 83] = "TurnLong3",
                            e[e.SlopePillarShort = 84] = "SlopePillarShort",
                            e[e.BlockSlopeUp = 85] = "BlockSlopeUp",
                            e[e.BlockSlopeDown = 86] = "BlockSlopeDown",
                            e[e.BlockSlopeVerticalTop = 87] = "BlockSlopeVerticalTop",
                            e[e.BlockSlopeVerticalBottom = 88] = "BlockSlopeVerticalBottom",
                            e[e.PlaneSlopeVerticalBottom = 90] = "PlaneSlopeVerticalBottom",
                            e[e.StartWide = 91] = "StartWide",
                            e[e.PlaneStart = 92] = "PlaneStart",
                            e[e.PlaneStartWide = 93] = "PlaneStartWide",
                            e[e.TurnShortLeftWide = 94] = "TurnShortLeftWide",
                            e[e.TurnShortRightWide = 95] = "TurnShortRightWide",
                            e[e.TurnLongLeftWide = 96] = "TurnLongLeftWide",
                            e[e.TurnLongRightWide = 97] = "TurnLongRightWide",
                            e[e.SlopeUpVertical = 98] = "SlopeUpVertical",
                            e[e.PlaneSlopePillar = 99] = "PlaneSlopePillar",
                            e[e.PlaneSlopePillarShort = 100] = "PlaneSlopePillarShort",
                            e[e.PillarBranch1Top = 101] = "PillarBranch1Top",
                            e[e.PillarBranch1Bottom = 102] = "PillarBranch1Bottom",
                        e[e.PillarBranch1Middle = 103] = "PillarBranch1Middle",
                        e[e.PillarBranch2Top = 104] = "PillarBranch2Top",
                        e[e.PillarBranch2Middle = 105] = "PillarBranch2Middle",
                        e[e.PillarBranch2Bottom = 106] = "PillarBranch2Bottom",
                        e[e.PillarBranch3Top = 107] = "PillarBranch3Top",
                        e[e.PillarBranch3Middle = 108] = "PillarBranch3Middle",
                        e[e.PillarBranch3Bottom = 109] = "PillarBranch3Bottom",
                        e[e.PillarBranch4Top = 110] = "PillarBranch4Top",
                        e[e.PillarBranch4Middle = 111] = "PillarBranch4Middle",
                        e[e.PillarBranch4Bottom = 112] = "PillarBranch4Bottom",
                        e[e.PillarBranch5 = 113] = "PillarBranch5",
                        e[e.PillarBranch5Top = 114] = "PillarBranch5Top",
                        e[e.PillarBranch5Middle = 115] = "PillarBranch5Middle",
                        e[e.PillarBranch5Bottom = 116] = "PillarBranch5Bottom",
                        e[e.ToWideDouble = 117] = "ToWideDouble",
                        e[e.ToWideDiagonal = 118] = "ToWideDiagonal",
                        e[e.StraightPillarBottom = 119] = "StraightPillarBottom",
                        e[e.StraightPillarShort = 120] = "StraightPillarShort",
                        e[e.TurnSharpPillarBottom = 121] = "TurnSharpPillarBottom",
                        e[e.TurnSharpPillarShort = 122] = "TurnSharpPillarShort",
                        e[e.IntersectionTPillarBottom = 123] = "IntersectionTPillarBottom",
                        e[e.IntersectionTPillarShort = 124] = "IntersectionTPillarShort",
                        e[e.IntersectionCrossPillarBottom = 125] = "IntersectionCrossPillarBottom",
                        e[e.IntersectionCrossPillarShort = 126] = "IntersectionCrossPillarShort",
                        e[e.PlaneBridgeCorner = 127] = "PlaneBridgeCorner",
                        e[e.PlaneBridgeIntersectionT = 128] = "PlaneBridgeIntersectionT",
                        e[e.PlaneBridgeIntersectionCross = 129] = "PlaneBridgeIntersectionCross",
                        e[e.BlockBridge = 130] = "BlockBridge",
                        e[e.BlockBridgeCorner = 131] = "BlockBridgeCorner",
                        e[e.BlockBridgeIntersectionT = 132] = "BlockBridgeIntersectionT",
                        e[e.BlockBridgeIntersectionCross = 133] = "BlockBridgeIntersectionCross",
                        e[e.WallTrackCeilingCorner = 134] = "WallTrackCeilingCorner",
                        e[e.WallTrackCeilingPlaneCorner = 135] = "WallTrackCeilingPlaneCorner",
                        e[e.WallTrackFloorCorner = 136] = "WallTrackFloorCorner",
                        e[e.WallTrackFloorPlaneCorner = 137] = "WallTrackFloorPlaneCorner",
                        e[e.SlopeUpVerticalLeftWide = 138] = "SlopeUpVerticalLeftWide",
                        e[e.SlopeUpVerticalRightWide = 139] = "SlopeUpVerticalRightWide",
                        e[e.BlockSlopeVerticalCornerTop = 140] = "BlockSlopeVerticalCornerTop",
                        e[e.BlockSlopeVerticalCornerBottom = 141] = "BlockSlopeVerticalCornerBottom",
                        e[e.WallTrackSlopeToVertical = 142] = "WallTrackSlopeToVertical",
                        e[e.PlaneSlopeToVertical = 143] = "PlaneSlopeToVertical",
                        e[e.BlockSlopeToVertical = 144] = "BlockSlopeToVertical",
                        e[e.PlaneSlopeUpLong = 145] = "PlaneSlopeUpLong",
                        e[e.PlaneSlopeDownLong = 146] = "PlaneSlopeDownLong",
                        e[e.SlopeUpLongLeftWide = 147] = "SlopeUpLongLeftWide",
                        e[e.SlopeUpLongRightWide = 148] = "SlopeUpLongRightWide",
                        e[e.SlopeDownLongLeftWide = 149] = "SlopeDownLongLeftWide",
                        e[e.SlopeDownLongRightWide = 150] = "SlopeDownLongRightWide",
                        e[e.BlockSlopeUpLong = 151] = "BlockSlopeUpLong",
                        e[e.BlockSlopeDownLong = 152] = "BlockSlopeDownLong",
                        e[e.BlockSlopeVerticalInnerCornerBottom = 153] = "BlockSlopeVerticalInnerCornerBottom",
                        e[e.BlockSlopeVerticalInnerCornerTop = 154] = "BlockSlopeVerticalInnerCornerTop",
                        e[e.BlockInnerCorner = 155] = "BlockInnerCorner"
                    }(_A || (_A = {}));
                    const IA = _A;
                    var PA;
                    !function(e) {
                        e[e.YPositive = 0] = "YPositive",
                            e[e.YNegative = 1] = "YNegative",
                            e[e.XPositive = 2] = "XPositive",
                            e[e.XNegative = 3] = "XNegative",
                            e[e.ZPositive = 4] = "ZPositive",
                            e[e.ZNegative = 5] = "ZNegative"
                    }(PA || (PA = {}));
                    const RA = PA;
                    var LA, NA, DA, BA, UA, zA, OA, FA, WA = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, HA = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    LA = new WeakMap,
                        NA = new WeakMap,
                        DA = new WeakMap,
                        BA = new WeakMap,
                        UA = new WeakMap,
                        zA = new WeakMap,
                        OA = new WeakMap,
                        FA = new WeakMap;
                    const VA = class {
                            constructor(e, t, n, i, r, a, s, o, l, c, h) {
                                LA.set(this, void 0),
                                    NA.set(this, void 0),
                                    DA.set(this, void 0),
                                    BA.set(this, void 0),
                                    UA.set(this, void 0),
                                    zA.set(this, void 0),
                                    OA.set(this, void 0),
                                    FA.set(this, void 0),
                                    WA(this, LA, a, "f"),
                                    WA(this, NA, t, "f"),
                                    WA(this, DA, n, "f"),
                                    WA(this, BA, i, "f"),
                                    WA(this, UA, r, "f"),
                                    WA(this, zA, o, "f");
                                for (let e = -100; e < 100; ++e)
                                    0 == e ? t.setPart(0, 0, 4 * e, IA.Start, 2, RA.YPositive, CA.Default, null, 0) : t.setPart(0, 0, 4 * e, IA.Straight, 0, RA.YPositive, CA.Default, null, null);
                                t.generateMeshes(),
                                    n.generateMountains(t.getBounds());
                                const d = t.getStartTransform();
                                if (null == d)
                                    throw new Error("Start transform is null");
                                WA(this, FA, new yw(null,d,null,null,r,a,n,t,o), "f"),
                                    HA(this, FA, "f").audioVolume = 0,
                                    HA(this, FA, "f").update(0),
                                    WA(this, OA, new MA(HA(this, FA, "f"),e,r,a,l,s,c,h), "f"),
                                    r.setCamera(HA(this, OA, "f").camera)
                            }
                            dispose() {
                                HA(this, NA, "f").clear(),
                                    HA(this, DA, "f").clearMountains(),
                                    HA(this, OA, "f").dispose(),
                                    HA(this, FA, "f").dispose()
                            }
                            update(e) {
                                HA(this, DA, "f").update(HA(this, NA, "f")),
                                    HA(this, BA, "f").update(e, HA(this, UA, "f").camera, HA(this, NA, "f").sunDirection),
                                    HA(this, LA, "f").update(e, !0, HA(this, UA, "f"), HA(this, zA, "f")),
                                    HA(this, UA, "f").update(HA(this, FA, "f").getPosition(), HA(this, NA, "f").sunDirection)
                            }
                        }
                    ;
                    var GA = n(4344)
                        , jA = {};
                    jA.styleTagTransform = u(),
                        jA.setAttributes = l(),
                        jA.insert = s().bind(null, "head"),
                        jA.domAPI = r(),
                        jA.insertStyleElement = h();
                    t()(GA.A, jA);
                    GA.A && GA.A.locals && GA.A.locals;
                    var QA, YA, qA, KA, XA, ZA, JA, $A = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, ey = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    YA = new WeakMap,
                        qA = new WeakMap,
                        KA = new WeakMap,
                        XA = new WeakMap,
                        ZA = new WeakMap,
                        QA = new WeakSet,
                        JA = function() {
                            if (null != ey(this, qA, "f")) {
                                const e = "FPS: " + ey(this, ZA, "f").toString();
                                ey(this, qA, "f").textContent != e && (ey(this, qA, "f").textContent = e)
                            }
                        }
                    ;
                    const ty = class {
                            constructor() {
                                QA.add(this),
                                    YA.set(this, void 0),
                                    qA.set(this, null),
                                    KA.set(this, 0),
                                    XA.set(this, 0),
                                    ZA.set(this, 0);
                                const e = document.getElementById("ui");
                                if (null == e)
                                    throw new Error("UI element not found");
                                $A(this, YA, e, "f")
                            }
                            show() {
                                $A(this, qA, document.createElement("div"), "f"),
                                    ey(this, qA, "f").className = "debug",
                                    ey(this, YA, "f").appendChild(ey(this, qA, "f")),
                                    ey(this, QA, "m", JA).call(this)
                            }
                            hide() {
                                null != ey(this, qA, "f") && (ey(this, YA, "f").removeChild(ey(this, qA, "f")),
                                    $A(this, qA, null, "f"))
                            }
                            toggle() {
                                null != ey(this, qA, "f") ? this.hide() : this.show()
                            }
                            update(e) {
                                $A(this, KA, ey(this, KA, "f") + e, "f"),
                                    $A(this, XA, ey(this, XA, "f") + 1, "f"),
                                ey(this, KA, "f") >= 1 && ($A(this, ZA, ey(this, XA, "f"), "f"),
                                    $A(this, KA, ey(this, KA, "f") - Math.trunc(ey(this, KA, "f")), "f"),
                                    $A(this, XA, 0, "f"),
                                    ey(this, QA, "m", JA).call(this))
                            }
                        }
                    ;
                    var ny = n(6057)
                        , iy = {};
                    iy.styleTagTransform = u(),
                        iy.setAttributes = l(),
                        iy.insert = s().bind(null, "head"),
                        iy.domAPI = r(),
                        iy.insertStyleElement = h();
                    t()(ny.A, iy);
                    ny.A && ny.A.locals && ny.A.locals;
                    class ry extends uo {
                        constructor(e) {
                            super(e)
                        }
                        load(e, t, n, i) {
                            const r = this
                                , a = new mo(this.manager);
                            a.setPath(this.path),
                                a.setRequestHeader(this.requestHeader),
                                a.setWithCredentials(this.withCredentials),
                                a.load(e, (function(e) {
                                        const n = r.parse(JSON.parse(e));
                                        t && t(n)
                                    }
                                ), n, i)
                        }
                        parse(e) {
                            return new ay(e)
                        }
                    }
                    class ay {
                        constructor(e) {
                            this.isFont = !0,
                                this.type = "Font",
                                this.data = e
                        }
                        generateShapes(e, t=100) {
                            const n = []
                                , i = function(e, t, n) {
                                const i = Array.from(e)
                                    , r = t / n.resolution
                                    , a = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * r
                                    , s = [];
                                let o = 0
                                    , l = 0;
                                for (let e = 0; e < i.length; e++) {
                                    const t = i[e];
                                    if ("\n" === t)
                                        o = 0,
                                            l -= a;
                                    else {
                                        const e = sy(t, r, o, l, n);
                                        o += e.offsetX,
                                            s.push(e.path)
                                    }
                                }
                                return s
                            }(e, t, this.data);
                            for (let e = 0, t = i.length; e < t; e++)
                                n.push(...i[e].toShapes());
                            return n
                        }
                    }
                    function sy(e, t, n, i, r) {
                        const a = r.glyphs[e] || r.glyphs["?"];
                        if (!a)
                            return void console.error('THREE.Font: character "' + e + '" does not exists in font family ' + r.familyName + ".");
                        const s = new Ko;
                        let o, l, c, h, d, u, p, f;
                        if (a.o) {
                            const e = a._cachedOutline || (a._cachedOutline = a.o.split(" "));
                            for (let r = 0, a = e.length; r < a; ) {
                                switch (e[r++]) {
                                    case "m":
                                        o = e[r++] * t + n,
                                            l = e[r++] * t + i,
                                            s.moveTo(o, l);
                                        break;
                                    case "l":
                                        o = e[r++] * t + n,
                                            l = e[r++] * t + i,
                                            s.lineTo(o, l);
                                        break;
                                    case "q":
                                        c = e[r++] * t + n,
                                            h = e[r++] * t + i,
                                            d = e[r++] * t + n,
                                            u = e[r++] * t + i,
                                            s.quadraticCurveTo(d, u, c, h);
                                        break;
                                    case "b":
                                        c = e[r++] * t + n,
                                            h = e[r++] * t + i,
                                            d = e[r++] * t + n,
                                            u = e[r++] * t + i,
                                            p = e[r++] * t + n,
                                            f = e[r++] * t + i,
                                            s.bezierCurveTo(d, u, p, f, c, h)
                                }
                            }
                        }
                        return {
                            offsetX: a.ha * t,
                            path: s
                        }
                    }
                    class oy extends ua {
                        constructor(e, t) {
                            const n = new ji({
                                color: t,
                                depthWrite: !1
                            });
                            super(e.geometry, n, e.count);
                            for (let t = 0; t < e.count; ++t) {
                                const n = new Kn;
                                e.getMatrixAt(t, n),
                                    this.setMatrixAt(t, n)
                            }
                            this.meshMatrix = e.matrixWorld,
                                this.frustumCulled = !1,
                                this.matrixAutoUpdate = !1,
                                this.renderOrder = -1
                        }
                        update(e, t) {
                            var n = new Kn
                                , i = e.normal.x * t.x + e.normal.y * t.y + e.normal.z * t.z + -e.constant * t.w
                                , r = n.elements;
                            r[0] = i - t.x * e.normal.x,
                                r[4] = -t.x * e.normal.y,
                                r[8] = -t.x * e.normal.z,
                                r[12] = -t.x * -e.constant,
                                r[1] = -t.y * e.normal.x,
                                r[5] = i - t.y * e.normal.y,
                                r[9] = -t.y * e.normal.z,
                                r[13] = -t.y * -e.constant,
                                r[2] = -t.z * e.normal.x,
                                r[6] = -t.z * e.normal.y,
                                r[10] = i - t.z * e.normal.z,
                                r[14] = -t.z * -e.constant,
                                r[3] = -t.w * e.normal.x,
                                r[7] = -t.w * e.normal.y,
                                r[11] = -t.w * e.normal.z,
                                r[15] = i - t.w * -e.constant,
                                this.matrix.multiplyMatrices(n, this.meshMatrix)
                        }
                    }
                    var ly = n(1312);
                    const cy = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]
                        , hy = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51];
                    function dy(e) {
                        let t = 0
                            , n = "";
                        for (; t < 8 * e.length; ) {
                            const i = py(e, t);
                            let r;
                            30 & ~i ? (r = i,
                                t += 6) : (r = 31 & i,
                                t += 5),
                                n += cy[r]
                        }
                        return n
                    }
                    function uy(e) {
                        let t = 0;
                        const n = []
                            , i = e.length;
                        for (let r = 0; r < i; r++) {
                            const a = e.charCodeAt(r);
                            if (a >= hy.length)
                                return null;
                            const s = hy[a];
                            if (-1 == s)
                                return null;
                            30 & ~s ? (fy(n, t, 6, s, r == i - 1),
                                t += 6) : (fy(n, t, 5, s, r == i - 1),
                                t += 5)
                        }
                        return new Uint8Array(n)
                    }
                    function py(e, t) {
                        if (t >= 8 * e.length)
                            throw new Error("Out of range");
                        const n = Math.floor(t / 8)
                            , i = e[n]
                            , r = t - 8 * n;
                        if (r <= 2 || n >= e.length - 1)
                            return (i & 63 << r) >>> r;
                        return (i & 63 << r) >>> r | (e[n + 1] & 63 >>> 8 - r) << 8 - r
                    }
                    function fy(e, t, n, i, r) {
                        const a = Math.floor(t / 8);
                        for (; a >= e.length; )
                            e.push(0);
                        const s = t - 8 * a;
                        if (e[a] |= i << s & 255,
                        s > 8 - n && !r) {
                            const t = a + 1;
                            t >= e.length && e.push(0),
                                e[t] |= i >> 8 - s
                        }
                    }
                    var my, gy = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, vy = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    class wy {
                        constructor(e=28) {
                            if (my.set(this, void 0),
                                !(Number.isSafeInteger(e) && e >= 0 && e < 180))
                                throw new Error("Representation is not a safe integer or is out of range");
                            gy(this, my, e, "f")
                        }
                        clone() {
                            return new wy(vy(this, my, "f"))
                        }
                        toDegrees() {
                            return 2 * vy(this, my, "f")
                        }
                        static fromDegrees(e) {
                            const t = Math.round(e / 2 % 180);
                            return new wy(t)
                        }
                        getSunPosition() {
                            const e = 2 * vy(this, my, "f") * (Math.PI / 180)
                                , t = Math.cos(e)
                                , n = Math.sin(e);
                            return new An(t,.78,n).normalize()
                        }
                        get representation() {
                            return vy(this, my, "f")
                        }
                    }
                    my = new WeakMap;
                    const Ay = wy;
                    var yy;
                    !function(e) {
                        e[e.Summer = 0] = "Summer",
                            e[e.Winter = 1] = "Winter",
                            e[e.Desert = 2] = "Desert"
                    }(yy || (yy = {}));
                    const by = yy;
                    var xy;
                    !function(e) {
                        e[e.Special = 0] = "Special",
                            e[e.Road = 1] = "Road",
                            e[e.RoadTurns = 2] = "RoadTurns",
                            e[e.RoadWide = 3] = "RoadWide",
                            e[e.Plane = 4] = "Plane",
                            e[e.Block = 5] = "Block",
                            e[e.WallTrack = 6] = "WallTrack",
                            e[e.Pillar = 7] = "Pillar",
                            e[e.Sign = 8] = "Sign"
                    }(xy || (xy = {}));
                    const ky = xy;
                    var Ey;
                    !function(e) {
                        e[e.Checkpoint = 0] = "Checkpoint",
                            e[e.Finish = 1] = "Finish"
                    }(Ey || (Ey = {}));
                    const Sy = Ey;
                    var My, Ty = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, Cy = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    class _y {
                        constructor(e) {
                            My.set(this, void 0);
                            const t = [];
                            for (const [n,i,r] of e)
                                t.push([n, i, r]);
                            Ty(this, My, t, "f")
                        }
                        rotated(e, t) {
                            const n = t == RA.YNegative || t == RA.XNegative || t == RA.ZNegative;
                            return new _y(Cy(this, My, "f").map(( ([i,r,a]) => {
                                    if (n)
                                        switch (e) {
                                            case 0:
                                                break;
                                            case 1:
                                                [i,a] = [-a - 1, i];
                                                break;
                                            case 2:
                                                [i,a] = [-i - 1, -a - 1];
                                                break;
                                            case 3:
                                                [i,a] = [a, -i - 1];
                                                break;
                                            default:
                                                throw new Error("Invalid rotation")
                                        }
                                    else
                                        switch (e) {
                                            case 0:
                                                break;
                                            case 1:
                                                [i,a] = [a, -i - 1];
                                                break;
                                            case 2:
                                                [i,a] = [-i - 1, -a - 1];
                                                break;
                                            case 3:
                                                [i,a] = [-a - 1, i];
                                                break;
                                            default:
                                                throw new Error("Invalid rotation")
                                        }
                                    return t == RA.YPositive || (t == RA.YNegative ? [i,r] = [-i - 1, -r - 1] : t == RA.XPositive ? [i,r] = [r, -i - 1] : t == RA.XNegative ? [i,r] = [-r - 1, i] : t == RA.ZPositive ? [r,a] = [-a - 1, r] : [r,a] = [a, -r - 1]),
                                        [i, r, a]
                                }
                            )))
                        }
                        forEach(e) {
                            for (let t = 0; t < Cy(this, My, "f").length; t++) {
                                const [n,i,r] = Cy(this, My, "f")[t];
                                e(n, i, r, t)
                            }
                        }
                        get length() {
                            return Cy(this, My, "f").length
                        }
                    }
                    My = new WeakMap;
                    const Iy = _y
                        , Py = [{
                        id: CA.Summer,
                        colors: {}
                    }, {
                        id: CA.Winter,
                        colors: {
                            Road: "#5077b2",
                            RoadBarrier: "#898989",
                            RoadEdgeWhite: "#ffffff",
                            RoadEdgeRed: "#1f3d6b",
                            BlockSurface: "#878787",
                            Pillar: "#2b4d7f",
                            PillarEdge: "#071428",
                            WallTrack: "#5077b2",
                            WallTrackBottom: "#878787",
                            WallTrackSides: "#ffffff",
                            PlaneWall: "#1f3d6b",
                            PlaneWallDetail: "#878787",
                            SignYellow: "#1b2a89",
                            SignRed: "#841901",
                            SignBlack: "#5077b2"
                        }
                    }, {
                        id: CA.Desert,
                        colors: {
                            Road: "#997240",
                            RoadBarrier: "#211001",
                            RoadEdgeRed: "#5b2424",
                            RoadEdgeWhite: "#510808",
                            BlockSurface: "#b78f5b",
                            Pillar: "#99713d",
                            PillarEdge: "#1c1105",
                            WallTrack: "#260b0b",
                            WallTrackBottom: "#160606",
                            WallTrackSides: "#75562e",
                            PlaneWall: "#633030",
                            PlaneWallDetail: "#aa8a53",
                            SignYellow: "#997240",
                            SignRed: "#d80202",
                            SignBlack: "#601d1d"
                        }
                    }]
                        , Ry = Py.concat([{
                        id: CA.Custom0,
                        colors: {
                            BlockSurface: "#131313"
                        }
                    }, {
                        id: CA.Custom1,
                        colors: {
                            BlockSurface: "#501b1b"
                        }
                    }, {
                        id: CA.Custom2,
                        colors: {
                            BlockSurface: "#7f4d2b"
                        }
                    }, {
                        id: CA.Custom3,
                        colors: {
                            BlockSurface: "#93862d"
                        }
                    }, {
                        id: CA.Custom4,
                        colors: {
                            BlockSurface: "#2a5e30"
                        }
                    }, {
                        id: CA.Custom5,
                        colors: {
                            BlockSurface: "#236363"
                        }
                    }, {
                        id: CA.Custom6,
                        colors: {
                            BlockSurface: "#20244b"
                        }
                    }, {
                        id: CA.Custom7,
                        colors: {
                            BlockSurface: "#592759"
                        }
                    }, {
                        id: CA.Custom8,
                        colors: {
                            BlockSurface: "#302318"
                        }
                    }]);
                    class Ly {
                        constructor(e, t, n, i, r, a, s=null, o=null) {
                            const l = [];
                            for (const [e,t] of a)
                                for (let n = e[0]; n <= t[0]; n++)
                                    for (let i = e[1]; i <= t[1]; i++)
                                        for (let r = e[2]; r <= t[2]; r++) {
                                            if (null != l.find(( ([e,t,a]) => e == n && t == i && a == r)))
                                                throw new Error("Duplicate tile in track part");
                                            l.push([n, i, r])
                                        }
                            this.checksum = e,
                                this.category = t,
                                this.id = n,
                                this.models = i,
                                this.colors = r,
                                this.tiles = new Iy(l),
                                this.detector = s,
                                this.startOffset = o,
                                Object.freeze(this)
                        }
                    }
                    const Ny = [new Ly("6d94d798abd14dc3bce4e99c180309d993ad43adb5f2c90eef8e350eedafe7cf",ky.Special,IA.Start,[["Road", "Start"]],Py,[[[-2, 0, -2], [1, 0, 1]]],null,new An(0,.35,1.35)), new Ly("f29e34b2e05e0a4751109ae564b03fe8878a79cc6b26288f1117ed296d09c5bb",ky.Special,IA.StartWide,[["RoadWide", "StartWide"]],Py,[[[-2, 0, -2], [5, 0, 1]]],null,new An(-10,.35,1.35)), new Ly("3c304054f415fbede4f73a43517db04302f38b16fa2cd4e587082b37b75e20e5",ky.Special,IA.PlaneStart,[["Planes", "PlaneStart"]],Py,[[[-2, 0, -2], [1, 0, 1]]],null,new An(0,.35,1.35)), new Ly("f08710416bdaa3d91d0d43f014e45d421fdb4587a334993bad0056f3dbbcb6bb",ky.Special,IA.PlaneStartWide,[["Planes", "PlaneStartWide"]],Py,[[[-2, 0, -2], [5, 0, 1]]],null,new An(-10,.35,1.35)), new Ly("223fc87c72bb64b58677062ffa08ab7eafd78071bced7c53233606763cd5316b",ky.Special,IA.Checkpoint,[["Road", "Checkpoint"]],Py,[[[-2, 0, -2], [1, 0, 1]]],{
                        type: Sy.Checkpoint,
                        center: [0, 2.2, 0],
                        size: [10.5, 3.8, 1]
                    }), new Ly("82d9a9879cee92c04c8d4ba2e16fc31bb1917a31f5802a3bb5177ca9a5cfee01",ky.Special,IA.CheckpointWide,[["RoadWide", "CheckpointWide"]],Py,[[[-2, 0, -2], [5, 0, 1]]],{
                        type: Sy.Checkpoint,
                        center: [10, 2.2, 0],
                        size: [30.6, 3.8, 1]
                    }), new Ly("fe8946d7f09724b5e11f493eb5c2a5b5e3d502b15beaad003f8134ac63558948",ky.Special,IA.PlaneCheckpoint,[["Planes", "PlaneCheckpoint"]],Py,[[[-2, 0, -2], [1, 0, 1]]],{
                        type: Sy.Checkpoint,
                        center: [0, 2.2, 0],
                        size: [18.25, 3.8, 1]
                    }), new Ly("d486d9b851db35dd44c15f9e0bb3bf582118daf7be514598a19307f61cf46678",ky.Special,IA.PlaneCheckpointWide,[["Planes", "PlaneCheckpointWide"]],Py,[[[-2, 0, -2], [5, 0, 1]]],{
                        type: Sy.Checkpoint,
                        center: [10, 2.2, 0],
                        size: [38.25, 3.8, 1]
                    }), new Ly("c01200d573a3594a6a4cb73ebb600964d653e4a89267d3297f3969220742aa79",ky.Special,IA.Finish,[["Road", "Finish"]],Py,[[[-2, 0, -2], [1, 0, 1]]],{
                        type: Sy.Finish,
                        center: [0, 2.2, 0],
                        size: [10.5, 3.8, 2]
                    }), new Ly("a9cefdff816e94a643210c58582c2809de0e3e0e0478b8d5baabd7fe81f13e73",ky.Special,IA.FinishWide,[["RoadWide", "FinishWide"]],Py,[[[-2, 0, -2], [5, 0, 1]]],{
                        type: Sy.Finish,
                        center: [10, 2.2, 0],
                        size: [30.6, 3.8, 2]
                    }), new Ly("75e5f09fe8a18ecafaf1fb80929173ef0a7dc0b785596bbe0ccd85a934d79578",ky.Special,IA.PlaneFinish,[["Planes", "PlaneFinish"]],Py,[[[-2, 0, -2], [1, 0, 1]]],{
                        type: Sy.Finish,
                        center: [0, 2.2, 0],
                        size: [18.25, 3.8, 2]
                    }), new Ly("5801b3268c75809728c63450d06000c5f6fcfd5d72691902f99d7d19d25e1d78",ky.Special,IA.PlaneFinishWide,[["Planes", "PlaneFinishWide"]],Py,[[[-2, 0, -2], [5, 0, 1]]],{
                        type: Sy.Finish,
                        center: [10, 2.2, 0],
                        size: [38.25, 3.8, 2]
                    }), new Ly("3421096c1986d008da88b5fac64cd4c475603138c9bf8a98ab6d581dda6befa7",ky.Road,IA.Straight,[["Road", "Straight"]],Py,[[[-2, 0, -2], [1, 0, 1]]]), new Ly("bdc3bcdafec9bc26835dc76159f7223da7da5babb3a5770129fa11046c748b69",ky.Road,IA.StraightPillarBottom,[["Road", "Straight"], ["Pillar", "SurfacePillarBottom"]],Py,[[[-2, 0, -2], [1, 0, 1]]]), new Ly("2758e984d87b3170f6618c9c689554ef169fd5f80ea7f0df292ffd69792d414e",ky.Road,IA.StraightPillarShort,[["Road", "Straight"], ["Pillar", "SurfacePillarShort"]],Py,[[[-2, 0, -2], [1, 0, 1]]]), new Ly("fb5a81784022cfc2d3d0007a032976c8dfd066e72a3bc92f671c98c5cca36aaa",ky.Road,IA.TurnSharp,[["Road", "TurnSharp"]],Py,[[[-2, 0, -2], [1, 0, 1]]]), new Ly("3da2e9a93da06b1376c33486f30a5f02d8c2f125f5b7d8b41166049ecd95f269",ky.Road,IA.TurnSharpPillarBottom,[["Road", "TurnSharp"], ["Pillar", "SurfacePillarBottom"]],Py,[[[-2, 0, -2], [1, 0, 1]]]), new Ly("c642122276547382e37dcb857b130088f4dc0d208dc7fdb6055b2a93080a3ffe",ky.Road,IA.TurnSharpPillarShort,[["Road", "TurnSharp"], ["Pillar", "SurfacePillarShort"]],Py,[[[-2, 0, -2], [1, 0, 1]]]), new Ly("110efb0facc096e1c875e545b075b0effaa1b78d50b97f906aec44796501544b",ky.RoadTurns,IA.TurnShort,[["Road", "TurnShort"]],Py,[[[-2, 0, 0], [1, 0, 1]], [[-2, 0, -1], [2, 0, -1]], [[-1, 0, -2], [3, 0, -2]], [[-1, 0, -3], [5, 0, -3]], [[0, 0, -4], [5, 0, -4]], [[1, 0, -5], [5, 0, -5]], [[3, 0, -6], [5, 0, -6]]]), new Ly("20a164840b0e83f3eac96ba9e3650a30e3b3dec4bb635946e3e9e9a1b74820d2",ky.RoadTurns,IA.TurnLong,[["Road", "TurnLong"]],Py,[[[-2, 0, -1], [1, 0, 1]], [[-1, 0, -2], [2, 0, -2]], [[-1, 0, -3], [2, 0, -3]], [[-1, 0, -4], [3, 0, -4]], [[0, 0, -5], [4, 0, -5]], [[1, 0, -6], [6, 0, -6]], [[2, 0, -7], [9, 0, -7]], [[3, 0, -8], [9, 0, -8]], [[4, 0, -9], [9, 0, -9]], [[7, 0, -10], [9, 0, -10]]]), new Ly("c36dddde35a740c6f01227522bf35e1a450cddbfdd8bde1617873bef0d47c95c",ky.RoadTurns,IA.TurnLong2,[["Road", "TurnLong2"]],Py,[[[-2, 0, -2], [1, 0, 1]], [[-1, 0, -4], [2, 0, -3]], [[-1, 0, -5], [3, 0, -5]], [[0, 0, -6], [4, 0, -6]], [[0, 0, -7], [5, 0, -7]], [[1, 0, -8], [6, 0, -8]], [[2, 0, -9], [7, 0, -9]], [[3, 0, -10], [9, 0, -10]], [[4, 0, -11], [13, 0, -11]], [[5, 0, -12], [13, 0, -12]], [[7, 0, -13], [13, 0, -13]], [[10, 0, -14], [13, 0, -14]]]), new Ly("0ed20c04a941708c23fe6ced4af3f357c0e435f09278e06f3de2806786d44059",ky.RoadTurns,IA.TurnLong3,[["Road", "TurnLong3"]],Py,[[[-2, 0, -2], [1, 0, 1]], [[-1, 0, -4], [2, 0, -3]], [[-1, 0, -5], [2, 0, -5]], [[0, 0, -6], [3, 0, -6]], [[0, 0, -7], [3, 0, -7]], [[0, 0, -8], [4, 0, -8]], [[1, 0, -9], [5, 0, -9]], [[2, 0, -10], [6, 0, -10]], [[2, 0, -11], [7, 0, -11]], [[3, 0, -12], [8, 0, -12]], [[4, 0, -13], [10, 0, -13]], [[5, 0, -14], [13, 0, -14]], [[7, 0, -15], [17, 0, -15]], [[8, 0, -16], [17, 0, -16]], [[11, 0, -17], [17, 0, -17]], [[14, 0, -18], [17, 0, -18]]]), new Ly("034ef287319877f2fcc32fbd6f32415539a4c287dfcd620360386a781adad22a",ky.RoadTurns,IA.TurnSLeft,[["Road", "TurnS", {
                        flipX: !0
                    }]],Py,[[[-2, 0, -1], [1, 0, 1]], [[-3, 0, -3], [0, 0, -2]], [[-4, 0, -4], [0, 0, -4]], [[-5, 0, -5], [-1, 0, -5]], [[-5, 0, -7], [-2, 0, -6]], [[-6, 0, -10], [-3, 0, -8]]]), new Ly("0d49e9feb603d0899927c7e5184f4f4fdd4363d2e1fd296f0b7b3cf4dbbf0e8d",ky.RoadTurns,IA.TurnSRight,[["Road", "TurnS"]],Py,[[[-2, 0, -1], [1, 0, 1]], [[-1, 0, -3], [2, 0, -2]], [[-1, 0, -4], [3, 0, -4]], [[0, 0, -5], [4, 0, -5]], [[1, 0, -7], [4, 0, -6]], [[2, 0, -10], [5, 0, -8]]]), new Ly("26bca19e63867bc0b755ff6fcca65de296c9d1f109f87540103565eb88a0e03d",ky.RoadTurns,IA.TurnShortLeftWide,[["RoadWide", "TurnShortLeftWide"]],Py,[[[-2, 0, -1], [1, 0, 1]], [[-1, 0, -2], [1, 0, -2]], [[-1, 0, -4], [5, 0, -3]], [[0, 0, -5], [5, 0, -5]], [[1, 0, -6], [5, 0, -6]], [[2, 0, -7], [9, 0, -7]], [[3, 0, -8], [9, 0, -8]], [[4, 0, -9], [9, 0, -9]], [[7, 0, -10], [9, 0, -10]]]), new Ly("e3845854f85dafd8cec193bcbecdac6cb79f625066de29524d5c10c5580611c5",ky.RoadTurns,IA.TurnShortRightWide,[["RoadWide", "TurnShortRightWide"]],Py,[[[-2, 0, 0], [1, 0, 1]], [[-2, 0, -1], [2, 0, -1]], [[-2, 0, -2], [3, 0, -2]], [[2, 0, -6], [5, 0, -3]]]), new Ly("dc6088960a65a55c74353a1e7c8a1ca8ec99e683f6273bf666d6909b288bb84b",ky.RoadTurns,IA.TurnLongLeftWide,[["RoadWide", "TurnLongLeftWide"]],Py,[[[-2, 0, -2], [1, 0, 1]], [[-1, 0, -5], [1, 0, -3]], [[0, 0, -6], [1, 0, -6]], [[0, 0, -7], [5, 0, -7]], [[1, 0, -8], [5, 0, -8]], [[2, 0, -9], [5, 0, -9]], [[3, 0, -10], [5, 0, -10]], [[4, 0, -11], [13, 0, -11]], [[5, 0, -12], [13, 0, -12]], [[7, 0, -13], [13, 0, -13]], [[10, 0, -14], [13, 0, -14]]]), new Ly("0bbb8d6c1e4a325e10643cf45546da725c1ea18e92a3a95f753339629a06ef6c",ky.RoadTurns,IA.TurnLongRightWide,[["RoadWide", "TurnLongRightWide"]],Py,[[[-2, 0, -1], [1, 0, 1]], [[-2, 0, -3], [2, 0, -2]], [[-2, 0, -4], [3, 0, -4]], [[-2, 0, -5], [4, 0, -5]], [[-2, 0, -6], [6, 0, -6]], [[2, 0, -10], [9, 0, -7]]]), new Ly("7d8d1eed719515ba7e48b5ef4a53b6b4bb2bef42496b6b40d2551230435ecb66",ky.Road,IA.SlopeUp,[["Road", "SlopeUp"]],Py,[[[-2, 0, -2], [1, 0, 1]], [[-2, 1, -2], [1, 1, -2]]]), new Ly("d6d54dbf283f7209032541fc6b924dc879d914f253e391cf8b34dde8354661be",ky.Road,IA.SlopeUpLong,[["Road", "SlopeUpLong"]],Py,[[[-2, 0, -4], [1, 0, 1]], [[-2, 1, -5], [1, 1, -4]], [[-2, 1, -6], [1, 2, -6]]]), new Ly("435e8cf33d28e52f75890cba1cb6529991148afd701f9b40e9ab876c11b2c448",ky.Road,IA.SlopeDown,[["Road", "SlopeDown"]],Py,[[[-2, 0, -2], [1, 0, 1]], [[-2, 1, 0], [1, 1, 1]]]), new Ly("01990158f65e5d499030d8c6d0ce80d34c136189ae1a9430d4260ea7a85e91a9",ky.Road,IA.SlopeDownLong,[["Road", "SlopeDownLong"]],Py,[[[-2, 0, -2], [1, 0, 0]], [[-2, 1, -1], [1, 1, 5]], [[-2, 2, 3], [1, 2, 5]]]), new Ly("4afecc8b9bd7a3b074112008831fef6b11f9a55ab8c1e570e3e73c1e92b43c6d",ky.Road,IA.Slope,[["Road", "Slope"]],Py,[[[-2, 0, 0], [1, 0, 1]], [[-2, 1, -2], [1, 1, 0]], [[-2, 2, -2], [1, 2, -2]]]), new Ly("27f9b25126b1006514941bd148c8f19dc2d82022b0c1aa2358f36cb711d4b59c",ky.Road,IA.SlopePillar,[["Road", "Slope"], ["Pillar", "PillarTopSlope"]],Py,[[[-2, 0, 0], [1, 0, 1]], [[-2, 1, -2], [1, 1, 0]], [[-2, 2, -2], [1, 2, -2]], [[-1, 0, -1], [0, 0, -1]]]), new Ly("eb236f0ac4bd895c170db53cb518c8df5167a9db5af4bb4f33f73c02deec5265",ky.Road,IA.SlopePillarShort,[["Road", "Slope"], ["Pillar", "PillarShortSlope"]],Py,[[[-2, 0, 0], [1, 0, 1]], [[-2, 1, -2], [1, 1, 0]], [[-2, 2, -2], [1, 2, -2]], [[-1, 0, -1], [0, 0, -1]]]), new Ly("99cb9068cb3f97e7cbfdbb3f1edc1085ea37514f3d5dd8936bc32089cc066a5c",ky.Road,IA.SlopeUpVertical,[["Road", "SlopeUpVertical"]],Py,[[[-2, 0, -2], [1, 0, 1]], [[-2, 1, -2], [1, 1, -1]], [[-2, 2, -2], [1, 3, -2]]]), new Ly("63628b23e104a3eb3c2ba8189cd408a10fbb6ebcd6fa4359d981e3c3804c13d8",ky.Road,IA.IntersectionT,[["Road", "IntersectionT"]],Py,[[[-2, 0, -2], [1, 0, 1]]]), new Ly("400dc4643653001d283bb13f740593fc2300c547bb4d2a962054ba6aabf3721c",ky.Road,IA.IntersectionTPillarBottom,[["Road", "IntersectionT"], ["Pillar", "SurfacePillarBottom"]],Py,[[[-2, 0, -2], [1, 0, 1]]]), new Ly("60355388650d35fcbddaaac29e0d03bc2ae46db1a05cd23ddd3f2722ec2d409e",ky.Road,IA.IntersectionTPillarShort,[["Road", "IntersectionT"], ["Pillar", "SurfacePillarShort"]],Py,[[[-2, 0, -2], [1, 0, 1]]]), new Ly("74197b3731c2befd03498bf5172859f0b3652f1972c19e43a99bb938769573df",ky.Road,IA.IntersectionCross,[["Road", "IntersectionCross"]],Py,[[[-2, 0, -2], [1, 0, 1]]]), new Ly("464e69b5c4f2667c246ade9ed33fd3e50b49438ed0ab787a086dfe74c217ff6c",ky.Road,IA.IntersectionCrossPillarBottom,[["Road", "IntersectionCross"], ["Pillar", "SurfacePillarBottom"]],Py,[[[-2, 0, -2], [1, 0, 1]]]), new Ly("90004caf354627289265314966f11b5656e6879ca7de10507e6c50cd95254b75",ky.Road,IA.IntersectionCrossPillarShort,[["Road", "IntersectionCross"], ["Pillar", "SurfacePillarShort"]],Py,[[[-2, 0, -2], [1, 0, 1]]]), new Ly("2af8aa6050028dd6ee69b7150e83a6d8819e1848a7b1c782848d3f6448c5091a",ky.RoadWide,IA.ToWideMiddle,[["RoadWide", "ToWideMiddle"]],Py,[[[-2, 0, -2], [1, 0, 1]]]), new Ly("26341cfe6bec34f46b10ffcd9a7706a8156b9ac41ed2cdfd166f9f8d3e9bc8f3",ky.RoadWide,IA.ToWideLeft,[["RoadWide", "ToWideSide", {
                        flipX: !0
                    }]],Py,[[[-2, 0, -2], [1, 0, 1]]]), new Ly("3f82ebd6c72110b532a20673f8b54c7b25ae5988a51d3793bf383fea8ffcffc3",ky.RoadWide,IA.ToWideRight,[["RoadWide", "ToWideSide"]],Py,[[[-2, 0, -2], [1, 0, 1]]]), new Ly("f5cecce9870f41f8cba7a9fbe631c315370a7a82824d04977ec857dbb1dfed29",ky.RoadWide,IA.ToWideDouble,[["RoadWide", "ToWideDouble"]],Py,[[[-2, 0, -2], [1, 0, 1]]]), new Ly("99dc726611397f81b47459d32c7bfb8232322d1ca976ba9a3e71cc15451d8cfb",ky.RoadWide,IA.ToWideDiagonal,[["RoadWide", "ToWideDiagonal"]],Py,[[[-2, 0, -2], [1, 0, 1]]]), new Ly("47d7e3fb334681911e122babef127881a36a763fb22176854114495802d5ce84",ky.RoadWide,IA.StraightWide,[["RoadWide", "StraightWide"]],Py,[[[-2, 0, -2], [1, 0, 1]]]), new Ly("521adc95ed5a4809eeff7eec872c3d6449e4d6a7e4941d672f1e06a50a6615de",ky.RoadWide,IA.InnerCornerWide,[["RoadWide", "InnerCornerWide"]],Py,[[[-2, 0, -2], [1, 0, 1]]]), new Ly("d82274b362794e3c1772510002d5015dde345f1e72dd675c8bac41cf2331398b",ky.RoadWide,IA.OuterCornerWide,[["RoadWide", "OuterCornerWide"]],Py,[[[-2, 0, -2], [1, 0, 1]]]), new Ly("9b1df4dd4687404adb5789f3b90af39ea6fa65ef741a07b116dc436dc14a2aa1",ky.RoadWide,IA.SlopeUpLeftWide,[["RoadWide", "SlopeUpWide", {
                        flipX: !0
                    }]],Py,[[[-2, 0, -2], [1, 0, 1]], [[-2, 1, -2], [1, 1, -2]]]), new Ly("651d4e988913b84359ad10e0c4745965b6a388eaa8c9bfbba4b6a50ae6d4f592",ky.RoadWide,IA.SlopeUpRightWide,[["RoadWide", "SlopeUpWide"]],Py,[[[-2, 0, -2], [1, 0, 1]], [[-2, 1, -2], [1, 1, -2]]]), new Ly("848d9930c58e66152090d7853af87c8bb7971e1771d3c337ac1a50aaa4975a78",ky.RoadWide,IA.SlopeUpLongLeftWide,[["RoadWide", "SlopeUpLongWide", {
                        flipX: !0
                    }]],Py,[[[-2, 0, -4], [1, 0, 1]], [[-2, 1, -5], [1, 1, -4]], [[-2, 1, -6], [1, 2, -6]]]), new Ly("e4d54c6c3b6011a1acfb6766b6b3e7ea0de6f9c6569a5ec88c47968ad4105b2a",ky.RoadWide,IA.SlopeUpLongRightWide,[["RoadWide", "SlopeUpLongWide"]],Py,[[[-2, 0, -4], [1, 0, 1]], [[-2, 1, -5], [1, 1, -4]], [[-2, 1, -6], [1, 2, -6]]]), new Ly("106ad1d4c5aded30cc3ef4cd1bdc40babab84464ce7dbce3b81cc20d55fd615f",ky.RoadWide,IA.SlopeDownLeftWide,[["RoadWide", "SlopeDownWide", {
                        flipX: !0
                    }]],Py,[[[-2, 0, -2], [1, 0, 1]], [[-2, 1, 0], [1, 1, 1]]]), new Ly("23a693633b8453c7a531de9723e6ca14d0676b1d7a4df7f78278914467b90a27",ky.RoadWide,IA.SlopeDownRightWide,[["RoadWide", "SlopeDownWide"]],Py,[[[-2, 0, -2], [1, 0, 1]], [[-2, 1, 0], [1, 1, 1]]]), new Ly("0f2e33a8b68667e30e80ceaefdb890a77643799d63c7f20672ca3185bbc04270",ky.RoadWide,IA.SlopeDownLongLeftWide,[["RoadWide", "SlopeDownLongWide", {
                        flipX: !0
                    }]],Py,[[[-2, 0, -2], [1, 0, 0]], [[-2, 1, -1], [1, 1, 5]], [[-2, 2, 3], [1, 2, 5]]]), new Ly("164903518c7efa4890a792017ea2b8125a2c3dae76bba4c6f1f56fb0f7e40ebc",ky.RoadWide,IA.SlopeDownLongRightWide,[["RoadWide", "SlopeDownLongWide"]],Py,[[[-2, 0, -2], [1, 0, 0]], [[-2, 1, -1], [1, 1, 5]], [[-2, 2, 3], [1, 2, 5]]]), new Ly("c20560fd35288c5cc74af61834b9a56efaeacdde55eb793d400b7c5b97904993",ky.RoadWide,IA.SlopeLeftWide,[["RoadWide", "SlopeWide", {
                        flipX: !0
                    }]],Py,[[[-2, 0, 0], [1, 0, 1]], [[-2, 1, -2], [1, 1, 0]], [[-2, 2, -2], [1, 2, -2]]]), new Ly("b6a26eb3cefee53d4deef24544e5b5c1ecd25e8e8bd7c3070c7947ada55c57c2",ky.RoadWide,IA.SlopeRightWide,[["RoadWide", "SlopeWide"]],Py,[[[-2, 0, 0], [1, 0, 1]], [[-2, 1, -2], [1, 1, 0]], [[-2, 2, -2], [1, 2, -2]]]), new Ly("b598ff14bda99600434b24a619132fec4bffcc535483b9b57b0c8c09c1be1f1b",ky.RoadWide,IA.SlopeUpVerticalLeftWide,[["RoadWide", "SlopeUpVerticalWide"]],Py,[[[-2, 0, -2], [1, 0, 1]], [[-2, 1, -2], [1, 1, -1]], [[-2, 2, -2], [1, 3, -2]]]), new Ly("4e0275d3a01eaca6ec5118b8b816ed292cb7172710cf9b7801068424ab684b22",ky.RoadWide,IA.SlopeUpVerticalRightWide,[["RoadWide", "SlopeUpVerticalWide", {
                        flipX: !0
                    }]],Py,[[[-2, 0, -2], [1, 0, 1]], [[-2, 1, -2], [1, 1, -1]], [[-2, 2, -2], [1, 3, -2]]]), new Ly("896b47675cc2ff58494979168f6fd36c27c43da29aed6a52fdf80f054630166a",ky.Plane,IA.Plane,[["Planes", "Plane"]],Py,[[[-2, 0, -2], [1, 0, 1]]]), new Ly("dc9afb98a8bb998d3b76c3563385e58c1749e56ff43fbc7577b1f57ba8360702",ky.Plane,IA.PlanePillarBottom,[["Planes", "Plane"], ["Pillar", "SurfacePillarBottom"]],Py,[[[-2, 0, -2], [1, 0, 1]]]), new Ly("f59ad95edd26814236ab30b73f6f4f68003885ef150201a4ace14b832abcf438",ky.Plane,IA.PlanePillarShort,[["Planes", "Plane"], ["Pillar", "SurfacePillarShort"]],Py,[[[-2, 0, -2], [1, 0, 1]]]), new Ly("48247a66b232461083fa2aa36644e7e8779f5b426d474efd375ee7d21d009c9a",ky.Plane,IA.HalfPlane,[["Planes", "HalfPlane"]],Py,[[[-2, 0, 1], [1, 0, 1]], [[-2, 0, 0], [0, 0, 0]], [[-2, 0, -1], [-1, 0, -1]], [[-2, 0, -2], [-2, 0, -2]]]), new Ly("eac8530d1a025291674bf34b206f75700dc8626012d8d33ed398f7aed746dac8",ky.Plane,IA.QuarterPlane,[["Planes", "QuarterPlane"]],Py,[[[-2, 0, 1], [-2, 0, 1]], [[-2, 0, -1], [-1, 0, 0]], [[-2, 0, -2], [-2, 0, -2]]]), new Ly("1da4dcad366aa90a5977e1b20c5d79297106ed3b4f664be04b6b3f6370c105b4",ky.Plane,IA.PlaneSlopeUp,[["Planes", "PlaneSlopeUp"]],Py,[[[-2, 0, -2], [1, 0, 1]], [[-2, 1, -2], [1, 1, -2]]]), new Ly("3e203219ec0ea114da510b37a4c392b90417af796e2b089da6d996e628c0a323",ky.Plane,IA.PlaneSlopeUpLong,[["Planes", "PlaneSlopeUpLong"]],Py,[[[-2, 0, -4], [1, 0, 1]], [[-2, 1, -5], [1, 1, -4]], [[-2, 1, -6], [1, 2, -6]]]), new Ly("053dbf6c03eea5102b67168ccb479d8364233b36c4210aff093928bbb83d859d",ky.Plane,IA.PlaneSlopeDown,[["Planes", "PlaneSlopeDown"]],Py,[[[-2, 0, -2], [1, 0, 1]], [[-2, 1, 0], [1, 1, 1]]]), new Ly("d68121a3cb0ee19cab45adb136e0df6145f43ca9ecbde8a417c02a6d4a75a757",ky.Plane,IA.PlaneSlopeDownLong,[["Planes", "PlaneSlopeDownLong"]],Py,[[[-2, 0, -2], [1, 0, 0]], [[-2, 1, -1], [1, 1, 5]], [[-2, 2, 3], [1, 2, 5]]]), new Ly("67ec222e8fe770a8d728bb76ff571377c261d2f232134d4cb328c9ab772cf3ca",ky.Plane,IA.PlaneSlope,[["Planes", "PlaneSlope"]],Py,[[[-2, 0, 0], [1, 0, 1]], [[-2, 1, -2], [1, 1, 0]], [[-2, 2, -2], [1, 2, -2]]]), new Ly("a52c09d87d37088b68420db07626f274c74f792cb223764624d887a5ed145a2e",ky.Plane,IA.PlaneSlopePillar,[["Planes", "PlaneSlope"], ["Pillar", "PillarTopSlope"]],Py,[[[-2, 0, 0], [1, 0, 1]], [[-2, 1, -2], [1, 1, 0]], [[-2, 2, -2], [1, 2, -2]], [[-1, 0, -1], [0, 0, -1]]]), new Ly("57df805433e706ec946d767d7ff0881f163c2e36bb1db00b0e3259954a787dec",ky.Plane,IA.PlaneSlopePillarShort,[["Planes", "PlaneSlope"], ["Pillar", "PillarShortSlope"]],Py,[[[-2, 0, 0], [1, 0, 1]], [[-2, 1, -2], [1, 1, 0]], [[-2, 2, -2], [1, 2, -2]], [[-1, 0, -1], [0, 0, -1]]]), new Ly("ba0d6ec33647740bf4c60e542d1758095afa3ef451bdaec76c783dd32116e4cb",ky.Plane,IA.PlaneSlopeVerticalBottom,[["Planes", "PlaneSlopeVertical"]],Py,[[[-2, 0, -1], [1, 0, 1]], [[-2, 1, -1], [1, 1, -1]], [[-2, 1, -2], [1, 3, -2]]]), new Ly("78a372de15f3151f901cf7fa7a3983ee6513cf19fa8568f10946e195c5a62515",ky.Plane,IA.PlaneSlopeToVertical,[["Planes", "PlaneSlopeToVertical"]],Py,[[[-2, 0, 0], [1, 0, 1]], [[-2, 1, -2], [1, 1, 0]], [[-2, 2, -2], [1, 3, -2]]]), new Ly("5f6d1ece085d450643f1399af53673dcc6bbbf413094d8dd5ee6816d80e1c8ae",ky.Plane,IA.PlaneBridge,[["Planes", "PlaneBridge"]],Py,[[[-1, 0, -2], [0, 0, 1]]]), new Ly("32b91fc4cdf95f5b7a490d81058522bae14741601dd44c73cc110121aa1dd6e6",ky.Plane,IA.PlaneBridgeCorner,[["Planes", "PlaneBridgeCorner"]],Py,[[[-1, 0, -1], [0, 0, 1]], [[1, 0, -1], [1, 0, 0]]]), new Ly("2db870b1821fb655437bd0527569d5a6843718fa0775682701437432265a1a88",ky.Plane,IA.PlaneBridgeIntersectionT,[["Planes", "PlaneBridgeIntersectionT"]],Py,[[[-1, 0, -1], [0, 0, 1]], [[1, 0, -1], [1, 0, 0]], [[-2, 0, -1], [-2, 0, 0]]]), new Ly("33aa0e7524b74dcdae4aed89856c09d25248c4cab8f70dcc31b347f0a00fcb52",ky.Plane,IA.PlaneBridgeIntersectionCross,[["Planes", "PlaneBridgeIntersectionCross"]],Py,[[[-1, 0, -1], [0, 0, 1]], [[1, 0, -1], [1, 0, 0]], [[-2, 0, -1], [-2, 0, 0]], [[-1, 0, -2], [0, 0, -2]]]), new Ly("bd7cc4ab180fc0a6936fef828ae3a91566b3dd621b888fbcc57c9ac11dcb713b",ky.Plane,IA.PlaneWall,[["Planes", "PlaneWall"]],Py,[[[-2, 0, 1], [1, 0, 1]]]), new Ly("d92568164028bb2e65799abd9dc6ba66cfe8a28515c09fbe5ac175f5966af66a",ky.Plane,IA.PlaneWallCorner,[["Planes", "PlaneWallCorner"]],Py,[[[-2, 0, 1], [1, 0, 1]], [[1, 0, -2], [1, 0, 0]]]), new Ly("792ab5a6f0e2bf8e556575ef12731ec30755855d4394f98eb4ca7ec8b713933c",ky.Plane,IA.PlaneWallInnerCorner,[["Planes", "PlaneWallInnerCorner"]],Py,[[[1, 0, 1], [1, 0, 1]]]), new Ly("de0d588c4b2fe6b32d72a7e0e2984285955f805ccb86d3c269f7155401cd6b20",ky.Block,IA.Block,[["Blocks", "Block"]],Ry,[[[-2, 0, -2], [1, 0, 1]]]), new Ly("1ce6b585c0e99d71877fefe015ff16336ae62eb0caebeca62dd09d836092d7b6",ky.Block,IA.HalfBlock,[["Blocks", "HalfBlock"]],Ry,[[[-2, 0, 1], [1, 0, 1]], [[-2, 0, 0], [0, 0, 0]], [[-2, 0, -1], [-1, 0, -1]], [[-2, 0, -2], [-2, 0, -2]]]), new Ly("0d5f0609c3c98f687d55d3a73313225c1642f6285ddaca3ed536db742c85958d",ky.Block,IA.QuarterBlock,[["Blocks", "QuarterBlock"]],Ry,[[[-2, 0, 1], [-2, 0, 1]], [[-2, 0, -1], [-1, 0, 0]], [[-2, 0, -2], [-2, 0, -2]]]), new Ly("18fc1c569c6fc04f95f10174143d19e7a9ea4e387302363f4ae60883c1acd3f0",ky.Block,IA.BlockSlopedDown,[["Blocks", "BlockSlopedDown"]],Ry,[[[-2, 0, -2], [1, 0, -1]], [[-2, 1, -2], [1, 1, 1]]]), new Ly("22dd5b2804c88994a4d283cb822f47de3c72f82376e4c9332d39feae85206c0f",ky.Block,IA.BlockSlopedDownInnerCorner,[["Blocks", "BlockSlopedDownInnerCorner"]],Ry,[[[-2, 0, -2], [-1, 0, 1]], [[0, 0, -2], [1, 0, -1]], [[-2, 1, -2], [1, 1, 1]]]), new Ly("81a71b4cc6ef8520f20fd738457abc31b04258c97f9862f70190fd2a0ba91382",ky.Block,IA.BlockSlopedDownOuterCorner,[["Blocks", "BlockSlopedDownOuterCorner"]],Ry,[[[-2, 0, -2], [-1, 0, -1]], [[-2, 1, -2], [1, 1, 1]]]), new Ly("f4e19d3bc49994a85fecd187b76c21d258e7f30f0506d90bc6f173336e11627d",ky.Block,IA.BlockSlopedUp,[["Blocks", "BlockSlopedUp"]],Ry,[[[-2, 0, -2], [1, 0, 1]], [[-2, 1, -2], [1, 1, -1]]]), new Ly("fd9309468e97131bbbd1404fac34a7137cb176327789b955c1aea30267e1cded",ky.Block,IA.BlockSlopedUpInnerCorner,[["Blocks", "BlockSlopedUpInnerCorner"]],Ry,[[[-2, 1, -2], [-1, 1, 1]], [[0, 1, -2], [1, 1, -1]], [[-2, 0, -2], [1, 0, 1]]]), new Ly("1321fb07ece1b80b99dc4671b52673ac028fbf43322e9e652ad633ff6afac21b",ky.Block,IA.BlockSlopedUpOuterCorner,[["Blocks", "BlockSlopedUpOuterCorner"]],Ry,[[[-2, 1, -2], [-1, 1, -1]], [[-2, 0, -2], [1, 0, 1]]]), new Ly("b97c17388fc38139f2f5a98a36d94831095f79db709dd97748ad2904bc54d689",ky.Block,IA.BlockSlopeDown,[["Blocks", "BlockSlopeDown"]],Ry,[[[-2, 0, -2], [1, 0, 1]]]), new Ly("50276826bbfb9fcb11a8519b8dae8a2b1cf82817d5431418d9a376664261be82",ky.Block,IA.BlockSlopeUp,[["Blocks", "BlockSlopeUp"]],Ry,[[[-2, 0, -2], [1, 0, 1]]]), new Ly("63fd3032796397f8e25669c1c1d3fc97b8ec0e5fc88bfcb5c00a2a2c2b517888",ky.Block,IA.BlockSlopeDownLong,[["Blocks", "BlockSlopeDownLong"]],Ry,[[[-2, 0, -2], [1, 0, 5]], [[-2, 1, 0], [1, 1, 5]]]), new Ly("2d29131222a8d891b4350e6a2f335b114e001cf22e4e2f170dc9b86c4b2fd325",ky.Block,IA.BlockSlopeUpLong,[["Blocks", "BlockSlopeUpLong"]],Ry,[[[-2, 0, -6], [1, 0, 1]], [[-2, 1, -6], [1, 1, -4]]]), new Ly("0bbcd96c91b69e6e8005bfae5b64455b0d6510cb1595f3fca7f77c86ddda4560",ky.Block,IA.BlockSlopeVerticalTop,[["Blocks", "BlockSlopeVertical", {
                        flipY: !0
                    }]],Ry,[[[-2, 3, -2], [1, 3, 1]], [[-2, 2, -2], [1, 2, -1]], [[-2, 0, -2], [1, 1, -2]]]), new Ly("e81a123c0be3f8f168fb584d53e8aa038785569bbf2cd1c1cead2272889591e0",ky.Block,IA.BlockSlopeVerticalBottom,[["Blocks", "BlockSlopeVertical"]],Ry,[[[-2, 0, -2], [1, 0, 1]], [[-2, 1, -2], [1, 1, -1]], [[-2, 2, -2], [1, 3, -2]]]), new Ly("94e14468f31af7f39b9d7ba188a364089ae81da2bd6a9db2b8f5b1b8cedce741",ky.Block,IA.BlockSlopeToVertical,[["Blocks", "BlockSlopeToVertical"]],Ry,[[[-2, 0, -2], [1, 0, 1]], [[-2, 1, -2], [1, 1, -1]], [[-2, 2, -2], [1, 3, -2]]]), new Ly("3a2f05b1c2c2fd976997fa473f1adb3ba14495701dc5a998f8697798384c6946",ky.Block,IA.BlockSlopeVerticalCornerTop,[["Blocks", "BlockSlopeVerticalCornerBottom", {
                        flipY: !0
                    }]],Ry,[[[-2, 3, -2], [1, 3, 1]], [[-2, 2, -2], [0, 2, 0]], [[1, 2, -2], [1, 2, -1]], [[-2, 2, 1], [-1, 2, 1]], [[-2, 1, -2], [-1, 1, -1]], [[-2, 1, 0], [-1, 1, 0]], [[0, 1, -2], [0, 1, -1]], [[1, 1, -2], [1, 1, -2]], [[-2, 1, 1], [-2, 1, 1]], [[-2, 0, -2], [-1, 0, -1]], [[-2, 0, 0], [-2, 0, 1]], [[0, 0, -2], [1, 0, -2]]]), new Ly("3e4fa43e69aa1dbee584e16451a95a16229bba8d638df2bf6f6c9ffb3a9629c9",ky.Block,IA.BlockInnerCorner,[["Blocks", "BlockInnerCorner"]],Ry,[[[-2, 0, 0], [-2, 0, 1]], [[-2, 0, -2], [-1, 0, -1]], [[0, 0, -2], [1, 0, -2]]]), new Ly("cc9c95eef56def4cf013e4ac85b8013a2b4f4b4346f1f5dd41fa017de763ef17",ky.Block,IA.BlockSlopeVerticalCornerBottom,[["Blocks", "BlockSlopeVerticalCornerBottom"]],Ry,[[[-2, 0, -2], [1, 0, 1]], [[-2, 1, -2], [0, 1, 0]], [[1, 1, -2], [1, 1, -1]], [[-2, 1, 1], [-1, 1, 1]], [[-2, 2, -2], [-1, 2, -1]], [[-2, 2, 0], [-1, 2, 0]], [[0, 2, -2], [0, 2, -1]], [[1, 2, -2], [1, 2, -2]], [[-2, 2, 1], [-2, 2, 1]], [[-2, 3, -2], [-1, 3, -1]], [[-2, 3, 0], [-2, 3, 1]], [[0, 3, -2], [1, 3, -2]]]), new Ly("e4c82c8e512d52269cb6588fa34b06c179340ea40e71f74cbadadc7e8353f5a2",ky.Block,IA.BlockSlopeVerticalInnerCornerTop,[["Blocks", "BlockSlopeVerticalInnerCorner", {
                        flipY: !0
                    }]],Ry,[[[-2, 3, -2], [0, 3, 1]], [[1, 3, -2], [1, 3, 0]], [[-2, 2, -2], [-2, 2, -1]], [[-1, 2, -2], [-1, 2, -2]], [[-2, 0, -2], [-2, 1, -2]]]), new Ly("926fdc6e82ecd709cc535faea6bb8778c6e2e91edb39eb6ae6308076dca2ed18",ky.Block,IA.BlockSlopeVerticalInnerCornerBottom,[["Blocks", "BlockSlopeVerticalInnerCorner"]],Ry,[[[-2, 0, -2], [0, 0, 1]], [[1, 0, -2], [1, 0, 0]], [[-2, 1, -2], [-2, 1, -1]], [[-1, 1, -2], [-1, 1, -2]], [[-2, 2, -2], [-2, 3, -2]]]), new Ly("1086515ba3c1d8e5ec76b378f0bdbc77fc5a57fc8eba8972f0d5e611be945235",ky.Block,IA.BlockBridge,[["Blocks", "BlockBridge"]],Ry,[[[-1, 0, -2], [0, 0, 1]]]), new Ly("5426ad4ff64af3f1a0f0794ad30cfc20434dfffdf44d93010f5f98671c246ff3",ky.Block,IA.BlockBridgeCorner,[["Blocks", "BlockBridgeCorner"]],Ry,[[[-1, 0, -1], [0, 0, 1]], [[1, 0, -1], [1, 0, 0]]]), new Ly("784b9b4459e838e5b8f74f6250769ffa52ec5cc3608abc24c380a2e792c3d338",ky.Block,IA.BlockBridgeIntersectionT,[["Blocks", "BlockBridgeIntersectionT"]],Ry,[[[-1, 0, -1], [0, 0, 1]], [[1, 0, -1], [1, 0, 0]], [[-2, 0, -1], [-2, 0, 0]]]), new Ly("dfbcbc107a3c12217bfa3b224a5757d08e995705d1c122bb2c2665bbb8447b1c",ky.Block,IA.BlockBridgeIntersectionCross,[["Blocks", "BlockBridgeIntersectionCross"]],Ry,[[[-1, 0, -1], [0, 0, 1]], [[1, 0, -1], [1, 0, 0]], [[-2, 0, -1], [-2, 0, 0]], [[-1, 0, -2], [0, 0, -2]]]), new Ly("5fe53442e559418b7cc9483315b0ac45b8797f9630d5ecc4c7604dab4be25584",ky.WallTrack,IA.WallTrackTop,[["WallTrack", "WallTrackBottom", {
                        flipY: !0
                    }]],Py,[[[-2, 3, -1], [1, 3, 1]], [[-2, 2, -1], [1, 2, -1]], [[-2, 0, -2], [1, 2, -2]]]), new Ly("010d187fbfbd399bfe880bbea1b548678c239eba0be2913e5cb8a69fbd17adf7",ky.WallTrack,IA.WallTrackMiddle,[["WallTrack", "WallTrackMiddle"]],Py,[[[-2, 0, -2], [1, 0, -2]]]), new Ly("33216a4dcb734511a80c5bf70ca6f66de555800426686eae5a2519d4c837090e",ky.WallTrack,IA.WallTrackBottom,[["WallTrack", "WallTrackBottom"]],Py,[[[-2, 0, -1], [1, 0, 1]], [[-2, 1, -1], [1, 1, -1]], [[-2, 1, -2], [1, 3, -2]]]), new Ly("1e306d2a6347b68d6e275bf4ccc9c8942e0a633bf625a3bba95fa9f98ecd50ff",ky.WallTrack,IA.WallTrackSlopeToVertical,[["WallTrack", "WallTrackSlopeToVertical"]],Py,[[[-2, 0, 0], [1, 0, 1]], [[-2, 1, -2], [1, 1, 0]], [[-2, 2, -2], [1, 3, -2]]]), new Ly("3ed21ddbc756a6644e05f5e1ca78ff8df6d51affc472c2d86e7f23d85911e273",ky.WallTrack,IA.WallTrackTopCorner,[["WallTrack", "WallTrackBottomCorner", {
                        flipY: !0
                    }]],Py,[[[-2, 0, -1], [-2, 0, 1]], [[-1, 0, -1], [-1, 0, -1]], [[-1, 0, -2], [1, 0, -2]], [[-2, 1, -1], [-2, 1, 1]], [[-1, 1, -1], [-1, 1, 0]], [[0, 1, -1], [0, 1, -1]], [[-1, 1, -2], [1, 1, -2]], [[-2, 2, 0], [-2, 2, 1]], [[-1, 2, 1], [-1, 2, 1]], [[-1, 2, -1], [0, 2, 0]], [[1, 2, -1], [1, 2, -1]], [[0, 2, -2], [1, 2, -2]], [[0, 3, -1], [1, 3, 1]], [[-1, 3, 0], [-1, 3, 1]]]), new Ly("4027a2439cc3e42ceda50ff3d427a31e127b25a6457b55edc2d498b474a296a7",ky.WallTrack,IA.WallTrackMiddleCorner,[["WallTrack", "WallTrackMiddleCorner"]],Py,[[[-2, 0, -1], [-2, 0, 1]], [[-1, 0, -1], [-1, 0, -1]], [[-1, 0, -2], [1, 0, -2]]]), new Ly("498286e062056a537a482ed3385fe0ac0343b399f29d470641df8f74c0532672",ky.WallTrack,IA.WallTrackBottomCorner,[["WallTrack", "WallTrackBottomCorner"]],Py,[[[-2, 3, -1], [-2, 3, 1]], [[-1, 3, -1], [-1, 3, -1]], [[-1, 3, -2], [1, 3, -2]], [[-2, 2, -1], [-2, 2, 1]], [[-1, 2, -1], [-1, 2, 0]], [[0, 2, -1], [0, 2, -1]], [[-1, 2, -2], [1, 2, -2]], [[-2, 1, 0], [-2, 1, 1]], [[-1, 1, 1], [-1, 1, 1]], [[-1, 1, -1], [0, 1, 0]], [[1, 1, -1], [1, 1, -1]], [[0, 1, -2], [1, 1, -2]], [[0, 0, -1], [1, 0, 1]], [[-1, 0, 0], [-1, 0, 1]]]), new Ly("ac09cd62c83af376f23d37dd88273614a2a11cc04a04bff6075fd749bb1ff421",ky.WallTrack,IA.WallTrackTopInnerCorner,[["WallTrack", "WallTrackBottomInnerCorner", {
                        flipY: !0
                    }]],Py,[[[-2, 3, -1], [1, 3, 1]], [[-1, 3, -2], [1, 3, -2]], [[-2, 2, -2], [-1, 2, -1]], [[-2, 0, -2], [-2, 1, -2]]]), new Ly("16c9c8ece47c097f60cfc7f8a2daa2f0e7ad0befb0ebfd185402013fd1ec8e0f",ky.WallTrack,IA.WallTrackInnerCorner,[["WallTrack", "WallTrackInnerCorner"]],Py,[[[-2, 0, -2], [-2, 0, -2]]]), new Ly("404e7506c2f7e9302acac39c31a659e7e09e7852786e5f0244f9827727a0bf1e",ky.WallTrack,IA.WallTrackBottomInnerCorner,[["WallTrack", "WallTrackBottomInnerCorner"]],Py,[[[-2, 0, -1], [1, 0, 1]], [[-1, 0, -2], [1, 0, -2]], [[-2, 1, -2], [-1, 1, -1]], [[-2, 2, -2], [-2, 3, -2]]]), new Ly("8b7023471502607ef19109760bee3b954ea3b3883c32f3960f75c6651c912ffd",ky.WallTrack,IA.WallTrackFloor,[["WallTrack", "WallTrackFloor"]],Py,[[[-2, 0, -2], [1, 0, 1]]]), new Ly("59e7f31827236c71db8b16f3f1f259c4c82c87a37e4d57a5a097c0d527d128f3",ky.WallTrack,IA.WallTrackFloorCorner,[["WallTrack", "WallTrackFloorCorner"]],Py,[[[-2, 0, -2], [1, 0, 1]]]), new Ly("d58e3805b550b70940c845a807086865b21a4c36da74ffddedcfe5ce2d08e093",ky.WallTrack,IA.WallTrackFloorPlaneCorner,[["WallTrack", "WallTrackFloorPlaneCorner"]],Py,[[[-2, 0, -2], [1, 0, 1]]]), new Ly("a56b0c1cf964b213a38167cbbac6f33acd403978ad75746eb51bcfd8c6a36148",ky.WallTrack,IA.WallTrackCeiling,[["WallTrack", "WallTrackCeiling"]],Py,[[[-2, 0, -2], [1, 0, 1]]]), new Ly("f87b592d02120312e8e93d8a27c02dcda1095ac2f09879c6efafb2ca2b49d127",ky.WallTrack,IA.WallTrackCeilingCorner,[["WallTrack", "WallTrackCeilingCorner"]],Py,[[[-2, 0, -2], [1, 0, 1]]]), new Ly("cfce1fe50f8cd26393eadd475783830e02f0b39bad4c0e00f7aa69614b22decc",ky.WallTrack,IA.WallTrackCeilingPlaneCorner,[["WallTrack", "WallTrackCeilingPlaneCorner"]],Py,[[[-2, 0, -2], [1, 0, 1]]]), new Ly("19656d02145f1a4ba07dbf2f236f865d34c86f823741b247b5d444a36d61c316",ky.Pillar,IA.PillarTop,[["Pillar", "PillarTop"]],Py,[[[-1, 0, -1], [0, 0, 0]]]), new Ly("dde596d55ffc00f0f00d361667239d9f71c414f03304fecb6a7d11f6f5e702f1",ky.Pillar,IA.PillarMiddle,[["Pillar", "PillarMiddle"]],Py,[[[-1, 0, -1], [0, 0, 0]]]), new Ly("dced5202d9373f9dd81a39530a87a1a7036c93ae71604a4e26c3a191abf3c197",ky.Pillar,IA.PillarBottom,[["Pillar", "PillarBottom"]],Py,[[[-1, 0, -1], [0, 0, 0]]]), new Ly("af83eebf50c302880377e4f8c1fb3b2ef96ae193e8d03c17e1fd77c73a847e63",ky.Pillar,IA.PillarShort,[["Pillar", "PillarShort"]],Py,[[[-1, 0, -1], [0, 0, 0]]]), new Ly("25b41116fb04b1f3cdd3119f57e0000a6ea8cb12d435718ffd6bb765866c272f",ky.Pillar,IA.PillarBranch1,[["Pillar", "PillarBranch1"]],Py,[[[-1, 0, -2], [0, 0, 0]]]), new Ly("05ae39aea4f1ddd818fa57860e688c9cb875544f9b82eafe58a2eb9c19d8d91d",ky.Pillar,IA.PillarBranch1Top,[["Pillar", "PillarBranch1Top"]],Py,[[[-1, 0, -2], [0, 0, 0]]]), new Ly("06c29d92e42e0c32050af98d69eecc94ce15adf8ac81dbe53dfb577a83265f4e",ky.Pillar,IA.PillarBranch1Middle,[["Pillar", "PillarBranch1Middle"]],Py,[[[-1, 0, -2], [0, 0, 0]]]), new Ly("4a989027e0bd6db264f092bac729d9d450e012a710ea28d199f7ff52efd70fbd",ky.Pillar,IA.PillarBranch1Bottom,[["Pillar", "PillarBranch1Bottom"]],Py,[[[-1, 0, -2], [0, 0, 0]]]), new Ly("78b2ff83ad71e7f3d692abc35923fa20c2ae14c01e37d44ec430746ca1bac992",ky.Pillar,IA.PillarBranch2,[["Pillar", "PillarBranch2"]],Py,[[[-1, 0, -2], [0, 0, 0]], [[1, 0, -1], [1, 0, 0]]]), new Ly("b22c93bc73ec2da9dbff218da1676d7436527ed284e264f37294e48ef1307301",ky.Pillar,IA.PillarBranch2Top,[["Pillar", "PillarBranch2Top"]],Py,[[[-1, 0, -2], [0, 0, 0]], [[1, 0, -1], [1, 0, 0]]]), new Ly("79a456a8fa3da24bec6c033f6c736fa1c728745f9624ae78ca20b6a4a76afae8",ky.Pillar,IA.PillarBranch2Middle,[["Pillar", "PillarBranch2Middle"]],Py,[[[-1, 0, -2], [0, 0, 0]], [[1, 0, -1], [1, 0, 0]]]), new Ly("3b81b3f965cbc9fda4fe09e830ba25f1b96ce512d87b0146a1192a6cd0d07335",ky.Pillar,IA.PillarBranch2Bottom,[["Pillar", "PillarBranch2Bottom"]],Py,[[[-1, 0, -2], [0, 0, 0]], [[1, 0, -1], [1, 0, 0]]]), new Ly("27727678bbcac9d3b0172b165ca5c92b10f4b4584a3a18fef4c542f3e791f26f",ky.Pillar,IA.PillarBranch3,[["Pillar", "PillarBranch3"]],Py,[[[-1, 0, -2], [0, 0, 0]], [[1, 0, -1], [1, 0, 0]], [[-2, 0, -1], [-2, 0, 0]]]), new Ly("50c7ac511d30ab9e065c928b776652f038be7683d948082bbefc419ee049e505",ky.Pillar,IA.PillarBranch3Top,[["Pillar", "PillarBranch3Top"]],Py,[[[-1, 0, -2], [0, 0, 0]], [[1, 0, -1], [1, 0, 0]], [[-2, 0, -1], [-2, 0, 0]]]), new Ly("98b3bfe99e7132825f5aa93122e4e5fdec46eb2877c8eb91fa2648f709527b60",ky.Pillar,IA.PillarBranch3Middle,[["Pillar", "PillarBranch3Middle"]],Py,[[[-1, 0, -2], [0, 0, 0]], [[1, 0, -1], [1, 0, 0]], [[-2, 0, -1], [-2, 0, 0]]]), new Ly("7326bbb558f8bcc28d5875c43b1b8e3646caadb873a14fde3ab517f779aea345",ky.Pillar,IA.PillarBranch3Bottom,[["Pillar", "PillarBranch3Bottom"]],Py,[[[-1, 0, -2], [0, 0, 0]], [[1, 0, -1], [1, 0, 0]], [[-2, 0, -1], [-2, 0, 0]]]), new Ly("0e23c2615cfdb350bb3a700b6169589265a1d1079f61294fb497b8f80191d523",ky.Pillar,IA.PillarBranch4,[["Pillar", "PillarBranch4"]],Py,[[[-1, 0, -2], [0, 0, 0]], [[1, 0, -1], [1, 0, 0]], [[-2, 0, -1], [-2, 0, 0]], [[-1, 0, 1], [0, 0, 1]]]), new Ly("e62b55e111dbcb3faefed0a203eac5b55051a2b11911946660310e3df3588da3",ky.Pillar,IA.PillarBranch4Top,[["Pillar", "PillarBranch4Top"]],Py,[[[-1, 0, -2], [0, 0, 0]], [[1, 0, -1], [1, 0, 0]], [[-2, 0, -1], [-2, 0, 0]], [[-1, 0, 1], [0, 0, 1]]]), new Ly("4e2cfb89c1c591803a1440532a74c3ace37ec7fe78a526c1b57f6679c620df2e",ky.Pillar,IA.PillarBranch4Middle,[["Pillar", "PillarBranch4Middle"]],Py,[[[-1, 0, -2], [0, 0, 0]], [[1, 0, -1], [1, 0, 0]], [[-2, 0, -1], [-2, 0, 0]], [[-1, 0, 1], [0, 0, 1]]]), new Ly("e7807350788e4570c8bb74d4a635639ef731d83e52922fac5bc10f415f73f794",ky.Pillar,IA.PillarBranch4Bottom,[["Pillar", "PillarBranch4Bottom"]],Py,[[[-1, 0, -2], [0, 0, 0]], [[1, 0, -1], [1, 0, 0]], [[-2, 0, -1], [-2, 0, 0]], [[-1, 0, 1], [0, 0, 1]]]), new Ly("836bfd12791bfebd99aba70531da4c9bd6e332d16c1e120a8888ea54f59456f9",ky.Pillar,IA.PillarBranch5,[["Pillar", "PillarBranch5"]],Py,[[[-2, 0, -1], [1, 0, 0]]]), new Ly("ab85228116faf9ae7b1e6cb4a03530cbec808df3d3c1d7883eb41eb7cfe231d7",ky.Pillar,IA.PillarBranch5Top,[["Pillar", "PillarBranch5Top"]],Py,[[[-2, 0, -1], [1, 0, 0]]]), new Ly("db93d5cea4e523fd67a56f8d928084ab6355331a8e5d1899115c1841866006bb",ky.Pillar,IA.PillarBranch5Middle,[["Pillar", "PillarBranch5Middle"]],Py,[[[-2, 0, -1], [1, 0, 0]]]), new Ly("dd793efa234159e3a0ff28b064ecb715e6c8bb76e06acfe4bd0d9a2f2b9bba88",ky.Pillar,IA.PillarBranch5Bottom,[["Pillar", "PillarBranch5Bottom"]],Py,[[[-2, 0, -1], [1, 0, 0]]]), new Ly("350f7d3591ffd0b2cfb8204d1c6cd0022fd3bda81ea7e950fce3abea7ec89e1a",ky.Sign,IA.SignArrowLeft,[["Signs", "SignArrowRight", {
                        flipX: !0
                    }]],Py,[[[-2, 0, -2], [1, 0, -2]]]), new Ly("22e104e58bba0a609d379578e391ce50ca523c9eee1c3fddebb6d1bb2246a0b9",ky.Sign,IA.SignArrowRight,[["Signs", "SignArrowRight"]],Py,[[[-2, 0, -2], [1, 0, -2]]]), new Ly("acba0cfe380e625285b973e09344e61740e77d6f8cac8691ef3e0a0b0878040e",ky.Sign,IA.SignArrowUp,[["Signs", "SignArrowUp"]],Py,[[[-2, 0, -2], [1, 0, -2]]]), new Ly("8d0dbea0a26bdf3addd372f5d9a2fdecfd776a48f31218acdeb036129b248ca5",ky.Sign,IA.SignArrowDown,[["Signs", "SignArrowUp", {
                        flipY: !0
                    }]],Py,[[[-2, 0, -2], [1, 0, -2]]]), new Ly("e5e1b1ca69d7b230331171be07876c4b1bdebba557c19b18ab17d91eee2771d5",ky.Sign,IA.SignWarning,[["Signs", "SignWarning"]],Py,[[[-2, 0, -2], [1, 0, -2]]]), new Ly("64ed1fba4990a25bc774575ff8835117638d2c3e7c8f41bf0032d219e1083e4c",ky.Sign,IA.SignWrongWay,[["Signs", "SignWrongWay"]],Py,[[[-2, 0, -2], [1, 0, -2]]])]
                        , Dy = new Map;
                    for (const e of Ny) {
                        if (Dy.has(e.id))
                            throw new Error("Duplicate track part id " + e.id.toString());
                        Dy.set(e.id, e)
                    }
                    function By(e) {
                        const t = Dy.get(e);
                        if (null == t)
                            throw new Error("Unknown track part id " + e.toString());
                        return t
                    }
                    const Uy = Ny.filter((e => {
                            var t;
                            return (null === (t = e.detector) || void 0 === t ? void 0 : t.type) == Sy.Checkpoint
                        }
                    )).map((e => e.id))
                        , zy = Ny.filter((e => null != e.startOffset)).map((e => e.id));
                    function Oy(e) {
                        const t = e.parts;
                        if ("object" != typeof t && null !== t && !Array.isArray(t))
                            return null;
                        const n = new eb(by.Summer,new Ay)
                            , i = Object.keys(t);
                        for (const e of i) {
                            const i = parseInt(e, 10);
                            if (!(i in IA))
                                return null;
                            {
                                const e = t[i];
                                if (!Array.isArray(e))
                                    return null;
                                if (e.length % 4 != 0)
                                    return null;
                                for (let t = 0; t < e.length; t += 4) {
                                    const r = parseInt(e[t + 0], 10)
                                        , a = parseInt(e[t + 1], 10)
                                        , s = parseInt(e[t + 2], 10)
                                        , o = parseInt(e[t + 3], 10);
                                    if (isNaN(r) || isNaN(a) || isNaN(s) || isNaN(o))
                                        return null;
                                    if (!(o >= 0 && o <= 3 && Math.abs(r) <= 1e9 && a >= 0 && a <= 1e9 && Math.abs(s) <= 1e9))
                                        return null;
                                    {
                                        if (Uy.includes(i))
                                            return null;
                                        let e = null;
                                        zy.includes(i) && (e = 0),
                                            n.addPart(4 * r, a, 4 * s, i, o, RA.YPositive, CA.Default, null, e)
                                    }
                                }
                            }
                        }
                        return n
                    }
                    function Fy(e) {
                        let t, n;
                        try {
                            t = JSON.parse(e)
                        } catch (e) {
                            return console.error(e),
                                null
                        }
                        if ("string" != typeof t.name)
                            return null;
                        if ("string" != typeof t.track)
                            return null;
                        try {
                            n = JSON.parse(t.track)
                        } catch (e) {
                            return console.error(e),
                                null
                        }
                        const i = Oy(n);
                        return null == i ? null : {
                            trackMetadata: {
                                name: t.name,
                                author: null
                            },
                            trackData: i
                        }
                    }
                    function Wy(e) {
                        const t = qg(e);
                        if (null == t)
                            return null;
                        const n = new eb(by.Summer,new Ay);
                        let i = 0;
                        for (; i < t.length; ) {
                            if (t.length - i < 2)
                                return null;
                            const e = t[i + 0] | t[i + 1] << 8;
                            if (i += 2,
                                !(e in IA))
                                return null;
                            if (t.length - i < 4)
                                return null;
                            const r = t[i + 0] | t[i + 1] << 8 | t[i + 2] << 16 | t[i + 3] << 24;
                            i += 4;
                            for (let a = 0; a < r; ++a) {
                                if (t.length - i < 3)
                                    return null;
                                const r = (t[i + 0] | t[i + 1] << 8 | t[i + 2] << 16) - Math.pow(2, 23);
                                if (i += 3,
                                t.length - i < 3)
                                    return null;
                                const a = t[i + 0] | t[i + 1] << 8 | t[i + 2] << 16;
                                if (i += 3,
                                t.length - i < 3)
                                    return null;
                                const s = (t[i + 0] | t[i + 1] << 8 | t[i + 2] << 16) - Math.pow(2, 23);
                                if (i += 3,
                                t.length - i < 1)
                                    return null;
                                const o = 3 & t[i + 0];
                                if (i += 1,
                                o < 0 || o > 3)
                                    return null;
                                if (Uy.includes(e))
                                    return null;
                                let l = null;
                                zy.includes(e) && (l = 0),
                                    n.addPart(4 * r, a, 4 * s, e, o, RA.YPositive, CA.Default, null, l)
                            }
                        }
                        return n
                    }
                    function Hy(e) {
                        const t = uy(e);
                        if (null == t)
                            return null;
                        const n = new Yg.Inflate;
                        if (n.push(t, !0),
                            n.err)
                            return null;
                        const i = n.result;
                        if (!(i instanceof Uint8Array))
                            return null;
                        const r = new eb(by.Summer,new Ay);
                        let a = 0;
                        for (; a < i.length; ) {
                            if (i.length - a < 2)
                                return null;
                            const e = i[a + 0] | i[a + 1] << 8;
                            if (a += 2,
                                !(e in IA))
                                return null;
                            if (i.length - a < 4)
                                return null;
                            const t = i[a + 0] | i[a + 1] << 8 | i[a + 2] << 16 | i[a + 3] << 24;
                            a += 4;
                            for (let n = 0; n < t; ++n) {
                                if (i.length - a < 3)
                                    return null;
                                const t = (i[a + 0] | i[a + 1] << 8 | i[a + 2] << 16) - Math.pow(2, 23);
                                if (a += 3,
                                i.length - a < 3)
                                    return null;
                                const n = i[a + 0] | i[a + 1] << 8 | i[a + 2] << 16;
                                if (a += 3,
                                i.length - a < 3)
                                    return null;
                                const s = (i[a + 0] | i[a + 1] << 8 | i[a + 2] << 16) - Math.pow(2, 23);
                                if (a += 3,
                                i.length - a < 1)
                                    return null;
                                const o = i[a + 0];
                                if (a += 1,
                                o < 0 || o > 3)
                                    return null;
                                let l = null;
                                if (Uy.includes(e)) {
                                    if (i.length - a < 2)
                                        return null;
                                    l = i[a + 0] | i[a + 1] << 8,
                                        a += 2
                                }
                                let c = null;
                                zy.includes(e) && (c = 0),
                                    r.addPart(4 * t, n, 4 * s, e, o, RA.YPositive, CA.Default, l, c)
                            }
                        }
                        return r
                    }
                    function Vy(e) {
                        const t = uy(e);
                        if (null == t)
                            return null;
                        const n = new Yg.Inflate;
                        if (n.push(t, !0),
                            n.err)
                            return null;
                        const i = n.result;
                        if (!(i instanceof Uint8Array))
                            return null;
                        const r = new eb(by.Summer,new Ay);
                        let a = 0;
                        for (; a < i.length; ) {
                            if (i.length - a < 2)
                                return null;
                            let e = i[a + 0] | i[a + 1] << 8;
                            a += 2;
                            let t = CA.Default;
                            if (e >= 134 && e <= 178)
                                switch (e) {
                                    case 134:
                                        e = IA.Block,
                                            t = CA.Custom1;
                                        break;
                                    case 135:
                                        e = IA.HalfBlock,
                                            t = CA.Custom1;
                                        break;
                                    case 136:
                                        e = IA.QuarterBlock,
                                            t = CA.Custom1;
                                        break;
                                    case 137:
                                        e = IA.BlockSlopedDown,
                                            t = CA.Custom1;
                                        break;
                                    case 138:
                                        e = IA.BlockSlopedDownInnerCorner,
                                            t = CA.Custom1;
                                        break;
                                    case 139:
                                        e = IA.BlockSlopedDownOuterCorner,
                                            t = CA.Custom1;
                                        break;
                                    case 140:
                                        e = IA.BlockSlopedUp,
                                            t = CA.Custom1;
                                        break;
                                    case 141:
                                        e = IA.BlockSlopedUpInnerCorner,
                                            t = CA.Custom1;
                                        break;
                                    case 142:
                                        e = IA.BlockSlopedUpOuterCorner,
                                            t = CA.Custom1;
                                        break;
                                    case 143:
                                        e = IA.BlockSlopeDown,
                                            t = CA.Custom1;
                                        break;
                                    case 144:
                                        e = IA.BlockSlopeUp,
                                            t = CA.Custom1;
                                        break;
                                    case 145:
                                        e = IA.BlockBridge,
                                            t = CA.Custom1;
                                        break;
                                    case 146:
                                        e = IA.BlockBridgeCorner,
                                            t = CA.Custom1;
                                        break;
                                    case 147:
                                        e = IA.BlockBridgeIntersectionT,
                                            t = CA.Custom1;
                                        break;
                                    case 148:
                                        e = IA.BlockBridgeIntersectionCross,
                                            t = CA.Custom1;
                                        break;
                                    case 149:
                                        e = IA.Block,
                                            t = CA.Custom6;
                                        break;
                                    case 150:
                                        e = IA.HalfBlock,
                                            t = CA.Custom6;
                                        break;
                                    case 151:
                                        e = IA.QuarterBlock,
                                            t = CA.Custom6;
                                        break;
                                    case 152:
                                        e = IA.BlockSlopedDown,
                                            t = CA.Custom6;
                                        break;
                                    case 153:
                                        e = IA.BlockSlopedDownInnerCorner,
                                            t = CA.Custom6;
                                        break;
                                    case 154:
                                        e = IA.BlockSlopedDownOuterCorner,
                                            t = CA.Custom6;
                                        break;
                                    case 155:
                                        e = IA.BlockSlopedUp,
                                            t = CA.Custom6;
                                        break;
                                    case 156:
                                        e = IA.BlockSlopedUpInnerCorner,
                                            t = CA.Custom6;
                                        break;
                                    case 157:
                                        e = IA.BlockSlopedUpOuterCorner,
                                            t = CA.Custom6;
                                        break;
                                    case 158:
                                        e = IA.BlockSlopeDown,
                                            t = CA.Custom6;
                                        break;
                                    case 159:
                                        e = IA.BlockSlopeUp,
                                            t = CA.Custom6;
                                        break;
                                    case 160:
                                        e = IA.BlockBridge,
                                            t = CA.Custom6;
                                        break;
                                    case 161:
                                        e = IA.BlockBridgeCorner,
                                            t = CA.Custom6;
                                        break;
                                    case 162:
                                        e = IA.BlockBridgeIntersectionT,
                                            t = CA.Custom6;
                                        break;
                                    case 163:
                                        e = IA.BlockBridgeIntersectionCross,
                                            t = CA.Custom6;
                                        break;
                                    case 164:
                                        e = IA.Block,
                                            t = CA.Custom0;
                                        break;
                                    case 165:
                                        e = IA.HalfBlock,
                                            t = CA.Custom0;
                                        break;
                                    case 166:
                                        e = IA.QuarterBlock,
                                            t = CA.Custom0;
                                        break;
                                    case 167:
                                        e = IA.BlockSlopedDown,
                                            t = CA.Custom0;
                                        break;
                                    case 168:
                                        e = IA.BlockSlopedDownInnerCorner,
                                            t = CA.Custom0;
                                        break;
                                    case 169:
                                        e = IA.BlockSlopedDownOuterCorner,
                                            t = CA.Custom0;
                                        break;
                                    case 170:
                                        e = IA.BlockSlopedUp,
                                            t = CA.Custom0;
                                        break;
                                    case 171:
                                        e = IA.BlockSlopedUpInnerCorner,
                                            t = CA.Custom0;
                                        break;
                                    case 172:
                                        e = IA.BlockSlopedUpOuterCorner,
                                            t = CA.Custom0;
                                        break;
                                    case 173:
                                        e = IA.BlockSlopeDown,
                                            t = CA.Custom0;
                                        break;
                                    case 174:
                                        e = IA.BlockSlopeUp,
                                            t = CA.Custom0;
                                        break;
                                    case 175:
                                        e = IA.BlockBridge,
                                            t = CA.Custom0;
                                        break;
                                    case 176:
                                        e = IA.BlockBridgeCorner,
                                            t = CA.Custom0;
                                        break;
                                    case 177:
                                        e = IA.BlockBridgeIntersectionT,
                                            t = CA.Custom0;
                                        break;
                                    case 178:
                                        e = IA.BlockBridgeIntersectionCross,
                                            t = CA.Custom0
                                }
                            let n = null
                                , s = {
                                x: 0,
                                y: 0,
                                z: 0
                            };
                            if (79 == e)
                                n = IA.WallTrackFloorPlaneCorner;
                            else if (81 == e)
                                n = IA.WallTrackCeilingPlaneCorner,
                                    s = {
                                        x: 0,
                                        y: 3,
                                        z: 0
                                    };
                            else if (e >= 87 && e <= 98)
                                switch (e) {
                                    case 87:
                                        e = IA.Slope,
                                            n = IA.BlockSlopedUp;
                                        break;
                                    case 88:
                                        e = IA.SlopeUp,
                                            n = IA.BlockSlopeUp;
                                        break;
                                    case 89:
                                        e = IA.SlopeDown,
                                            n = IA.BlockSlopeDown;
                                        break;
                                    case 90:
                                        e = IA.SlopeUpLeftWide,
                                            n = IA.BlockSlopeUp;
                                        break;
                                    case 91:
                                        e = IA.SlopeUpRightWide,
                                            n = IA.BlockSlopeUp;
                                        break;
                                    case 92:
                                        e = IA.SlopeDownLeftWide,
                                            n = IA.BlockSlopeDown;
                                        break;
                                    case 93:
                                        e = IA.SlopeDownRightWide,
                                            n = IA.BlockSlopeDown;
                                        break;
                                    case 94:
                                        e = IA.SlopeLeftWide,
                                            n = IA.BlockSlopedUp;
                                        break;
                                    case 95:
                                        e = IA.SlopeRightWide,
                                            n = IA.BlockSlopedUp;
                                        break;
                                    case 96:
                                        e = IA.PlaneSlopeUp,
                                            n = IA.BlockSlopeUp;
                                        break;
                                    case 97:
                                        e = IA.PlaneSlopeDown,
                                            n = IA.BlockSlopeDown;
                                        break;
                                    case 98:
                                        e = IA.PlaneSlope,
                                            n = IA.BlockSlopedUp;
                                        break;
                                    default:
                                        throw new Error("Invalid track part id")
                                }
                            if (!(e in IA))
                                return null;
                            if (i.length - a < 4)
                                return null;
                            const o = i[a + 0] | i[a + 1] << 8 | i[a + 2] << 16 | i[a + 3] << 24;
                            a += 4;
                            for (let l = 0; l < o; ++l) {
                                if (i.length - a < 3)
                                    return null;
                                const o = (i[a + 0] | i[a + 1] << 8 | i[a + 2] << 16) - Math.pow(2, 23);
                                if (a += 3,
                                i.length - a < 3)
                                    return null;
                                const l = i[a + 0] | i[a + 1] << 8 | i[a + 2] << 16;
                                if (a += 3,
                                i.length - a < 3)
                                    return null;
                                const c = (i[a + 0] | i[a + 1] << 8 | i[a + 2] << 16) - Math.pow(2, 23);
                                if (a += 3,
                                i.length - a < 1)
                                    return null;
                                const h = i[a + 0];
                                if (a += 1,
                                h < 0 || h > 3)
                                    return null;
                                let d = null;
                                if (Uy.includes(e)) {
                                    if (i.length - a < 2)
                                        return null;
                                    d = i[a + 0] | i[a + 1] << 8,
                                        a += 2
                                }
                                let u = null;
                                zy.includes(e) && (u = 0),
                                null != n && r.addPart(4 * o + s.x, l + s.y, 4 * c + s.z, n, h, RA.YPositive, CA.Default, null, u),
                                    r.addPart(4 * o, l, 4 * c, e, h, RA.YPositive, t, d, u)
                            }
                        }
                        return r
                    }
                    function Gy(e, t) {
                        let n = e;
                        if (t.length - n < 1)
                            return null;
                        const i = t[n];
                        if (n += 1,
                            !(i in by))
                            return null;
                        if (t.length - n < 1)
                            return null;
                        const r = t[n];
                        if (n += 1,
                        !Number.isSafeInteger(r) || r < 0 || r >= 180)
                            return null;
                        const a = new eb(i,new Ay(r));
                        if (t.length - n < 9)
                            return null;
                        const s = t[n] | t[n + 1] << 8 | t[n + 2] << 16 | t[n + 3] << 24;
                        n += 4;
                        const o = t[n] | t[n + 1] << 8 | t[n + 2] << 16 | t[n + 3] << 24;
                        n += 4;
                        const l = t[n] | t[n + 1] << 8 | t[n + 2] << 16 | t[n + 3] << 24;
                        n += 4;
                        const c = 3 & t[n]
                            , h = t[n] >> 2 & 3
                            , d = t[n] >> 4 & 3;
                        if (n += 1,
                        c < 1 || c > 4 || h < 1 || h > 4 || d < 1 || d > 4)
                            return null;
                        for (; n < t.length; ) {
                            if (t.length - n < 1)
                                return null;
                            const e = t[n + 0];
                            if (n += 1,
                                !(e in IA))
                                return null;
                            if (t.length - n < 4)
                                return null;
                            const i = t[n + 0] | t[n + 1] << 8 | t[n + 2] << 16 | t[n + 3] << 24;
                            n += 4;
                            for (let r = 0; r < i; ++r) {
                                if (t.length - n < c)
                                    return null;
                                let i = 0;
                                for (let e = 0; e < c; ++e)
                                    i |= t[n + e] << 8 * e;
                                if (i += s,
                                    n += c,
                                t.length - n < h)
                                    return null;
                                let r = 0;
                                for (let e = 0; e < h; ++e)
                                    r |= t[n + e] << 8 * e;
                                if (r += o,
                                    n += h,
                                t.length - n < d)
                                    return null;
                                let u = 0;
                                for (let e = 0; e < d; ++e)
                                    u |= t[n + e] << 8 * e;
                                if (u += l,
                                    n += d,
                                t.length - n < 1)
                                    return null;
                                const p = t[n + 0];
                                if (n += 1,
                                p < 0 || p > 3)
                                    return null;
                                if (t.length - n < 1)
                                    return null;
                                const f = t[n + 0];
                                if (n += 1,
                                    !(f in RA))
                                    return null;
                                if (t.length - n < 1)
                                    return null;
                                const m = t[n + 0];
                                if (n += 1,
                                    !(m in CA))
                                    return null;
                                let g = null;
                                if (Uy.includes(e)) {
                                    if (t.length - n < 2)
                                        return null;
                                    g = t[n + 0] | t[n + 1] << 8,
                                        n += 2
                                }
                                let v = null;
                                if (zy.includes(e)) {
                                    if (t.length - n < 4)
                                        return null;
                                    v = t[n + 0] | t[n + 1] << 8 | t[n + 2] << 16 | t[n + 3] << 24,
                                        n += 4
                                }
                                a.addPart(i, r, u, e, p, f, m, g, v)
                            }
                        }
                        return a
                    }
                    const jy = [[new wn(0,0,0,1), new wn(0,.7071067811865475,0,.7071067811865476), new wn(0,1,0,0), new wn(0,.7071067811865476,0,-.7071067811865475)], [new wn(0,0,1,0), new wn(.7071067811865475,0,.7071067811865476,0), new wn(1,0,0,0), new wn(.7071067811865476,0,-.7071067811865475,0)], [new wn(0,0,-.7071067811865477,.7071067811865475), new wn(.5,.5,-.5,.5), new wn(.7071067811865475,.7071067811865477,0,0), new wn(.5,.5,.5,-.5)], [new wn(0,0,.7071067811865475,.7071067811865476), new wn(.5,-.5,.5,.5), new wn(.7071067811865476,-.7071067811865475,0,0), new wn(.5,-.5,-.5,-.5)], [new wn(.7071067811865475,0,0,.7071067811865476), new wn(.5,.5,.5,.5), new wn(0,.7071067811865476,.7071067811865475,0), new wn(-.5,.5,.5,-.5)], [new wn(-.7071067811865477,0,0,.7071067811865475), new wn(-.5,-.5,.5,.5), new wn(0,-.7071067811865475,.7071067811865477,0), new wn(.5,-.5,.5,-.5)]];
                    function Qy(e, t) {
                        return jy[t][e].clone()
                    }
                    var Yy, qy, Ky, Xy, Zy, Jy = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, $y = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    qy = new WeakMap,
                        Ky = new WeakMap,
                        Yy = new WeakSet,
                        Xy = function() {
                            let e = -1 / 0
                                , t = null;
                            for (const [n,i] of $y(this, Ky, "f")) {
                                const r = By(n).startOffset;
                                if (i.length > 0 && null != r)
                                    for (const n of i) {
                                        if (null == n.startOrder)
                                            throw new Error("Start part has no start order");
                                        n.startOrder >= e && (e = n.startOrder,
                                            t = {
                                                part: n,
                                                startOffset: r
                                            })
                                    }
                            }
                            return null != t ? {
                                x: t.part.x,
                                y: t.part.y,
                                z: t.part.z,
                                rotation: t.part.rotation,
                                rotationAxis: t.part.rotationAxis,
                                startOffset: t.startOffset.clone()
                            } : null
                        }
                        ,
                        Zy = function() {
                            const e = [];
                            e.push(this.environment),
                                e.push($y(this, qy, "f").representation);
                            let t = 1 / 0
                                , n = 1 / 0
                                , i = 1 / 0
                                , r = -1 / 0
                                , a = -1 / 0
                                , s = -1 / 0;
                            for (const [,e] of $y(this, Ky, "f"))
                                for (const o of e)
                                    t = Math.min(o.x, t),
                                        n = Math.min(o.y, n),
                                        i = Math.min(o.z, i),
                                        r = Math.max(o.x, r),
                                        a = Math.max(o.y, a),
                                        s = Math.max(o.z, s);
                            Number.isFinite(t) && Number.isFinite(n) && Number.isFinite(i) && Number.isFinite(r) && Number.isFinite(a) && Number.isFinite(s) || (t = 0,
                                n = 0,
                                i = 0,
                                r = 0,
                                a = 0,
                                s = 0);
                            const o = r - t + 1
                                , l = a - n + 1
                                , c = s - i + 1
                                , h = Math.max(1, Math.min(4, Math.ceil(Math.log2(o + 1) / 8)))
                                , d = Math.max(1, Math.min(4, Math.ceil(Math.log2(l + 1) / 8)))
                                , u = Math.max(1, Math.min(4, Math.ceil(Math.log2(c + 1) / 8)));
                            e.push(255 & t, t >>> 8 & 255, t >>> 16 & 255, t >>> 24 & 255, 255 & n, n >>> 8 & 255, n >>> 16 & 255, n >>> 24 & 255, 255 & i, i >>> 8 & 255, i >>> 16 & 255, i >>> 24 & 255, 255 & (h | d << 2 | u << 4));
                            for (const [r,a] of $y(this, Ky, "f")) {
                                if (r < 0 || r > 255)
                                    throw new Error("Type id is out of range");
                                const s = a.length;
                                e.push(255 & r, 255 & s, s >>> 8 & 255, s >>> 16 & 255, s >>> 24 & 255);
                                for (const s of a) {
                                    const a = s.x - t
                                        , o = s.y - n
                                        , l = s.z - i;
                                    if (1 == h ? e.push(255 & a) : 2 == h ? e.push(255 & a, a >>> 8 & 255) : 3 == h ? e.push(255 & a, a >>> 8 & 255, a >>> 16 & 255) : 4 == h && e.push(255 & a, a >>> 8 & 255, a >>> 16 & 255, a >>> 24 & 255),
                                        1 == d ? e.push(255 & o) : 2 == d ? e.push(255 & o, o >>> 8 & 255) : 3 == d ? e.push(255 & o, o >>> 8 & 255, o >>> 16 & 255) : 4 == d && e.push(255 & o, o >>> 8 & 255, o >>> 16 & 255, o >>> 24 & 255),
                                        1 == u ? e.push(255 & l) : 2 == u ? e.push(255 & l, l >>> 8 & 255) : 3 == u ? e.push(255 & l, l >>> 8 & 255, l >>> 16 & 255) : 4 == u && e.push(255 & l, l >>> 8 & 255, l >>> 16 & 255, l >>> 24 & 255),
                                        e.push(3 & s.rotation, 7 & s.rotationAxis, 255 & s.color),
                                        Uy.includes(r)) {
                                        if (null == s.checkpointOrder)
                                            throw new Error("Checkpoint has no checkpoint order");
                                        e.push(255 & s.checkpointOrder, s.checkpointOrder >>> 8 & 255)
                                    }
                                    if (zy.includes(r)) {
                                        if (null == s.startOrder)
                                            throw new Error("Start has no start order");
                                        e.push(255 & s.startOrder, s.startOrder >>> 8 & 255, s.startOrder >>> 16 & 255, s.startOrder >>> 24 & 255)
                                    }
                                }
                            }
                            return new Uint8Array(e)
                        }
                    ;
                    const eb = class {
                            constructor(e, t) {
                                Yy.add(this),
                                    qy.set(this, void 0),
                                    Ky.set(this, new Map),
                                    this.environment = e,
                                    Jy(this, qy, t.clone(), "f")
                            }
                            get sunDirection() {
                                return $y(this, qy, "f").clone()
                            }
                            set sunDirection(e) {
                                Jy(this, qy, e.clone(), "f")
                            }
                            addPart(e, t, n, i, r, a, s, o, l) {
                                const c = {
                                    x: e,
                                    y: t,
                                    z: n,
                                    rotation: r,
                                    rotationAxis: a,
                                    color: s,
                                    checkpointOrder: o,
                                    startOrder: l
                                }
                                    , h = $y(this, Ky, "f").get(i);
                                null != h ? h.push(c) : $y(this, Ky, "f").set(i, [c])
                            }
                            forEachPart(e) {
                                for (const [t,n] of $y(this, Ky, "f"))
                                    for (const i of n)
                                        e(i.x, i.y, i.z, t, i.rotation, i.rotationAxis, i.color, i.checkpointOrder, i.startOrder)
                            }
                            getId() {
                                return (0,
                                    ly.sha256)($y(this, Yy, "m", Zy).call(this))
                            }
                            getBounds() {
                                let e = 1 / 0
                                    , t = 1 / 0
                                    , n = -1 / 0
                                    , i = -1 / 0;
                                return this.forEachPart(( (r, a, s) => {
                                        e = Math.min(r, e),
                                            t = Math.min(s, t),
                                            n = Math.max(r, n),
                                            i = Math.max(s, i)
                                    }
                                )),
                                    Number.isFinite(e) && Number.isFinite(t) && Number.isFinite(n) && Number.isFinite(i) ? {
                                        min: new jt(e,t),
                                        max: new jt(n,i)
                                    } : {
                                        min: new jt,
                                        max: new jt
                                    }
                            }
                            hasStartingPoint() {
                                return null != $y(this, Yy, "m", Xy).call(this)
                            }
                            getStartTransform() {
                                const e = $y(this, Yy, "m", Xy).call(this);
                                if (null != e) {
                                    const t = Qy(e.rotation, e.rotationAxis).multiply((new wn).setFromEuler(new ai(0,Math.PI,0)))
                                        , n = e.startOffset;
                                    return n.applyQuaternion(t),
                                        {
                                            position: new An(e.x * yb.partSize + n.x,e.y * yb.partSize + n.y,e.z * yb.partSize + n.z),
                                            quaternion: t
                                        }
                                }
                                return null
                            }
                            toSaveString() {
                                const e = $y(this, Yy, "m", Zy).call(this)
                                    , t = new Yg.Deflate({
                                    level: 9,
                                    windowBits: 9,
                                    memLevel: 9
                                });
                                t.push(e, !0);
                                const n = dy(t.result)
                                    , i = new Yg.Deflate({
                                    level: 9,
                                    windowBits: 15,
                                    memLevel: 9
                                });
                                return i.push(n, !0),
                                    dy(i.result)
                            }
                            toExportString(e) {
                                const t = (new TextEncoder).encode(e.name);
                                let n, i;
                                null != e.author ? (i = (new TextEncoder).encode(e.author),
                                    n = i.length) : (i = null,
                                    n = 0);
                                const r = new Uint8Array(1 + t.length + 1 + n);
                                r[0] = t.length,
                                    r.set(t, 1),
                                    r[1 + t.length] = n,
                                null != i && r.set(i, 1 + t.length + 1);
                                const a = $y(this, Yy, "m", Zy).call(this)
                                    , s = new Yg.Deflate({
                                    level: 9,
                                    windowBits: 9,
                                    memLevel: 9
                                });
                                s.push(r, !1),
                                    s.push(a, !0);
                                const o = dy(s.result)
                                    , l = new Yg.Deflate({
                                    level: 9,
                                    windowBits: 15,
                                    memLevel: 9
                                });
                                return l.push(o, !0),
                                "PolyTrack1" + dy(l.result)
                            }
                            static fromSaveString(e) {
                                const t = function(e) {
                                    const t = uy(e);
                                    if (null == t)
                                        return null;
                                    const n = new Yg.Inflate({
                                        to: "string"
                                    });
                                    if (n.push(t, !0),
                                        n.err)
                                        return null;
                                    const i = n.result;
                                    if ("string" != typeof i)
                                        return null;
                                    const r = uy(i);
                                    if (null == r)
                                        return null;
                                    const a = new Yg.Inflate;
                                    if (a.push(r, !0),
                                        a.err)
                                        return null;
                                    const s = a.result;
                                    return s instanceof Uint8Array ? Gy(0, s) : null
                                }(e);
                                if (null != t)
                                    return t;
                                const n = Vy(e);
                                if (null != n)
                                    return n;
                                const i = Hy(e);
                                if (null != i)
                                    return i;
                                const r = Wy(e);
                                if (null != r)
                                    return r;
                                const a = Oy(e);
                                return null != a ? a : null
                            }
                            static fromExportString(e) {
                                const t = e.replace(/\s+/g, "")
                                    , n = function(e) {
                                    const t = "PolyTrack1";
                                    if (!e.startsWith(t))
                                        return null;
                                    const n = uy(e.substring(10));
                                    if (null == n)
                                        return null;
                                    const i = new Yg.Inflate({
                                        to: "string"
                                    });
                                    if (i.push(n, !0),
                                        i.err)
                                        return null;
                                    const r = i.result;
                                    if ("string" != typeof r)
                                        return null;
                                    const a = uy(r);
                                    if (null == a)
                                        return null;
                                    const s = new Yg.Inflate;
                                    if (s.push(a, !0),
                                        s.err)
                                        return null;
                                    const o = s.result;
                                    if (!(o instanceof Uint8Array))
                                        return null;
                                    const l = o[0];
                                    if (o.length < 1 + l)
                                        return null;
                                    const c = new TextDecoder("utf-8").decode(o.subarray(1, 1 + l))
                                        , h = o[1 + l];
                                    if (o.length < 1 + l + 1 + h)
                                        return null;
                                    let d;
                                    d = h > 0 ? new TextDecoder("utf-8").decode(o.subarray(1 + l + 1, 1 + l + 1 + h)) : null;
                                    const u = Gy(1 + l + 1 + h, o);
                                    return null == u ? null : {
                                        trackMetadata: {
                                            name: c,
                                            author: d
                                        },
                                        trackData: u
                                    }
                                }(t);
                                if (null != n)
                                    return n;
                                const i = function(e) {
                                    if (!e.startsWith("v3"))
                                        return null;
                                    const t = uy(e.substring(2, 4));
                                    if (null == t)
                                        return null;
                                    if (1 != t.length)
                                        return null;
                                    const n = t[0]
                                        , i = uy(e.substring(4, 4 + n));
                                    if (null == i)
                                        return null;
                                    let r;
                                    try {
                                        r = new TextDecoder("utf-8").decode(i)
                                    } catch (e) {
                                        return null
                                    }
                                    const a = Vy(e.substring(4 + n));
                                    return null == a ? null : {
                                        trackMetadata: {
                                            name: r,
                                            author: null
                                        },
                                        trackData: a
                                    }
                                }(t);
                                if (null != i)
                                    return i;
                                const r = function(e) {
                                    if (!e.startsWith("v2"))
                                        return null;
                                    const t = uy(e.substring(2, 4));
                                    if (null == t)
                                        return null;
                                    if (1 != t.length)
                                        return null;
                                    const n = t[0]
                                        , i = Math.ceil(n / 3 * 4)
                                        , r = uy(e.substring(4, 4 + i));
                                    if (null == r)
                                        return null;
                                    let a;
                                    try {
                                        a = new TextDecoder("utf-8").decode(r)
                                    } catch (e) {
                                        return null
                                    }
                                    const s = Hy(e.substring(4 + i));
                                    return null == s ? null : {
                                        trackMetadata: {
                                            name: a,
                                            author: null
                                        },
                                        trackData: s
                                    }
                                }(t);
                                if (null != r)
                                    return r;
                                const a = function(e) {
                                    if (!e.startsWith("v1n"))
                                        return null;
                                    const t = qg(e.substring(3, 5));
                                    if (null == t)
                                        return null;
                                    if (1 != t.length)
                                        return null;
                                    const n = t[0]
                                        , i = e.substring(5, 5 + n);
                                    let r;
                                    try {
                                        r = decodeURIComponent(i)
                                    } catch (e) {
                                        return console.error(e),
                                            null
                                    }
                                    const a = Wy(e.substring(5 + n));
                                    return null == a ? null : {
                                        trackMetadata: {
                                            name: r,
                                            author: null
                                        },
                                        trackData: a
                                    }
                                }(t);
                                if (null != a)
                                    return a;
                                const s = Fy(e);
                                return null != s ? s : null
                            }
                            createThumbnail() {
                                let e = 1 / 0
                                    , t = 1 / 0
                                    , n = -1 / 0
                                    , i = -1 / 0;
                                this.forEachPart(( (r, a, s, o, l, c) => {
                                        By(o).tiles.rotated(l, c).forEach(( (a, o, l) => {
                                                e = Math.min(e, Math.floor((r + a - 2) / 4)),
                                                    t = Math.min(t, Math.floor((s + l - 2) / 4)),
                                                    n = Math.max(n, Math.floor((r + a - 2) / 4)),
                                                    i = Math.max(i, Math.floor((s + l - 2) / 4))
                                            }
                                        ))
                                    }
                                )),
                                Number.isFinite(e) && Number.isFinite(t) && Number.isFinite(n) && Number.isFinite(i) || (e = 0,
                                    t = 0,
                                    n = 0,
                                    i = 0);
                                const r = 10
                                    , a = n - e + 1;
                                a <= r && (n += Math.ceil((r - a) / 2),
                                    e -= Math.ceil((r - a) / 2));
                                const s = i - t + 1;
                                s <= r && (i += Math.ceil((r - s) / 2),
                                    t -= Math.ceil((r - s) / 2));
                                const o = document.createElement("canvas");
                                o.width = Math.min(1024, n - e + 1),
                                    o.height = Math.min(1024, i - t + 1);
                                const l = o.getContext("2d");
                                if (null == l)
                                    throw new Error("Failed to get canvas context");
                                const c = l.createImageData(o.width, o.height)
                                    , h = []
                                    , d = []
                                    , u = [];
                                let p, f, m;
                                switch (this.environment) {
                                    case by.Summer:
                                        p = 255,
                                            f = 255,
                                            m = 255;
                                        break;
                                    case by.Winter:
                                        p = 190,
                                            f = 216,
                                            m = 247;
                                        break;
                                    case by.Desert:
                                        p = 237,
                                            f = 226,
                                            m = 175
                                }
                                this.forEachPart(( (n, i, r, a, s, l) => {
                                        const g = By(a);
                                        g.tiles.rotated(s, l).forEach(( (i, a, s) => {
                                                const l = Math.floor((n + i - 2) / 4) - e
                                                    , v = Math.floor((r + s - 2) / 4) - t
                                                    , w = 4 * (l + v * o.width);
                                                c.data[w + 0] = p,
                                                    c.data[w + 1] = f,
                                                    c.data[w + 2] = m,
                                                    c.data[w + 3] = 255,
                                                    null != g.startOffset ? d.push([l, v]) : null != g.detector && g.detector.type == Sy.Checkpoint ? h.push([l, v]) : null != g.detector && g.detector.type == Sy.Finish && u.push([l, v])
                                            }
                                        ))
                                    }
                                ));
                                for (const [e,t] of h)
                                    c.data[4 * (e + t * o.width) + 0] = 226,
                                        c.data[4 * (e + t * o.width) + 1] = 192,
                                        c.data[4 * (e + t * o.width) + 2] = 38,
                                        c.data[4 * (e + t * o.width) + 3] = 255;
                                for (const [e,t] of d)
                                    c.data[4 * (e + t * o.width) + 0] = 51,
                                        c.data[4 * (e + t * o.width) + 1] = 140,
                                        c.data[4 * (e + t * o.width) + 2] = 224,
                                        c.data[4 * (e + t * o.width) + 3] = 255;
                                for (const [e,t] of u)
                                    c.data[4 * (e + t * o.width) + 0] = 209,
                                        c.data[4 * (e + t * o.width) + 1] = 41,
                                        c.data[4 * (e + t * o.width) + 2] = 41,
                                        c.data[4 * (e + t * o.width) + 3] = 255;
                                return l.putImageData(c, 0, 0),
                                    o
                            }
                        }
                    ;
                    var tb, nb, ib, rb, ab, sb, ob, lb, cb, hb, db, ub, pb, fb, mb, gb = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, vb = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    class wb {
                        constructor(e, t, n, i, r, a, s, o, l, c) {
                            if (this.checkpointOrder = null,
                                this.startOrder = null,
                                this.x = e,
                                this.y = t,
                                this.z = n,
                                this.rotation = i,
                                this.rotationAxis = r,
                                this.color = a,
                                this.type = s,
                                this.matrix = o,
                                this.checkpointOrder = l,
                                this.startOrder = c,
                            null != s.configuration.detector && s.configuration.detector.type == Sy.Checkpoint) {
                                if (null == l)
                                    throw new Error("Checkpoint has no checkpoint order")
                            } else if (null != l)
                                throw new Error("Non-checkpoint has checkpoint order");
                            if (null != s.configuration.startOffset && null == c)
                                throw new Error("Start part has no start order");
                            if (null == s.configuration.startOffset && null != c)
                                throw new Error("Non-start part has start order")
                        }
                    }
                    class Ab {
                        constructor(e, t, n) {
                            tb.add(this),
                                nb.set(this, void 0),
                                ib.set(this, void 0),
                                rb.set(this, void 0),
                                this.environment = by.Summer,
                                ab.set(this, new Ay),
                                sb.set(this, []),
                                ob.set(this, new Map),
                                lb.set(this, new Map),
                                cb.set(this, {
                                    min: new jt(0,0),
                                    max: new jt(0,0)
                                }),
                                hb.set(this, null),
                                db.set(this, []),
                                gb(this, nb, e, "f"),
                                gb(this, ib, t, "f"),
                                gb(this, rb, n, "f")
                        }
                        get sunDirection() {
                            return vb(this, ab, "f")
                        }
                        set sunDirection(e) {
                            gb(this, ab, e.clone(), "f")
                        }
                        getID() {
                            return vb(this, hb, "f")
                        }
                        clear() {
                            gb(this, hb, null, "f"),
                                vb(this, sb, "f").length = 0,
                                vb(this, ob, "f").clear(),
                                vb(this, lb, "f").clear(),
                                vb(this, tb, "m", ub).call(this)
                        }
                        getPartsAt(e, t, n) {
                            const i = vb(this, ob, "f").get(e.toString() + "|" + t.toString() + "|" + n.toString());
                            return null == i ? [] : i.map((e => ({
                                id: e.type.configuration.id,
                                x: e.x,
                                y: e.y,
                                z: e.z,
                                rotation: e.rotation,
                                rotationAxis: e.rotationAxis,
                                color: e.color
                            })))
                        }
                        setPart(e, t, n, i, r, a, s, o, l) {
                            const c = vb(this, rb, "f").getPart(i);
                            if (s != CA.Default && !c.colors.has(s))
                                throw new Error("Track part color does not exist");
                            const h = Qy(r, a)
                                , d = new An(e * Ab.partSize,t * Ab.partSize,n * Ab.partSize)
                                , u = (new Kn).compose(d, h, new An(1,1,1))
                                , p = new wb(e,t,n,r,a,s,c,u,o,l);
                            vb(this, sb, "f").push(p);
                            c.configuration.tiles.rotated(r, a).forEach(( (i, r, a) => {
                                    const s = (e + i).toString() + "|" + (t + r).toString() + "|" + (n + a).toString();
                                    if (t + r < 0)
                                        throw new Error("Track part below ground");
                                    {
                                        const e = vb(this, ob, "f").get(s);
                                        null == e ? vb(this, ob, "f").set(s, [p]) : e.push(p)
                                    }
                                }
                            ));
                            const f = vb(this, lb, "f").get(i);
                            null == f ? vb(this, lb, "f").set(i, [p]) : f.push(p)
                        }
                        deletePartsAt(e, t, n) {
                            const i = vb(this, ob, "f").get(e.toString() + "|" + t.toString() + "|" + n.toString());
                            if (null == i)
                                return !1;
                            for (const e of i)
                                vb(this, tb, "m", fb).call(this, e);
                            return !0
                        }
                        deleteSpecificPart(e, t, n, i, r, a) {
                            for (const s of vb(this, sb, "f"))
                                if (s.type.configuration.id == e && s.x == t && s.y == n && s.z == i && s.rotation == r && s.rotationAxis == a)
                                    return vb(this, tb, "m", fb).call(this, s),
                                        !0;
                            return !1
                        }
                        getBounds() {
                            return vb(this, cb, "f")
                        }
                        shortRaycast(e) {
                            const t = new An(Math.floor(e.ray.origin.x / Ab.partSize),Math.floor(e.ray.origin.y / Ab.partSize),Math.floor(e.ray.origin.z / Ab.partSize))
                                , n = new Set;
                            for (let e = -1; e <= 0; e++)
                                for (let i = -1; i <= 0; i++)
                                    for (let r = -1; r <= 0; r++) {
                                        const a = vb(this, tb, "m", pb).call(this, t.x + e, t.y + i, t.z + r);
                                        for (const e of a)
                                            n.add(e)
                                    }
                            let i = null;
                            for (const t of n) {
                                let n = t.color;
                                n == CA.Default && (n = CA.Summer);
                                const r = t.type.colors.get(n);
                                if (null == r)
                                    throw new Error("Track part is not loaded yet");
                                if (null == i) {
                                    r.matrixWorld.copy(t.matrix);
                                    const n = e.intersectObject(r, !0);
                                    n.length > 0 && (i = n[0])
                                }
                            }
                            return i
                        }
                        generateMeshes() {
                            vb(this, tb, "m", ub).call(this);
                            const e = vb(this, ab, "f").getSunPosition()
                                , t = new pn(e.x,e.y,e.z,0);
                            let n, i = null;
                            if (vb(this, ib, "f").getSettingBoolean(Jo.TrackShadowEnabled))
                                switch (this.environment) {
                                    case by.Summer:
                                        i = new Wi(1192238);
                                        break;
                                    case by.Winter:
                                        i = new Wi(4223411);
                                        break;
                                    case by.Desert:
                                        i = new Wi(3883831)
                                }
                            switch (this.environment) {
                                case by.Summer:
                                    n = CA.Summer;
                                    break;
                                case by.Winter:
                                    n = CA.Winter;
                                    break;
                                case by.Desert:
                                    n = CA.Desert
                            }
                            for (const e of vb(this, rb, "f").getAllParts())
                                for (const [r,a] of e.colors) {
                                    const s = [];
                                    for (const t of vb(this, sb, "f")) {
                                        let i = t.color;
                                        i == CA.Default && (i = n),
                                        t.type == e && i == r && s.push(t)
                                    }
                                    if (s.length > 0) {
                                        if (null == a)
                                            throw new Error("Mesh is not loaded");
                                        const e = new ua(a.geometry,a.material,s.length);
                                        e.frustumCulled = !1,
                                            e.receiveShadow = !0;
                                        for (let t = 0; t < s.length; ++t)
                                            e.setMatrixAt(t, s[t].matrix);
                                        if (vb(this, nb, "f").scene.add(e),
                                            vb(this, db, "f").push(e),
                                        null != i) {
                                            const n = new oy(e,i);
                                            n.update(new ga(new An(0,1,0),0), t),
                                                vb(this, nb, "f").scene.add(n),
                                                vb(this, db, "f").push(n)
                                        }
                                    }
                                }
                            vb(this, tb, "m", mb).call(this)
                        }
                        getCheckpoints() {
                            let e = [];
                            const t = vb(this, rb, "f").getPartTypesWithDetector(Sy.Checkpoint);
                            for (const n of t) {
                                const t = vb(this, lb, "f").get(n);
                                null != t && (e = e.concat(t))
                            }
                            return e.map((e => {
                                    if (null == e.checkpointOrder)
                                        throw new Error("Checkpoint has no checkpoint order");
                                    if (null == e.type.configuration.detector)
                                        throw new Error("Checkpoint has no detector");
                                    return {
                                        x: e.x,
                                        y: e.y,
                                        z: e.z,
                                        rotation: e.rotation,
                                        rotationAxis: e.rotationAxis,
                                        type: e.type.configuration.id,
                                        checkpointOrder: e.checkpointOrder,
                                        detector: e.type.configuration.detector
                                    }
                                }
                            ))
                        }
                        getCheckpointOrders() {
                            let e = [];
                            const t = vb(this, rb, "f").getPartTypesWithDetector(Sy.Checkpoint);
                            for (const n of t) {
                                const t = vb(this, lb, "f").get(n);
                                null != t && (e = e.concat(t))
                            }
                            return e.map((e => {
                                    if (null == e.checkpointOrder)
                                        throw new Error("Checkpoint has no checkpoint order");
                                    if (null == e.type.configuration.detector)
                                        throw new Error("Checkpoint has no detector");
                                    return e.checkpointOrder
                                }
                            ))
                        }
                        getTotalNumberOfCheckpointIndices() {
                            let e = [];
                            const t = vb(this, rb, "f").getPartTypesWithDetector(Sy.Checkpoint);
                            for (const n of t) {
                                const t = vb(this, lb, "f").get(n);
                                null != t && (e = e.concat(t))
                            }
                            return e.map((e => e.checkpointOrder)).filter(( (e, t, n) => n.indexOf(e) == t)).length
                        }
                        getStart() {
                            let e = -1 / 0
                                , t = null;
                            for (const [n,i] of vb(this, lb, "f")) {
                                const r = vb(this, rb, "f").getPartStartOffset(n);
                                if (i.length > 0 && null != r)
                                    for (const n of i) {
                                        if (null == n.startOrder)
                                            throw new Error("Start part has no start order");
                                        n.startOrder >= e && (e = n.startOrder,
                                            t = {
                                                part: n,
                                                startOffset: r
                                            })
                                    }
                            }
                            return null != t ? {
                                x: t.part.x,
                                y: t.part.y,
                                z: t.part.z,
                                rotation: t.part.rotation,
                                rotationAxis: t.part.rotationAxis,
                                startOffset: t.startOffset
                            } : null
                        }
                        getStartTransform() {
                            const e = this.getStart();
                            if (null != e) {
                                const t = Qy(e.rotation, e.rotationAxis).multiply((new wn).setFromEuler(new ai(0,Math.PI,0)))
                                    , n = e.startOffset;
                                return n.applyQuaternion(t),
                                    {
                                        position: new An(e.x * Ab.partSize + n.x,e.y * Ab.partSize + n.y,e.z * Ab.partSize + n.z),
                                        quaternion: t
                                    }
                            }
                            return null
                        }
                        getNextStartOrder() {
                            let e = 0;
                            for (const [t,n] of vb(this, lb, "f")) {
                                const i = vb(this, rb, "f").getPartStartOffset(t);
                                if (n.length > 0 && null != i)
                                    for (const t of n) {
                                        if (null == t.startOrder)
                                            throw new Error("Start part has no start order");
                                        e = Math.max(e, t.startOrder + 1)
                                    }
                            }
                            return e
                        }
                        getTrackData() {
                            const e = new eb(this.environment,vb(this, ab, "f"));
                            for (const t of vb(this, sb, "f"))
                                e.addPart(t.x, t.y, t.z, t.type.configuration.id, t.rotation, t.rotationAxis, t.color, t.checkpointOrder, t.startOrder);
                            return e
                        }
                        loadTrackData(e, t=!0) {
                            return this.clear(),
                                gb(this, hb, t ? e.getId() : null, "f"),
                                this.environment = e.environment,
                                this.sunDirection = e.sunDirection.clone(),
                                e.forEachPart(( (e, t, n, i, r, a, s, o, l) => {
                                        this.setPart(e, t, n, i, r, a, s, o, l)
                                    }
                                )),
                                !0
                        }
                    }
                    nb = new WeakMap,
                        ib = new WeakMap,
                        rb = new WeakMap,
                        ab = new WeakMap,
                        sb = new WeakMap,
                        ob = new WeakMap,
                        lb = new WeakMap,
                        cb = new WeakMap,
                        hb = new WeakMap,
                        db = new WeakMap,
                        tb = new WeakSet,
                        ub = function() {
                            for (const e of vb(this, db, "f"))
                                vb(this, nb, "f").scene.remove(e);
                            vb(this, db, "f").length = 0
                        }
                        ,
                        pb = function(e, t, n) {
                            var i;
                            return null !== (i = vb(this, ob, "f").get(e.toString() + "|" + t.toString() + "|" + n.toString())) && void 0 !== i ? i : []
                        }
                        ,
                        fb = function(e) {
                            const t = vb(this, sb, "f").indexOf(e);
                            if (!(t >= 0))
                                throw new Error("Track part missing from parts list");
                            vb(this, sb, "f").splice(t, 1);
                            e.type.configuration.tiles.rotated(e.rotation, e.rotationAxis).forEach(( (t, n, i) => {
                                    const r = (e.x + t).toString() + "|" + (e.y + n).toString() + "|" + (e.z + i).toString()
                                        , a = vb(this, ob, "f").get(r);
                                    if (null == a)
                                        throw new Error("Track part section missing");
                                    {
                                        const t = a.indexOf(e);
                                        if (!(t >= 0))
                                            throw new Error("Track part missing from parts by position map");
                                        a.splice(t, 1),
                                        0 == a.length && vb(this, ob, "f").delete(r)
                                    }
                                }
                            ));
                            const n = vb(this, lb, "f").get(e.type.configuration.id);
                            if (null == n)
                                throw new Error("Track part type is missing from parts by type map");
                            for (let t = 0; t < n.length; ++t) {
                                if (n[t] == e) {
                                    n.splice(t, 1);
                                    break
                                }
                                if (t == n.length - 1)
                                    throw new Error("Track part is missing from parts by type map")
                            }
                        }
                        ,
                        mb = function() {
                            let e = 1 / 0
                                , t = 1 / 0
                                , n = -1 / 0
                                , i = -1 / 0;
                            for (const r of vb(this, sb, "f"))
                                e = Math.min(r.x, e),
                                    t = Math.min(r.z, t),
                                    n = Math.max(r.x, n),
                                    i = Math.max(r.z, i);
                            Number.isFinite(e) && Number.isFinite(t) && Number.isFinite(n) && Number.isFinite(i) ? gb(this, cb, {
                                min: new jt(e,t),
                                max: new jt(n,i)
                            }, "f") : gb(this, cb, {
                                min: new jt,
                                max: new jt
                            }, "f")
                        }
                        ,
                        Ab.partSize = 5;
                    const yb = Ab;
                    var bb, xb, kb, Eb, Sb, Mb = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, Tb = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    class Cb {
                        constructor(e) {
                            xb.set(this, void 0),
                                kb.set(this, []),
                                Eb.set(this, []),
                                Mb(this, xb, e, "f")
                        }
                        dispose() {
                            for (const e of Tb(this, kb, "f")) {
                                if (Array.isArray(e.material))
                                    for (const t of e.material)
                                        t.dispose();
                                else
                                    e.material.dispose();
                                e.geometry.dispose(),
                                    Tb(this, xb, "f").scene.remove(e)
                            }
                            Tb(this, kb, "f").length = 0
                        }
                        refresh(e) {
                            const t = e.getCheckpoints();
                            let n = !1;
                            if (t.length == Tb(this, Eb, "f").length)
                                for (let e = 0; e < t.length; e++) {
                                    const i = t[e]
                                        , r = Tb(this, Eb, "f")[e];
                                    if (i.x != r.x || i.y != r.y || i.z != r.z || i.rotation != r.rotation || i.rotationAxis != r.rotationAxis || i.type != r.type || i.checkpointOrder != r.checkpointOrder) {
                                        n = !0;
                                        break
                                    }
                                }
                            else
                                n = !0;
                            if (n) {
                                this.dispose(),
                                    Mb(this, Eb, t, "f");
                                const e = new ji({
                                    color: 16777215
                                });
                                for (const n of t) {
                                    if (null == Tb(bb, bb, "f", Sb))
                                        throw new Error("Font is not loaded yet");
                                    const t = Qy(n.rotation, n.rotationAxis)
                                        , i = new An(...n.detector.center).add(new An(0,-1.3,0)).applyQuaternion(t);
                                    i.add(new An(n.x * yb.partSize,n.y * yb.partSize,n.z * yb.partSize));
                                    const r = Tb(bb, bb, "f", Sb).generateShapes((n.checkpointOrder + 1).toString(), 4)
                                        , a = new Bs(r);
                                    a.computeBoundingBox();
                                    const s = a.boundingBox;
                                    if (null == s)
                                        throw new Error("Bounding box is null");
                                    const o = -.5 * (s.max.x - s.min.x);
                                    a.translate(o, 0, 0);
                                    const l = new wr(a,e);
                                    l.position.copy(i),
                                        l.quaternion.copy(t),
                                        Tb(this, xb, "f").scene.add(l),
                                        Tb(this, kb, "f").push(l);
                                    const c = new wr(a,e);
                                    c.position.copy(i),
                                        c.quaternion.copy(t).multiply((new wn).setFromEuler(new ai(0,Math.PI,0))),
                                        Tb(this, xb, "f").scene.add(c),
                                        Tb(this, kb, "f").push(c)
                                }
                            }
                        }
                        static initResources(e) {
                            e.addResource();
                            (new ry).load("forced_square.json", (t => {
                                    Mb(this, bb, t, "f", Sb),
                                        e.loadedResource()
                                }
                            ))
                        }
                    }
                    bb = Cb,
                        xb = new WeakMap,
                        kb = new WeakMap,
                        Eb = new WeakMap,
                        Sb = {
                            value: null
                        };
                    const _b = Cb;
                    var Ib = n(8909)
                        , Pb = {};
                    Pb.styleTagTransform = u(),
                        Pb.setAttributes = l(),
                        Pb.insert = s().bind(null, "head"),
                        Pb.domAPI = r(),
                        Pb.insertStyleElement = h();
                    t()(Ib.A, Pb);
                    Ib.A && Ib.A.locals && Ib.A.locals;
                    var Rb, Lb, Nb, Db, Bb, Ub, zb, Ob, Fb, Wb, Hb = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, Vb = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    Lb = new WeakMap,
                        Nb = new WeakMap,
                        Db = new WeakMap,
                        Bb = new WeakMap,
                        Ub = new WeakMap,
                        zb = new WeakMap,
                        Ob = new WeakMap,
                        Rb = new WeakSet,
                        Fb = function() {
                            Vb(this, Ub, "f").textContent = Vb(this, Nb, "f").get("Checkpoint order") + ": " + (this.checkpointOrder + 1).toString()
                        }
                        ,
                        Wb = function(e) {
                            const t = e.getCheckpointOrders()
                                , n = new Set;
                            for (const e of t)
                                n.add(e);
                            for (let e = 0; e < 65535; e++)
                                if (!n.has(e))
                                    return e;
                            return 65535
                        }
                    ;
                    const Gb = class {
                            constructor(e, t, n, i) {
                                Rb.add(this),
                                    Lb.set(this, void 0),
                                    Nb.set(this, void 0),
                                    Db.set(this, void 0),
                                    Bb.set(this, void 0),
                                    Ub.set(this, void 0),
                                    zb.set(this, 0),
                                    Ob.set(this, void 0),
                                    Hb(this, Lb, e, "f"),
                                    Hb(this, Nb, t, "f"),
                                    Hb(this, Db, i, "f"),
                                    Hb(this, Bb, document.createElement("div"), "f"),
                                    Vb(this, Bb, "f").className = "hidden",
                                    e.appendChild(Vb(this, Bb, "f")),
                                    Vb(this, Db, "f").addChangeListener(Hb(this, Ob, (e => {
                                            e ? Vb(this, Bb, "f").classList.add("touch") : Vb(this, Bb, "f").classList.remove("touch")
                                        }
                                    ), "f"));
                                const r = document.createElement("div");
                                r.className = "buttons",
                                    Vb(this, Bb, "f").appendChild(r);
                                const a = document.createElement("button");
                                a.addEventListener("click", ( () => {
                                        n.playUIClick(),
                                            this.checkpointOrder++
                                    }
                                )),
                                    r.appendChild(a);
                                const s = document.createElement("img");
                                s.src = "images/arrow_up.svg",
                                    a.appendChild(s);
                                const o = document.createElement("button");
                                o.addEventListener("click", ( () => {
                                        n.playUIClick(),
                                            this.checkpointOrder--
                                    }
                                )),
                                    r.appendChild(o);
                                const l = document.createElement("img");
                                l.src = "images/arrow_down.svg",
                                    o.appendChild(l),
                                    Hb(this, Ub, document.createElement("p"), "f"),
                                    Vb(this, Bb, "f").appendChild(Vb(this, Ub, "f")),
                                    Vb(this, Rb, "m", Fb).call(this)
                            }
                            dispose() {
                                Vb(this, Lb, "f").removeChild(Vb(this, Bb, "f")),
                                    Vb(this, Db, "f").removeChangeListener(Vb(this, Ob, "f"))
                            }
                            hide() {
                                Vb(this, Bb, "f").classList.add("hidden"),
                                    Vb(this, Bb, "f").classList.remove("editor-checkpoint-order")
                            }
                            show() {
                                Vb(this, Bb, "f").classList.remove("hidden"),
                                    Vb(this, Bb, "f").classList.add("editor-checkpoint-order")
                            }
                            reset() {
                                this.checkpointOrder = 0
                            }
                            get checkpointOrder() {
                                return Vb(this, zb, "f")
                            }
                            set checkpointOrder(e) {
                                Hb(this, zb, Math.max(0, Math.min(65535, e)), "f"),
                                    Vb(this, Rb, "m", Fb).call(this)
                            }
                            setFromExistingCheckpoints(e) {
                                this.checkpointOrder = Vb(this, Rb, "m", Wb).call(this, e)
                            }
                        }
                    ;
                    var jb = n(5007)
                        , Qb = {};
                    Qb.styleTagTransform = u(),
                        Qb.setAttributes = l(),
                        Qb.insert = s().bind(null, "head"),
                        Qb.domAPI = r(),
                        Qb.insertStyleElement = h();
                    t()(jb.A, Qb);
                    jb.A && jb.A.locals && jb.A.locals;
                    var Yb, qb, Kb, Xb, Zb, Jb, $b, ex, tx, nx = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, ix = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    Yb = new WeakMap,
                        qb = new WeakMap,
                        Kb = new WeakMap,
                        Xb = new WeakMap,
                        Zb = new WeakMap,
                        Jb = new WeakMap,
                        $b = new WeakMap,
                        ex = new WeakMap,
                        tx = new WeakMap;
                    const rx = class {
                            constructor(e, t, n, i, r) {
                                Yb.set(this, void 0),
                                    qb.set(this, void 0),
                                    Kb.set(this, void 0),
                                    Xb.set(this, void 0),
                                    Zb.set(this, void 0),
                                    Jb.set(this, void 0),
                                    $b.set(this, !1),
                                    ex.set(this, !1),
                                    tx.set(this, void 0),
                                    nx(this, Yb, e, "f"),
                                    nx(this, qb, t, "f"),
                                    nx(this, Kb, n, "f"),
                                    nx(this, Xb, document.createElement("div"), "f"),
                                    ix(this, Xb, "f").className = "editor-height-selector",
                                    e.appendChild(ix(this, Xb, "f")),
                                    ix(this, Kb, "f").addChangeListener(nx(this, Jb, (e => {
                                            e ? ix(this, Xb, "f").classList.add("touch") : ix(this, Xb, "f").classList.remove("touch")
                                        }
                                    ), "f")),
                                    nx(this, Zb, document.createElement("p"), "f"),
                                    ix(this, Xb, "f").appendChild(ix(this, Zb, "f"));
                                const a = document.createElement("div");
                                a.className = "buttons",
                                    ix(this, Xb, "f").appendChild(a);
                                const s = document.createElement("button");
                                s.addEventListener("pointerdown", ( () => {
                                        if (i(),
                                            !ix(this, $b, "f")) {
                                            nx(this, $b, !0, "f");
                                            const e = () => {
                                                    ix(this, $b, "f") && (i(),
                                                        setTimeout(e, 50))
                                                }
                                            ;
                                            setTimeout(e, 500)
                                        }
                                    }
                                )),
                                    a.appendChild(s);
                                const o = document.createElement("img");
                                o.src = "images/arrow_up.svg",
                                    s.appendChild(o);
                                const l = document.createElement("button");
                                l.addEventListener("pointerdown", ( () => {
                                        if (r(),
                                            !ix(this, ex, "f")) {
                                            nx(this, ex, !0, "f");
                                            const e = () => {
                                                    ix(this, ex, "f") && (r(),
                                                        setTimeout(e, 50))
                                                }
                                            ;
                                            setTimeout(e, 500)
                                        }
                                    }
                                )),
                                    a.appendChild(l);
                                const c = document.createElement("img");
                                c.src = "images/arrow_down.svg",
                                    l.appendChild(c),
                                    nx(this, tx, ( () => {
                                            nx(this, $b, !1, "f"),
                                                nx(this, ex, !1, "f")
                                        }
                                    ), "f"),
                                    window.addEventListener("pointerup", ix(this, tx, "f"))
                            }
                            refresh(e) {
                                ix(this, Zb, "f").textContent = ix(this, qb, "f").get("Height") + ": " + e.toString()
                            }
                            dispose() {
                                ix(this, Yb, "f").removeChild(ix(this, Xb, "f")),
                                    ix(this, Kb, "f").removeChangeListener(ix(this, Jb, "f")),
                                    window.removeEventListener("pointerup", ix(this, tx, "f"))
                            }
                        }
                    ;
                    var ax;
                    !function(e) {
                        e[e.VehicleAccelerate = 0] = "VehicleAccelerate",
                            e[e.VehicleTurnRight = 1] = "VehicleTurnRight",
                            e[e.VehicleBrake = 2] = "VehicleBrake",
                            e[e.VehicleTurnLeft = 3] = "VehicleTurnLeft",
                            e[e.VehicleCheckpointReset = 4] = "VehicleCheckpointReset",
                            e[e.VehicleStartReset = 5] = "VehicleStartReset",
                            e[e.VehicleCockpitCamera = 6] = "VehicleCockpitCamera",
                            e[e.ToggleUI = 7] = "ToggleUI",
                            e[e.Pause = 8] = "Pause",
                            e[e.EditorRotatePart = 9] = "EditorRotatePart",
                            e[e.EditorHeightModifier = 10] = "EditorHeightModifier",
                            e[e.EditorDelete = 11] = "EditorDelete",
                            e[e.EditorMoveForwards = 12] = "EditorMoveForwards",
                            e[e.EditorMoveRight = 13] = "EditorMoveRight",
                            e[e.EditorMoveBackwards = 14] = "EditorMoveBackwards",
                            e[e.EditorMoveLeft = 15] = "EditorMoveLeft",
                            e[e.EditorRotateViewLeft = 16] = "EditorRotateViewLeft",
                            e[e.EditorRotateViewRight = 17] = "EditorRotateViewRight",
                            e[e.EditorMoveDown = 18] = "EditorMoveDown",
                            e[e.EditorMoveUp = 19] = "EditorMoveUp",
                            e[e.EditorTest = 20] = "EditorTest",
                            e[e.EditorPick = 21] = "EditorPick",
                            e[e.ToggleFpsCounter = 22] = "ToggleFpsCounter",
                            e[e.ToggleSpectatorCamera = 23] = "ToggleSpectatorCamera",
                            e[e.SpectatorMoveForwards = 24] = "SpectatorMoveForwards",
                            e[e.SpectatorMoveRight = 25] = "SpectatorMoveRight",
                            e[e.SpectatorMoveBackwards = 26] = "SpectatorMoveBackwards",
                            e[e.SpectatorMoveLeft = 27] = "SpectatorMoveLeft",
                            e[e.SpectatorSpeedModifier = 28] = "SpectatorSpeedModifier"
                    }(ax || (ax = {}));
                    const sx = ax;
                    var ox = n(7687)
                        , lx = {};
                    lx.styleTagTransform = u(),
                        lx.setAttributes = l(),
                        lx.insert = s().bind(null, "head"),
                        lx.domAPI = r(),
                        lx.insertStyleElement = h();
                    t()(ox.A, lx);
                    ox.A && ox.A.locals && ox.A.locals;
                    var cx, hx, dx, ux, px, fx, mx, gx = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, vx = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    cx = new WeakMap,
                        hx = new WeakMap,
                        dx = new WeakMap,
                        ux = new WeakMap,
                        px = new WeakMap,
                        fx = new WeakMap,
                        mx = new WeakMap;
                    const wx = class {
                            constructor(e, t, n, i, r, a, s, o) {
                                cx.set(this, void 0),
                                    hx.set(this, void 0),
                                    dx.set(this, void 0),
                                    ux.set(this, void 0),
                                    px.set(this, void 0),
                                    fx.set(this, void 0),
                                    mx.set(this, void 0),
                                    gx(this, cx, r, "f");
                                const l = document.getElementById("ui");
                                if (null == l)
                                    throw new Error("UI element not found");
                                gx(this, hx, l, "f"),
                                    gx(this, dx, document.createElement("div"), "f"),
                                    vx(this, dx, "f").className = "track-export",
                                    vx(this, hx, "f").appendChild(vx(this, dx, "f"));
                                const c = document.createElement("div");
                                c.className = "background",
                                    vx(this, dx, "f").appendChild(c);
                                const h = document.createElement("div");
                                h.className = "box",
                                    vx(this, dx, "f").appendChild(h);
                                const d = document.createElement("div");
                                d.className = "bar",
                                    h.appendChild(d);
                                const u = document.createElement("button");
                                u.className = "button",
                                    u.innerHTML = '<img class="button-icon" src="images/back.svg"> ',
                                    u.append(document.createTextNode(r.get("Back"))),
                                    u.addEventListener("click", ( () => {
                                            a.playUIClick(),
                                                t()
                                        }
                                    )),
                                    d.appendChild(u),
                                    gx(this, px, document.createElement("button"), "f"),
                                    vx(this, px, "f").className = "hidden",
                                    vx(this, px, "f").innerHTML = '<img class="button-icon" src="images/copy.svg"> ',
                                    vx(this, px, "f").append(document.createTextNode(r.get("Copy"))),
                                    vx(this, px, "f").addEventListener("click", ( () => {
                                            a.playUIClick();
                                            try {
                                                navigator.clipboard.writeText(vx(this, ux, "f").value).catch((e => {
                                                        console.error(e)
                                                    }
                                                ))
                                            } catch (e) {
                                                console.error(e)
                                            }
                                        }
                                    )),
                                    d.appendChild(vx(this, px, "f")),
                                    gx(this, fx, document.createElement("button"), "f"),
                                    vx(this, fx, "f").className = "hidden",
                                    vx(this, fx, "f").innerHTML = '<img class="button-icon" src="images/import.svg"> ',
                                    vx(this, fx, "f").append(document.createTextNode(r.get("Import"))),
                                    vx(this, fx, "f").addEventListener("click", ( () => {
                                            a.playUIClick();
                                            const e = () => {
                                                const e = vx(this, dx, "f").className;
                                                vx(this, dx, "f").className = "hidden",
                                                    o.show(r.get("Failed to import track"), r.get("Ok"), ( () => {
                                                            vx(this, dx, "f").className = e
                                                        }
                                                    ))
                                            }
                                                , i = vx(this, ux, "f").value
                                                , l = eb.fromExportString(i);
                                            if (null == l)
                                                e();
                                            else {
                                                const {trackMetadata: i, trackData: a} = l
                                                    , c = a.getId()
                                                    , h = a.createThumbnail();
                                                if (s.checkCustomTrackNameExists(i.name)) {
                                                    const l = vx(this, dx, "f").className;
                                                    vx(this, dx, "f").className = "hidden",
                                                        o.showConfirm(r.get('The track "{0}" already exists. Do you wish to overwrite it?', [i.name]), r.get("Cancel"), r.get("Overwrite"), ( () => {
                                                                vx(this, dx, "f").className = l
                                                            }
                                                        ), ( () => {
                                                                vx(this, dx, "f").className = l,
                                                                    s.saveCustomTrack(i, a) ? null != n ? n(i, a, c, h) : t() : e()
                                                            }
                                                        ))
                                                } else
                                                    s.saveCustomTrack(i, a) ? null != n ? n(i, a, c, h) : t() : e()
                                            }
                                        }
                                    )),
                                    d.appendChild(vx(this, fx, "f")),
                                    gx(this, ux, document.createElement("textarea"), "f"),
                                    vx(this, ux, "f").spellcheck = !1,
                                    h.appendChild(vx(this, ux, "f")),
                                i && (vx(this, ux, "f").placeholder = vx(this, cx, "f").get("Paste track data here...")),
                                    vx(this, ux, "f").value = e,
                                    vx(this, ux, "f").readOnly = !i,
                                    i ? (vx(this, px, "f").className = "hidden",
                                        vx(this, fx, "f").className = "button right") : (vx(this, px, "f").className = "button right",
                                        vx(this, fx, "f").className = "hidden"),
                                    window.addEventListener("keydown", gx(this, mx, (e => {
                                            "Escape" == e.code && (t(),
                                                e.preventDefault())
                                        }
                                    ), "f"))
                            }
                            dispose() {
                                vx(this, hx, "f").removeChild(vx(this, dx, "f")),
                                    window.removeEventListener("keydown", vx(this, mx, "f"))
                            }
                        }
                    ;
                    var Ax = n(8353)
                        , yx = {};
                    yx.styleTagTransform = u(),
                        yx.setAttributes = l(),
                        yx.insert = s().bind(null, "head"),
                        yx.domAPI = r(),
                        yx.insertStyleElement = h();
                    t()(Ax.A, yx);
                    Ax.A && Ax.A.locals && Ax.A.locals;
                    var bx = n(7479)
                        , xx = {};
                    xx.styleTagTransform = u(),
                        xx.setAttributes = l(),
                        xx.insert = s().bind(null, "head"),
                        xx.domAPI = r(),
                        xx.insertStyleElement = h();
                    t()(bx.A, xx);
                    bx.A && bx.A.locals && bx.A.locals;
                    var kx, Ex, Sx, Mx, Tx, Cx, _x, Ix, Px, Rx, Lx, Nx, Dx, Bx, Ux, zx, Ox, Fx = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, Wx = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    class Hx {
                        constructor(e, t, n=!1) {
                            kx.set(this, void 0),
                                Ex.set(this, void 0),
                                Sx.set(this, void 0),
                                Mx.set(this, void 0),
                                Tx.set(this, null),
                                Cx.set(this, void 0),
                                _x.set(this, null),
                                Ix.set(this, null),
                                Px.set(this, void 0),
                                Rx.set(this, null),
                                Lx.set(this, []),
                                Nx.set(this, void 0),
                                Dx.set(this, void 0),
                                Bx.set(this, void 0),
                                Ux.set(this, null),
                                zx.set(this, null),
                                Ox.set(this, null),
                                this.record = null,
                                Fx(this, kx, e, "f"),
                                Fx(this, Ex, t, "f");
                            const i = document.getElementById("ui");
                            if (null == i)
                                throw new Error("UI element not found");
                            if (Fx(this, Sx, i, "f"),
                                Fx(this, Mx, document.createElement("div"), "f"),
                                "off" == t.getSetting(Jo.Timer) ? Wx(this, Mx, "f").className = "timer hidden" : "top" == t.getSetting(Jo.Timer) ? Wx(this, Mx, "f").className = "timer up" : Wx(this, Mx, "f").className = "timer",
                                n)
                                Fx(this, Nx, null, "f");
                            else {
                                const t = document.createElement("div");
                                t.className = "left",
                                    Wx(this, Mx, "f").appendChild(t);
                                const n = document.createElement("div");
                                n.className = "title-container",
                                    t.appendChild(n),
                                    Fx(this, Tx, document.createElement("h2"), "f"),
                                    Wx(this, Tx, "f").className = "title",
                                    Wx(this, Tx, "f").textContent = e.get("Record"),
                                    n.appendChild(Wx(this, Tx, "f")),
                                    Fx(this, Ix, document.createElement("h2"), "f"),
                                    Wx(this, Ix, "f").className = "checkpoint-time",
                                    n.appendChild(Wx(this, Ix, "f"));
                                const i = document.createElement("div");
                                i.className = "time",
                                    t.appendChild(i),
                                    Fx(this, Nx, document.createElement("p"), "f"),
                                    Wx(this, Nx, "f").className = "small",
                                    Wx(this, Nx, "f").textContent = "- - -",
                                    i.appendChild(Wx(this, Nx, "f"))
                            }
                            const r = document.createElement("div");
                            r.className = "center",
                                Wx(this, Mx, "f").appendChild(r);
                            const a = document.createElement("div");
                            a.className = "title-container",
                                r.appendChild(a),
                                Fx(this, Cx, document.createElement("h2"), "f"),
                                Wx(this, Cx, "f").className = "title",
                                Wx(this, Cx, "f").textContent = e.get("Current"),
                                a.appendChild(Wx(this, Cx, "f")),
                                Fx(this, Px, document.createElement("h2"), "f"),
                                Wx(this, Px, "f").className = "checkpoint-time",
                                a.appendChild(Wx(this, Px, "f"));
                            const s = document.createElement("div");
                            if (s.className = "time",
                                r.appendChild(s),
                                Fx(this, Dx, document.createElement("p"), "f"),
                                Wx(this, Dx, "f").textContent = "- - -",
                                s.appendChild(Wx(this, Dx, "f")),
                                n)
                                Fx(this, Bx, null, "f");
                            else {
                                const t = document.createElement("div");
                                t.className = "right",
                                    Wx(this, Mx, "f").appendChild(t);
                                const n = document.createElement("div");
                                n.className = "title-container",
                                    t.appendChild(n),
                                    Fx(this, _x, document.createElement("h2"), "f"),
                                    Wx(this, _x, "f").className = "title",
                                    Wx(this, _x, "f").textContent = e.get("Difference"),
                                    n.appendChild(Wx(this, _x, "f")),
                                    Fx(this, Rx, document.createElement("h2"), "f"),
                                    Wx(this, Rx, "f").className = "checkpoint-time",
                                    n.appendChild(Wx(this, Rx, "f"));
                                const i = document.createElement("div");
                                i.className = "time",
                                    t.appendChild(i),
                                    Fx(this, Bx, document.createElement("p"), "f"),
                                    Wx(this, Bx, "f").className = "small",
                                    Wx(this, Bx, "f").textContent = "- - -",
                                    i.appendChild(Wx(this, Bx, "f"))
                            }
                            Wx(this, Sx, "f").appendChild(Wx(this, Mx, "f"))
                        }
                        dispose() {
                            Wx(this, Sx, "f").removeChild(Wx(this, Mx, "f"))
                        }
                        setOverridePosition(e) {
                            const t = Wx(this, Ex, "f").getSetting(Jo.Timer);
                            Wx(this, Mx, "f").className = "off" == t ? "timer hidden" : (null != e ? e : "top" == t) ? "timer up" : "timer"
                        }
                        hideCheckpointTime() {
                            for (const e of Wx(this, Lx, "f"))
                                e.cancel();
                            Wx(this, Lx, "f").length = 0
                        }
                        showCheckpointTime(e, t) {
                            if (this.hideCheckpointTime(),
                            null != Wx(this, Ix, "f") && null != t && (Wx(this, Ix, "f").textContent = Hx.formatTimeString(t, !1),
                                Wx(this, Lx, "f").push(Wx(this, Ix, "f").animate([{
                                    opacity: 0,
                                    transform: "translateX(20px)",
                                    offset: 0,
                                    easing: "ease-in-out"
                                }, {
                                    opacity: 1,
                                    transform: "translateX(0)",
                                    offset: 1 / 28,
                                    easing: "ease-in-out"
                                }, {
                                    opacity: 1,
                                    transform: "translateX(0)",
                                    offset: 27 / 28,
                                    easing: "ease-in-out"
                                }, {
                                    opacity: 0,
                                    transform: "translateX(-10px)",
                                    offset: 1,
                                    easing: "ease-in-out"
                                }], {
                                    duration: 3500
                                }))),
                                Wx(this, Px, "f").textContent = Hx.formatTimeString(e, !1),
                                Wx(this, Lx, "f").push(Wx(this, Px, "f").animate([{
                                    opacity: 0,
                                    transform: "translateX(20px)",
                                    offset: 0,
                                    easing: "ease-in-out"
                                }, {
                                    opacity: 1,
                                    transform: "translateX(0)",
                                    offset: 1 / 28,
                                    easing: "ease-in-out"
                                }, {
                                    opacity: 1,
                                    transform: "translateX(0)",
                                    offset: 27 / 28,
                                    easing: "ease-in-out"
                                }, {
                                    opacity: 0,
                                    transform: "translateX(-10px)",
                                    offset: 1,
                                    easing: "ease-in-out"
                                }], {
                                    duration: 3500
                                })),
                            null != Wx(this, Rx, "f") && null != t) {
                                const n = e.difference(t);
                                Wx(this, Rx, "f").textContent = Hx.formatTimeString(n, !0),
                                    n.isNegative() ? (Wx(this, Rx, "f").classList.remove("red"),
                                        Wx(this, Rx, "f").classList.add("green")) : (Wx(this, Rx, "f").classList.add("red"),
                                        Wx(this, Rx, "f").classList.remove("green")),
                                    Wx(this, Lx, "f").push(Wx(this, Rx, "f").animate([{
                                        opacity: 0,
                                        transform: "translateX(20px)",
                                        offset: 0,
                                        easing: "ease-in-out"
                                    }, {
                                        opacity: 1,
                                        transform: "translateX(0)",
                                        offset: 1 / 28,
                                        easing: "ease-in-out"
                                    }, {
                                        opacity: 1,
                                        transform: "translateX(0)",
                                        offset: 27 / 28,
                                        easing: "ease-in-out"
                                    }, {
                                        opacity: 0,
                                        transform: "translateX(-10px)",
                                        offset: 1,
                                        easing: "ease-in-out"
                                    }], {
                                        duration: 3500
                                    }))
                            }
                            null != Wx(this, Tx, "f") && null != t && Wx(this, Lx, "f").push(Wx(this, Tx, "f").animate([{
                                opacity: 1,
                                offset: 0,
                                easing: "ease-in-out"
                            }, {
                                opacity: 0,
                                offset: 1 / 28,
                                easing: "ease-in-out"
                            }, {
                                opacity: 0,
                                offset: 27 / 28,
                                easing: "ease-in-out"
                            }, {
                                opacity: 1,
                                offset: 1,
                                easing: "ease-in-out"
                            }], {
                                duration: 3500
                            })),
                                Wx(this, Lx, "f").push(Wx(this, Cx, "f").animate([{
                                    opacity: 1,
                                    offset: 0,
                                    easing: "ease-in-out"
                                }, {
                                    opacity: 0,
                                    offset: 1 / 28,
                                    easing: "ease-in-out"
                                }, {
                                    opacity: 0,
                                    offset: 27 / 28,
                                    easing: "ease-in-out"
                                }, {
                                    opacity: 1,
                                    offset: 1,
                                    easing: "ease-in-out"
                                }], {
                                    duration: 3500
                                })),
                            null != Wx(this, _x, "f") && null != t && Wx(this, Lx, "f").push(Wx(this, _x, "f").animate([{
                                opacity: 1,
                                offset: 0,
                                easing: "ease-in-out"
                            }, {
                                opacity: 0,
                                offset: 1 / 28,
                                easing: "ease-in-out"
                            }, {
                                opacity: 0,
                                offset: 27 / 28,
                                easing: "ease-in-out"
                            }, {
                                opacity: 1,
                                offset: 1,
                                easing: "ease-in-out"
                            }], {
                                duration: 3500
                            }))
                        }
                        static formatTimeString(e, t=!1) {
                            if (null == e)
                                return "---";
                            {
                                const n = Math.abs(e.numberOfFrames)
                                    , i = Math.floor(n / 6e4)
                                    , r = Math.floor((n - 6e4 * i) / 1e3)
                                    , a = n - 6e4 * i - 1e3 * r;
                                let s;
                                return s = t ? e.isNegative() ? "-" : "+" : "",
                                s + i.toString().padStart(2, "0") + ":" + r.toString().padStart(2, "0") + "." + a.toString().padStart(3, "0")
                            }
                        }
                        update(e) {
                            var t;
                            const n = null !== (t = e.getFinishTime()) && void 0 !== t ? t : e.getTime();
                            let i;
                            if (i = null != this.record ? n.difference(this.record) : null,
                            null != Wx(this, Nx, "f")) {
                                const e = Hx.formatTimeString(this.record, !1);
                                if (e != Wx(this, Ux, "f")) {
                                    Wx(this, Nx, "f").innerHTML = "";
                                    for (const t of e) {
                                        const e = document.createElement("span");
                                        e.textContent = t,
                                            Wx(this, Nx, "f").appendChild(e)
                                    }
                                    Fx(this, Ux, e, "f")
                                }
                                null == this.record ? "small center" != Wx(this, Nx, "f").className && (Wx(this, Nx, "f").className = "small center") : "small" != Wx(this, Nx, "f").className && (Wx(this, Nx, "f").className = "small")
                            }
                            const r = Hx.formatTimeString(n, !1);
                            if (r != Wx(this, zx, "f")) {
                                Wx(this, Dx, "f").innerHTML = "";
                                for (const e of r) {
                                    const t = document.createElement("span");
                                    t.textContent = e,
                                        Wx(this, Dx, "f").appendChild(t)
                                }
                                Fx(this, zx, r, "f")
                            }
                            if (null != Wx(this, Bx, "f")) {
                                const e = Hx.formatTimeString(i, !0);
                                if (e != Wx(this, Ox, "f")) {
                                    Wx(this, Bx, "f").innerHTML = "";
                                    for (let t = 0; t < e.length; ++t) {
                                        const n = document.createElement("span");
                                        0 == t && Number.isFinite(i) && (n.className = "sign"),
                                            n.textContent = e[t],
                                            Wx(this, Bx, "f").appendChild(n)
                                    }
                                    Fx(this, Ox, e, "f")
                                }
                                null == i ? "small center" != Wx(this, Bx, "f").className && (Wx(this, Bx, "f").className = "small center") : i.isNegative() ? "small green" != Wx(this, Bx, "f").className && (Wx(this, Bx, "f").className = "small green") : "small red" != Wx(this, Bx, "f").className && (Wx(this, Bx, "f").className = "small red")
                            }
                        }
                        set nickname(e) {
                            null != Wx(this, Tx, "f") ? Wx(this, Tx, "f").textContent = null != e ? '"' + e + '"' : Wx(this, kx, "f").get("Record") : Wx(this, Cx, "f").textContent = null != e ? '"' + e + '"' : Wx(this, kx, "f").get("Current")
                        }
                    }
                    kx = new WeakMap,
                        Ex = new WeakMap,
                        Sx = new WeakMap,
                        Mx = new WeakMap,
                        Tx = new WeakMap,
                        Cx = new WeakMap,
                        _x = new WeakMap,
                        Ix = new WeakMap,
                        Px = new WeakMap,
                        Rx = new WeakMap,
                        Lx = new WeakMap,
                        Nx = new WeakMap,
                        Dx = new WeakMap,
                        Bx = new WeakMap,
                        Ux = new WeakMap,
                        zx = new WeakMap,
                        Ox = new WeakMap;
                    const Vx = Hx;
                    var Gx, jx, Qx, Yx, qx, Kx, Xx, Zx, Jx, $x, ek, tk, nk, ik, rk, ak, sk, ok, lk, ck, hk, dk, uk, pk, fk, mk, gk, vk, wk, Ak, yk, bk, xk = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, kk = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    let Ek = null
                        , Sk = 0
                        , Mk = 0
                        , Tk = 0;
                    jx = new WeakMap,
                        Qx = new WeakMap,
                        Yx = new WeakMap,
                        qx = new WeakMap,
                        Kx = new WeakMap,
                        Xx = new WeakMap,
                        Zx = new WeakMap,
                        Jx = new WeakMap,
                        $x = new WeakMap,
                        ek = new WeakMap,
                        tk = new WeakMap,
                        nk = new WeakMap,
                        ik = new WeakMap,
                        rk = new WeakMap,
                        ak = new WeakMap,
                        sk = new WeakMap,
                        ok = new WeakMap,
                        lk = new WeakMap,
                        ck = new WeakMap,
                        hk = new WeakMap,
                        dk = new WeakMap,
                        uk = new WeakMap,
                        pk = new WeakMap,
                        fk = new WeakMap,
                        mk = new WeakMap,
                        gk = new WeakMap,
                        vk = new WeakMap,
                        wk = new WeakMap,
                        Gx = new WeakSet,
                        Ak = function(e, t, n, i, r, a=null) {
                            const s = document.createElement("div");
                            let o;
                            switch (s.className = "track",
                                e) {
                                case "official":
                                    o = kk(this, lk, "f");
                                    break;
                                case "community":
                                    o = kk(this, ck, "f");
                                    break;
                                case "custom":
                                    o = kk(this, hk, "f")
                            }
                            let l = o.get(n.environment);
                            if (null == l) {
                                let t, i, r, a;
                                switch (e) {
                                    case "official":
                                        t = kk(this, ak, "f");
                                        break;
                                    case "community":
                                        t = kk(this, sk, "f");
                                        break;
                                    case "custom":
                                        t = kk(this, ok, "f")
                                }
                                switch (l = document.createElement("div"),
                                    o.set(n.environment, l),
                                    n.environment) {
                                    case by.Summer:
                                        t.prepend(l);
                                        break;
                                    case by.Winter:
                                    {
                                        const e = o.get(by.Desert);
                                        null != e ? t.insertBefore(l, e) : t.appendChild(l);
                                        break
                                    }
                                    case by.Desert:
                                        t.appendChild(l)
                                }
                                switch (n.environment) {
                                    case by.Summer:
                                        i = "summer",
                                            r = kk(this, Qx, "f").get("Summer"),
                                            a = "images/summer.svg";
                                        break;
                                    case by.Winter:
                                        i = "winter",
                                            r = kk(this, Qx, "f").get("Winter"),
                                            a = "images/winter_colored.svg";
                                        break;
                                    case by.Desert:
                                        i = "desert",
                                            r = kk(this, Qx, "f").get("Desert"),
                                            a = "images/desert_colored.svg"
                                }
                                const s = document.createElement("div");
                                s.className = "environment-title " + i,
                                    s.textContent = r,
                                    l.appendChild(s);
                                const c = document.createElement("img");
                                c.src = a,
                                    s.prepend(c)
                            }
                            l.appendChild(s);
                            const c = document.createElement("button");
                            c.className = "button",
                                c.addEventListener("click", ( () => {
                                        kk(this, Yx, "f").playUIClick(),
                                            kk(this, ek, "f").call(this, t, n, e, i, r)
                                    }
                                )),
                                s.appendChild(c);
                            const h = document.createElement("div");
                            h.className = "track-title",
                                c.appendChild(h);
                            const d = document.createElement("p");
                            let u;
                            switch (d.textContent = t.name,
                                h.appendChild(d),
                                c.appendChild(r),
                                n.environment) {
                                case by.Summer:
                                    u = "images/summer.svg";
                                    break;
                                case by.Winter:
                                    u = "images/winter.svg";
                                    break;
                                case by.Desert:
                                    u = "images/desert.svg"
                            }
                            const p = document.createElement("img");
                            p.className = "environment",
                                p.src = u,
                                c.appendChild(p);
                            const f = kk(this, qx, "f").getRecordTime(kk(this, Xx, "f").profileSlot, i)
                                , m = document.createElement("div");
                            if (m.className = "record",
                                m.textContent = null != f ? Vx.formatTimeString(f) : kk(this, Qx, "f").get("No record"),
                                c.appendChild(m),
                            null != a) {
                                const e = document.createElement("button");
                                e.className = "delete-button",
                                    e.innerHTML = '<img src="images/erase.svg">',
                                    e.addEventListener("click", ( () => {
                                            kk(this, Yx, "f").playUIClick(),
                                                a()
                                        }
                                    )),
                                    s.appendChild(e)
                            }
                            kk(this, dk, "f").push({
                                category: e,
                                trackData: n,
                                trackMetadata: t,
                                buttonContainer: s
                            })
                        }
                        ,
                        yk = function(e) {
                            Ek = e,
                                kk(this, Jx, "f").saveTrackSelectionTab(Ek),
                                "official" == e ? (kk(this, nk, "f").classList.add("selected"),
                                    kk(this, ik, "f").classList.remove("selected"),
                                    kk(this, rk, "f").classList.remove("selected"),
                                    kk(this, ak, "f").classList.add("open"),
                                    kk(this, sk, "f").classList.remove("open"),
                                    kk(this, ok, "f").classList.remove("open")) : "community" == e ? (kk(this, nk, "f").classList.remove("selected"),
                                    kk(this, ik, "f").classList.add("selected"),
                                    kk(this, rk, "f").classList.remove("selected"),
                                    kk(this, ak, "f").classList.remove("open"),
                                    kk(this, sk, "f").classList.add("open"),
                                    kk(this, ok, "f").classList.remove("open")) : (kk(this, nk, "f").classList.remove("selected"),
                                    kk(this, ik, "f").classList.remove("selected"),
                                    kk(this, rk, "f").classList.add("selected"),
                                    kk(this, ak, "f").classList.remove("open"),
                                    kk(this, sk, "f").classList.remove("open"),
                                    kk(this, ok, "f").classList.add("open"))
                        }
                        ,
                        bk = function() {
                            const e = kk(this, uk, "f").value.trim().toLowerCase();
                            for (const t of kk(this, dk, "f"))
                                t.trackMetadata.name.toLowerCase().includes(e) ? t.buttonContainer.style.display = "" : t.buttonContainer.style.display = "none";
                            for (const e of ["official", "community", "custom"]) {
                                let t;
                                switch (e) {
                                    case "official":
                                        t = kk(this, lk, "f");
                                        break;
                                    case "community":
                                        t = kk(this, ck, "f");
                                        break;
                                    case "custom":
                                        t = kk(this, hk, "f")
                                }
                                for (const [n,i] of t.entries())
                                    kk(this, dk, "f").some((t => t.category == e && t.trackData.environment == n && "none" != t.buttonContainer.style.display)) ? i.style.display = "" : i.style.display = "none"
                            }
                            if (null == Ek && (Ek = kk(this, Jx, "f").loadTrackSelectionTab()),
                                kk(this, dk, "f").filter((e => e.category == Ek)).every((e => "none" == e.buttonContainer.style.display)))
                                for (const e of ["official", "community", "custom"])
                                    if (kk(this, dk, "f").some((t => t.category == e && "none" != t.buttonContainer.style.display))) {
                                        kk(this, Gx, "m", yk).call(this, e);
                                        break
                                    }
                        }
                    ;
                    const Ck = class {
                            constructor(e, t, n, i, r, a, s, o, l, c, h) {
                                Gx.add(this),
                                    jx.set(this, void 0),
                                    Qx.set(this, void 0),
                                    Yx.set(this, void 0),
                                    qx.set(this, void 0),
                                    Kx.set(this, void 0),
                                    Xx.set(this, void 0),
                                    Zx.set(this, void 0),
                                    Jx.set(this, void 0),
                                    $x.set(this, void 0),
                                    ek.set(this, void 0),
                                    tk.set(this, void 0),
                                    nk.set(this, void 0),
                                    ik.set(this, void 0),
                                    rk.set(this, void 0),
                                    ak.set(this, void 0),
                                    sk.set(this, void 0),
                                    ok.set(this, void 0),
                                    lk.set(this, new Map),
                                    ck.set(this, new Map),
                                    hk.set(this, new Map),
                                    dk.set(this, []),
                                    uk.set(this, void 0),
                                    pk.set(this, null),
                                    fk.set(this, !1),
                                    mk.set(this, !1),
                                    gk.set(this, void 0),
                                    vk.set(this, void 0),
                                    wk.set(this, void 0),
                                    xk(this, jx, e, "f"),
                                    xk(this, Qx, t, "f"),
                                    xk(this, Yx, n, "f"),
                                    xk(this, qx, i, "f"),
                                    xk(this, Kx, r, "f"),
                                    xk(this, Xx, a, "f"),
                                    xk(this, Zx, s, "f"),
                                    xk(this, Jx, o, "f"),
                                    xk(this, $x, l, "f"),
                                    xk(this, ek, h, "f"),
                                    xk(this, tk, document.createElement("div"), "f"),
                                    kk(this, tk, "f").className = "hidden",
                                    e.appendChild(kk(this, tk, "f"));
                                const d = document.createElement("div");
                                d.className = "bar",
                                    kk(this, tk, "f").appendChild(d);
                                const u = document.createElement("div");
                                u.className = "category-container",
                                    kk(this, tk, "f").appendChild(u),
                                    xk(this, nk, document.createElement("button"), "f"),
                                    kk(this, nk, "f").className = "button official selected",
                                    kk(this, nk, "f").append(document.createTextNode(kk(this, Qx, "f").get("Official tracks"))),
                                    kk(this, nk, "f").addEventListener("click", ( () => {
                                            kk(this, Yx, "f").playUIClick(),
                                                kk(this, Gx, "m", yk).call(this, "official")
                                        }
                                    )),
                                    u.appendChild(kk(this, nk, "f"));
                                const p = document.createElement("div");
                                p.className = "cover",
                                    kk(this, nk, "f").prepend(p),
                                    xk(this, ik, document.createElement("button"), "f"),
                                    kk(this, ik, "f").className = "button community",
                                    kk(this, ik, "f").append(document.createTextNode(kk(this, Qx, "f").get("Community tracks"))),
                                    kk(this, ik, "f").addEventListener("click", ( () => {
                                            kk(this, Yx, "f").playUIClick(),
                                                kk(this, Gx, "m", yk).call(this, "community")
                                        }
                                    )),
                                    u.appendChild(kk(this, ik, "f"));
                                const f = document.createElement("div");
                                f.className = "cover",
                                    kk(this, ik, "f").prepend(f),
                                    xk(this, rk, document.createElement("button"), "f"),
                                    kk(this, rk, "f").className = "button custom",
                                    kk(this, rk, "f").append(document.createTextNode(kk(this, Qx, "f").get("Custom tracks"))),
                                    kk(this, rk, "f").addEventListener("click", ( () => {
                                            kk(this, Yx, "f").playUIClick(),
                                                kk(this, Gx, "m", yk).call(this, "custom")
                                        }
                                    )),
                                    u.appendChild(kk(this, rk, "f"));
                                const m = document.createElement("div");
                                m.className = "cover",
                                    kk(this, rk, "f").prepend(m),
                                    xk(this, ak, document.createElement("div"), "f"),
                                    kk(this, ak, "f").className = "tracks-container open",
                                    kk(this, tk, "f").appendChild(kk(this, ak, "f")),
                                    xk(this, sk, document.createElement("div"), "f"),
                                    kk(this, sk, "f").className = "tracks-container",
                                    kk(this, tk, "f").appendChild(kk(this, sk, "f")),
                                    xk(this, ok, document.createElement("div"), "f"),
                                    kk(this, ok, "f").className = "tracks-container",
                                    kk(this, tk, "f").appendChild(kk(this, ok, "f"));
                                const g = document.createElement("button");
                                g.className = "button",
                                    l ? (g.innerHTML = '<img class="button-icon" src="images/erase.svg"> ',
                                        g.append(document.createTextNode(kk(this, Qx, "f").get("Cancel")))) : (g.innerHTML = '<img class="button-icon" src="images/back.svg"> ',
                                        g.append(document.createTextNode(kk(this, Qx, "f").get("Back")))),
                                    g.addEventListener("click", ( () => {
                                            kk(this, Yx, "f").playUIClick(),
                                                c()
                                        }
                                    )),
                                    d.appendChild(g);
                                const v = document.createElement("div");
                                v.className = "search-bar-container",
                                    d.appendChild(v),
                                    xk(this, uk, document.createElement("input"), "f"),
                                    kk(this, uk, "f").type = "text",
                                    kk(this, uk, "f").spellcheck = !1,
                                    kk(this, uk, "f").autocomplete = "off",
                                    kk(this, uk, "f").autocapitalize = "off",
                                    kk(this, uk, "f").enterKeyHint = "search",
                                    kk(this, uk, "f").placeholder = kk(this, Qx, "f").get("Search tracks..."),
                                    kk(this, uk, "f").addEventListener("input", ( () => {
                                            kk(this, Gx, "m", bk).call(this)
                                        }
                                    )),
                                    v.appendChild(kk(this, uk, "f"));
                                const w = document.createElement("img");
                                w.src = "images/search.svg",
                                    v.appendChild(w);
                                const A = document.createElement("button");
                                A.className = "button",
                                    A.innerHTML = '<img class="button-icon" src="images/import.svg"> ',
                                    A.append(document.createTextNode(kk(this, Qx, "f").get("Import"))),
                                    A.addEventListener("click", ( () => {
                                            kk(this, Yx, "f").playUIClick(),
                                                this.hide(),
                                                xk(this, pk, new wx("",( () => {
                                                        var e;
                                                        this.show(),
                                                        null === (e = kk(this, pk, "f")) || void 0 === e || e.dispose(),
                                                            xk(this, pk, null, "f")
                                                    }
                                                ),( (e, t, n, i) => {
                                                        var r;
                                                        null === (r = kk(this, pk, "f")) || void 0 === r || r.dispose(),
                                                            xk(this, pk, null, "f"),
                                                            kk(this, Gx, "m", yk).call(this, "custom"),
                                                            kk(this, ek, "f").call(this, e, t, "custom", n, i)
                                                    }
                                                ),!0,t,n,r,s), "f")
                                        }
                                    )),
                                    d.appendChild(A),
                                    window.addEventListener("keydown", xk(this, gk, (e => {
                                            kk(this, fk, "f") && "Escape" == e.code && (c(),
                                                e.preventDefault())
                                        }
                                    ), "f")),
                                    kk(this, Kx, "f").addCustomTracksChangedListener(xk(this, vk, ( () => {
                                            kk(this, mk, "f") && this.refresh()
                                        }
                                    ), "f")),
                                    kk(this, ak, "f").addEventListener("scroll", ( () => {
                                            Sk = kk(this, ak, "f").scrollTop
                                        }
                                    ), {
                                        passive: !0
                                    }),
                                    kk(this, sk, "f").addEventListener("scroll", ( () => {
                                            Mk = kk(this, sk, "f").scrollTop
                                        }
                                    ), {
                                        passive: !0
                                    }),
                                    kk(this, ok, "f").addEventListener("scroll", ( () => {
                                            Tk = kk(this, ok, "f").scrollTop
                                        }
                                    ), {
                                        passive: !0
                                    }),
                                    kk(this, qx, "f").addRecordChangedCallback(xk(this, wk, ( () => {
                                            this.refresh()
                                        }
                                    ), "f"))
                            }
                            dispose() {
                                var e;
                                kk(this, jx, "f").removeChild(kk(this, tk, "f")),
                                    window.removeEventListener("keydown", kk(this, gk, "f")),
                                null === (e = kk(this, pk, "f")) || void 0 === e || e.dispose(),
                                    xk(this, pk, null, "f"),
                                    kk(this, Kx, "f").removeCustomTracksChangedListener(kk(this, vk, "f")),
                                    kk(this, qx, "f").removeRecordChangedCallback(kk(this, wk, "f"))
                            }
                            hide() {
                                kk(this, tk, "f").className = "hidden",
                                    xk(this, fk, !1, "f")
                            }
                            show() {
                                kk(this, $x, "f") ? kk(this, tk, "f").className = "track-selection editor-track-selection" : kk(this, tk, "f").className = "track-selection",
                                    xk(this, fk, !0, "f"),
                                kk(this, mk, "f") || this.refresh(),
                                null == Ek && (Ek = kk(this, Jx, "f").loadTrackSelectionTab()),
                                    "official" == Ek ? (kk(this, nk, "f").classList.add("selected"),
                                        kk(this, ik, "f").classList.remove("selected"),
                                        kk(this, rk, "f").classList.remove("selected"),
                                        kk(this, ak, "f").classList.add("open"),
                                        kk(this, sk, "f").classList.remove("open"),
                                        kk(this, ok, "f").classList.remove("open"),
                                        kk(this, ak, "f").scrollTop = Sk) : "community" == Ek ? (kk(this, nk, "f").classList.remove("selected"),
                                        kk(this, ik, "f").classList.add("selected"),
                                        kk(this, rk, "f").classList.remove("selected"),
                                        kk(this, ak, "f").classList.remove("open"),
                                        kk(this, sk, "f").classList.add("open"),
                                        kk(this, ok, "f").classList.remove("open"),
                                        kk(this, sk, "f").scrollTop = Mk) : (kk(this, nk, "f").classList.remove("selected"),
                                        kk(this, ik, "f").classList.remove("selected"),
                                        kk(this, rk, "f").classList.add("selected"),
                                        kk(this, ak, "f").classList.remove("open"),
                                        kk(this, sk, "f").classList.remove("open"),
                                        kk(this, ok, "f").classList.add("open"),
                                        kk(this, ok, "f").scrollTop = Tk)
                            }
                            get isOpen() {
                                return kk(this, fk, "f") || null != kk(this, pk, "f")
                            }
                            refresh() {
                                if (xk(this, dk, [], "f"),
                                    kk(this, ak, "f").innerHTML = "",
                                    kk(this, sk, "f").innerHTML = "",
                                    kk(this, ok, "f").innerHTML = "",
                                    kk(this, lk, "f").clear(),
                                    kk(this, ck, "f").clear(),
                                    kk(this, hk, "f").clear(),
                                    kk(this, Kx, "f").forEachOfficialTrack(( (e, t, n, i) => {
                                            kk(this, Gx, "m", Ak).call(this, "official", t, n, e, i)
                                        }
                                    )),
                                    kk(this, Kx, "f").isCommunityTracksEmpty()) {
                                    const e = document.createElement("div");
                                    e.className = "empty";
                                    const t = document.createElement("div");
                                    t.className = "title",
                                        t.textContent = kk(this, Qx, "f").get("No community tracks"),
                                        e.appendChild(t);
                                    const n = document.createElement("div");
                                    n.className = "description",
                                        n.textContent = kk(this, Qx, "f").get("Community tracks are coming soon"),
                                        e.appendChild(n),
                                        kk(this, sk, "f").appendChild(e)
                                } else
                                    kk(this, Kx, "f").forEachCommunityTrack(( (e, t, n, i) => {
                                            kk(this, Gx, "m", Ak).call(this, "community", t, n, e, i)
                                        }
                                    ));
                                if (kk(this, Kx, "f").isCustomTracksEmpty()) {
                                    const e = document.createElement("div");
                                    e.className = "empty";
                                    const t = document.createElement("div");
                                    t.className = "title",
                                        t.textContent = kk(this, Qx, "f").get("No custom tracks"),
                                        e.appendChild(t);
                                    const n = document.createElement("div");
                                    n.className = "description",
                                        n.textContent = kk(this, Qx, "f").get("Create a track using the editor or import a track code"),
                                        e.appendChild(n),
                                        kk(this, ok, "f").appendChild(e)
                                } else
                                    kk(this, Kx, "f").forEachCustomTrack(( (e, t, n, i) => {
                                            kk(this, Gx, "m", Ak).call(this, "custom", t, n, e, i, ( () => {
                                                    this.hide(),
                                                        kk(this, Zx, "f").showConfirm(kk(this, Qx, "f").get('Are you sure you want to delete "{0}"?', [t.name]), kk(this, Qx, "f").get("Cancel"), kk(this, Qx, "f").get("Delete"), ( () => {
                                                                this.show()
                                                            }
                                                        ), ( () => {
                                                                kk(this, Kx, "f").deleteCustomTrack(t.name),
                                                                    this.show()
                                                            }
                                                        ))
                                                }
                                            ))
                                        }
                                    ));
                                kk(this, Gx, "m", bk).call(this),
                                    xk(this, mk, !0, "f")
                            }
                        }
                    ;
                    var _k = n(2346)
                        , Ik = {};
                    Ik.styleTagTransform = u(),
                        Ik.setAttributes = l(),
                        Ik.insert = s().bind(null, "head"),
                        Ik.domAPI = r(),
                        Ik.insertStyleElement = h();
                    t()(_k.A, Ik);
                    _k.A && _k.A.locals && _k.A.locals;
                    var Pk, Rk, Lk, Nk, Dk, Bk, Uk, zk, Ok = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, Fk = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    Pk = new WeakMap,
                        Rk = new WeakMap,
                        Lk = new WeakMap,
                        Nk = new WeakMap,
                        Dk = new WeakMap,
                        Bk = new WeakMap,
                        Uk = new WeakMap,
                        zk = new WeakMap;
                    const Wk = class {
                            constructor(e, t, n, i, r, a, s) {
                                Pk.set(this, void 0),
                                    Rk.set(this, void 0),
                                    Lk.set(this, void 0),
                                    Nk.set(this, void 0),
                                    Dk.set(this, void 0),
                                    Bk.set(this, void 0),
                                    Uk.set(this, []),
                                    zk.set(this, void 0),
                                    Ok(this, Pk, e, "f"),
                                    Ok(this, Rk, n, "f"),
                                    Ok(this, Lk, document.createElement("div"), "f"),
                                    Fk(this, Lk, "f").className = "editor-side-toolbar",
                                    Fk(this, Pk, "f").appendChild(Fk(this, Lk, "f"));
                                let o = !1;
                                const l = document.createElement("button")
                                    , c = document.createElement("img");
                                c.src = "images/overlapping_disabled.svg",
                                    l.appendChild(c),
                                    l.addEventListener("click", ( () => {
                                            t.playUIClick(),
                                                o = !o,
                                                c.src = o ? "images/overlapping_enabled.svg" : "images/overlapping_disabled.svg",
                                                i(o)
                                        }
                                    )),
                                    Fk(this, Lk, "f").appendChild(l);
                                let h = !0;
                                const d = document.createElement("button")
                                    , u = document.createElement("img");
                                u.src = "images/grid_large.svg",
                                    d.appendChild(u),
                                    d.addEventListener("click", ( () => {
                                            t.playUIClick(),
                                                h = !h,
                                                u.src = h ? "images/grid_large.svg" : "images/grid_small.svg",
                                                r(h)
                                        }
                                    )),
                                    Fk(this, Lk, "f").appendChild(d);
                                const p = document.createElement("div");
                                p.className = "accordion",
                                    Fk(this, Lk, "f").appendChild(p),
                                    Ok(this, Bk, document.createElement("button"), "f"),
                                    Fk(this, Bk, "f").innerHTML = '<img src="images/rotation_axis_y_positive.svg">',
                                    Fk(this, Bk, "f").addEventListener("click", ( () => {
                                            t.playUIClick(),
                                                p.classList.toggle("open");
                                            for (const e of p.children)
                                                e != Fk(this, Bk, "f") && e instanceof HTMLButtonElement && (p.classList.contains("open") ? (e.inert = !1,
                                                    e.tabIndex = 0) : (e.inert = !0,
                                                    e.tabIndex = -1))
                                        }
                                    )),
                                    p.appendChild(Fk(this, Bk, "f"));
                                for (const e of [RA.YPositive, RA.YNegative, RA.XPositive, RA.XNegative, RA.ZPositive, RA.ZNegative]) {
                                    const n = document.createElement("button");
                                    switch (n.inert = !0,
                                        n.tabIndex = -1,
                                        e) {
                                        case RA.YPositive:
                                            n.innerHTML = '<img src="images/rotation_axis_y_positive.svg">';
                                            break;
                                        case RA.YNegative:
                                            n.innerHTML = '<img src="images/rotation_axis_y_negative.svg">';
                                            break;
                                        case RA.XPositive:
                                            n.innerHTML = '<img src="images/rotation_axis_x_positive.svg">';
                                            break;
                                        case RA.XNegative:
                                            n.innerHTML = '<img src="images/rotation_axis_x_negative.svg">';
                                            break;
                                        case RA.ZPositive:
                                            n.innerHTML = '<img src="images/rotation_axis_z_positive.svg">';
                                            break;
                                        case RA.ZNegative:
                                            n.innerHTML = '<img src="images/rotation_axis_z_negative.svg">'
                                    }
                                    n.addEventListener("click", ( () => {
                                            t.playUIClick(),
                                                a(e)
                                        }
                                    )),
                                    e == RA.YPositive && n.classList.add("selected"),
                                        p.appendChild(n),
                                        Fk(this, Uk, "f").push([e, n])
                                }
                                const f = document.createElement("button");
                                f.className = "rotate",
                                    f.addEventListener("click", ( () => {
                                            t.playUIClick(),
                                                s()
                                        }
                                    )),
                                    Fk(this, Lk, "f").appendChild(f),
                                    Ok(this, Nk, document.createElement("div"), "f"),
                                    Fk(this, Nk, "f").innerHTML = '<img src="images/rotate.svg">',
                                    f.appendChild(Fk(this, Nk, "f")),
                                    Ok(this, Dk, document.createElement("span"), "f"),
                                    Fk(this, Dk, "f").textContent = "0",
                                    f.appendChild(Fk(this, Dk, "f")),
                                    n.addChangeListener(Ok(this, zk, (e => {
                                            e ? Fk(this, Lk, "f").classList.add("touch") : Fk(this, Lk, "f").classList.remove("touch")
                                        }
                                    ), "f"))
                            }
                            dispose() {
                                Fk(this, Pk, "f").removeChild(Fk(this, Lk, "f")),
                                    Fk(this, Rk, "f").removeChangeListener(Fk(this, zk, "f"))
                            }
                            set rotation(e) {
                                Fk(this, Nk, "f").style.transform = `rotate(${(90 * -e).toString()}deg)`,
                                    Fk(this, Dk, "f").textContent = (90 * e).toString() + ""
                            }
                            set rotationAxis(e) {
                                let t;
                                switch (e) {
                                    case RA.YPositive:
                                        t = "images/rotation_axis_y_positive.svg";
                                        break;
                                    case RA.YNegative:
                                        t = "images/rotation_axis_y_negative.svg";
                                        break;
                                    case RA.XPositive:
                                        t = "images/rotation_axis_x_positive.svg";
                                        break;
                                    case RA.XNegative:
                                        t = "images/rotation_axis_x_negative.svg";
                                        break;
                                    case RA.ZPositive:
                                        t = "images/rotation_axis_z_positive.svg";
                                        break;
                                    case RA.ZNegative:
                                        t = "images/rotation_axis_z_negative.svg"
                                }
                                Fk(this, Bk, "f").innerHTML = "";
                                const n = document.createElement("img");
                                n.src = t,
                                    Fk(this, Bk, "f").appendChild(n);
                                for (const [t,n] of Fk(this, Uk, "f"))
                                    t == e ? n.classList.add("selected") : n.classList.remove("selected")
                            }
                            hide() {
                                Fk(this, Lk, "f").classList.add("hidden")
                            }
                            show() {
                                Fk(this, Lk, "f").classList.remove("hidden")
                            }
                        }
                    ;
                    var Hk = n(9242)
                        , Vk = {};
                    Vk.styleTagTransform = u(),
                        Vk.setAttributes = l(),
                        Vk.insert = s().bind(null, "head"),
                        Vk.domAPI = r(),
                        Vk.insertStyleElement = h();
                    t()(Hk.A, Vk);
                    Hk.A && Hk.A.locals && Hk.A.locals;
                    var Gk, jk, Qk, Yk = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, qk = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    Gk = new WeakMap,
                        jk = new WeakMap,
                        Qk = new WeakMap;
                    const Kk = class {
                            constructor(e, t, n, i, r, a, s, o) {
                                Gk.set(this, void 0),
                                    jk.set(this, void 0),
                                    Qk.set(this, void 0);
                                const l = document.getElementById("ui");
                                if (null == l)
                                    throw new Error("UI element not found");
                                Yk(this, Gk, l, "f"),
                                    Yk(this, jk, document.createElement("div"), "f"),
                                    qk(this, jk, "f").className = "editor-help",
                                    qk(this, Gk, "f").appendChild(qk(this, jk, "f"));
                                const c = document.createElement("div");
                                c.className = "background",
                                    qk(this, jk, "f").appendChild(c);
                                const h = document.createElement("section");
                                h.className = "container",
                                    qk(this, jk, "f").appendChild(h);
                                const d = document.createElement("h1");
                                d.textContent = t.get("How to use the editor"),
                                    h.appendChild(d);
                                const u = document.createElement("section");
                                u.className = "content",
                                    h.appendChild(u);
                                const p = document.createElement("h2");
                                function f(e) {
                                    const i = n.getKeyBindings(e).filter((e => null != e));
                                    return 0 == i.length ? t.get("Not set") : i.map((e => "[" + e + "]")).join(" " + t.get("or") + " ")
                                }
                                p.textContent = t.get("Camera controls"),
                                    u.appendChild(p);
                                let m = "";
                                i.touchEnabled ? (m += t.get("The camera can be moved by dragging with one finger. Rotate the camera by dragging with two fingers. Zoom in and out by pinching.") + "\n\n",
                                    m += t.get("The edited height can be changed by using the height selection in the bottom left corner.")) : (m += t.get("The camera can be moved by right clicking and dragging the mouse. Rotate the camera by clicking the middle mouse button (mouse wheel) or holding the control key and right clicking and dragging the mouse. Zoom in and out by scrolling the mouse wheel.") + "\n\n",
                                    m += t.get("Alternatively, the camera can also be controlled using the following keyboard keys:") + "\n\n",
                                    m += "\t" + t.get("Move forwards:") + " " + f(sx.EditorMoveForwards) + "\n",
                                    m += "\t" + t.get("Move backwards:") + " " + f(sx.EditorMoveBackwards) + "\n",
                                    m += "\t" + t.get("Move left:") + " " + f(sx.EditorMoveLeft) + "\n",
                                    m += "\t" + t.get("Move right:") + " " + f(sx.EditorMoveRight) + "\n",
                                    m += "\t" + t.get("Rotate left:") + " " + f(sx.EditorRotateViewLeft) + "\n",
                                    m += "\t" + t.get("Rotate right:") + " " + f(sx.EditorRotateViewRight) + "\n\n",
                                    m += t.get("The edited height can be changed either by using the height selection in the bottom left corner, or holding the shift key and scrolling the mouse wheel. Alternatively, you can use the following keyboard keys:") + "\n\n",
                                    m += "\t" + t.get("Move up:") + " " + f(sx.EditorMoveUp) + "\n",
                                    m += "\t" + t.get("Move down:") + " " + f(sx.EditorMoveDown));
                                const g = document.createElement("p");
                                g.textContent = m,
                                    u.appendChild(g);
                                const v = document.createElement("h2");
                                v.textContent = t.get("Editing"),
                                    u.appendChild(v);
                                let w = "";
                                i.touchEnabled ? (w += t.get("Track parts can be selected in the menu on the right after which they can be placed by tapping on the screen.") + "\n\n",
                                    w += t.get("The selected part can then be rotated by tapping the rotate button in the bottom left corner.") + "\n\n",
                                    w += t.get("Track parts can be deleted by using the delete tool in the right side menu.")) : (w += t.get("Track parts can be selected in the menu on the right after which they can be placed by left clicking with the mouse.") + "\n\n",
                                    w += t.get("Alternatively, the track part currently hovered by the mouse can be selected with the following keyboard shortcut:") + " " + f(sx.EditorPick) + "\n\n",
                                    w += t.get("The selected part can then be rotated using the following keyboard shortcut:") + " " + f(sx.EditorRotatePart) + "\n\n",
                                    w += t.get("Track parts can be deleted by using the delete tool in the right side menu or by holding the following key:") + " " + f(sx.EditorDelete));
                                const A = document.createElement("p");
                                A.textContent = w,
                                    u.appendChild(A);
                                const y = document.createElement("h2");
                                y.textContent = t.get("Starting points, checkpoints and the finish line"),
                                    u.appendChild(y);
                                let b = t.get("Starting points, checkpoints and finish lines can all be selected in the uppermost category in the right side menu.") + "\n\n";
                                b += t.get("Each track must have at least one starting point. If there are multiple starting points, the last placed one will be used.") + "\n\n",
                                    b += t.get("Checkpoints should be placed between the starting point and the finish line. When a checkpoint track part is selected there will be a tool in the bottom right to select the order of the checkpoint. This determines the order in which the checkpoints must be passed before driving to the finish line. Notice that it is possible to have multiple checkpoints with the same checkpoint order.") + "\n\n",
                                    b += t.get("The finish line is where the track ends but will only become active after all checkpoints have been passed. It is also possible to have multiple finish lines.");
                                const x = document.createElement("p");
                                x.textContent = b,
                                    u.appendChild(x);
                                const k = document.createElement("div");
                                k.className = "part-images",
                                    u.appendChild(k);
                                const E = document.createElement("div");
                                k.appendChild(E);
                                const S = document.createElement("img");
                                S.className = "loading",
                                    r.then((e => {
                                            S.className = "",
                                                S.src = e
                                        }
                                    )).catch((e => {
                                            console.error(e)
                                        }
                                    )),
                                    E.appendChild(S);
                                const M = document.createElement("span");
                                M.textContent = t.get("Starting point"),
                                    E.appendChild(M);
                                const T = document.createElement("div");
                                k.appendChild(T);
                                const C = document.createElement("img");
                                C.className = "loading",
                                    a.then((e => {
                                            C.className = "",
                                                C.src = e
                                        }
                                    )).catch((e => {
                                            console.error(e)
                                        }
                                    )),
                                    T.appendChild(C);
                                const _ = document.createElement("span");
                                _.textContent = t.get("Checkpoint"),
                                    T.appendChild(_);
                                const I = document.createElement("div");
                                k.appendChild(I);
                                const P = document.createElement("img");
                                P.className = "loading",
                                    s.then((e => {
                                            P.className = "",
                                                P.src = e
                                        }
                                    )).catch((e => {
                                            console.error(e)
                                        }
                                    )),
                                    I.appendChild(P);
                                const R = document.createElement("span");
                                R.textContent = t.get("Finish line"),
                                    I.appendChild(R);
                                const L = document.createElement("h2");
                                L.textContent = t.get("Exporting the track"),
                                    u.appendChild(L);
                                const N = t.get("When the track is finished, a name for the track can be entered in top left after which the track can be exported using the export button. This will reveal a track code which can be sent to other users so they can import and play the track.") + "\n\n"
                                    , D = document.createElement("p");
                                D.textContent = N,
                                    u.appendChild(D);
                                const B = document.createElement("div");
                                B.className = "button-wrapper",
                                    h.appendChild(B);
                                const U = document.createElement("button");
                                U.className = "button",
                                    U.innerHTML = '<img class="button-icon" src="images/cancel.svg"> ',
                                    U.append(document.createTextNode(t.get("Close"))),
                                    U.addEventListener("click", ( () => {
                                            e.playUIClick(),
                                                o()
                                        }
                                    )),
                                    B.appendChild(U),
                                    window.addEventListener("keydown", Yk(this, Qk, (e => {
                                            "Escape" == e.code && (o(),
                                                e.preventDefault())
                                        }
                                    ), "f"))
                            }
                            dispose() {
                                qk(this, Gk, "f").removeChild(qk(this, jk, "f")),
                                    window.removeEventListener("keydown", qk(this, Qk, "f"))
                            }
                        }
                    ;
                    var Xk = n(1997)
                        , Zk = {};
                    Zk.styleTagTransform = u(),
                        Zk.setAttributes = l(),
                        Zk.insert = s().bind(null, "head"),
                        Zk.domAPI = r(),
                        Zk.insertStyleElement = h();
                    t()(Xk.A, Zk);
                    Xk.A && Xk.A.locals && Xk.A.locals;
                    var Jk, $k, eE, tE, nE = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, iE = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    Jk = new WeakMap,
                        $k = new WeakMap,
                        eE = new WeakMap,
                        tE = new WeakMap;
                    const rE = class {
                            constructor(e, t, n, i, r, a, s, o, l) {
                                Jk.set(this, void 0),
                                    $k.set(this, void 0),
                                    eE.set(this, null),
                                    tE.set(this, void 0);
                                const c = document.getElementById("ui");
                                if (null == c)
                                    throw new Error("UI element not found");
                                nE(this, Jk, c, "f"),
                                    nE(this, $k, document.createElement("div"), "f"),
                                    iE(this, $k, "f").className = "editor-track-settings",
                                    iE(this, Jk, "f").appendChild(iE(this, $k, "f"));
                                const h = document.createElement("div");
                                h.className = "background",
                                    iE(this, $k, "f").appendChild(h);
                                const d = document.createElement("section");
                                d.className = "container",
                                    iE(this, $k, "f").appendChild(d);
                                const u = document.createElement("h1");
                                u.textContent = t.get("Track settings"),
                                    d.appendChild(u);
                                const p = document.createElement("section");
                                p.className = "content",
                                    d.appendChild(p);
                                const f = document.createElement("div");
                                f.className = "setting",
                                    p.appendChild(f);
                                const m = document.createElement("label");
                                m.className = "title",
                                    m.append(document.createTextNode(t.get("Track name"))),
                                    f.appendChild(m);
                                const g = document.createElement("input");
                                g.type = "text",
                                    g.maxLength = 64,
                                    g.spellcheck = !1,
                                    g.value = null != n ? n : "",
                                    g.addEventListener("input", ( () => {
                                            0 == g.value.trim().length ? (null != iE(this, eE, "f") && (iE(this, eE, "f").disabled = !0),
                                                f.classList.add("error")) : (null != iE(this, eE, "f") && (iE(this, eE, "f").disabled = !1),
                                                f.classList.remove("error"))
                                        }
                                    )),
                                    f.appendChild(g),
                                null != n && 0 != n.length || (f.classList.add("error"),
                                    g.focus());
                                const v = document.createElement("div");
                                v.className = "setting",
                                    p.appendChild(v);
                                const w = document.createElement("label");
                                w.className = "title",
                                    w.append(document.createTextNode(t.get("Author"))),
                                    v.appendChild(w);
                                const A = document.createElement("input");
                                A.type = "text",
                                    A.maxLength = 64,
                                    A.spellcheck = !1,
                                    A.value = null != i ? i : "",
                                    A.placeholder = t.get("Unknown"),
                                    A.addEventListener("input", ( () => {
                                            const e = A.value.trim();
                                            0 == e.length ? r.trackAuthor = null : r.trackAuthor = e
                                        }
                                    )),
                                    v.appendChild(A);
                                const y = document.createElement("div");
                                y.className = "setting",
                                    p.appendChild(y);
                                const b = document.createElement("div");
                                b.className = "title",
                                    b.append(document.createTextNode(t.get("Environment"))),
                                    y.appendChild(b);
                                const x = document.createElement("button");
                                x.className = "button environment-button",
                                a.environment == by.Summer && (x.classList.add("selected"),
                                    x.disabled = !0),
                                    x.innerHTML = '<img src="images/summer.svg"> ',
                                    x.append(document.createTextNode(t.get("Summer"))),
                                    x.addEventListener("click", ( () => {
                                            e.playUIClick(),
                                                s(by.Summer),
                                                x.classList.add("selected"),
                                                k.classList.remove("selected"),
                                                E.classList.remove("selected"),
                                                x.disabled = !0,
                                                k.disabled = !1,
                                                E.disabled = !1
                                        }
                                    )),
                                    y.appendChild(x);
                                const k = document.createElement("button");
                                k.className = "button environment-button",
                                a.environment == by.Winter && (k.classList.add("selected"),
                                    k.disabled = !0),
                                    k.innerHTML = '<img src="images/winter.svg"> ',
                                    k.append(document.createTextNode(t.get("Winter"))),
                                    k.addEventListener("click", ( () => {
                                            e.playUIClick(),
                                                s(by.Winter),
                                                x.classList.remove("selected"),
                                                k.classList.add("selected"),
                                                E.classList.remove("selected"),
                                                x.disabled = !1,
                                                k.disabled = !0,
                                                E.disabled = !1
                                        }
                                    )),
                                    y.appendChild(k);
                                const E = document.createElement("button");
                                E.className = "button environment-button",
                                a.environment == by.Desert && (E.classList.add("selected"),
                                    E.disabled = !0),
                                    E.innerHTML = '<img src="images/desert.svg"> ',
                                    E.append(document.createTextNode(t.get("Desert"))),
                                    E.addEventListener("click", ( () => {
                                            e.playUIClick(),
                                                s(by.Desert),
                                                x.classList.remove("selected"),
                                                k.classList.remove("selected"),
                                                E.classList.add("selected"),
                                                x.disabled = !1,
                                                k.disabled = !1,
                                                E.disabled = !0
                                        }
                                    )),
                                    y.appendChild(E);
                                const S = document.createElement("div");
                                S.className = "setting",
                                    p.appendChild(S);
                                const M = document.createElement("label");
                                M.className = "title",
                                    M.append(document.createTextNode(t.get("Sun direction") + " (")),
                                    S.appendChild(M);
                                const T = document.createTextNode(a.sunDirection.toDegrees().toString());
                                M.appendChild(T),
                                    M.append(document.createTextNode(")"));
                                let C = null;
                                const _ = document.createElement("input");
                                _.type = "range",
                                    _.min = "0",
                                    _.max = "360",
                                    _.step = "2",
                                    _.value = a.sunDirection.toDegrees().toString(),
                                    _.addEventListener("input", ( () => {
                                            a.sunDirection = Ay.fromDegrees(parseInt(_.value, 10)),
                                                T.textContent = _.value,
                                            null == C && (C = setTimeout(( () => {
                                                    a.generateMeshes(),
                                                        C = null
                                                }
                                            ), 100))
                                        }
                                    )),
                                    S.appendChild(_);
                                const I = document.createElement("div");
                                I.className = "button-wrapper",
                                    d.appendChild(I);
                                const P = document.createElement("button");
                                P.className = "button",
                                    P.innerHTML = '<img class="button-icon" src="images/cancel.svg"> ',
                                    P.append(document.createTextNode(t.get("Close"))),
                                    P.addEventListener("click", ( () => {
                                            e.playUIClick();
                                            const t = g.value.trim();
                                            0 == t.length ? o(null) : o(t)
                                        }
                                    )),
                                    I.appendChild(P),
                                null != l && (nE(this, eE, document.createElement("button"), "f"),
                                    iE(this, eE, "f").disabled = null == n || 0 == n.length,
                                    iE(this, eE, "f").className = "button",
                                    iE(this, eE, "f").innerHTML = '<img class="button-icon" src="images/save.svg"> ',
                                    iE(this, eE, "f").append(document.createTextNode(t.get("Save"))),
                                    iE(this, eE, "f").addEventListener("click", ( () => {
                                            e.playUIClick();
                                            const t = g.value.trim();
                                            0 == t.length || l(t)
                                        }
                                    )),
                                    I.appendChild(iE(this, eE, "f"))),
                                    window.addEventListener("keydown", nE(this, tE, (e => {
                                            if ("Escape" == e.code) {
                                                const t = g.value.trim();
                                                0 == t.length ? o(null) : o(t),
                                                    e.preventDefault()
                                            }
                                        }
                                    ), "f"))
                            }
                            dispose() {
                                iE(this, Jk, "f").removeChild(iE(this, $k, "f")),
                                    window.removeEventListener("keydown", iE(this, tE, "f"))
                            }
                        }
                    ;
                    var aE = function(e, t, n, i) {
                        return new (n || (n = Promise))((function(r, a) {
                                function s(e) {
                                    try {
                                        l(i.next(e))
                                    } catch (e) {
                                        a(e)
                                    }
                                }
                                function o(e) {
                                    try {
                                        l(i.throw(e))
                                    } catch (e) {
                                        a(e)
                                    }
                                }
                                function l(e) {
                                    var t;
                                    e.done ? r(e.value) : (t = e.value,
                                        t instanceof n ? t : new n((function(e) {
                                                e(t)
                                            }
                                        ))).then(s, o)
                                }
                                l((i = i.apply(e, t || [])).next())
                            }
                        ))
                    };
                    let sE = null
                        , oE = null
                        , lE = null
                        , cE = null;
                    function hE(e) {
                        return aE(this, void 0, void 0, (function*() {
                                for (; null != cE; )
                                    yield cE;
                                const t = function(e) {
                                    return new Promise((t => {
                                            setTimeout(( () => {
                                                    var n;
                                                    if (null == sE || null == oE || null == lE) {
                                                        const e = document.createElement("canvas");
                                                        e.width = 128,
                                                            e.height = 128,
                                                            sE = new Kd({
                                                                canvas: e,
                                                                alpha: !0,
                                                                preserveDrawingBuffer: !0,
                                                                antialias: !0
                                                            }),
                                                            sE.outputColorSpace = vt,
                                                            lE = new Or,
                                                            oE = new Po(-1,1,1,-1,.5,yu.maxViewDistance),
                                                            oE.position.set(1e3, 1e3, 1e3),
                                                            oE.lookAt(0, 0, 0),
                                                            lE.add(oE);
                                                        const t = new Lo(16777215,4.7);
                                                        t.position.set(8, 10, 10),
                                                            lE.add(t)
                                                    }
                                                    e.geometry.computeBoundingSphere();
                                                    const i = null === (n = e.geometry.boundingSphere) || void 0 === n ? void 0 : n.clone();
                                                    if (null == i)
                                                        throw new Error("Bounding sphere is null");
                                                    oE.zoom = 1 / i.radius * .9,
                                                        oE.position.copy(i.center),
                                                        oE.position.addScalar(1e3),
                                                        oE.updateProjectionMatrix(),
                                                        sE.clear(),
                                                        lE.add(e),
                                                        sE.render(lE, oE),
                                                        lE.remove(e),
                                                        t(sE.domElement.toDataURL())
                                                }
                                            ), 25)
                                        }
                                    ))
                                }(e);
                                let n;
                                cE = t;
                                try {
                                    n = yield t
                                } finally {
                                    cE = null
                                }
                                return n
                            }
                        ))
                    }
                    var dE, uE, pE, fE, mE, gE, vE, wE, AE, yE, bE, xE, kE, EE, SE, ME, TE, CE, _E, IE, PE, RE, LE, NE, DE, BE, UE, zE, OE, FE, WE, HE, VE, GE, jE, QE, YE, qE, KE, XE, ZE, JE, $E, eS, tS, nS, iS, rS, aS, sS, oS, lS, cS, hS, dS, uS, pS, fS, mS, gS, vS, wS, AS, yS, bS, xS, kS, ES, SS, MS, TS, CS, _S, IS, PS, RS, LS, NS, DS, BS, US, zS, OS, FS, WS, HS, VS, GS, jS, QS, YS, qS, KS, XS, ZS, JS, $S, eM, tM = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, nM = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    uE = new WeakMap,
                        pE = new WeakMap,
                        fE = new WeakMap,
                        mE = new WeakMap,
                        gE = new WeakMap,
                        vE = new WeakMap,
                        wE = new WeakMap,
                        AE = new WeakMap,
                        yE = new WeakMap,
                        bE = new WeakMap,
                        xE = new WeakMap,
                        kE = new WeakMap,
                        EE = new WeakMap,
                        SE = new WeakMap,
                        ME = new WeakMap,
                        TE = new WeakMap,
                        CE = new WeakMap,
                        _E = new WeakMap,
                        IE = new WeakMap,
                        PE = new WeakMap,
                        RE = new WeakMap,
                        LE = new WeakMap,
                        NE = new WeakMap,
                        DE = new WeakMap,
                        BE = new WeakMap,
                        UE = new WeakMap,
                        zE = new WeakMap,
                        OE = new WeakMap,
                        FE = new WeakMap,
                        WE = new WeakMap,
                        HE = new WeakMap,
                        VE = new WeakMap,
                        GE = new WeakMap,
                        jE = new WeakMap,
                        QE = new WeakMap,
                        YE = new WeakMap,
                        qE = new WeakMap,
                        KE = new WeakMap,
                        XE = new WeakMap,
                        ZE = new WeakMap,
                        JE = new WeakMap,
                        $E = new WeakMap,
                        eS = new WeakMap,
                        tS = new WeakMap,
                        nS = new WeakMap,
                        iS = new WeakMap,
                        rS = new WeakMap,
                        aS = new WeakMap,
                        sS = new WeakMap,
                        oS = new WeakMap,
                        lS = new WeakMap,
                        cS = new WeakMap,
                        hS = new WeakMap,
                        dS = new WeakMap,
                        uS = new WeakMap,
                        pS = new WeakMap,
                        fS = new WeakMap,
                        mS = new WeakMap,
                        gS = new WeakMap,
                        vS = new WeakMap,
                        wS = new WeakMap,
                        AS = new WeakMap,
                        yS = new WeakMap,
                        bS = new WeakMap,
                        xS = new WeakMap,
                        kS = new WeakMap,
                        ES = new WeakMap,
                        SS = new WeakMap,
                        MS = new WeakMap,
                        TS = new WeakMap,
                        CS = new WeakMap,
                        _S = new WeakMap,
                        IS = new WeakMap,
                        PS = new WeakMap,
                        RS = new WeakMap,
                        LS = new WeakMap,
                        NS = new WeakMap,
                        dE = new WeakSet,
                        DS = function(e) {
                            var t;
                            tM(this, TS, e, "f"),
                                nM(this, WE, "f").innerHTML = '<img class="button-icon" src="images/settings.svg"> ',
                                nM(this, WE, "f").append(document.createTextNode(null !== (t = nM(this, TS, "f")) && void 0 !== t ? t : nM(this, fE, "f").get("Unnamed Track")))
                        }
                        ,
                        BS = function(e) {
                            const t = () => {
                                    nM(this, gE, "f").trigger(( () => {
                                            tM(this, oS, !0, "f"),
                                                nM(this, dE, "m", DS).call(this, null),
                                                e(),
                                                nM(this, CE, "f").inert = !1
                                        }
                                    ))
                                }
                            ;
                            nM(this, oS, "f") ? t() : (nM(this, CE, "f").inert = !0,
                                nM(this, kE, "f").showConfirm(nM(this, fE, "f").get("Are you sure you want to exit the editor?") + "\n\n" + nM(this, fE, "f").get("All unsaved data will be lost!"), nM(this, fE, "f").get("Cancel"), nM(this, fE, "f").get("Confirm"), ( () => {
                                        nM(this, CE, "f").inert = !1
                                    }
                                ), ( () => {
                                        t()
                                    }
                                )))
                        }
                        ,
                        US = function() {
                            if (null != nM(this, vE, "f").getStartTransform()) {
                                if (null == nM(this, ME, "f"))
                                    throw new Error("Test callback is null");
                                nM(this, ME, "f").call(this)
                            } else
                                nM(this, dE, "m", OS).call(this, nM(this, fE, "f").get("Starting point is missing!"), !1)
                        }
                        ,
                        zS = function() {
                            if (null != nM(this, yS, "f") && null != nM(this, PS, "f")) {
                                const e = nM(this, IS, "f")[nM(this, PS, "f")]
                                    , t = nM(this, dE, "m", ZS).call(this, nM(this, yS, "f"), e.tiles);
                                if (t.length > 0) {
                                    let e;
                                    e = nM(this, ES, "f") ? new An(nM(this, yS, "f").x + 2,nM(this, yS, "f").y,nM(this, yS, "f").z + 2) : new An(nM(this, yS, "f").x,nM(this, yS, "f").y,Math.floor(nM(this, yS, "f").z));
                                    let n = t[0]
                                        , i = e.distanceToSquared(new An(n.x,n.y,n.z));
                                    for (let r = 1; r < t.length; r++) {
                                        const a = t[r]
                                            , s = e.distanceToSquared(new An(a.x,a.y,a.z));
                                        s < i && (n = a,
                                            i = s)
                                    }
                                    const r = n.parts[n.parts.length - 1]
                                        , a = nM(this, IS, "f").findIndex((e => e.id == r.id));
                                    if (a >= 0) {
                                        const e = nM(this, IS, "f")[a];
                                        tM(this, xS, r.rotation, "f"),
                                            nM(this, zE, "f").rotation = nM(this, xS, "f"),
                                            tM(this, kS, r.rotationAxis, "f"),
                                            nM(this, zE, "f").rotationAxis = nM(this, kS, "f"),
                                            tM(this, RS, r.color, "f"),
                                            nM(this, dE, "m", GS).call(this, e.category),
                                            nM(this, dE, "m", jS).call(this, a)
                                    }
                                }
                            }
                        }
                        ,
                        OS = function(e, t) {
                            null != nM(this, PE, "f") && (clearTimeout(nM(this, PE, "f")),
                                tM(this, PE, null, "f")),
                                t ? nM(this, IE, "f").classList.add("green") : nM(this, IE, "f").classList.remove("green"),
                                nM(this, IE, "f").classList.remove("show"),
                                nM(this, IE, "f").classList.remove("hide"),
                                tM(this, PE, window.setTimeout(( () => {
                                        nM(this, IE, "f").textContent = e,
                                            nM(this, IE, "f").classList.add("show"),
                                            tM(this, PE, window.setTimeout(( () => {
                                                    nM(this, IE, "f").classList.remove("show"),
                                                        nM(this, IE, "f").classList.add("hide")
                                                }
                                            ), 3e3), "f")
                                    }
                                ), 0), "f")
                        }
                        ,
                        FS = function() {
                            var e;
                            const t = nM(this, wE, "f").getAllParts();
                            for (let n = 0; n < t.length; n++) {
                                const i = t[n]
                                    , r = i.colors.get(CA.Summer);
                                if (null == r)
                                    throw new Error("Mesh is not loaded");
                                const a = r.clone();
                                a.material = nM(this, dS, "f"),
                                    nM(this, hS, "f").add(a);
                                let s = null === (e = nM(this, LS, "f").find((e => e.category == i.configuration.category))) || void 0 === e ? void 0 : e.partPanel;
                                if (null == s) {
                                    s = document.createElement("div"),
                                        s.className = "part-panel hidden",
                                        nM(this, RE, "f").prepend(s);
                                    const e = nM(this, wE, "f").getCategoryMesh(i.configuration.category, nM(this, vE, "f").environment)
                                        , t = document.createElement("button");
                                    t.addEventListener("click", ( () => {
                                            nM(this, dE, "m", GS).call(this, i.configuration.category),
                                                nM(this, uE, "f").playUIClick()
                                        }
                                    )),
                                        nM(this, LE, "f").appendChild(t);
                                    const n = document.createElement("img");
                                    n.className = "loading",
                                        hE(e).then((e => {
                                                n.src = e,
                                                    n.className = ""
                                            }
                                        )).catch((e => {
                                                console.error(e)
                                            }
                                        )),
                                        t.appendChild(n),
                                        nM(this, LS, "f").push({
                                            category: i.configuration.category,
                                            button: t,
                                            image: n,
                                            partPanel: s,
                                            selectedIndex: null
                                        })
                                }
                                const o = document.createElement("button");
                                o.addEventListener("click", ( () => {
                                        nM(this, uE, "f").playUIClick(),
                                            nM(this, dE, "m", jS).call(this, 1 + n)
                                    }
                                )),
                                    s.appendChild(o);
                                const l = document.createElement("img");
                                l.className = "loading",
                                    o.appendChild(l);
                                const c = [];
                                let h;
                                if (i.colors.size <= 1)
                                    h = null;
                                else {
                                    h = document.createElement("div"),
                                        h.className = "color-panel hidden",
                                        nM(this, RE, "f").prepend(h);
                                    const e = [CA.Default].concat(Array.from(i.colors.keys()));
                                    for (const t of e) {
                                        const e = document.createElement("button");
                                        e.addEventListener("click", ( () => {
                                                nM(this, uE, "f").playUIClick(),
                                                    tM(this, RS, t, "f"),
                                                    e.classList.add("selected");
                                                const n = e.parentElement;
                                                if (null == n)
                                                    throw new Error("Color panel not found");
                                                for (const t of n.children)
                                                    t != e && t.classList.remove("selected")
                                            }
                                        )),
                                        t == CA.Default && e.classList.add("selected"),
                                            h.appendChild(e);
                                        const n = document.createElement("img");
                                        n.className = "loading",
                                            e.appendChild(n),
                                            c.push([t, e, n])
                                    }
                                }
                                const d = {
                                    id: i.configuration.id,
                                    selectionMesh: a,
                                    button: o,
                                    image: l,
                                    colorPanel: h,
                                    colorButtons: c,
                                    tiles: i.configuration.tiles,
                                    isCheckpoint: null != i.configuration.detector && i.configuration.detector.type == Sy.Checkpoint,
                                    isStart: null != i.configuration.startOffset,
                                    category: i.configuration.category
                                };
                                nM(this, IS, "f").push(d)
                            }
                        }
                        ,
                        WS = function() {
                            if (null == nM(this, PS, "f"))
                                return CA.Default;
                            return nM(this, IS, "f")[nM(this, PS, "f")].colorButtons.some(( ([e]) => e == nM(this, RS, "f"))) ? nM(this, RS, "f") : CA.Default
                        }
                        ,
                        HS = function(e) {
                            nM(this, vE, "f").environment = e,
                                nM(this, dE, "m", VS).call(this),
                                nM(this, vE, "f").generateMeshes()
                        }
                        ,
                        VS = function() {
                            for (const e of nM(this, LS, "f")) {
                                const t = nM(this, wE, "f").getCategoryMesh(e.category, nM(this, vE, "f").environment);
                                e.image.removeAttribute("src"),
                                    e.image.className = "loading",
                                    hE(t).then((t => {
                                            e.image.src = t,
                                                e.image.className = ""
                                        }
                                    )).catch((e => {
                                            console.error(e)
                                        }
                                    ))
                            }
                            let e;
                            switch (nM(this, vE, "f").environment) {
                                case by.Summer:
                                    e = CA.Summer;
                                    break;
                                case by.Winter:
                                    e = CA.Winter;
                                    break;
                                case by.Desert:
                                    e = CA.Desert
                            }
                            for (const t of nM(this, IS, "f"))
                                if (null != t.id)
                                    if (t.category == nM(this, NS, "f")) {
                                        const n = nM(this, wE, "f").getPart(t.id).colors.get(e);
                                        if (null == n)
                                            throw new Error("Mesh is not loaded");
                                        t.image.removeAttribute("src"),
                                            t.image.className = "loading",
                                            hE(n).then((e => {
                                                    t.image.src = e,
                                                        t.image.className = ""
                                                }
                                            )).catch((e => {
                                                    console.error(e)
                                                }
                                            ))
                                    } else
                                        t.image.removeAttribute("src"),
                                            t.image.className = "loading"
                        }
                        ,
                        GS = function(e) {
                            var t;
                            if (nM(this, NS, "f") != e || null == e) {
                                tM(this, NS, e, "f");
                                for (const t of nM(this, LS, "f"))
                                    t.category == e ? (t.button.classList.add("selected"),
                                        t.partPanel.classList.remove("hidden")) : (t.button.classList.remove("selected"),
                                        t.partPanel.classList.add("hidden"));
                                if (null == e)
                                    nM(this, dE, "m", jS).call(this, 0);
                                else {
                                    let n;
                                    switch (nM(this, vE, "f").environment) {
                                        case by.Summer:
                                            n = CA.Summer;
                                            break;
                                        case by.Winter:
                                            n = CA.Winter;
                                            break;
                                        case by.Desert:
                                            n = CA.Desert
                                    }
                                    for (const t of nM(this, IS, "f"))
                                        if (t.category == e && null != t.id && !t.image.hasAttribute("src")) {
                                            const e = nM(this, wE, "f").getPart(t.id).colors.get(n);
                                            if (null == e)
                                                throw new Error("Mesh is not loaded");
                                            t.image.className = "loading",
                                                hE(e).then((e => {
                                                        t.image.src = e,
                                                            t.image.className = ""
                                                    }
                                                )).catch((e => {
                                                        console.error(e)
                                                    }
                                                ))
                                        }
                                    let i = null === (t = nM(this, LS, "f").find((t => t.category == e))) || void 0 === t ? void 0 : t.selectedIndex;
                                    if (null == i && (i = nM(this, IS, "f").findIndex((t => t.category == e)),
                                    i < 0))
                                        throw new Error("Empty category");
                                    nM(this, dE, "m", jS).call(this, i)
                                }
                            }
                        }
                        ,
                        jS = function(e) {
                            for (let t = 0; t < nM(this, IS, "f").length; t++) {
                                const {selectionMesh: n, button: i, colorPanel: r} = nM(this, IS, "f")[t];
                                t == e ? (n.visible = !0,
                                    i.className = "selected",
                                null == r || r.classList.remove("hidden")) : (n.visible = !1,
                                    i.className = "",
                                null == r || r.classList.add("hidden"))
                            }
                            tM(this, PS, e, "f");
                            const t = nM(this, LS, "f").find((e => e.category == nM(this, NS, "f")));
                            if (null != t && (t.selectedIndex = e),
                            null != nM(this, fS, "f")) {
                                if (nM(this, hS, "f").remove(nM(this, fS, "f")),
                                    nM(this, fS, "f").geometry.dispose(),
                                    Array.isArray(nM(this, fS, "f").material))
                                    for (const e of nM(this, fS, "f").material)
                                        e.dispose();
                                else
                                    nM(this, fS, "f").material.dispose();
                                nM(this, fS, "f").dispose(),
                                    tM(this, fS, null, "f")
                            }
                            if (null != e && e >= 0 && e < nM(this, IS, "f").length) {
                                const t = nM(this, IS, "f")[e];
                                t.isCheckpoint ? nM(this, DE, "f").show() : nM(this, DE, "f").hide();
                                const n = new ua(nM(this, pS, "f"),nM(this, uS, "f"),t.tiles.length);
                                t.tiles.forEach(( (e, t, i, r) => {
                                        const a = (new Kn).makeTranslation(e * yb.partSize, t * yb.partSize, i * yb.partSize);
                                        n.setMatrixAt(r, a)
                                    }
                                )),
                                    nM(this, hS, "f").add(n),
                                    tM(this, fS, n, "f");
                                const i = nM(this, dE, "m", WS).call(this);
                                if (null != t.id)
                                    for (const [e,n,r] of t.colorButtons)
                                        if (e == i ? n.classList.add("selected") : n.classList.remove("selected"),
                                            !r.hasAttribute("src"))
                                            if (e == CA.Default)
                                                r.src = "images/empty.svg",
                                                    r.className = "";
                                            else {
                                                const n = nM(this, wE, "f").getPart(t.id).colors.get(e);
                                                if (null == n)
                                                    throw new Error("Mesh is not loaded");
                                                r.className = "loading",
                                                    hE(n).then((e => {
                                                            r.src = e,
                                                                r.className = ""
                                                        }
                                                    )).catch((e => {
                                                            console.error(e)
                                                        }
                                                    ))
                                            }
                            } else
                                nM(this, DE, "f").hide();
                            nM(this, dE, "m", qS).call(this)
                        }
                        ,
                        QS = function() {
                            return Math.floor(nM(this, cS, "f").position.y / 5)
                        }
                        ,
                        YS = function(e) {
                            const t = nM(this, dE, "a", QS);
                            nM(this, cS, "f").position.y = 5 * e,
                                nM(this, JE, "f").position.y += 5 * (e - t),
                                nM(this, $E, "f").target.y = 5 * e,
                                nM(this, NE, "f").refresh(e),
                                nM(this, cS, "f").updateWorldMatrix(!0, !0),
                                nM(this, $E, "f").update()
                        }
                        ,
                        qS = function() {
                            if (null != nM(this, PS, "f") && nM(this, PS, "f") >= 0 && nM(this, PS, "f") < nM(this, IS, "f").length) {
                                const e = nM(this, IS, "f")[nM(this, PS, "f")];
                                tM(this, bS, 0, "f"),
                                    e.tiles.rotated(nM(this, xS, "f"), nM(this, kS, "f")).forEach(( (e, t) => {
                                            tM(this, bS, Math.max(nM(this, bS, "f"), -t), "f")
                                        }
                                    ))
                            } else
                                tM(this, bS, 0, "f")
                        }
                        ,
                        KS = function() {
                            const e = performance.now();
                            if (e - nM(this, pE, "f") > 35) {
                                const t = nM(this, uE, "f").getBuffer("editor_edit");
                                if (null != t && null != nM(this, uE, "f").context && null != nM(this, uE, "f").destinationSfx) {
                                    const e = nM(this, uE, "f").context.createBufferSource();
                                    e.buffer = t,
                                        e.playbackRate.value = .7;
                                    const n = nM(this, uE, "f").context.createGain();
                                    n.gain.value = .05,
                                        e.connect(n),
                                        n.connect(nM(this, uE, "f").destinationSfx),
                                        e.start(0)
                                }
                                tM(this, pE, e, "f")
                            }
                        }
                        ,
                        XS = function() {
                            let e;
                            if (nM(this, EE, "f").touchEnabled)
                                e = new An(nM(this, $E, "f").target.x / yb.partSize,nM(this, $E, "f").target.y / yb.partSize,nM(this, $E, "f").target.z / yb.partSize);
                            else {
                                let t;
                                if (null != nM(this, vS, "f") ? (nM(this, lS, "f").setFromCamera(nM(this, vS, "f"), nM(this, mE, "f").camera),
                                    t = nM(this, lS, "f").intersectObjects([nM(this, cS, "f")])) : t = [],
                                t.length > 0) {
                                    const n = t[0];
                                    e = n.point.distanceToSquared(nM(this, $E, "f").target) <= nM(this, CS, "f") * nM(this, CS, "f") ? new An(Math.round(n.point.x / yb.partSize),Math.floor(nM(this, cS, "f").position.y / yb.partSize),Math.round(n.point.z / yb.partSize)) : null
                                } else
                                    e = null
                            }
                            if (null != e) {
                                let t, n;
                                t = nM(this, ES, "f") ? 4 : 1,
                                    n = nM(this, kS, "f") == RA.XPositive || nM(this, kS, "f") == RA.XNegative ? Math.round(e.x) : Math.round(e.x / t) * t;
                                const i = Math.round(e.y) + nM(this, bS, "f");
                                let r;
                                return r = nM(this, kS, "f") == RA.ZPositive || nM(this, kS, "f") == RA.ZNegative ? Math.round(e.z) : Math.round(e.z / t) * t,
                                    new An(n,i,r)
                            }
                            return null
                        }
                        ,
                        ZS = function(e, t) {
                            const n = [];
                            return t.rotated(nM(this, xS, "f"), nM(this, kS, "f")).forEach(( (t, i, r) => {
                                    const a = e.x + t
                                        , s = e.y + i
                                        , o = e.z + r
                                        , l = nM(this, vE, "f").getPartsAt(a, s, o);
                                    l.length > 0 && n.push({
                                        x: a,
                                        y: s,
                                        z: o,
                                        parts: l
                                    })
                                }
                            )),
                                n
                        }
                        ,
                        JS = function(e) {
                            var t;
                            let n = !1;
                            for (const {x: t, y: i, z: r} of e)
                                nM(this, vE, "f").deletePartsAt(t, i, r) && (n = !0);
                            n && (nM(this, dE, "m", KS).call(this),
                                nM(this, vE, "f").generateMeshes(),
                            null === (t = nM(this, _S, "f")) || void 0 === t || t.refresh(nM(this, vE, "f")),
                                nM(this, DE, "f").setFromExistingCheckpoints(nM(this, vE, "f")),
                                tM(this, oS, !1, "f"))
                        }
                        ,
                        $S = function(e) {
                            const t = 4 * nM(this, $E, "f").getDistance();
                            if (nM(this, TE, "f") && nM(this, dE, "m", eM).call(this)) {
                                const n = new An;
                                if (nM(this, tS, "f") && (n.z = -1),
                                nM(this, nS, "f") && (n.x = 1),
                                nM(this, iS, "f") && (n.z = 1),
                                nM(this, rS, "f") && (n.x = -1),
                                0 != n.x || 0 != n.z) {
                                    const i = n.applyQuaternion(nM(this, JE, "f").quaternion)
                                        , r = new jt(i.x,i.z).normalize()
                                        , a = new An(r.x,0,r.y).multiplyScalar(t * e);
                                    nM(this, JE, "f").position.add(a),
                                        nM(this, $E, "f").target.add(a)
                                }
                                let i = 0;
                                if (nM(this, aS, "f") && (i += 1.5 * Math.PI * e),
                                nM(this, sS, "f") && (i -= 1.5 * Math.PI * e),
                                0 != i) {
                                    const e = new jt(nM(this, JE, "f").position.x,nM(this, JE, "f").position.z).distanceTo(new jt(nM(this, $E, "f").target.x,nM(this, $E, "f").target.z))
                                        , t = Math.atan2(nM(this, JE, "f").position.z - nM(this, $E, "f").target.z, nM(this, JE, "f").position.x - nM(this, $E, "f").target.x) + i;
                                    nM(this, JE, "f").position.x = nM(this, $E, "f").target.x + Math.cos(t) * e,
                                        nM(this, JE, "f").position.z = nM(this, $E, "f").target.z + Math.sin(t) * e,
                                        nM(this, $E, "f").update()
                                }
                            }
                        }
                        ,
                        eM = function() {
                            return !!nM(this, TE, "f") && (!nM(this, kE, "f").isOpen && null == nM(this, UE, "f") && !nM(this, BE, "f").isOpen && null == nM(this, OE, "f") && null == nM(this, FE, "f"))
                        }
                    ;
                    const iM = class {
                            constructor(e, t, n, i, r, a, s, o, l, c, h, d, u, p) {
                                var f;
                                dE.add(this),
                                    uE.set(this, void 0),
                                    pE.set(this, performance.now()),
                                    fE.set(this, void 0),
                                    mE.set(this, void 0),
                                    gE.set(this, void 0),
                                    vE.set(this, void 0),
                                    wE.set(this, void 0),
                                    AE.set(this, void 0),
                                    yE.set(this, void 0),
                                    bE.set(this, void 0),
                                    xE.set(this, void 0),
                                    kE.set(this, void 0),
                                    EE.set(this, void 0),
                                    SE.set(this, void 0),
                                    ME.set(this, null),
                                    TE.set(this, !1),
                                    CE.set(this, void 0),
                                    _E.set(this, void 0),
                                    IE.set(this, void 0),
                                    PE.set(this, null),
                                    RE.set(this, void 0),
                                    LE.set(this, void 0),
                                    NE.set(this, void 0),
                                    DE.set(this, void 0),
                                    BE.set(this, void 0),
                                    UE.set(this, null),
                                    zE.set(this, void 0),
                                    OE.set(this, null),
                                    FE.set(this, null),
                                    WE.set(this, void 0),
                                    HE.set(this, void 0),
                                    VE.set(this, void 0),
                                    GE.set(this, void 0),
                                    jE.set(this, void 0),
                                    QE.set(this, void 0),
                                    YE.set(this, void 0),
                                    qE.set(this, void 0),
                                    KE.set(this, void 0),
                                    XE.set(this, void 0),
                                    ZE.set(this, void 0),
                                    JE.set(this, void 0),
                                    $E.set(this, void 0),
                                    eS.set(this, !1),
                                    tS.set(this, !1),
                                    nS.set(this, !1),
                                    iS.set(this, !1),
                                    rS.set(this, !1),
                                    aS.set(this, !1),
                                    sS.set(this, !1),
                                    oS.set(this, !0),
                                    lS.set(this, void 0),
                                    cS.set(this, void 0),
                                    hS.set(this, void 0),
                                    dS.set(this, void 0),
                                    uS.set(this, void 0),
                                    pS.set(this, void 0),
                                    fS.set(this, null),
                                    mS.set(this, !1),
                                    gS.set(this, !1),
                                    vS.set(this, null),
                                    wS.set(this, null),
                                    AS.set(this, !1),
                                    yS.set(this, null),
                                    bS.set(this, 0),
                                    xS.set(this, 0),
                                    kS.set(this, RA.YPositive),
                                    ES.set(this, !0),
                                    SS.set(this, !1),
                                    MS.set(this, null),
                                    TS.set(this, null),
                                    CS.set(this, 1e3),
                                    _S.set(this, null),
                                    IS.set(this, []),
                                    PS.set(this, null),
                                    RS.set(this, CA.Default),
                                    LS.set(this, []),
                                    NS.set(this, null),
                                    tM(this, fE, e, "f"),
                                    tM(this, uE, t, "f"),
                                    tM(this, mE, n, "f"),
                                    tM(this, gE, i, "f"),
                                    tM(this, vE, r, "f"),
                                    tM(this, wE, a, "f"),
                                    tM(this, bE, s, "f"),
                                    tM(this, xE, o, "f"),
                                    tM(this, AE, l, "f"),
                                    tM(this, yE, c, "f"),
                                    tM(this, kE, h, "f"),
                                    tM(this, EE, d, "f"),
                                    tM(this, SE, u, "f"),
                                    tM(this, JE, new Ir(70,1,.5,yu.maxViewDistance), "f"),
                                    nM(this, JE, "f").position.set(40, 40, -40),
                                    n.scene.add(nM(this, JE, "f")),
                                    tM(this, $E, new Cw(nM(this, JE, "f"),n.canvas), "f"),
                                    nM(this, $E, "f").mouseButtons = {
                                        MIDDLE: g,
                                        RIGHT: w
                                    },
                                    nM(this, $E, "f").minDistance = 4,
                                    nM(this, $E, "f").maxDistance = 600,
                                    tM(this, lS, new jo, "f"),
                                    this.trackAuthor = o.getCurrentUserProfile().nickname,
                                    tM(this, dS, new Fs({
                                        transparent: !0,
                                        opacity: .3,
                                        polygonOffset: !0,
                                        polygonOffsetFactor: -.3,
                                        depthWrite: !1
                                    }), "f"),
                                tM(this, hS, new Dr, "f"),
                                nM(this, hS, "f").visible = !1,
                                n.scene.add(nM(this, hS, "f")),
                                tM(this, pS, (new sr).setFromPoints([new An(0,0,0), new An(0,0,0), new An(0,0,1), new An(0,0,1), new An(0,0,1), new An(1,0,1), new An(1,0,1), new An(1,0,1), new An(1,0,0), new An(1,0,0), new An(1,0,0), new An(0,0,0), new An(0,1,0), new An(0,1,0), new An(0,1,1), new An(0,1,1), new An(0,1,1), new An(1,1,1), new An(1,1,1), new An(1,1,1), new An(1,1,0), new An(1,1,0), new An(1,1,0), new An(0,1,0), new An(0,0,0), new An(0,0,0), new An(0,1,0), new An(0,0,1), new An(0,0,1), new An(0,1,1), new An(1,0,1), new An(1,0,1), new An(1,1,1), new An(1,0,0), new An(1,0,0), new An(1,1,0)]).scale(yb.partSize, yb.partSize, yb.partSize), "f"),
                                tM(this, uS, new ji({
                                    wireframe: !0
                                }), "f"),
                                tM(this, cS, new wr(new Ds(1e6,1e6),new ji({
                                    side: 2
                                })), "f"),
                                nM(this, cS, "f").rotation.x = -Math.PI / 2,
                                nM(this, cS, "f").updateWorldMatrix(!0, !0),
                                n.canvas.addEventListener("mousemove", tM(this, HE, (e => {
                                        const t = e.clientX / window.innerWidth * 2 - 1
                                            , n = -e.clientY / window.innerHeight * 2 + 1;
                                        null == nM(this, vS, "f") ? tM(this, vS, new jt(t,n), "f") : nM(this, vS, "f").set(t, n)
                                    }
                                ), "f")),
                                n.canvas.addEventListener("mousedown", tM(this, VE, (e => {
                                        0 == e.button && tM(this, gS, !0, "f"),
                                        1 == e.button && e.preventDefault()
                                    }
                                ), "f")),
                                window.addEventListener("mouseup", tM(this, GE, (e => {
                                        0 == e.button && (tM(this, gS, !1, "f"),
                                            tM(this, MS, null, "f"))
                                    }
                                ), "f")),
                                n.canvas.addEventListener("mouseout", tM(this, jE, ( () => {
                                        tM(this, vS, null, "f")
                                    }
                                ), "f")),
                                n.canvas.addEventListener("touchstart", tM(this, QE, ( () => {
                                        nM(this, EE, "f").touchEnabled && tM(this, wS, Date.now(), "f")
                                    }
                                ), "f")),
                                n.canvas.addEventListener("click", tM(this, YE, ( () => {
                                        nM(this, EE, "f").touchEnabled && null != nM(this, wS, "f") && Date.now() - nM(this, wS, "f") < 200 && (tM(this, wS, null, "f"),
                                            tM(this, AS, !0, "f"))
                                    }
                                ), "f")),
                                window.addEventListener("keydown", tM(this, qE, (e => {
                                        nM(this, dE, "m", eM).call(this) && (nM(this, kE, "f").isOpen || nM(this, BE, "f").isOpen || null != nM(this, UE, "f") || null != nM(this, OE, "f") || "Escape" == e.code && (nM(this, dE, "m", BS).call(this, p),
                                            e.preventDefault()),
                                        u.checkKeyBinding(e, sx.EditorRotatePart) && (tM(this, xS, (nM(this, xS, "f") + 1) % 4, "f"),
                                            nM(this, zE, "f").rotation = nM(this, xS, "f"),
                                            nM(this, dE, "m", qS).call(this),
                                            e.preventDefault()),
                                        u.checkKeyBinding(e, sx.EditorHeightModifier) && (tM(this, eS, !0, "f"),
                                            nM(this, $E, "f").enableZoom = !1,
                                            e.preventDefault()),
                                        u.checkKeyBinding(e, sx.EditorDelete) && (tM(this, mS, !0, "f"),
                                            e.preventDefault()),
                                        u.checkKeyBinding(e, sx.EditorMoveForwards) && (tM(this, tS, !0, "f"),
                                            e.preventDefault()),
                                        u.checkKeyBinding(e, sx.EditorMoveRight) && (tM(this, nS, !0, "f"),
                                            e.preventDefault()),
                                        u.checkKeyBinding(e, sx.EditorMoveBackwards) && (tM(this, iS, !0, "f"),
                                            e.preventDefault()),
                                        u.checkKeyBinding(e, sx.EditorMoveLeft) && (tM(this, rS, !0, "f"),
                                            e.preventDefault()),
                                        u.checkKeyBinding(e, sx.EditorRotateViewLeft) && (tM(this, aS, !0, "f"),
                                            e.preventDefault()),
                                        u.checkKeyBinding(e, sx.EditorRotateViewRight) && (tM(this, sS, !0, "f"),
                                            e.preventDefault()),
                                        u.checkKeyBinding(e, sx.EditorMoveDown) && (tM(this, dE, Math.max(0, nM(this, dE, "a", QS) - 1), "a", YS),
                                            e.preventDefault()),
                                        u.checkKeyBinding(e, sx.EditorMoveUp) && (tM(this, dE, nM(this, dE, "a", QS) + 1, "a", YS),
                                            e.preventDefault()),
                                        u.checkKeyBinding(e, sx.EditorTest) && (nM(this, dE, "m", US).call(this),
                                            e.preventDefault()),
                                        u.checkKeyBinding(e, sx.EditorPick) && (nM(this, dE, "m", zS).call(this),
                                            e.preventDefault()))
                                    }
                                ), "f")),
                                window.addEventListener("keyup", tM(this, KE, (e => {
                                        u.checkKeyBinding(e, sx.EditorHeightModifier) && (tM(this, eS, !1, "f"),
                                            nM(this, $E, "f").enableZoom = !0),
                                        u.checkKeyBinding(e, sx.EditorDelete) && tM(this, mS, !1, "f"),
                                        u.checkKeyBinding(e, sx.EditorMoveForwards) && tM(this, tS, !1, "f"),
                                        u.checkKeyBinding(e, sx.EditorMoveRight) && tM(this, nS, !1, "f"),
                                        u.checkKeyBinding(e, sx.EditorMoveBackwards) && tM(this, iS, !1, "f"),
                                        u.checkKeyBinding(e, sx.EditorMoveLeft) && tM(this, rS, !1, "f"),
                                        u.checkKeyBinding(e, sx.EditorRotateViewLeft) && tM(this, aS, !1, "f"),
                                        u.checkKeyBinding(e, sx.EditorRotateViewRight) && tM(this, sS, !1, "f")
                                    }
                                ), "f")),
                                window.addEventListener("wheel", tM(this, XE, (e => {
                                        nM(this, eS, "f") && nM(this, TE, "f") && (e.deltaY > 0 ? tM(this, dE, nM(this, dE, "a", QS) + 1, "a", YS) : e.deltaY < 0 && tM(this, dE, Math.max(0, nM(this, dE, "a", QS) - 1), "a", YS))
                                    }
                                ), "f")),
                                window.addEventListener("beforeunload", tM(this, ZE, (e => !nM(this, oS, "f") && (e.preventDefault(),
                                    !0)), "f"));
                                const m = document.getElementById("ui");
                                if (null == m)
                                    throw new Error("Failed to find UI element");
                                tM(this, CE, document.createElement("div"), "f"),
                                    nM(this, CE, "f").className = "hidden",
                                    m.appendChild(nM(this, CE, "f")),
                                    tM(this, _E, document.createElement("div"), "f"),
                                    nM(this, _E, "f").className = "top",
                                    nM(this, CE, "f").appendChild(nM(this, _E, "f"));
                                const v = document.createElement("div");
                                v.className = "button-bar",
                                    nM(this, _E, "f").appendChild(v);
                                const A = document.createElement("button");
                                A.className = "button",
                                    A.innerHTML = '<img class="button-icon" src="images/quit.svg"> ',
                                    A.append(document.createTextNode(nM(this, fE, "f").get("Exit"))),
                                    A.addEventListener("click", ( () => {
                                            nM(this, uE, "f").playUIClick(),
                                                nM(this, dE, "m", BS).call(this, p)
                                        }
                                    )),
                                    v.appendChild(A);
                                const y = document.createElement("button");
                                y.className = "button",
                                    y.innerHTML = '<img class="button-icon" src="images/test.svg"> ',
                                    y.append(nM(this, fE, "f").get("Test")),
                                    y.addEventListener("click", ( () => {
                                            nM(this, uE, "f").playUIClick(),
                                                nM(this, dE, "m", US).call(this)
                                        }
                                    )),
                                    v.appendChild(y);
                                const b = document.createElement("button");
                                b.className = "button",
                                    b.innerHTML = '<img class="button-icon" src="images/random.svg"> ',
                                    b.append(nM(this, fE, "f").get("Generate")),
                                    b.addEventListener("click", ( () => {
                                            nM(this, uE, "f").playUIClick();
                                            const e = () => {
                                                    var e;
                                                    !function(e) {
                                                        let t;
                                                        e.clear();
                                                        do {
                                                            let n = 0
                                                                , i = 0
                                                                , r = 0
                                                                , a = Math.floor(4 * Math.random());
                                                            Math.random() < .5 && (i = Math.floor(20 * Math.random()));
                                                            const s = new Map;
                                                            function o() {
                                                                switch (a) {
                                                                    case 0:
                                                                        --r;
                                                                        break;
                                                                    case 1:
                                                                        --n;
                                                                        break;
                                                                    case 2:
                                                                        ++r;
                                                                        break;
                                                                    case 3:
                                                                        ++n
                                                                }
                                                            }
                                                            function l() {
                                                                switch (a) {
                                                                    case 0:
                                                                        ++r;
                                                                        break;
                                                                    case 1:
                                                                        ++n;
                                                                        break;
                                                                    case 2:
                                                                        --r;
                                                                        break;
                                                                    case 3:
                                                                        --n
                                                                }
                                                            }
                                                            function c() {
                                                                switch ((a + 1) % 4) {
                                                                    case 0:
                                                                        --r;
                                                                        break;
                                                                    case 1:
                                                                        --n;
                                                                        break;
                                                                    case 2:
                                                                        ++r;
                                                                        break;
                                                                    case 3:
                                                                        ++n
                                                                }
                                                            }
                                                            function h() {
                                                                switch (((a - 1) % 4 + 4) % 4) {
                                                                    case 0:
                                                                        --r;
                                                                        break;
                                                                    case 1:
                                                                        --n;
                                                                        break;
                                                                    case 2:
                                                                        ++r;
                                                                        break;
                                                                    case 3:
                                                                        ++n
                                                                }
                                                            }
                                                            function d(e, n, i, r=null) {
                                                                const a = e.toString() + "|" + n.toString() + "|" + i.toString();
                                                                s.has(a) && (t = !0),
                                                                null != r && (r.x = e,
                                                                    r.y = n,
                                                                    r.z = i,
                                                                "direction"in r && (r.direction = (r.direction % 4 + 4) % 4)),
                                                                    s.set(a, r)
                                                            }
                                                            function u(e, t, n) {
                                                                return !!s.has(e.toString() + "|" + t.toString() + "|" + n.toString())
                                                            }
                                                            function p() {
                                                                let e = !1;
                                                                for (let t = 0; t < i; ++t)
                                                                    if (u(n, t, r)) {
                                                                        e = !0;
                                                                        break
                                                                    }
                                                                if (!e)
                                                                    for (let e = 0; e < i; ++e) {
                                                                        let t;
                                                                        t = 0 == e && e == i - 1 ? 22 : 0 == e ? 21 : e == i - 1 ? 19 : 20,
                                                                            d(n, e, r, {
                                                                                type: t,
                                                                                direction: 0
                                                                            })
                                                                    }
                                                            }
                                                            function f(e) {
                                                                e > 0 ? (--e,
                                                                    Math.random() < .2 ? E(e) : Math.random() < .6 ? g(e) : Math.random() < .5 ? A(e, i < 2 || Math.random() < .5) : Math.random() < .5 ? v(e) : w(e)) : x()
                                                            }
                                                            function m(e) {
                                                                e > 0 ? (--e,
                                                                    Math.random() < .1 ? S(e) : Math.random() < .6 ? M(e) : Math.random() < .5 ? _(e, i < 2 || Math.random() < .5) : Math.random() < .5 ? T(e) : C(e)) : S(e)
                                                            }
                                                            function g(e) {
                                                                d(n, i, r, {
                                                                    type: 0,
                                                                    direction: a
                                                                }),
                                                                    p(),
                                                                    o(),
                                                                    f(e)
                                                            }
                                                            function v(e) {
                                                                d(n, i, r, {
                                                                    type: 1,
                                                                    direction: a - 1
                                                                }),
                                                                    p(),
                                                                    a = (a + 1) % 4,
                                                                    o(),
                                                                    e > 0 ? (--e,
                                                                        Math.random() < .4 ? g(e) : Math.random() < .5 ? v(e) : w(e)) : x()
                                                            }
                                                            function w(e) {
                                                                d(n, i, r, {
                                                                    type: 1,
                                                                    direction: a
                                                                }),
                                                                    p(),
                                                                    a = ((a - 1) % 4 + 4) % 4,
                                                                    o(),
                                                                    e > 0 ? (--e,
                                                                        Math.random() < .4 ? g(e) : Math.random() < .5 ? v(e) : w(e)) : x()
                                                            }
                                                            function A(e, t) {
                                                                let s;
                                                                s = t ? 2 : 3,
                                                                t || --i,
                                                                    d(n, i + 1, r),
                                                                    d(n, i, r, {
                                                                        type: s,
                                                                        direction: a
                                                                    }),
                                                                    o(),
                                                                t && ++i,
                                                                    e > 0 ? (--e,
                                                                        Math.random() < .4 || i <= 3 ? y(e, t) : b(e, t)) : y(e, t)
                                                            }
                                                            function y(e, t) {
                                                                let s;
                                                                t || --i,
                                                                    d(n, i + 1, r),
                                                                    s = t ? 3 : 2,
                                                                    d(n, i, r, {
                                                                        type: s,
                                                                        direction: a + 2
                                                                    }),
                                                                    o(),
                                                                t && ++i,
                                                                    e > 0 ? f(--e) : x()
                                                            }
                                                            function b(e, t) {
                                                                let s;
                                                                t || (i -= 2),
                                                                    d(n, i + 1, r),
                                                                    d(n, i + 2, r),
                                                                    s = t ? a : a + 2,
                                                                    d(n, i, r, {
                                                                        type: 4,
                                                                        direction: s
                                                                    }),
                                                                    o(),
                                                                t && (i += 2),
                                                                    e > 0 ? (--e,
                                                                        Math.random() < .4 || i <= 3 ? y(e, t) : b(e, t)) : y(e, t)
                                                            }
                                                            function x() {
                                                                d(n, i, r, {
                                                                    type: 6,
                                                                    direction: a
                                                                })
                                                            }
                                                            function k(e) {
                                                                d(n, i, r, {
                                                                    type: 5,
                                                                    direction: a
                                                                }),
                                                                    p(),
                                                                    o(),
                                                                    f(e)
                                                            }
                                                            function E(e) {
                                                                Math.random() < .5 ? (d(n, i, r, {
                                                                    type: 8,
                                                                    direction: a
                                                                }),
                                                                    p(),
                                                                    h(),
                                                                    d(n, i, r, {
                                                                        type: 12,
                                                                        direction: a + 2
                                                                    }),
                                                                    p(),
                                                                    o()) : (d(n, i, r, {
                                                                    type: 9,
                                                                    direction: a
                                                                }),
                                                                    p(),
                                                                    c(),
                                                                    d(n, i, r, {
                                                                        type: 12,
                                                                        direction: a + 1
                                                                    }),
                                                                    p(),
                                                                    o(),
                                                                    h()),
                                                                    m(e)
                                                            }
                                                            function S(e) {
                                                                Math.random() < .5 ? (d(n, i, r, {
                                                                    type: 12,
                                                                    direction: a + 3
                                                                }),
                                                                    p(),
                                                                    c(),
                                                                    d(n, i, r, {
                                                                        type: 9,
                                                                        direction: a + 2
                                                                    }),
                                                                    p(),
                                                                    o()) : (d(n, i, r, {
                                                                    type: 8,
                                                                    direction: a + 2
                                                                }),
                                                                    p(),
                                                                    c(),
                                                                    d(n, i, r, {
                                                                        type: 12,
                                                                        direction: a
                                                                    }),
                                                                    p(),
                                                                    o(),
                                                                    h()),
                                                                    f(e)
                                                            }
                                                            function M(e) {
                                                                d(n, i, r, {
                                                                    type: 10,
                                                                    direction: a
                                                                }),
                                                                    p(),
                                                                    c(),
                                                                    d(n, i, r, {
                                                                        type: 10,
                                                                        direction: a + 2
                                                                    }),
                                                                    p(),
                                                                    h(),
                                                                    o(),
                                                                    m(e)
                                                            }
                                                            function T(e) {
                                                                d(n, i, r, {
                                                                    type: 10,
                                                                    direction: a
                                                                }),
                                                                    p(),
                                                                    o(),
                                                                    d(n, i, r, {
                                                                        type: 12,
                                                                        direction: a + 3
                                                                    }),
                                                                    p(),
                                                                    c(),
                                                                    d(n, i, r, {
                                                                        type: 10,
                                                                        direction: a + 1
                                                                    }),
                                                                    p(),
                                                                    l(),
                                                                    d(n, i, r, {
                                                                        type: 11,
                                                                        direction: a + 3
                                                                    }),
                                                                    p(),
                                                                    o(),
                                                                    a = (a + 1) % 4,
                                                                    o(),
                                                                    m(e)
                                                            }
                                                            function C(e) {
                                                                d(n, i, r, {
                                                                    type: 11,
                                                                    direction: a
                                                                }),
                                                                    p(),
                                                                    c(),
                                                                    d(n, i, r, {
                                                                        type: 10,
                                                                        direction: a + 2
                                                                    }),
                                                                    p(),
                                                                    o(),
                                                                    d(n, i, r, {
                                                                        type: 12,
                                                                        direction: a
                                                                    }),
                                                                    p(),
                                                                    h(),
                                                                    d(n, i, r, {
                                                                        type: 10,
                                                                        direction: a + 1
                                                                    }),
                                                                    p(),
                                                                    l(),
                                                                    a = ((a - 1) % 4 + 4) % 4,
                                                                    o(),
                                                                    m(e)
                                                            }
                                                            function _(e, t) {
                                                                let s, l;
                                                                t ? (s = 13,
                                                                    l = 14) : (s = 15,
                                                                    l = 16),
                                                                t || --i,
                                                                    c(),
                                                                    d(n, i + 1, r),
                                                                    d(n, i, r, {
                                                                        type: s,
                                                                        direction: a
                                                                    }),
                                                                    h(),
                                                                    d(n, i + 1, r),
                                                                    d(n, i, r, {
                                                                        type: l,
                                                                        direction: a
                                                                    }),
                                                                    o(),
                                                                t && ++i,
                                                                    e > 0 ? (--e,
                                                                        Math.random() < .4 || i <= 3 ? I(e, t) : P(e, t)) : I(e, t)
                                                            }
                                                            function I(e, t) {
                                                                let s, l;
                                                                t || --i,
                                                                    t ? (s = 16,
                                                                        l = 15) : (s = 14,
                                                                        l = 13),
                                                                    c(),
                                                                    d(n, i + 1, r),
                                                                    d(n, i, r, {
                                                                        type: s,
                                                                        direction: a + 2
                                                                    }),
                                                                    h(),
                                                                    d(n, i + 1, r),
                                                                    d(n, i, r, {
                                                                        type: l,
                                                                        direction: a + 2
                                                                    }),
                                                                    o(),
                                                                t && ++i,
                                                                    m(e)
                                                            }
                                                            function P(e, t) {
                                                                t || (i -= 2),
                                                                    t ? (c(),
                                                                        d(n, i + 1, r),
                                                                        d(n, i + 2, r),
                                                                        d(n, i, r, {
                                                                            type: 17,
                                                                            direction: a
                                                                        }),
                                                                        h(),
                                                                        d(n, i + 1, r),
                                                                        d(n, i + 2, r),
                                                                        d(n, i, r, {
                                                                            type: 18,
                                                                            direction: a
                                                                        })) : (c(),
                                                                        d(n, i + 1, r),
                                                                        d(n, i + 2, r),
                                                                        d(n, i, r, {
                                                                            type: 18,
                                                                            direction: a + 2
                                                                        }),
                                                                        h(),
                                                                        d(n, i + 1, r),
                                                                        d(n, i + 2, r),
                                                                        d(n, i, r, {
                                                                            type: 17,
                                                                            direction: a + 2
                                                                        })),
                                                                    o(),
                                                                t && (i += 2),
                                                                    e > 0 ? (--e,
                                                                        Math.random() < .4 || i <= 3 ? I(e, t) : P(e, t)) : I(e, t)
                                                            }
                                                            if (t = !1,
                                                                k(50),
                                                                !t)
                                                                for (const R of s.values())
                                                                    if (null != R) {
                                                                        let L = null;
                                                                        R.type == IA.Start && (L = 0),
                                                                            e.setPart(4 * R.x, R.y, 4 * R.z, R.type, R.direction, RA.YPositive, CA.Default, null, L)
                                                                    }
                                                        } while (t)
                                                    }(nM(this, vE, "f")),
                                                        nM(this, vE, "f").generateMeshes(),
                                                    null === (e = nM(this, _S, "f")) || void 0 === e || e.refresh(nM(this, vE, "f")),
                                                        nM(this, DE, "f").setFromExistingCheckpoints(nM(this, vE, "f")),
                                                        tM(this, oS, !0, "f")
                                                }
                                            ;
                                            nM(this, oS, "f") ? e() : (nM(this, CE, "f").inert = !0,
                                                nM(this, kE, "f").showConfirm(nM(this, fE, "f").get("Are you sure you want to generate a new track?\n\nYour current track will be lost!"), nM(this, fE, "f").get("Cancel"), nM(this, fE, "f").get("Confirm"), ( () => {
                                                        nM(this, CE, "f").inert = !1
                                                    }
                                                ), ( () => {
                                                        e(),
                                                            nM(this, CE, "f").inert = !1
                                                    }
                                                )))
                                        }
                                    )),
                                    v.appendChild(b),
                                    tM(this, BE, new Ck(m,nM(this, fE, "f"),nM(this, uE, "f"),nM(this, AE, "f"),nM(this, yE, "f"),nM(this, xE, "f"),nM(this, kE, "f"),nM(this, bE, "f"),!0,( () => {
                                            nM(this, CE, "f").className = "editor",
                                                nM(this, BE, "f").hide()
                                        }
                                    ),( (e, t) => {
                                            var n;
                                            const i = nM(this, vE, "f").environment;
                                            nM(this, vE, "f").loadTrackData(t, !1),
                                            nM(this, vE, "f").environment != i && nM(this, dE, "m", VS).call(this),
                                                nM(this, vE, "f").generateMeshes(),
                                            null === (n = nM(this, _S, "f")) || void 0 === n || n.refresh(nM(this, vE, "f")),
                                                nM(this, DE, "f").setFromExistingCheckpoints(nM(this, vE, "f")),
                                                tM(this, oS, !0, "f"),
                                                nM(this, dE, "m", DS).call(this, e.name),
                                                this.trackAuthor = e.author;
                                            const r = nM(this, vE, "f").getStart();
                                            if (null != r)
                                                this.resetView(r.x, r.y, r.z);
                                            else {
                                                const e = nM(this, vE, "f").getBounds();
                                                this.resetView(e.min.x + Math.floor((e.max.x - e.min.x) / 2), 0, e.min.y + Math.floor((e.max.y - e.min.y) / 2))
                                            }
                                            nM(this, CE, "f").className = "editor",
                                                nM(this, BE, "f").hide()
                                        }
                                    )), "f"),
                                    tM(this, zE, new Wk(nM(this, CE, "f"),nM(this, uE, "f"),nM(this, EE, "f"),(e => {
                                            tM(this, SS, e, "f")
                                        }
                                    ),(e => {
                                            tM(this, ES, e, "f")
                                        }
                                    ),(e => {
                                            tM(this, kS, e, "f"),
                                                nM(this, zE, "f").rotationAxis = nM(this, kS, "f"),
                                                nM(this, dE, "m", qS).call(this)
                                        }
                                    ),( () => {
                                            tM(this, xS, (nM(this, xS, "f") + 1) % 4, "f"),
                                                nM(this, zE, "f").rotation = nM(this, xS, "f"),
                                                nM(this, dE, "m", qS).call(this)
                                        }
                                    )), "f");
                                const x = document.createElement("button");
                                x.className = "button",
                                    x.innerHTML = '<img class="button-icon" src="images/load.svg"> ',
                                    x.append(document.createTextNode(nM(this, fE, "f").get("Load"))),
                                    x.addEventListener("click", ( () => {
                                            nM(this, uE, "f").playUIClick(),
                                                nM(this, oS, "f") ? (nM(this, BE, "f").show(),
                                                    nM(this, CE, "f").className = "hidden") : (nM(this, CE, "f").inert = !0,
                                                    nM(this, kE, "f").showConfirm(nM(this, fE, "f").get("Are you sure you want to load a new track?\n\nYour current track will be lost!"), nM(this, fE, "f").get("Cancel"), nM(this, fE, "f").get("Confirm"), ( () => {
                                                            nM(this, CE, "f").inert = !1
                                                        }
                                                    ), ( () => {
                                                            nM(this, BE, "f").show(),
                                                                nM(this, CE, "f").className = "hidden",
                                                                nM(this, CE, "f").inert = !1
                                                        }
                                                    )))
                                        }
                                    )),
                                    v.appendChild(x);
                                const k = document.createElement("button");
                                k.className = "button",
                                    k.innerHTML = '<img class="button-icon" src="images/save.svg"> ',
                                    k.append(document.createTextNode(nM(this, fE, "f").get("Save"))),
                                    k.addEventListener("click", ( () => {
                                            nM(this, uE, "f").playUIClick();
                                            const e = e => {
                                                const t = {
                                                    name: e,
                                                    author: this.trackAuthor
                                                }
                                                    , n = nM(this, vE, "f").getTrackData();
                                                nM(this, yE, "f").saveCustomTrack(t, n) ? (nM(this, dE, "m", OS).call(this, nM(this, fE, "f").get("Track saved!"), !0),
                                                    tM(this, oS, !0, "f")) : nM(this, dE, "m", OS).call(this, nM(this, fE, "f").get("Failed to save!"), !1)
                                            }
                                                , t = this.getTrackName();
                                            if (null == t)
                                                nM(this, CE, "f").className = "hidden",
                                                    tM(this, FE, new rE(nM(this, uE, "f"),nM(this, fE, "f"),nM(this, TS, "f"),this.trackAuthor,this,nM(this, vE, "f"),(e => {
                                                            nM(this, dE, "m", HS).call(this, e)
                                                        }
                                                    ),(e => {
                                                            var t;
                                                            nM(this, dE, "m", DS).call(this, e),
                                                            null === (t = nM(this, FE, "f")) || void 0 === t || t.dispose(),
                                                                tM(this, FE, null, "f"),
                                                                nM(this, CE, "f").className = "editor"
                                                        }
                                                    ),(t => {
                                                            var n;
                                                            nM(this, dE, "m", DS).call(this, t),
                                                            null === (n = nM(this, FE, "f")) || void 0 === n || n.dispose(),
                                                                tM(this, FE, null, "f"),
                                                                e(t),
                                                                nM(this, CE, "f").className = "editor"
                                                        }
                                                    )), "f");
                                            else {
                                                nM(this, yE, "f").checkCustomTrackNameExists(t) ? (nM(this, CE, "f").inert = !0,
                                                    nM(this, kE, "f").showConfirm(nM(this, fE, "f").get('Are you sure you want to overwrite "{0}"?', [t]), nM(this, fE, "f").get("Cancel"), nM(this, fE, "f").get("Confirm"), ( () => {
                                                            nM(this, CE, "f").inert = !1
                                                        }
                                                    ), ( () => {
                                                            e(t),
                                                                nM(this, CE, "f").inert = !1
                                                        }
                                                    ))) : e(t)
                                            }
                                        }
                                    )),
                                    v.appendChild(k);
                                const E = document.createElement("button");
                                E.className = "button",
                                    E.innerHTML = '<img class="button-icon" src="images/export.svg"> ',
                                    E.append(document.createTextNode(nM(this, fE, "f").get("Export"))),
                                    E.addEventListener("click", ( () => {
                                            nM(this, uE, "f").playUIClick();
                                            const e = this.getTrackName();
                                            if (null == e)
                                                nM(this, CE, "f").className = "hidden",
                                                    tM(this, FE, new rE(nM(this, uE, "f"),nM(this, fE, "f"),nM(this, TS, "f"),this.trackAuthor,this,nM(this, vE, "f"),(e => {
                                                            nM(this, dE, "m", HS).call(this, e)
                                                        }
                                                    ),(e => {
                                                            var t;
                                                            nM(this, dE, "m", DS).call(this, e),
                                                            null === (t = nM(this, FE, "f")) || void 0 === t || t.dispose(),
                                                                tM(this, FE, null, "f"),
                                                                nM(this, CE, "f").className = "editor"
                                                        }
                                                    ),(e => {
                                                            var t;
                                                            nM(this, dE, "m", DS).call(this, e),
                                                            null === (t = nM(this, FE, "f")) || void 0 === t || t.dispose(),
                                                                tM(this, FE, null, "f");
                                                            const n = {
                                                                name: e,
                                                                author: this.trackAuthor
                                                            }
                                                                , i = nM(this, vE, "f").getTrackData().toExportString(n);
                                                            tM(this, UE, new wx(i,( () => {
                                                                    var e;
                                                                    null === (e = nM(this, UE, "f")) || void 0 === e || e.dispose(),
                                                                        tM(this, UE, null, "f"),
                                                                        nM(this, CE, "f").className = "editor"
                                                                }
                                                            ),null,!1,nM(this, fE, "f"),nM(this, uE, "f"),nM(this, yE, "f"),nM(this, kE, "f")), "f")
                                                        }
                                                    )), "f");
                                            else {
                                                nM(this, CE, "f").className = "hidden";
                                                const t = {
                                                    name: e,
                                                    author: this.trackAuthor
                                                }
                                                    , n = nM(this, vE, "f").getTrackData().toExportString(t);
                                                tM(this, UE, new wx(n,( () => {
                                                        var e;
                                                        null === (e = nM(this, UE, "f")) || void 0 === e || e.dispose(),
                                                            tM(this, UE, null, "f"),
                                                            nM(this, CE, "f").className = "editor"
                                                    }
                                                ),null,!1,nM(this, fE, "f"),nM(this, uE, "f"),nM(this, yE, "f"),nM(this, kE, "f")), "f")
                                            }
                                        }
                                    )),
                                    v.appendChild(E);
                                const S = document.createElement("button");
                                S.className = "button",
                                    S.innerHTML = '<img class="button-icon" src="images/help.svg"> ',
                                    S.append(document.createTextNode(nM(this, fE, "f").get("Help"))),
                                    S.addEventListener("click", ( () => {
                                            nM(this, uE, "f").playUIClick();
                                            const e = nM(this, wE, "f").getPart(IA.Start).colors.get(CA.Summer);
                                            if (null == e)
                                                throw new Error("Starting point mesh is null");
                                            const t = hE(e)
                                                , n = nM(this, wE, "f").getPart(IA.Checkpoint).colors.get(CA.Summer);
                                            if (null == n)
                                                throw new Error("Checkpoint mesh is null");
                                            const i = hE(n)
                                                , r = nM(this, wE, "f").getPart(IA.Finish).colors.get(CA.Summer);
                                            if (null == r)
                                                throw new Error("Finish line mesh is null");
                                            const a = hE(r);
                                            nM(this, CE, "f").className = "hidden",
                                                tM(this, OE, new Kk(nM(this, uE, "f"),nM(this, fE, "f"),nM(this, SE, "f"),nM(this, EE, "f"),t,i,a,( () => {
                                                        var e;
                                                        null === (e = nM(this, OE, "f")) || void 0 === e || e.dispose(),
                                                            tM(this, OE, null, "f"),
                                                            nM(this, CE, "f").className = "editor"
                                                    }
                                                )), "f")
                                        }
                                    )),
                                    v.appendChild(S);
                                const M = document.createElement("div");
                                M.className = "track-settings-container",
                                    nM(this, _E, "f").appendChild(M),
                                    tM(this, WE, document.createElement("button"), "f"),
                                    nM(this, WE, "f").className = "button",
                                    nM(this, WE, "f").innerHTML = '<img class="button-icon" src="images/settings.svg"> ',
                                    nM(this, WE, "f").append(document.createTextNode(null !== (f = nM(this, TS, "f")) && void 0 !== f ? f : nM(this, fE, "f").get("Unnamed Track"))),
                                    nM(this, WE, "f").addEventListener("click", ( () => {
                                            nM(this, uE, "f").playUIClick(),
                                                nM(this, CE, "f").className = "hidden",
                                                tM(this, FE, new rE(nM(this, uE, "f"),nM(this, fE, "f"),nM(this, TS, "f"),this.trackAuthor,this,nM(this, vE, "f"),(e => {
                                                        nM(this, dE, "m", HS).call(this, e)
                                                    }
                                                ),(e => {
                                                        var t;
                                                        nM(this, dE, "m", DS).call(this, e),
                                                        null === (t = nM(this, FE, "f")) || void 0 === t || t.dispose(),
                                                            tM(this, FE, null, "f"),
                                                            nM(this, CE, "f").className = "editor"
                                                    }
                                                ),null), "f")
                                        }
                                    )),
                                    M.appendChild(nM(this, WE, "f")),
                                    tM(this, IE, document.createElement("div"), "f"),
                                    nM(this, IE, "f").className = "message",
                                    nM(this, CE, "f").appendChild(nM(this, IE, "f"));
                                const T = document.createElement("side");
                                T.className = "side",
                                    nM(this, CE, "f").appendChild(T),
                                    tM(this, DE, new Gb(T,nM(this, fE, "f"),nM(this, uE, "f"),nM(this, EE, "f")), "f"),
                                    tM(this, RE, document.createElement("div"), "f"),
                                    nM(this, RE, "f").className = "side-panel",
                                    T.appendChild(nM(this, RE, "f")),
                                    tM(this, LE, document.createElement("div"), "f"),
                                    nM(this, LE, "f").className = "category-panel",
                                    nM(this, RE, "f").appendChild(nM(this, LE, "f"));
                                const C = new yr(4 * yb.partSize,yb.partSize,4 * yb.partSize);
                                C.translate(0, yb.partSize / 2, 0);
                                const _ = new wr(C,nM(this, dS, "f"))
                                    , I = document.createElement("button");
                                I.addEventListener("click", ( () => {
                                        nM(this, uE, "f").playUIClick(),
                                            nM(this, dE, "m", GS).call(this, null)
                                    }
                                )),
                                    nM(this, LE, "f").appendChild(I);
                                const P = document.createElement("img");
                                P.src = "images/erase.svg",
                                    I.appendChild(P),
                                    nM(this, hS, "f").add(_),
                                    nM(this, IS, "f").push({
                                        id: null,
                                        selectionMesh: _,
                                        button: I,
                                        image: P,
                                        colorPanel: null,
                                        colorButtons: [],
                                        tiles: new Iy([[-2, 0, -2], [-1, 0, -2], [0, 0, -2], [1, 0, -2], [-2, 0, -1], [-1, 0, -1], [0, 0, -1], [1, 0, -1], [-2, 0, 0], [-1, 0, 0], [0, 0, 0], [1, 0, 0], [-2, 0, 1], [-1, 0, 1], [0, 0, 1], [1, 0, 1]]),
                                        isCheckpoint: !1,
                                        isStart: !1,
                                        category: null
                                    }),
                                    tM(this, NE, new rx(nM(this, CE, "f"),nM(this, fE, "f"),nM(this, EE, "f"),( () => {
                                            nM(this, uE, "f").playUIClick(),
                                                tM(this, dE, nM(this, dE, "a", QS) + 1, "a", YS)
                                        }
                                    ),( () => {
                                            nM(this, uE, "f").playUIClick(),
                                                tM(this, dE, Math.max(0, nM(this, dE, "a", QS) - 1), "a", YS)
                                        }
                                    )), "f"),
                                    nM(this, NE, "f").refresh(nM(this, dE, "a", QS))
                            }
                            dispose() {
                                var e, t, n;
                                tM(this, TE, !1, "f"),
                                null === (e = nM(this, _S, "f")) || void 0 === e || e.dispose(),
                                    nM(this, NE, "f").dispose(),
                                    nM(this, DE, "f").dispose(),
                                null === (t = nM(this, UE, "f")) || void 0 === t || t.dispose(),
                                    tM(this, UE, null, "f"),
                                    nM(this, BE, "f").dispose(),
                                    nM(this, zE, "f").dispose(),
                                null === (n = nM(this, OE, "f")) || void 0 === n || n.dispose(),
                                    tM(this, OE, null, "f");
                                const i = document.getElementById("ui");
                                if (null == i)
                                    throw new Error("Failed to find UI element");
                                i.removeChild(nM(this, CE, "f")),
                                    nM(this, mE, "f").scene.remove(nM(this, JE, "f")),
                                    nM(this, $E, "f").dispose(),
                                    nM(this, mE, "f").canvas.style.touchAction = "",
                                    nM(this, dS, "f").dispose();
                                for (const e of nM(this, hS, "f").children) {
                                    const t = e;
                                    if (t.geometry.dispose(),
                                        Array.isArray(t.material))
                                        for (const e of t.material)
                                            e.dispose();
                                    else
                                        t.material.dispose()
                                }
                                if (nM(this, mE, "f").scene.remove(nM(this, hS, "f")),
                                null != nM(this, fS, "f") && (nM(this, mE, "f").scene.remove(nM(this, fS, "f")),
                                    nM(this, fS, "f").dispose(),
                                    nM(this, pS, "f").dispose(),
                                    nM(this, uS, "f").dispose(),
                                    tM(this, fS, null, "f")),
                                    nM(this, cS, "f").geometry.dispose(),
                                    Array.isArray(nM(this, cS, "f").material))
                                    for (const e of nM(this, cS, "f").material)
                                        e.dispose();
                                else
                                    nM(this, cS, "f").material.dispose();
                                nM(this, mE, "f").canvas.removeEventListener("mousemove", nM(this, HE, "f")),
                                    nM(this, mE, "f").canvas.removeEventListener("mousedown", nM(this, VE, "f")),
                                    window.removeEventListener("mouseup", nM(this, GE, "f")),
                                    nM(this, mE, "f").canvas.removeEventListener("mouseout", nM(this, jE, "f")),
                                    nM(this, mE, "f").canvas.removeEventListener("touchstart", nM(this, QE, "f")),
                                    nM(this, mE, "f").canvas.removeEventListener("click", nM(this, YE, "f")),
                                    window.removeEventListener("keydown", nM(this, qE, "f")),
                                    window.removeEventListener("keyup", nM(this, KE, "f")),
                                    window.removeEventListener("wheel", nM(this, XE, "f")),
                                    window.removeEventListener("beforeunload", nM(this, ZE, "f"))
                            }
                            getTrackName() {
                                return nM(this, TS, "f")
                            }
                            setTestCallback(e) {
                                tM(this, ME, e, "f")
                            }
                            enable() {
                                var e;
                                tM(this, TE, !0, "f"),
                                    nM(this, $E, "f").enabled = !0,
                                1 == nM(this, IS, "f").length && nM(this, dE, "m", FS).call(this),
                                null === (e = nM(this, _S, "f")) || void 0 === e || e.dispose(),
                                    tM(this, _S, new _b(nM(this, mE, "f")), "f"),
                                    nM(this, _S, "f").refresh(nM(this, vE, "f")),
                                    nM(this, zE, "f").show(),
                                    nM(this, CE, "f").className = "editor"
                            }
                            disable() {
                                var e, t, n;
                                tM(this, TE, !1, "f"),
                                    nM(this, $E, "f").enabled = !1,
                                    nM(this, hS, "f").visible = !1,
                                null === (e = nM(this, _S, "f")) || void 0 === e || e.dispose(),
                                    nM(this, CE, "f").className = "hidden",
                                null === (t = nM(this, UE, "f")) || void 0 === t || t.dispose(),
                                    tM(this, UE, null, "f"),
                                    nM(this, BE, "f").hide(),
                                    nM(this, zE, "f").hide(),
                                null === (n = nM(this, OE, "f")) || void 0 === n || n.dispose(),
                                    tM(this, OE, null, "f")
                            }
                            isEnabled() {
                                return nM(this, TE, "f")
                            }
                            resetView(e, t, n) {
                                tM(this, dE, t, "a", YS);
                                const i = new An(e * yb.partSize,t * yb.partSize,n * yb.partSize);
                                nM(this, JE, "f").position.copy(i).add(new An(40,40,-40)),
                                    nM(this, $E, "f").target.copy(i),
                                    nM(this, $E, "f").update()
                            }
                            get camera() {
                                return nM(this, JE, "f")
                            }
                            update(e) {
                                var t;
                                if (nM(this, TE, "f")) {
                                    if (nM(this, JE, "f").position.y < .5 && (nM(this, JE, "f").position.y = .5,
                                        nM(this, $E, "f").update()),
                                        tM(this, yS, nM(this, dE, "m", XS).call(this), "f"),
                                    null != nM(this, yS, "f")) {
                                        const e = Qy(nM(this, xS, "f"), nM(this, kS, "f"))
                                            , t = new An(nM(this, yS, "f").x * yb.partSize,nM(this, yS, "f").y * yb.partSize,nM(this, yS, "f").z * yb.partSize);
                                        nM(this, hS, "f").position.copy(t),
                                            nM(this, hS, "f").quaternion.copy(e),
                                            nM(this, hS, "f").visible = !0
                                    } else
                                        nM(this, hS, "f").visible = !1;
                                    const e = nM(this, yS, "f");
                                    if (null != e && null != nM(this, PS, "f")) {
                                        const n = nM(this, IS, "f")[nM(this, PS, "f")]
                                            , i = nM(this, dE, "m", ZS).call(this, e, n.tiles);
                                        if (null == n.id || nM(this, mS, "f"))
                                            i.length > 0 ? (nM(this, dS, "f").color.set(12255232),
                                                nM(this, uS, "f").color.set(12255232)) : (nM(this, dS, "f").color.set(12263970),
                                                nM(this, uS, "f").color.set(12263970));
                                        else {
                                            let t, r;
                                            if (nM(this, SS, "f"))
                                                t = i.some(( ({parts: t}) => t.some((t => t.id == n.id && t.x == e.x && t.y == e.y && t.z == e.z && t.rotation == nM(this, xS, "f") && t.rotationAxis == nM(this, kS, "f"))))),
                                                    r = !1;
                                            else {
                                                t = !1;
                                                for (const {parts: a} of i)
                                                    for (const i of a) {
                                                        if (!nM(this, wE, "f").isPartCombinationAllowed({
                                                            id: n.id,
                                                            x: e.x,
                                                            y: e.y,
                                                            z: e.z,
                                                            rotation: nM(this, xS, "f"),
                                                            rotationAxis: nM(this, kS, "f")
                                                        }, {
                                                            id: i.id,
                                                            x: i.x,
                                                            y: i.y,
                                                            z: i.z,
                                                            rotation: i.rotation,
                                                            rotationAxis: i.rotationAxis
                                                        })) {
                                                            t = !0;
                                                            break
                                                        }
                                                        r = !0
                                                    }
                                            }
                                            t ? (nM(this, dS, "f").color.set(12303104),
                                                nM(this, uS, "f").color.set(12303104)) : r ? (nM(this, dS, "f").color.set(48059),
                                                nM(this, uS, "f").color.set(48059)) : (nM(this, dS, "f").color.set(187),
                                                nM(this, uS, "f").color.set(187))
                                        }
                                        if (nM(this, mS, "f"))
                                            nM(this, dE, "m", JS).call(this, i);
                                        else if (nM(this, gS, "f") || nM(this, AS, "f")) {
                                            if (null == n.id)
                                                nM(this, dE, "m", JS).call(this, i);
                                            else if (null == nM(this, MS, "f") || nM(this, MS, "f").x != e.x || nM(this, MS, "f").y != e.y || nM(this, MS, "f").z != e.z || nM(this, MS, "f").id != n.id || nM(this, MS, "f").rotation != nM(this, xS, "f") || nM(this, MS, "f").rotationAxis != nM(this, kS, "f")) {
                                                if (nM(this, SS, "f"))
                                                    for (const {parts: t} of i) {
                                                        const i = t.find((t => t.id == n.id && t.x == e.x && t.y == e.y && t.z == e.z && t.rotation == nM(this, xS, "f") && t.rotationAxis == nM(this, kS, "f")));
                                                        null != i && nM(this, vE, "f").deleteSpecificPart(i.id, i.x, i.y, i.z, i.rotation, i.rotationAxis)
                                                    }
                                                else
                                                    for (const {parts: t} of i)
                                                        for (const i of t)
                                                            nM(this, wE, "f").isPartCombinationAllowed({
                                                                id: n.id,
                                                                x: e.x,
                                                                y: e.y,
                                                                z: e.z,
                                                                rotation: nM(this, xS, "f"),
                                                                rotationAxis: nM(this, kS, "f")
                                                            }, {
                                                                id: i.id,
                                                                x: i.x,
                                                                y: i.y,
                                                                z: i.z,
                                                                rotation: i.rotation,
                                                                rotationAxis: i.rotationAxis
                                                            }) || nM(this, vE, "f").deleteSpecificPart(i.id, i.x, i.y, i.z, i.rotation, i.rotationAxis);
                                                let r = null;
                                                n.isCheckpoint && (r = nM(this, DE, "f").checkpointOrder);
                                                let a = null;
                                                n.isStart && (a = nM(this, vE, "f").getNextStartOrder()),
                                                    nM(this, vE, "f").setPart(e.x, e.y, e.z, n.id, nM(this, xS, "f"), nM(this, kS, "f"), nM(this, dE, "m", WS).call(this), r, a),
                                                    nM(this, dE, "m", KS).call(this),
                                                    tM(this, MS, {
                                                        x: e.x,
                                                        y: e.y,
                                                        z: e.z,
                                                        id: n.id,
                                                        rotation: nM(this, xS, "f"),
                                                        rotationAxis: nM(this, kS, "f")
                                                    }, "f"),
                                                    nM(this, vE, "f").generateMeshes(),
                                                null === (t = nM(this, _S, "f")) || void 0 === t || t.refresh(nM(this, vE, "f")),
                                                    nM(this, DE, "f").setFromExistingCheckpoints(nM(this, vE, "f")),
                                                    tM(this, oS, !1, "f")
                                            }
                                            tM(this, AS, !1, "f")
                                        }
                                        nM(this, hS, "f").visible = !0
                                    } else
                                        nM(this, hS, "f").visible = !1
                                }
                                nM(this, dE, "m", $S).call(this, e)
                            }
                        }
                    ;
                    var rM, aM, sM, oM, lM, cM, hM, dM = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, uM = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    rM = new WeakMap,
                        aM = new WeakMap,
                        sM = new WeakMap,
                        oM = new WeakMap,
                        lM = new WeakMap,
                        cM = new WeakMap,
                        hM = new WeakMap;
                    const pM = class {
                            constructor(e, t, n, i, r, a, s, o, l, c, h, d, u, p, f, m, g) {
                                rM.set(this, void 0),
                                    aM.set(this, void 0),
                                    sM.set(this, void 0),
                                    oM.set(this, void 0),
                                    lM.set(this, void 0),
                                    cM.set(this, void 0),
                                    hM.set(this, void 0),
                                    this.isPaused = !1,
                                    dM(this, rM, e, "f"),
                                    dM(this, aM, i, "f"),
                                    dM(this, sM, r, "f"),
                                    dM(this, oM, s, "f"),
                                    dM(this, lM, o, "f"),
                                    dM(this, cM, l, "f"),
                                    dM(this, hM, new iM(a,s,o,c,e,t,n,h,d,u,p,f,l,m), "f"),
                                    uM(this, hM, "f").enable(),
                                    uM(this, rM, "f").clear(),
                                    uM(this, rM, "f").setPart(0, 0, 0, IA.Start, 0, RA.YPositive, CA.Default, null, 0),
                                    uM(this, rM, "f").generateMeshes(),
                                    o.setCamera(uM(this, hM, "f").camera),
                                    uM(this, hM, "f").setTestCallback(( () => {
                                            var e;
                                            uM(this, hM, "f").disable();
                                            const t = {
                                                name: null !== (e = uM(this, hM, "f").getTrackName()) && void 0 !== e ? e : a.get("Unnamed Track"),
                                                author: uM(this, hM, "f").trackAuthor
                                            };
                                            g(t, uM(this, rM, "f").getTrackData(), ( () => {
                                                    uM(this, hM, "f").enable(),
                                                        o.setCamera(uM(this, hM, "f").camera)
                                                }
                                            ))
                                        }
                                    ))
                            }
                            dispose() {
                                uM(this, hM, "f").dispose(),
                                    uM(this, rM, "f").clear()
                            }
                            update(e) {
                                this.isPaused || uM(this, hM, "f").update(e),
                                    uM(this, aM, "f").update(uM(this, rM, "f")),
                                    uM(this, sM, "f").update(e, uM(this, lM, "f").camera, uM(this, rM, "f").sunDirection),
                                    uM(this, oM, "f").update(e, !1, uM(this, lM, "f"), uM(this, cM, "f")),
                                    uM(this, lM, "f").update(new An, uM(this, rM, "f").sunDirection)
                            }
                        }
                    ;
                    var fM = n(5811)
                        , mM = {};
                    mM.styleTagTransform = u(),
                        mM.setAttributes = l(),
                        mM.insert = s().bind(null, "head"),
                        mM.domAPI = r(),
                        mM.insertStyleElement = h();
                    t()(fM.A, mM);
                    fM.A && fM.A.locals && fM.A.locals;
                    var gM, vM, wM, AM, yM, bM, xM = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, kM = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    gM = new WeakMap,
                        vM = new WeakMap,
                        wM = new WeakMap,
                        AM = new WeakMap,
                        yM = new WeakMap,
                        bM = new WeakMap;
                    const EM = class {
                            constructor(e, t) {
                                gM.set(this, void 0),
                                    vM.set(this, void 0),
                                    wM.set(this, void 0),
                                    AM.set(this, void 0),
                                    yM.set(this, void 0),
                                    bM.set(this, null),
                                    xM(this, gM, t, "f"),
                                    xM(this, vM, e, "f");
                                const n = document.getElementById("ui");
                                if (null == n)
                                    throw new Error("UI element not found");
                                xM(this, wM, n, "f"),
                                    xM(this, AM, document.createElement("div"), "f"),
                                    0 == kM(this, vM, "f") || "off" == t.getSetting(Jo.Checkpoints) ? "top" == t.getSetting(Jo.Checkpoints) ? kM(this, AM, "f").className = "checkpoint up" : kM(this, AM, "f").className = "checkpoint" : kM(this, AM, "f").className = "hidden",
                                    kM(this, wM, "f").appendChild(kM(this, AM, "f"));
                                const i = document.createElement("div");
                                kM(this, AM, "f").appendChild(i);
                                const r = document.createElement("img");
                                r.src = "images/checkpoint.svg",
                                    i.appendChild(r),
                                    xM(this, yM, document.createElement("span"), "f"),
                                    i.appendChild(kM(this, yM, "f"))
                            }
                            dispose() {
                                kM(this, wM, "f").removeChild(kM(this, AM, "f"))
                            }
                            setOverridePosition(e) {
                                const t = kM(this, gM, "f").getSetting(Jo.Checkpoints);
                                0 == kM(this, vM, "f") || "off" == t ? kM(this, AM, "f").className = "hidden" : kM(this, AM, "f").className = (null != e ? e : "top" == t) ? "checkpoint up" : "checkpoint"
                            }
                            update(e) {
                                const t = e.getNextCheckpointIndex().toString() + "/" + kM(this, vM, "f").toString();
                                t != kM(this, bM, "f") && (kM(this, yM, "f").textContent = t,
                                    xM(this, bM, t, "f"))
                            }
                        }
                    ;
                    var SM = n(8229)
                        , MM = {};
                    MM.styleTagTransform = u(),
                        MM.setAttributes = l(),
                        MM.insert = s().bind(null, "head"),
                        MM.domAPI = r(),
                        MM.insertStyleElement = h();
                    t()(SM.A, MM);
                    SM.A && SM.A.locals && SM.A.locals;
                    var TM, CM, _M, IM, PM, RM, LM, NM, DM, BM, UM, zM, OM, FM = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, WM = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    CM = new WeakMap,
                        _M = new WeakMap,
                        IM = new WeakMap,
                        PM = new WeakMap,
                        RM = new WeakMap,
                        LM = new WeakMap,
                        NM = new WeakMap,
                        DM = new WeakMap,
                        BM = new WeakMap,
                        TM = new WeakSet,
                        UM = function(e, t) {
                            WM(this, LM, "f").textContent = e,
                                WM(this, NM, "f").textContent = t,
                                WM(this, RM, "f").className = "hint show"
                        }
                        ,
                        zM = function() {
                            FM(this, DM, 2.5, "f"),
                                WM(this, RM, "f").className = "hint hide"
                        }
                        ,
                        OM = function() {
                            FM(this, DM, 2.5, "f"),
                                WM(this, RM, "f").className = "hint"
                        }
                    ;
                    const HM = class {
                            constructor(e, t, n) {
                                TM.add(this),
                                    CM.set(this, void 0),
                                    _M.set(this, void 0),
                                    IM.set(this, void 0),
                                    PM.set(this, void 0),
                                    RM.set(this, void 0),
                                    LM.set(this, void 0),
                                    NM.set(this, void 0),
                                    DM.set(this, 2.5),
                                    BM.set(this, void 0),
                                    FM(this, CM, e, "f"),
                                    FM(this, _M, t, "f"),
                                    FM(this, IM, n, "f");
                                const i = document.getElementById("ui");
                                if (null == i)
                                    throw new Error("UI element not found");
                                FM(this, PM, i, "f"),
                                    FM(this, RM, document.createElement("div"), "f"),
                                    WM(this, RM, "f").className = "hint",
                                    WM(this, PM, "f").appendChild(WM(this, RM, "f")),
                                    FM(this, LM, document.createElement("div"), "f"),
                                    WM(this, LM, "f").className = "title",
                                    WM(this, RM, "f").appendChild(WM(this, LM, "f")),
                                    FM(this, NM, document.createElement("div"), "f"),
                                    WM(this, NM, "f").className = "subtitle",
                                    WM(this, RM, "f").appendChild(WM(this, NM, "f")),
                                    FM(this, BM, ( () => {
                                            WM(this, TM, "m", OM).call(this)
                                        }
                                    ), "f"),
                                    WM(this, _M, "f").addChangeListener(WM(this, BM, "f"))
                            }
                            dispose() {
                                WM(this, PM, "f").removeChild(WM(this, RM, "f")),
                                    WM(this, _M, "f").removeChangeListener(WM(this, BM, "f"))
                            }
                            update(e, t) {
                                if (e.hasStarted() && !e.getControls().reset && WM(this, IM, "f").getSettingBoolean(Jo.ResetHintEnabled))
                                    if (e.getSpeedKmh() < 50 || e.hasFinished()) {
                                        if (0 != WM(this, DM, "f") && (FM(this, DM, WM(this, DM, "f") - t, "f"),
                                        WM(this, DM, "f") <= 0)) {
                                            if (WM(this, _M, "f").touchEnabled)
                                                WM(this, TM, "m", UM).call(this, WM(this, CM, "f").get("Reset once to return to the last checkpoint"), WM(this, CM, "f").get("Reset again to start over"));
                                            else {
                                                const e = WM(this, IM, "f").getKeyBindings(sx.VehicleCheckpointReset).filter((e => null != e))
                                                    , t = WM(this, IM, "f").getKeyBindings(sx.VehicleStartReset).filter((e => null != e));
                                                let n = "";
                                                e.length > 0 && (n = WM(this, CM, "f").get("Press {0} to return to the last checkpoint", [e.map((e => "[" + e + "]")).join(" / ")]));
                                                let i = "";
                                                t.length > 0 && (i = WM(this, CM, "f").get("Press {0} to start over", [t.map((e => "[" + e + "]")).join(" / ")])),
                                                    "" != n && "" != i ? WM(this, TM, "m", UM).call(this, n, i) : "" != n ? WM(this, TM, "m", UM).call(this, n, "") : "" != i && WM(this, TM, "m", UM).call(this, i, "")
                                            }
                                            FM(this, DM, 0, "f")
                                        }
                                    } else
                                        WM(this, TM, "m", zM).call(this);
                                else
                                    WM(this, TM, "m", OM).call(this)
                            }
                        }
                    ;
                    var VM = n(5151)
                        , GM = {};
                    GM.styleTagTransform = u(),
                        GM.setAttributes = l(),
                        GM.insert = s().bind(null, "head"),
                        GM.domAPI = r(),
                        GM.insertStyleElement = h();
                    t()(VM.A, GM);
                    VM.A && VM.A.locals && VM.A.locals;
                    var jM, QM, YM, qM, KM, XM, ZM, JM = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, $M = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    jM = new WeakMap,
                        QM = new WeakMap,
                        YM = new WeakMap,
                        qM = new WeakMap,
                        KM = new WeakMap,
                        XM = new WeakMap,
                        ZM = new WeakMap;
                    const eT = class {
                            constructor(e) {
                                jM.set(this, void 0),
                                    QM.set(this, void 0),
                                    YM.set(this, void 0),
                                    qM.set(this, void 0),
                                    KM.set(this, void 0),
                                    XM.set(this, null),
                                    ZM.set(this, void 0),
                                    JM(this, jM, e, "f"),
                                    JM(this, ZM, e.getSettingBoolean(Jo.ImperialUnitsEnabled), "f");
                                const t = document.getElementById("ui");
                                if (null == t)
                                    throw new Error("UI element not found");
                                JM(this, QM, t, "f"),
                                    JM(this, YM, document.createElement("div"), "f"),
                                    "off" == e.getSetting(Jo.Speedometer) ? $M(this, YM, "f").className = "speedometer hidden" : "top" == e.getSetting(Jo.Speedometer) ? $M(this, YM, "f").className = "speedometer up" : $M(this, YM, "f").className = "speedometer",
                                    $M(this, QM, "f").appendChild($M(this, YM, "f"));
                                const n = document.createElement("div");
                                $M(this, YM, "f").appendChild(n),
                                    JM(this, qM, document.createElement("span"), "f"),
                                    $M(this, qM, "f").textContent = "0",
                                    n.appendChild($M(this, qM, "f")),
                                    JM(this, KM, document.createElement("span"), "f"),
                                    $M(this, ZM, "f") ? $M(this, KM, "f").textContent = "mph" : $M(this, KM, "f").textContent = "km/h",
                                    n.appendChild($M(this, KM, "f"))
                            }
                            dispose() {
                                $M(this, QM, "f").removeChild($M(this, YM, "f"))
                            }
                            setOverridePosition(e) {
                                const t = $M(this, jM, "f").getSetting(Jo.Speedometer);
                                $M(this, YM, "f").className = "off" == t ? "speedometer hidden" : (null != e ? e : "top" == t) ? "speedometer up" : "speedometer"
                            }
                            update(e) {
                                const t = Math.abs(e.getSpeedKmh());
                                let n;
                                n = $M(this, ZM, "f") ? t / 1.609344 : t;
                                const i = Math.trunc(n).toString();
                                if (i != $M(this, XM, "f")) {
                                    $M(this, qM, "f").innerHTML = "";
                                    for (const e of i) {
                                        const t = document.createElement("span");
                                        t.textContent = e,
                                            $M(this, qM, "f").appendChild(t)
                                    }
                                    JM(this, XM, i, "f")
                                }
                            }
                        }
                    ;
                    var tT = n(2817)
                        , nT = {};
                    nT.styleTagTransform = u(),
                        nT.setAttributes = l(),
                        nT.insert = s().bind(null, "head"),
                        nT.domAPI = r(),
                        nT.insertStyleElement = h();
                    t()(tT.A, nT);
                    tT.A && tT.A.locals && tT.A.locals;
                    var iT, rT, aT, sT, oT, lT, cT, hT, dT, uT, pT = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, fT = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    iT = new WeakMap,
                        rT = new WeakMap,
                        aT = new WeakMap,
                        sT = new WeakMap,
                        oT = new WeakMap,
                        lT = new WeakMap,
                        cT = new WeakMap,
                        hT = new WeakMap,
                        dT = new WeakMap,
                        uT = new WeakMap;
                    const mT = class {
                            constructor(e, t, n, i, r) {
                                iT.set(this, void 0),
                                    rT.set(this, void 0),
                                    aT.set(this, void 0),
                                    sT.set(this, void 0),
                                    oT.set(this, void 0),
                                    lT.set(this, void 0),
                                    cT.set(this, void 0),
                                    hT.set(this, void 0),
                                    dT.set(this, void 0),
                                    uT.set(this, void 0);
                                const a = document.getElementById("ui");
                                if (null == a)
                                    throw new Error("UI element not found");
                                if (pT(this, iT, a, "f"),
                                    pT(this, rT, document.createElement("div"), "f"),
                                    fT(this, rT, "f").className = "time-announcer",
                                    pT(this, aT, document.createElement("div"), "f"),
                                    fT(this, aT, "f").className = "hidden",
                                    fT(this, aT, "f").textContent = e.get("New record"),
                                    fT(this, rT, "f").appendChild(fT(this, aT, "f")),
                                    pT(this, sT, document.createElement("div"), "f"),
                                    fT(this, sT, "f").className = "track-name",
                                    fT(this, sT, "f").textContent = t,
                                    fT(this, rT, "f").appendChild(fT(this, sT, "f")),
                                    pT(this, oT, document.createElement("div"), "f"),
                                    fT(this, oT, "f").className = "current",
                                    fT(this, rT, "f").appendChild(fT(this, oT, "f")),
                                    pT(this, lT, document.createElement("div"), "f"),
                                    fT(this, rT, "f").appendChild(fT(this, lT, "f")),
                                    pT(this, cT, document.createElement("p"), "f"),
                                    fT(this, lT, "f").appendChild(fT(this, cT, "f")),
                                    pT(this, hT, document.createElement("div"), "f"),
                                    fT(this, rT, "f").appendChild(fT(this, hT, "f")),
                                    pT(this, dT, document.createElement("p"), "f"),
                                    fT(this, dT, "f").className = "title",
                                    fT(this, hT, "f").appendChild(fT(this, dT, "f")),
                                    pT(this, uT, document.createElement("p"), "f"),
                                    fT(this, hT, "f").appendChild(fT(this, uT, "f")),
                                    fT(this, iT, "f").appendChild(fT(this, rT, "f")),
                                    fT(this, oT, "f").textContent = Vx.formatTimeString(n),
                                null == i)
                                    fT(this, aT, "f").className = "record",
                                        fT(this, lT, "f").className = "hidden";
                                else {
                                    const e = n.difference(i);
                                    fT(this, cT, "f").textContent = Vx.formatTimeString(e, !0),
                                        e.isNegative() ? (fT(this, aT, "f").className = "record",
                                            fT(this, lT, "f").className = "difference") : (fT(this, aT, "f").className = "hidden",
                                            fT(this, lT, "f").className = "difference red")
                                }
                                if (null == r)
                                    fT(this, hT, "f").className = "hidden";
                                else {
                                    const e = n.difference(r.record);
                                    fT(this, dT, "f").textContent = r.name,
                                        fT(this, uT, "f").textContent = Vx.formatTimeString(e, !0),
                                        e.isNegative() ? fT(this, hT, "f").className = "difference" : fT(this, hT, "f").className = "difference red"
                                }
                            }
                            dispose() {
                                fT(this, iT, "f").removeChild(fT(this, rT, "f"))
                            }
                        }
                    ;
                    var gT, vT, wT, AT, yT, bT, xT, kT, ET, ST, MT, TT, CT, _T, IT, PT = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, RT = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    gT = new WeakMap,
                        vT = new WeakMap,
                        wT = new WeakMap,
                        AT = new WeakMap,
                        yT = new WeakMap,
                        bT = new WeakMap,
                        xT = new WeakMap,
                        kT = new WeakMap,
                        ET = new WeakMap,
                        ST = new WeakMap,
                        MT = new WeakMap,
                        TT = new WeakMap,
                        CT = new WeakMap,
                        _T = new WeakMap,
                        IT = new WeakMap;
                    const LT = class {
                            constructor(e, t) {
                                gT.set(this, void 0),
                                    vT.set(this, void 0),
                                    wT.set(this, !1),
                                    AT.set(this, []),
                                    yT.set(this, void 0),
                                    bT.set(this, void 0),
                                    xT.set(this, void 0),
                                    kT.set(this, void 0),
                                    ET.set(this, void 0),
                                    ST.set(this, void 0),
                                    MT.set(this, !1),
                                    TT.set(this, !1),
                                    CT.set(this, !1),
                                    _T.set(this, !1),
                                    IT.set(this, !1),
                                    PT(this, gT, e, "f"),
                                    PT(this, vT, new Ir(70,1,.5,yu.maxViewDistance), "f"),
                                    RT(this, vT, "f").position.set(0, 20, 0),
                                    window.addEventListener("keydown", PT(this, yT, (e => {
                                            t.checkKeyBinding(e, sx.SpectatorMoveForwards) ? (PT(this, MT, !0, "f"),
                                                e.preventDefault()) : t.checkKeyBinding(e, sx.SpectatorMoveRight) ? (PT(this, TT, !0, "f"),
                                                e.preventDefault()) : t.checkKeyBinding(e, sx.SpectatorMoveBackwards) ? (PT(this, CT, !0, "f"),
                                                e.preventDefault()) : t.checkKeyBinding(e, sx.SpectatorMoveLeft) ? (PT(this, _T, !0, "f"),
                                                e.preventDefault()) : t.checkKeyBinding(e, sx.SpectatorSpeedModifier) && (PT(this, IT, !0, "f"),
                                                e.preventDefault())
                                        }
                                    ), "f")),
                                    window.addEventListener("keyup", PT(this, bT, (e => {
                                            t.checkKeyBinding(e, sx.SpectatorMoveForwards) ? PT(this, MT, !1, "f") : t.checkKeyBinding(e, sx.SpectatorMoveRight) ? PT(this, TT, !1, "f") : t.checkKeyBinding(e, sx.SpectatorMoveBackwards) ? PT(this, CT, !1, "f") : t.checkKeyBinding(e, sx.SpectatorMoveLeft) ? PT(this, _T, !1, "f") : t.checkKeyBinding(e, sx.SpectatorSpeedModifier) && PT(this, IT, !1, "f")
                                        }
                                    ), "f"));
                                let n = !1
                                    , i = {
                                    x: 0,
                                    y: 0
                                }
                                    , r = 0
                                    , a = 0;
                                e.canvas.addEventListener("mousedown", PT(this, xT, (e => {
                                        n = !0;
                                        const t = (new ai).setFromQuaternion(RT(this, vT, "f").quaternion, "YXZ");
                                        r = t.y,
                                            a = t.x,
                                            i = {
                                                x: e.clientX,
                                                y: e.clientY
                                            }
                                    }
                                ), "f")),
                                    window.addEventListener("mouseup", PT(this, kT, ( () => {
                                            n = !1
                                        }
                                    ), "f")),
                                    window.addEventListener("mousemove", PT(this, ET, (e => {
                                            if (n) {
                                                const t = Math.max(window.innerWidth, window.innerHeight)
                                                    , n = (e.clientX - i.x) / t
                                                    , s = (e.clientY - i.y) / t;
                                                i = {
                                                    x: e.clientX,
                                                    y: e.clientY
                                                };
                                                const o = 10;
                                                r -= n * o,
                                                    a -= s * o,
                                                    r %= 2 * Math.PI,
                                                    a = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, a));
                                                const l = (new wn).setFromAxisAngle(new An(1,0,0), a)
                                                    , c = (new wn).setFromAxisAngle(new An(0,1,0), r);
                                                RT(this, vT, "f").quaternion.copy(c).multiply(l)
                                            }
                                        }
                                    ), "f")),
                                    window.addEventListener("contextmenu", PT(this, ST, (e => {
                                            RT(this, wT, "f") && e.preventDefault()
                                        }
                                    ), "f"))
                            }
                            dispose() {
                                window.removeEventListener("keydown", RT(this, yT, "f")),
                                    window.removeEventListener("keyup", RT(this, bT, "f")),
                                    RT(this, gT, "f").canvas.removeEventListener("mousedown", RT(this, xT, "f")),
                                    window.removeEventListener("mouseup", RT(this, kT, "f")),
                                    window.removeEventListener("mousemove", RT(this, ET, "f")),
                                    window.removeEventListener("contextmenu", RT(this, ST, "f"))
                            }
                            addToggleListener(e) {
                                RT(this, AT, "f").push(e)
                            }
                            get isEnabled() {
                                return RT(this, wT, "f")
                            }
                            set isEnabled(e) {
                                if (RT(this, wT, "f") != e) {
                                    PT(this, wT, e, "f");
                                    for (const e of RT(this, AT, "f"))
                                        e(RT(this, wT, "f"))
                                }
                            }
                            toggle() {
                                this.isEnabled = !RT(this, wT, "f")
                            }
                            update(e) {
                                if (RT(this, wT, "f")) {
                                    let t;
                                    if (t = RT(this, IT, "f") ? 400 * e : 50 * e,
                                        RT(this, MT, "f")) {
                                        const e = new An(0,0,-1).applyQuaternion(RT(this, vT, "f").quaternion);
                                        RT(this, vT, "f").position.add(e.multiplyScalar(t))
                                    }
                                    if (RT(this, TT, "f")) {
                                        const e = new An(1,0,0).applyQuaternion(RT(this, vT, "f").quaternion);
                                        RT(this, vT, "f").position.add(e.multiplyScalar(t))
                                    }
                                    if (RT(this, CT, "f")) {
                                        const e = new An(0,0,1).applyQuaternion(RT(this, vT, "f").quaternion);
                                        RT(this, vT, "f").position.add(e.multiplyScalar(t))
                                    }
                                    if (RT(this, _T, "f")) {
                                        const e = new An(-1,0,0).applyQuaternion(RT(this, vT, "f").quaternion);
                                        RT(this, vT, "f").position.add(e.multiplyScalar(t))
                                    }
                                }
                            }
                            get camera() {
                                return RT(this, vT, "f")
                            }
                        }
                    ;
                    var NT = n(3571)
                        , DT = {};
                    DT.styleTagTransform = u(),
                        DT.setAttributes = l(),
                        DT.insert = s().bind(null, "head"),
                        DT.domAPI = r(),
                        DT.insertStyleElement = h();
                    t()(NT.A, DT);
                    NT.A && NT.A.locals && NT.A.locals;
                    var BT, UT, zT, OT = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, FT = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    BT = new WeakMap,
                        UT = new WeakMap,
                        zT = new WeakMap;
                    const WT = class {
                            constructor(e, t, n) {
                                BT.set(this, void 0),
                                    UT.set(this, void 0),
                                    zT.set(this, void 0);
                                const i = document.getElementById("ui");
                                if (null == i)
                                    throw new Error("UI element not found");
                                OT(this, BT, i, "f"),
                                    OT(this, UT, document.createElement("div"), "f"),
                                    FT(this, UT, "f").className = "hidden",
                                    FT(this, BT, "f").appendChild(FT(this, UT, "f"));
                                const r = document.createElement("button");
                                r.className = "reset",
                                    r.innerHTML = '<img src="images/reset.svg">',
                                    r.addEventListener("touchstart", ( () => {
                                            t.playUIClick(),
                                                r.classList.add("active"),
                                                n()
                                        }
                                    )),
                                    r.addEventListener("touchend", ( () => {
                                            r.classList.remove("active")
                                        }
                                    )),
                                    FT(this, UT, "f").appendChild(r);
                                const a = document.createElement("div");
                                a.className = "left-container",
                                    FT(this, UT, "f").appendChild(a);
                                const s = document.createElement("div");
                                s.innerHTML = '<img src="images/arrow_up.svg">',
                                    a.appendChild(s);
                                const o = document.createElement("div");
                                o.innerHTML = '<img src="images/arrow_down.svg">',
                                    a.appendChild(o);
                                const l = document.createElement("div");
                                l.className = "right-container",
                                    FT(this, UT, "f").appendChild(l);
                                const c = document.createElement("div");
                                c.innerHTML = '<img src="images/arrow_left.svg">',
                                    l.appendChild(c);
                                const h = document.createElement("div");
                                h.innerHTML = '<img src="images/arrow_right.svg">',
                                    l.appendChild(h),
                                    OT(this, zT, (t => {
                                            let n = !1
                                                , i = !1
                                                , r = !1
                                                , a = !1;
                                            for (let e = 0; e < t.touches.length; e++) {
                                                const l = t.touches.item(e);
                                                if (null != l) {
                                                    switch (document.elementFromPoint(l.clientX, l.clientY)) {
                                                        case s:
                                                            n = !0;
                                                            break;
                                                        case h:
                                                            i = !0;
                                                            break;
                                                        case o:
                                                            r = !0;
                                                            break;
                                                        case c:
                                                            a = !0
                                                    }
                                                }
                                            }
                                            e.up = n,
                                                e.right = i,
                                                e.down = r,
                                                e.left = a,
                                                s.className = n ? "active" : "",
                                                h.className = i ? "active" : "",
                                                o.className = r ? "active" : "",
                                                c.className = a ? "active" : "",
                                            t.target instanceof HTMLButtonElement || t.preventDefault()
                                        }
                                    ), "f"),
                                    window.addEventListener("touchstart", FT(this, zT, "f"), {
                                        passive: !1
                                    }),
                                    window.addEventListener("touchmove", FT(this, zT, "f"), {
                                        passive: !1
                                    }),
                                    window.addEventListener("touchend", FT(this, zT, "f"), {
                                        passive: !1
                                    })
                            }
                            setEnabled(e) {
                                FT(this, UT, "f").className = e ? "touch-controls" : "hidden"
                            }
                            dispose() {
                                FT(this, BT, "f").removeChild(FT(this, UT, "f")),
                                    window.removeEventListener("touchstart", FT(this, zT, "f")),
                                    window.removeEventListener("touchmove", FT(this, zT, "f")),
                                    window.removeEventListener("touchend", FT(this, zT, "f"))
                            }
                        }
                    ;
                    var HT, VT, GT, jT, QT, YT, qT, KT, XT = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, ZT = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    HT = new WeakMap,
                        VT = new WeakMap,
                        GT = new WeakMap,
                        jT = new WeakMap,
                        QT = new WeakMap,
                        YT = new WeakMap,
                        qT = new WeakMap,
                        KT = new WeakMap;
                    const JT = class {
                            constructor(e) {
                                HT.set(this, !1),
                                    VT.set(this, !1),
                                    GT.set(this, !1),
                                    jT.set(this, !1),
                                    QT.set(this, !1),
                                    YT.set(this, void 0),
                                    qT.set(this, void 0),
                                    KT.set(this, []),
                                    window.addEventListener("keydown", XT(this, YT, (t => {
                                            e.checkKeyBinding(t, sx.VehicleAccelerate) ? (this.up = !0,
                                                t.preventDefault()) : e.checkKeyBinding(t, sx.VehicleTurnRight) ? (this.right = !0,
                                                t.preventDefault()) : e.checkKeyBinding(t, sx.VehicleBrake) ? (this.down = !0,
                                                t.preventDefault()) : e.checkKeyBinding(t, sx.VehicleTurnLeft) && (this.left = !0,
                                                t.preventDefault())
                                        }
                                    ), "f")),
                                    window.addEventListener("keyup", XT(this, qT, (t => {
                                            e.checkKeyBinding(t, sx.VehicleAccelerate) ? this.up = !1 : e.checkKeyBinding(t, sx.VehicleTurnRight) ? this.right = !1 : e.checkKeyBinding(t, sx.VehicleBrake) ? this.down = !1 : e.checkKeyBinding(t, sx.VehicleTurnLeft) && (this.left = !1)
                                        }
                                    ), "f"))
                            }
                            get up() {
                                return ZT(this, HT, "f")
                            }
                            set up(e) {
                                if (ZT(this, HT, "f") != e) {
                                    XT(this, HT, e, "f");
                                    for (const e of ZT(this, KT, "f"))
                                        e(this)
                                }
                            }
                            get right() {
                                return ZT(this, VT, "f")
                            }
                            set right(e) {
                                if (ZT(this, VT, "f") != e) {
                                    XT(this, VT, e, "f");
                                    for (const e of ZT(this, KT, "f"))
                                        e(this)
                                }
                            }
                            get down() {
                                return ZT(this, GT, "f")
                            }
                            set down(e) {
                                if (ZT(this, GT, "f") != e) {
                                    XT(this, GT, e, "f");
                                    for (const e of ZT(this, KT, "f"))
                                        e(this)
                                }
                            }
                            get left() {
                                return ZT(this, jT, "f")
                            }
                            set left(e) {
                                if (ZT(this, jT, "f") != e) {
                                    XT(this, jT, e, "f");
                                    for (const e of ZT(this, KT, "f"))
                                        e(this)
                                }
                            }
                            get reset() {
                                return ZT(this, QT, "f")
                            }
                            set reset(e) {
                                if (ZT(this, QT, "f") != e) {
                                    XT(this, QT, e, "f");
                                    for (const e of ZT(this, KT, "f"))
                                        e(this)
                                }
                            }
                            addChangeCallback(e) {
                                ZT(this, KT, "f").push(e)
                            }
                            removeChangeCallback(e) {
                                const t = ZT(this, KT, "f").indexOf(e);
                                t >= 0 && ZT(this, KT, "f").splice(t, 1)
                            }
                            dispose() {
                                window.removeEventListener("keydown", ZT(this, YT, "f")),
                                    window.removeEventListener("keyup", ZT(this, qT, "f"))
                            }
                            getControls() {
                                return {
                                    up: this.up,
                                    right: this.right,
                                    down: this.down,
                                    left: this.left,
                                    reset: this.reset
                                }
                            }
                        }
                    ;
                    var $T, eC = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    $T = new WeakMap;
                    const tC = class {
                            constructor() {
                                $T.set(this, [])
                            }
                            push(e) {
                                if (eC(this, $T, "f").length > 0) {
                                    if (e.frames != eC(this, $T, "f")[eC(this, $T, "f").length - 1].frames + 1)
                                        throw new Error("Car states are not continuous")
                                } else if (e.frames > 0)
                                    throw new Error("First frame must be zero");
                                eC(this, $T, "f").push(e)
                            }
                            getFrame(e) {
                                return e >= 0 && e < eC(this, $T, "f").length ? eC(this, $T, "f")[e] : null
                            }
                            getLastFrame() {
                                return 0 == eC(this, $T, "f").length ? new xp(0) : new xp(eC(this, $T, "f")[eC(this, $T, "f").length - 1].frames)
                            }
                        }
                    ;
                    var nC = n(4804)
                        , iC = {};
                    iC.styleTagTransform = u(),
                        iC.setAttributes = l(),
                        iC.insert = s().bind(null, "head"),
                        iC.domAPI = r(),
                        iC.insertStyleElement = h();
                    t()(nC.A, iC);
                    nC.A && nC.A.locals && nC.A.locals;
                    var rC, aC, sC, oC, lC, cC, hC, dC, uC, pC = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, fC = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    aC = new WeakMap,
                        sC = new WeakMap,
                        oC = new WeakMap,
                        lC = new WeakMap,
                        cC = new WeakMap,
                        hC = new WeakMap,
                        dC = new WeakMap,
                        rC = new WeakSet,
                        uC = function() {
                            "top" == fC(this, sC, "f").getSetting(Jo.Checkpoints) || fC(this, oC, "f").touchEnabled ? fC(this, lC, "f").classList.remove("up") : fC(this, lC, "f").classList.add("up"),
                                fC(this, oC, "f").touchEnabled ? fC(this, lC, "f").classList.add("touch") : fC(this, lC, "f").classList.remove("touch")
                        }
                    ;
                    const mC = class {
                            constructor(e, t, n, i, r, a) {
                                rC.add(this),
                                    aC.set(this, void 0),
                                    sC.set(this, void 0),
                                    oC.set(this, void 0),
                                    lC.set(this, void 0),
                                    cC.set(this, void 0),
                                    hC.set(this, !0),
                                    dC.set(this, void 0),
                                    pC(this, sC, n, "f"),
                                    pC(this, oC, i, "f");
                                const s = document.getElementById("ui");
                                if (null == s)
                                    throw new Error("UI element not found");
                                pC(this, aC, s, "f"),
                                    pC(this, lC, document.createElement("div"), "f"),
                                    fC(this, lC, "f").className = "game-toolbar visible",
                                    fC(this, rC, "m", uC).call(this),
                                    fC(this, oC, "f").addChangeListener(pC(this, dC, ( () => {
                                            fC(this, rC, "m", uC).call(this)
                                        }
                                    ), "f"));
                                const o = document.createElement("button");
                                o.className = "button",
                                    o.innerHTML = '<img class="button-icon" src="images/quit.svg"> ',
                                    o.append(document.createTextNode(t.get("Exit"))),
                                    o.addEventListener("click", ( () => {
                                            e.playUIClick(),
                                                r()
                                        }
                                    )),
                                    fC(this, lC, "f").appendChild(o),
                                    pC(this, cC, document.createElement("button"), "f"),
                                    fC(this, cC, "f").className = "button",
                                    fC(this, cC, "f").innerHTML = '<img class="button-icon" src="images/preview.svg"> ',
                                    fC(this, cC, "f").append(document.createTextNode(t.get("Watch"))),
                                    fC(this, cC, "f").addEventListener("click", ( () => {
                                            e.playUIClick(),
                                                a()
                                        }
                                    )),
                                    fC(this, lC, "f").appendChild(fC(this, cC, "f")),
                                    fC(this, aC, "f").appendChild(fC(this, lC, "f"))
                            }
                            dispose() {
                                fC(this, aC, "f").removeChild(fC(this, lC, "f")),
                                    fC(this, oC, "f").removeChangeListener(fC(this, dC, "f"))
                            }
                            setWatchButtonEnabled(e) {
                                fC(this, cC, "f").disabled = !e
                            }
                            setVisible(e) {
                                fC(this, hC, "f") != e && (e ? fC(this, lC, "f").classList.add("visible") : fC(this, lC, "f").classList.remove("visible"),
                                    fC(this, lC, "f").inert = !e,
                                    pC(this, hC, e, "f"))
                            }
                        }
                    ;
                    var gC, vC = function(e, t, n, i) {
                        return new (n || (n = Promise))((function(r, a) {
                                function s(e) {
                                    try {
                                        l(i.next(e))
                                    } catch (e) {
                                        a(e)
                                    }
                                }
                                function o(e) {
                                    try {
                                        l(i.throw(e))
                                    } catch (e) {
                                        a(e)
                                    }
                                }
                                function l(e) {
                                    var t;
                                    e.done ? r(e.value) : (t = e.value,
                                        t instanceof n ? t : new n((function(e) {
                                                e(t)
                                            }
                                        ))).then(s, o)
                                }
                                l((i = i.apply(e, t || [])).next())
                            }
                        ))
                    };
                    !function(e) {
                        e[e.Loading = 0] = "Loading",
                            e[e.Error = 1] = "Error",
                            e[e.Ready = 2] = "Ready"
                    }(gC || (gC = {}));
                    let wC = gC.Loading
                        , AC = !1
                        , yC = !1;
                    function bC() {
                        return vC(this, void 0, void 0, (function*() {
                                try {
                                    wC = gC.Ready
                                } catch (e) {
                                    wC = gC.Error,
                                        console.error(e)
                                }
                            }
                        ))
                    }
                    function xC() {
                        if (wC == gC.Ready && !AC)
                            try {
                                window.CrazyGames ? window.CrazyGames.SDK.game.gameplayStart() : window.PokiSDK ? window.PokiSDK.gameplayStart() : window.adsbygoogle,
                                    AC = !0
                            } catch (e) {
                                console.error(e)
                            }
                    }
                    function kC() {
                        if (wC == gC.Ready && AC)
                            try {
                                window.CrazyGames ? window.CrazyGames.SDK.game.gameplayStop() : window.PokiSDK ? window.PokiSDK.gameplayStop() : window.adsbygoogle,
                                    AC = !1
                            } catch (e) {
                                console.error(e)
                            }
                    }
                    function EC() {
                        if (wC == gC.Ready && !yC)
                            try {
                                window.CrazyGames ? window.CrazyGames.SDK.game.loadingStart() : window.PokiSDK || window.adsbygoogle,
                                    yC = !0
                            } catch (e) {
                                console.error(e)
                            }
                    }
                    function SC() {
                        if (wC == gC.Ready && yC)
                            try {
                                window.CrazyGames ? window.CrazyGames.SDK.game.loadingStop() : window.PokiSDK || window.adsbygoogle,
                                    yC = !1
                            } catch (e) {
                                console.error(e)
                            }
                    }
                    function MC() {
                        if (wC == gC.Ready)
                            try {
                                window.CrazyGames ? window.CrazyGames.SDK.game.loadingStop() : window.PokiSDK ? window.PokiSDK.gameLoadingFinished() : window.adsbygoogle
                            } catch (e) {
                                console.error(e)
                            }
                    }
                    function TC(e, t) {
                        return vC(this, void 0, void 0, (function*() {
                                if (wC == gC.Ready)
                                    try {
                                        if (window.CrazyGames) {
                                            const t = window.CrazyGames;
                                            yield new Promise(( (n, i) => {
                                                    t.SDK.ad.requestAd("midgame", {
                                                        adFinished: n,
                                                        adError: i,
                                                        adStarted: e
                                                    })
                                                }
                                            ))
                                        } else if (window.PokiSDK)
                                            yield window.PokiSDK.commercialBreak();
                                        else if (window.adsbygoogle) {
                                            const n = window.adsbygoogle;
                                            yield new Promise((i => {
                                                    n.push({
                                                        type: "start",
                                                        name: t,
                                                        beforeAd: e,
                                                        adBreakDone: i
                                                    })
                                                }
                                            ))
                                        }
                                    } catch (e) {
                                        throw console.error(e),
                                            e
                                    }
                            }
                        ))
                    }
                    var CC = n(4538)
                        , _C = {};
                    _C.styleTagTransform = u(),
                        _C.setAttributes = l(),
                        _C.insert = s().bind(null, "head"),
                        _C.domAPI = r(),
                        _C.insertStyleElement = h();
                    t()(CC.A, _C);
                    CC.A && CC.A.locals && CC.A.locals;
                    var IC, PC, RC, LC = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, NC = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    IC = new WeakMap,
                        PC = new WeakMap,
                        RC = new WeakMap;
                    const DC = class {
                            constructor(e) {
                                IC.set(this, void 0),
                                    PC.set(this, void 0),
                                    RC.set(this, !1);
                                const t = document.getElementById("ui");
                                if (null == t)
                                    throw new Error("UI element not found");
                                LC(this, IC, t, "f"),
                                    LC(this, PC, document.createElement("div"), "f"),
                                    NC(this, PC, "f").className = "pause-screen",
                                    NC(this, IC, "f").appendChild(NC(this, PC, "f"));
                                const n = document.createElement("div");
                                n.className = "title",
                                    n.textContent = e.get("Paused"),
                                    NC(this, PC, "f").appendChild(n)
                            }
                            dispose() {
                                NC(this, IC, "f").removeChild(NC(this, PC, "f"))
                            }
                            startFadeOut(e) {
                                NC(this, RC, "f") || (LC(this, RC, !0, "f"),
                                    NC(this, PC, "f").classList.add("fade-out"),
                                    setTimeout(e, 250))
                            }
                        }
                    ;
                    var BC = n(4239)
                        , UC = {};
                    UC.styleTagTransform = u(),
                        UC.setAttributes = l(),
                        UC.insert = s().bind(null, "head"),
                        UC.domAPI = r(),
                        UC.insertStyleElement = h();
                    t()(BC.A, UC);
                    BC.A && BC.A.locals && BC.A.locals;
                    var zC, OC, FC, WC, HC = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, VC = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    zC = new WeakMap,
                        OC = new WeakMap,
                        FC = new WeakMap,
                        WC = new WeakMap;
                    const GC = class {
                            constructor(e, t) {
                                zC.set(this, void 0),
                                    OC.set(this, void 0),
                                    FC.set(this, void 0),
                                    WC.set(this, void 0),
                                    HC(this, zC, t, "f");
                                const n = document.getElementById("ui");
                                if (null == n)
                                    throw new Error("UI element not found");
                                HC(this, OC, n, "f"),
                                    HC(this, FC, document.createElement("div"), "f"),
                                    VC(this, FC, "f").className = "ghost-loading-ui",
                                    VC(this, FC, "f").textContent = e.get("Loading replay"),
                                    VC(this, OC, "f").appendChild(VC(this, FC, "f")),
                                    HC(this, WC, document.createElement("span"), "f"),
                                    VC(this, WC, "f").className = "percentage",
                                    VC(this, FC, "f").appendChild(VC(this, WC, "f")),
                                    this.update(1)
                            }
                            dispose() {
                                VC(this, OC, "f").removeChild(VC(this, FC, "f"))
                            }
                            setOverridePosition(e) {
                                const t = VC(this, zC, "f").getSetting(Jo.Speedometer);
                                (null != e ? e : "top" == t) ? VC(this, FC, "f").classList.add("down") : VC(this, FC, "f").classList.remove("down")
                            }
                            update(e) {
                                VC(this, WC, "f").textContent = Math.floor(100 * e).toString() + "%",
                                    e >= 1 ? VC(this, FC, "f").classList.add("hide") : VC(this, FC, "f").classList.remove("hide")
                            }
                        }
                    ;
                    new WeakMap,
                        new WeakMap,
                        new WeakMap,
                        new WeakMap,
                        new WeakMap,
                        new WeakMap;
                    var jC, QC, YC, qC, KC, XC, ZC, JC, $C, e_, t_, n_, i_, r_, a_, s_, o_, l_, c_, h_, d_, u_, p_, f_, m_, g_, v_, w_, A_, y_, b_, x_, k_, E_, S_, M_, T_, C_, __, I_, P_, R_, L_, N_, D_, B_, U_, z_, O_, F_, W_, H_, V_, G_, j_ = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, Q_ = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    QC = new WeakMap,
                        YC = new WeakMap,
                        qC = new WeakMap,
                        KC = new WeakMap,
                        XC = new WeakMap,
                        ZC = new WeakMap,
                        JC = new WeakMap,
                        $C = new WeakMap,
                        e_ = new WeakMap,
                        t_ = new WeakMap,
                        n_ = new WeakMap,
                        i_ = new WeakMap,
                        r_ = new WeakMap,
                        a_ = new WeakMap,
                        s_ = new WeakMap,
                        o_ = new WeakMap,
                        l_ = new WeakMap,
                        c_ = new WeakMap,
                        h_ = new WeakMap,
                        d_ = new WeakMap,
                        u_ = new WeakMap,
                        p_ = new WeakMap,
                        f_ = new WeakMap,
                        m_ = new WeakMap,
                        g_ = new WeakMap,
                        v_ = new WeakMap,
                        w_ = new WeakMap,
                        A_ = new WeakMap,
                        y_ = new WeakMap,
                        b_ = new WeakMap,
                        x_ = new WeakMap,
                        k_ = new WeakMap,
                        E_ = new WeakMap,
                        S_ = new WeakMap,
                        M_ = new WeakMap,
                        T_ = new WeakMap,
                        C_ = new WeakMap,
                        __ = new WeakMap,
                        I_ = new WeakMap,
                        P_ = new WeakMap,
                        R_ = new WeakMap,
                        L_ = new WeakMap,
                        N_ = new WeakMap,
                        D_ = new WeakMap,
                        B_ = new WeakMap,
                        U_ = new WeakMap,
                        jC = new WeakSet,
                        z_ = function(e) {
                            var t, n, i, r, a, s, o, l, c;
                            if (e) {
                                const e = Q_(this, jC, "m", H_).call(this);
                                j_(this, u_, new HM(Q_(this, ZC, "f"),Q_(this, r_, "f"),Q_(this, t_, "f")), "f"),
                                    j_(this, p_, new GC(Q_(this, ZC, "f"),Q_(this, t_, "f")), "f"),
                                    j_(this, f_, new EM(Q_(this, qC, "f").getTotalNumberOfCheckpointIndices(),Q_(this, t_, "f")), "f"),
                                    j_(this, m_, new eT(Q_(this, t_, "f")), "f"),
                                    j_(this, g_, new Vx(Q_(this, ZC, "f"),Q_(this, t_, "f")), "f"),
                                null == e || e.settings.isSelf || (Q_(this, g_, "f").nickname = e.settings.name),
                                    j_(this, w_, new mC(Q_(this, $C, "f"),Q_(this, ZC, "f"),Q_(this, t_, "f"),Q_(this, r_, "f"),Q_(this, s_, "f"),( () => {
                                            Q_(this, C_, "f").length > 0 && null != Q_(this, o_, "f") && Q_(this, o_, "f").call(this, Q_(this, l_, "f"), Q_(this, c_, "f"), Q_(this, h_, "f"), Q_(this, C_, "f").map((e => e.settings)))
                                        }
                                    )), "f"),
                                    Q_(this, w_, "f").setWatchButtonEnabled(Q_(this, C_, "f").length > 0 && null != Q_(this, o_, "f")),
                                    Q_(this, w_, "f").setVisible(!(null !== (n = null === (t = Q_(this, T_, "f")) || void 0 === t ? void 0 : t.hasStarted()) && void 0 !== n && n)),
                                    Q_(this, r_, "f").touchEnabled ? (Q_(this, p_, "f").setOverridePosition(!0),
                                        Q_(this, f_, "f").setOverridePosition(!0),
                                        Q_(this, g_, "f").setOverridePosition(!0),
                                        Q_(this, m_, "f").setOverridePosition(!0)) : (Q_(this, p_, "f").setOverridePosition(null),
                                        Q_(this, f_, "f").setOverridePosition(null),
                                        Q_(this, g_, "f").setOverridePosition(null),
                                        Q_(this, m_, "f").setOverridePosition(null)),
                                    Q_(this, x_, "f").setEnabled(Q_(this, r_, "f").touchEnabled),
                                    Q_(this, jC, "m", G_).call(this)
                            } else
                                null === (i = Q_(this, u_, "f")) || void 0 === i || i.dispose(),
                                    j_(this, u_, null, "f"),
                                null === (r = Q_(this, p_, "f")) || void 0 === r || r.dispose(),
                                    j_(this, p_, null, "f"),
                                null === (a = Q_(this, f_, "f")) || void 0 === a || a.dispose(),
                                    j_(this, f_, null, "f"),
                                null === (s = Q_(this, m_, "f")) || void 0 === s || s.dispose(),
                                    j_(this, m_, null, "f"),
                                null === (o = Q_(this, g_, "f")) || void 0 === o || o.dispose(),
                                    j_(this, g_, null, "f"),
                                null === (l = Q_(this, v_, "f")) || void 0 === l || l.dispose(),
                                    j_(this, v_, null, "f"),
                                null === (c = Q_(this, w_, "f")) || void 0 === c || c.dispose(),
                                    j_(this, w_, null, "f")
                        }
                        ,
                        O_ = function() {
                            var e;
                            Q_(this, B_, "f") || ((null === (e = Q_(this, T_, "f")) || void 0 === e ? void 0 : e.hasFinished()) ? (j_(this, B_, !0, "f"),
                                TC(( () => {
                                        Q_(this, $C, "f").mute()
                                    }
                                ), "game-finish-reset").finally(( () => {
                                        j_(this, B_, !1, "f"),
                                            Q_(this, $C, "f").unmute(),
                                            Q_(this, jC, "m", F_).call(this),
                                            Q_(this, jC, "m", W_).call(this)
                                    }
                                )).catch((e => {
                                        console.error(e)
                                    }
                                ))) : (Q_(this, jC, "m", F_).call(this),
                                Q_(this, jC, "m", W_).call(this)))
                        }
                        ,
                        F_ = function() {
                            var e, t;
                            const n = Q_(this, e_, "f").getCurrentUserProfile();
                            let i = !1;
                            null != Q_(this, T_, "f") ? (i = Q_(this, JC, "f").camera == Q_(this, T_, "f").cameraCockpit,
                                Q_(this, jC, "m", G_).call(this),
                                Q_(this, T_, "f").dispose(),
                                j_(this, T_, null, "f")) : i = Q_(this, t_, "f").getSettingBoolean(Jo.DefaultCameraMode);
                            const r = Q_(this, qC, "f").getStartTransform();
                            if (null == r)
                                throw new Error("Start transform is null");
                            j_(this, T_, new yw(Q_(this, QC, "f"),r,null,Q_(this, S_, "f"),Q_(this, JC, "f"),Q_(this, $C, "f"),Q_(this, KC, "f"),Q_(this, qC, "f"),Q_(this, t_, "f")), "f"),
                                Q_(this, T_, "f").notificationAudioEnabled = !0,
                                Q_(this, T_, "f").addResetCallback(( () => {
                                        Q_(this, S_, "f").reset = !1,
                                            null == Q_(this, T_, "f") ? j_(this, E_, !1, "f") : (j_(this, E_, Q_(this, T_, "f").getControls().up || Q_(this, T_, "f").getControls().down, "f"),
                                            Q_(this, E_, "f") && j_(this, M_, new Date, "f"))
                                    }
                                )),
                                Q_(this, T_, "f").addCheckpointCallback((e => {
                                        if (null == Q_(this, T_, "f") || null == Q_(this, g_, "f"))
                                            return;
                                        const t = Q_(this, T_, "f").getTime();
                                        let n = null;
                                        const i = Q_(this, jC, "m", H_).call(this);
                                        null != i && i.checkpointTimes.length > e && (n = i.checkpointTimes[e]),
                                            Q_(this, g_, "f").showCheckpointTime(t, n)
                                    }
                                )),
                                Q_(this, T_, "f").addFinishCallback((e => {
                                        var t, i;
                                        const r = e.getTime()
                                            , a = e.getRecording()
                                            , s = e.getColors()
                                            , o = Q_(this, I_, "f");
                                        if (null == Q_(this, I_, "f") || r.lessThan(Q_(this, I_, "f"))) {
                                            if (Q_(this, a_, "f").call(this, Q_(this, qC, "f").getID(), a, r),
                                            0 == Q_(this, C_, "f").length)
                                                Q_(this, C_, "f").push({
                                                    car: null,
                                                    carId: null,
                                                    hasEnded: !1,
                                                    loadedFrames: 0,
                                                    maxFrames: 0,
                                                    settings: {
                                                        recording: a,
                                                        carColors: s,
                                                        name: n.nickname,
                                                        time: r,
                                                        isSelf: !0
                                                    },
                                                    replay: null,
                                                    checkpointTimes: []
                                                }),
                                                null === (t = Q_(this, w_, "f")) || void 0 === t || t.setWatchButtonEnabled(null != Q_(this, o_, "f"));
                                            else {
                                                const e = Q_(this, C_, "f").find((e => e.settings.isSelf));
                                                null != e && (e.settings = {
                                                    recording: a,
                                                    carColors: s,
                                                    name: n.nickname,
                                                    time: r,
                                                    isSelf: !0
                                                }),
                                                null === (i = Q_(this, w_, "f")) || void 0 === i || i.setWatchButtonEnabled(null != Q_(this, o_, "f"))
                                            }
                                            j_(this, I_, r, "f")
                                        }
                                        let l = null;
                                        const c = Q_(this, jC, "m", H_).call(this);
                                        null == c || c.settings.isSelf || (l = {
                                            record: c.settings.time,
                                            name: c.settings.name
                                        }),
                                            j_(this, v_, new mT(Q_(this, ZC, "f"),Q_(this, l_, "f").name,r,o,l), "f")
                                    }
                                )),
                                Q_(this, T_, "f").setColors(n.carColors),
                                i ? Q_(this, JC, "f").setCamera(Q_(this, T_, "f").cameraCockpit) : Q_(this, JC, "f").setCamera(Q_(this, T_, "f").cameraOrbit),
                                Q_(this, L_, "f").isEnabled = !1,
                            null === (e = Q_(this, v_, "f")) || void 0 === e || e.dispose(),
                                j_(this, v_, null, "f"),
                            null === (t = Q_(this, g_, "f")) || void 0 === t || t.hideCheckpointTime(),
                                Q_(this, S_, "f").reset = !1,
                                j_(this, E_, !1, "f"),
                                j_(this, M_, null, "f")
                        }
                        ,
                        W_ = function() {
                            var e;
                            if (Q_(this, t_, "f").getSettingBoolean(Jo.GhostCarEnabled))
                                for (const t of Q_(this, C_, "f")) {
                                    null != t.car && (t.car.dispose(),
                                        t.car = null);
                                    const n = Q_(this, qC, "f").getStartTransform();
                                    if (null == n)
                                        throw new Error("Start transform is null");
                                    if (t.settings.recording != (null === (e = t.replay) || void 0 === e ? void 0 : e.recording) && (null != t.carId && (Q_(this, YC, "f").deleteCar(t.carId),
                                        t.carId = null),
                                        t.replay = null),
                                    null == t.replay) {
                                        const e = t.settings.time.numberOfFrames + Q_(this, U_, "f")
                                            , i = new tC
                                            , r = [];
                                        let a = 0;
                                        const s = Q_(this, YC, "f").createCar(n, Q_(this, KC, "f").getMountainVertices(), Q_(this, KC, "f").getMountainOffset(), Q_(this, qC, "f").getTrackData(), t.settings.recording, (n => {
                                                i.push(n),
                                                n.nextCheckpointIndex > a && (r.push(new xp(n.frames)),
                                                    a = n.nextCheckpointIndex),
                                                n.frames >= e && null != t.carId && (null != n.finishFrames && n.finishFrames == t.settings.time.numberOfFrames || j_(this, __, !0, "f"),
                                                    Q_(this, YC, "f").deleteCar(t.carId),
                                                    t.carId = null),
                                                    t.loadedFrames = n.frames,
                                                    t.maxFrames = e
                                            }
                                        ));
                                        i.push(s),
                                            Q_(this, YC, "f").startCar(s.id, new xp(e)),
                                            t.carId = s.id,
                                            t.loadedFrames = 0,
                                            t.maxFrames = e,
                                            t.replay = {
                                                replay: i,
                                                recording: t.settings.recording
                                            },
                                            t.checkpointTimes = r
                                    }
                                    const i = new yw(null,n,t.settings.recording,null,Q_(this, JC, "f"),Q_(this, $C, "f"),Q_(this, KC, "f"),Q_(this, qC, "f"),Q_(this, t_, "f"));
                                    i.setColors(t.settings.carColors),
                                        i.audioVolume = .35,
                                        Q_(this, jC, "m", V_).call(this),
                                        t.car = i,
                                        t.hasEnded = !1
                                }
                        }
                        ,
                        H_ = function() {
                            let e = null;
                            for (const t of Q_(this, C_, "f"))
                                (null == e || t.settings.time.lessThan(e.settings.time) || t.settings.time.equals(e.settings.time) && t.settings.isSelf) && (e = t);
                            return e
                        }
                        ,
                        V_ = function() {
                            if (null != Q_(this, T_, "f"))
                                for (const e of Q_(this, C_, "f"))
                                    if (null != e.car) {
                                        const t = e.car.getPosition().distanceTo(Q_(this, T_, "f").getPosition())
                                            , n = Math.max(0, Math.min(1, t / 5));
                                        e.car.setOpacity(n)
                                    }
                        }
                        ,
                        G_ = function() {
                            var e;
                            if (null != Q_(this, g_, "f")) {
                                const t = Q_(this, jC, "m", H_).call(this);
                                Q_(this, g_, "f").record = null !== (e = null == t ? void 0 : t.settings.time) && void 0 !== e ? e : null,
                                    null == t || t.settings.isSelf ? Q_(this, g_, "f").nickname = null : Q_(this, g_, "f").nickname = t.settings.name
                            }
                        }
                    ;
                    const Y_ = class {
                            constructor(e, t, n, i, r, a, s, o, l, c, h, d, u, p, f, m, g, v, w, A, y) {
                                if (jC.add(this),
                                    QC.set(this, void 0),
                                    YC.set(this, void 0),
                                    qC.set(this, void 0),
                                    KC.set(this, void 0),
                                    XC.set(this, void 0),
                                    ZC.set(this, void 0),
                                    JC.set(this, void 0),
                                    $C.set(this, void 0),
                                    e_.set(this, void 0),
                                    t_.set(this, void 0),
                                    n_.set(this, void 0),
                                    i_.set(this, void 0),
                                    r_.set(this, void 0),
                                    a_.set(this, void 0),
                                    s_.set(this, void 0),
                                    o_.set(this, void 0),
                                    l_.set(this, void 0),
                                    c_.set(this, void 0),
                                    h_.set(this, void 0),
                                    d_.set(this, !0),
                                    u_.set(this, null),
                                    p_.set(this, null),
                                    f_.set(this, null),
                                    m_.set(this, null),
                                    g_.set(this, null),
                                    v_.set(this, null),
                                    w_.set(this, null),
                                    A_.set(this, 0),
                                    y_.set(this, null),
                                    b_.set(this, null),
                                    x_.set(this, void 0),
                                    k_.set(this, void 0),
                                    E_.set(this, !1),
                                    S_.set(this, void 0),
                                    M_.set(this, null),
                                    T_.set(this, null),
                                    C_.set(this, []),
                                    __.set(this, !1),
                                    I_.set(this, void 0),
                                    P_.set(this, void 0),
                                    R_.set(this, void 0),
                                    L_.set(this, void 0),
                                    N_.set(this, null),
                                    D_.set(this, null),
                                    B_.set(this, !1),
                                    this.isPaused = !1,
                                    U_.set(this, 1e4),
                                    j_(this, QC, e, "f"),
                                    j_(this, YC, t, "f"),
                                    j_(this, qC, n, "f"),
                                    j_(this, KC, i, "f"),
                                    j_(this, XC, r, "f"),
                                    j_(this, ZC, a, "f"),
                                    j_(this, JC, s, "f"),
                                    j_(this, $C, o, "f"),
                                    j_(this, e_, l, "f"),
                                    j_(this, t_, c, "f"),
                                    j_(this, n_, h, "f"),
                                    j_(this, i_, d, "f"),
                                    j_(this, r_, u, "f"),
                                    j_(this, a_, w, "f"),
                                    j_(this, s_, A, "f"),
                                    j_(this, o_, y, "f"),
                                    j_(this, I_, v, "f"),
                                    j_(this, l_, p, "f"),
                                    j_(this, c_, f, "f"),
                                    j_(this, h_, m, "f"),
                                    n.loadTrackData(f),
                                    n.generateMeshes(),
                                    i.generateMountains(n.getBounds()),
                                    j_(this, C_, g.map((e => ({
                                        car: null,
                                        carId: null,
                                        hasEnded: !1,
                                        loadedFrames: 0,
                                        maxFrames: 0,
                                        settings: e,
                                        replay: null,
                                        checkpointTimes: []
                                    }))), "f"),
                                    j_(this, S_, new JT(c), "f"),
                                    Q_(this, S_, "f").addChangeCallback((e => {
                                            null == Q_(this, T_, "f") || !e.up && !e.down || Q_(this, E_, "f") || (j_(this, E_, !0, "f"),
                                                j_(this, M_, new Date, "f"))
                                        }
                                    )),
                                    h.setCursorHiddenWhenInactive(!0),
                                    j_(this, x_, new WT(Q_(this, S_, "f"),Q_(this, $C, "f"),( () => {
                                            var e;
                                            !Q_(this, B_, "f") && (null === (e = Q_(this, T_, "f")) || void 0 === e ? void 0 : e.hasStarted()) && (Q_(this, T_, "f").hasFinished() || 0 == Q_(this, T_, "f").getNextCheckpointIndex() || !Q_(this, E_, "f") || null != Q_(this, M_, "f") && (new Date).getTime() - Q_(this, M_, "f").getTime() < 250 ? (Q_(this, jC, "m", O_).call(this),
                                                Q_(this, S_, "f").reset = !1) : Q_(this, S_, "f").reset = !0)
                                        }
                                    )), "f"),
                                    Q_(this, x_, "f").setEnabled(Q_(this, r_, "f").touchEnabled),
                                    Q_(this, jC, "m", z_).call(this, !0),
                                    Q_(this, jC, "m", G_).call(this),
                                    j_(this, L_, new LT(s,c), "f"),
                                    Q_(this, L_, "f").addToggleListener((e => {
                                            e ? (Q_(this, jC, "m", z_).call(this, !1),
                                                s.setCamera(Q_(this, L_, "f").camera)) : null != Q_(this, T_, "f") && (Q_(this, jC, "m", z_).call(this, Q_(this, d_, "f")),
                                                Q_(this, t_, "f").getSettingBoolean(Jo.DefaultCameraMode) ? Q_(this, JC, "f").setCamera(Q_(this, T_, "f").cameraCockpit) : Q_(this, JC, "f").setCamera(Q_(this, T_, "f").cameraOrbit))
                                        }
                                    )),
                                    Q_(this, r_, "f").addChangeListener(j_(this, k_, (e => {
                                            var t, n, i, r, a, s, o, l;
                                            e ? (null === (t = Q_(this, p_, "f")) || void 0 === t || t.setOverridePosition(!0),
                                            null === (n = Q_(this, f_, "f")) || void 0 === n || n.setOverridePosition(!0),
                                            null === (i = Q_(this, g_, "f")) || void 0 === i || i.setOverridePosition(!0),
                                            null === (r = Q_(this, m_, "f")) || void 0 === r || r.setOverridePosition(!0)) : (null === (a = Q_(this, p_, "f")) || void 0 === a || a.setOverridePosition(null),
                                            null === (s = Q_(this, f_, "f")) || void 0 === s || s.setOverridePosition(null),
                                            null === (o = Q_(this, g_, "f")) || void 0 === o || o.setOverridePosition(null),
                                            null === (l = Q_(this, m_, "f")) || void 0 === l || l.setOverridePosition(null)),
                                                Q_(this, x_, "f").setEnabled(e)
                                        }
                                    ), "f")),
                                    Q_(this, jC, "m", F_).call(this),
                                    Q_(this, jC, "m", W_).call(this),
                                    window.addEventListener("keydown", j_(this, P_, (e => {
                                            var t, n, i;
                                            if (!Q_(this, B_, "f")) {
                                                if (Q_(this, L_, "f").isEnabled)
                                                    "Escape" == e.code && (Q_(this, L_, "f").isEnabled = !1);
                                                else if (Q_(this, t_, "f").checkKeyBinding(e, sx.VehicleCheckpointReset))
                                                    e.repeat || null == Q_(this, y_, "f") && (null === (t = Q_(this, T_, "f")) || void 0 === t ? void 0 : t.hasStarted()) && (Q_(this, T_, "f").hasFinished() || !Q_(this, T_, "f").hasCheckpointToRespawnAt() || !Q_(this, E_, "f") || null != Q_(this, M_, "f") && (new Date).getTime() - Q_(this, M_, "f").getTime() < 250 ? (Q_(this, jC, "m", O_).call(this),
                                                        Q_(this, S_, "f").reset = !1) : Q_(this, S_, "f").reset = !0),
                                                        e.preventDefault();
                                                else if (Q_(this, t_, "f").checkKeyBinding(e, sx.VehicleStartReset))
                                                    e.repeat || null == Q_(this, y_, "f") && (null === (n = Q_(this, T_, "f")) || void 0 === n ? void 0 : n.hasStarted()) && Q_(this, jC, "m", O_).call(this),
                                                        e.preventDefault();
                                                else if (Q_(this, t_, "f").checkKeyBinding(e, sx.VehicleCockpitCamera))
                                                    e.repeat || null == Q_(this, y_, "f") && (null == Q_(this, T_, "f") || Q_(this, T_, "f").hasFinished() || (Q_(this, t_, "f").getSettingBoolean(Jo.CockpitCameraToggle) ? Q_(this, JC, "f").camera == Q_(this, T_, "f").cameraOrbit ? Q_(this, JC, "f").setCamera(Q_(this, T_, "f").cameraCockpit) : Q_(this, JC, "f").setCamera(Q_(this, T_, "f").cameraOrbit) : Q_(this, t_, "f").getSettingBoolean(Jo.DefaultCameraMode) ? Q_(this, JC, "f").setCamera(Q_(this, T_, "f").cameraOrbit) : Q_(this, JC, "f").setCamera(Q_(this, T_, "f").cameraCockpit))),
                                                        e.preventDefault();
                                                else if (c.checkKeyBinding(e, sx.ToggleUI))
                                                    j_(this, d_, !Q_(this, d_, "f"), "f"),
                                                        Q_(this, jC, "m", z_).call(this, Q_(this, d_, "f")),
                                                        e.preventDefault();
                                                else if (c.checkKeyBinding(e, sx.Pause)) {
                                                    if (null == Q_(this, y_, "f")) {
                                                        if (!(null === (i = Q_(this, T_, "f")) || void 0 === i ? void 0 : i.hasFinished())) {
                                                            const e = new Date;
                                                            (null == Q_(this, b_, "f") || Math.abs(e.getTime() - Q_(this, b_, "f").getTime()) > 1e3) && (j_(this, y_, new DC(a), "f"),
                                                                j_(this, b_, e, "f"))
                                                        }
                                                    } else
                                                        Q_(this, y_, "f").startFadeOut(( () => {
                                                                var e;
                                                                null === (e = Q_(this, y_, "f")) || void 0 === e || e.dispose(),
                                                                    j_(this, y_, null, "f")
                                                            }
                                                        ));
                                                    e.preventDefault()
                                                } else
                                                    "Escape" == e.code && (null != Q_(this, y_, "f") ? Q_(this, y_, "f").startFadeOut(( () => {
                                                            var e;
                                                            null === (e = Q_(this, y_, "f")) || void 0 === e || e.dispose(),
                                                                j_(this, y_, null, "f")
                                                        }
                                                    )) : A(),
                                                        e.preventDefault());
                                                if (c.checkKeyBinding(e, sx.ToggleSpectatorCamera) && null != Q_(this, T_, "f")) {
                                                    if (null == Q_(this, y_, "f") && !Q_(this, T_, "f").hasFinished()) {
                                                        Q_(this, L_, "f").camera.position.copy(Q_(this, JC, "f").camera.position);
                                                        const e = new ai(0,0,0,"YXZ").setFromQuaternion(Q_(this, JC, "f").camera.quaternion);
                                                        e.x = Math.round(1e4 * e.x) / 1e4,
                                                            e.y = Math.round(1e4 * e.y) / 1e4,
                                                            e.z = 0,
                                                            Q_(this, L_, "f").camera.quaternion.setFromEuler(e),
                                                            Q_(this, L_, "f").toggle()
                                                    }
                                                    e.preventDefault()
                                                }
                                            }
                                        }
                                    ), "f")),
                                    window.addEventListener("keyup", j_(this, R_, (e => {
                                            Q_(this, L_, "f").isEnabled || Q_(this, t_, "f").checkKeyBinding(e, sx.VehicleCockpitCamera) && (null == Q_(this, T_, "f") || Q_(this, T_, "f").hasFinished() || Q_(this, t_, "f").getSettingBoolean(Jo.CockpitCameraToggle) || (Q_(this, t_, "f").getSettingBoolean(Jo.DefaultCameraMode) ? Q_(this, JC, "f").setCamera(Q_(this, T_, "f").cameraCockpit) : Q_(this, JC, "f").setCamera(Q_(this, T_, "f").cameraOrbit)))
                                        }
                                    ), "f")),
                                "official" == m)
                                    if ("Summer 1" == p.name) {
                                        let e = !1
                                            , t = null;
                                        (new gl).load("data:application/octet-stream;base64,Z2xURgIAAABABQAAtAIAAEpTT057ImFzc2V0Ijp7ImdlbmVyYXRvciI6Iktocm9ub3MgZ2xURiBCbGVuZGVyIEkvTyB2NC4zLjQ3IiwidmVyc2lvbiI6IjIuMCJ9LCJzY2VuZSI6MCwic2NlbmVzIjpbeyJuYW1lIjoiU2NlbmUiLCJub2RlcyI6WzBdfV0sIm5vZGVzIjpbeyJtZXNoIjowLCJuYW1lIjoiVGltIn1dLCJtZXNoZXMiOlt7Im5hbWUiOiJJY29zcGhlcmUiLCJwcmltaXRpdmVzIjpbeyJhdHRyaWJ1dGVzIjp7IlBPU0lUSU9OIjowfSwiaW5kaWNlcyI6MX1dfV0sImFjY2Vzc29ycyI6W3siYnVmZmVyVmlldyI6MCwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjQwLCJtYXgiOlsxLjkyMjk4MTczOTA0NDE4OTUsMC45Nzk5NTkyNDk0OTY0NiwxLjkyMzk4MzIxNjI4NTcwNTZdLCJtaW4iOlstMS42MTkzMzUxNzQ1NjA1NDY5LC0wLjAwMjY1NzAwMzcwMDczMzE4NSwtMS45MjM5ODMyMTYyODU3MDU2XSwidHlwZSI6IlZFQzMifSx7ImJ1ZmZlclZpZXciOjEsImNvbXBvbmVudFR5cGUiOjUxMjMsImNvdW50Ijo3MiwidHlwZSI6IlNDQUxBUiJ9XSwiYnVmZmVyVmlld3MiOlt7ImJ1ZmZlciI6MCwiYnl0ZUxlbmd0aCI6NDgwLCJieXRlT2Zmc2V0IjowLCJ0YXJnZXQiOjM0OTYyfSx7ImJ1ZmZlciI6MCwiYnl0ZUxlbmd0aCI6MTQ0LCJieXRlT2Zmc2V0Ijo0ODAsInRhcmdldCI6MzQ5NjN9XSwiYnVmZmVycyI6W3siYnl0ZUxlbmd0aCI6NjI0fV19IHACAABCSU4AYEbPv2KYkj0AAACAVHJ2vwDMGrnP99++pLydPwDMGrk24B2/RCT2PwDMGrkAAACAV3+OP6V5DT8AAACAUM+Fvs+7Sz4Yv+C9RFdmvi6DTT5GfDa+MSy1vwQnJD2OQq2/RVCtv35EKz2hUrO/EL9cPcD2DT44Hmy+lw8GPigmDT7YbnW+soYBvkD287rCHfO/fZtKvSAhLrvWR/S/a+9QP9nDJT70Gmy+jsBkP4VDJj7YG2e+tHeIPwD7eDoVRfa/MSSSP4BTvDp4CfS/slywP3B5qj5wHtq9IVfXP5zeej9eSjG/sqqyP941lz5w8BC+IaXZP9Q8cT+sQjq/urH2vakt/T4AAACAVHJ2vwDMGrnP998+pLydPwDMGrk24B0/UM+Fvs+7Sz4Yv+A9RFdmvi6DTT5GfDY+MSy1vwQnJD2OQq0/RVCtv35EKz2hUrM/EL9cPcD2DT44Hmw+lw8GPigmDT7YbnU+soYBvkD287rCHfM/fZtKvSAhLrvWR/Q/a+9QP9nDJT70Gmw+jsBkP4VDJj7YG2c+tHeIPwD7eDoVRfY/MSSSP4BTvDp4CfQ/slywP3B5qj5wHto9IVfXP5zeej9eSjE/sqqyP941lz5w8BA+IaXZP9Q8cT+sQjo/AgABAAQAAwACAAQAFQABAAAABgAHAAUACgALAAkADgAPAA0AEgATABEAFQAEAAEABgAIAAcACgAMAAsADgAQAA8AEgAUABMAFwAEABYAAwAEABcAFQAAABYAGQAYABoAHQAcAB4AIQAgACIAJQAkACYAFQAWAAQAGQAaABsAHQAeAB8AIQAiACMAJQAmACcA", (n => {
                                                if (n.scene.children.length > 1)
                                                    throw new Error("Model contains more than one object");
                                                if (!(n.scene.children[0]instanceof wr))
                                                    throw new Error("Model is not a mesh");
                                                e ? (t = n.scene.children[0],
                                                    t.geometry.dispose(),
                                                    t.material.dispose(),
                                                    t = null) : (t = n.scene.children[0],
                                                    t.geometry.computeVertexNormals(),
                                                    t.material = new Fs({
                                                        color: 4464662,
                                                        side: 2
                                                    }),
                                                    t.position.set(-155.65, .209, -21.87),
                                                    t.rotation.set(0, -2, 0),
                                                    t.scale.set(.05, .05, .05),
                                                    s.scene.add(t))
                                            }
                                        )),
                                            j_(this, N_, {
                                                dispose: () => {
                                                    null != t && (Q_(this, JC, "f").scene.remove(t),
                                                        t.geometry.dispose(),
                                                        t.material.dispose()),
                                                        e = !0
                                                }
                                                ,
                                                update: () => {
                                                    null != t && (t.visible = !Q_(this, L_, "f").isEnabled)
                                                }
                                            }, "f")
                                    } else if ("Summer 3" == p.name) {
                                        const e = (new vo).load("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIgAAACdCAYAAABvoTB6AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH6AsJEBUoIj2gSgAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAACAASURBVHjaXLxJr13Zcuf3i9Xt5nS3IZnMzPf0SvXUPJdkoQxU2WP7Sxiwh/4C/gr+Op564JkBe1CABwVYUqkklUvSa5nJTF7e5pyzm9XE8mBt3ieYAEFc8nCfvfeKFSvi34T8j//dX+D7HdY5rAtY5zHG8uVXrQqAaqHkjJZMrRWoGGOxziPGUFWptaIlA2BdoFKpqpQcAcGHDhc6QICKqiIiUCulZHJcyXFBS/sejMH5rt2XddSqlJwoOb1+j7EOYx2hHwn9iA8BY9zvr5cSpSSqKqqlPU/l9RmsD/jQY4x5vf9aa/sZXn8WZHueAki773/2Xqh1e6z6+ndVK9YFwrDDhw4Rg/UeAUrJ7VoiiJjf/9+SSetCzhGqbvcJIoIxDrGWqtrevQ9023OLCLUqKSaW6UqcJ2otIGCMeX33ZnuPaZ1Zpws5Le09Gof1oa29GJwPOBeQ/+G//XOM8xjr2o1WRcRgXNhuyrY/raNSKSmS1gXVgrUe4zxUyClhrCUMA855xEh7uFrJKVJyQkTaTRpLrZVaFc2ZnBMlraiW16Brb8UgIttv0+7RGKiVFGdyXFHVds/GIsYgxr4GeMnxn12zBX+tSi2FWivWeVwIiNj296pUtmCoipYWUF+u3XYMW/BsC4eAbAFf9HXjGOvax7VQSqZsQV9V231u31Frbdf//23IL0EBgnGuXXO7j9eggXYtEUrO5LRu9yVbvNVt4+rvn0PMtlny6yZrgbttwnYTsAWc8/2u7YRSyLlFk/OB+rpLK8Y6nAsg0navFqhKKQmk4kJPH0ZUlZIieV0oObVF2L7YWo9Yi4hFjAXVlpG2LGKdx0mHWNc+70J7GMA5BwJVdVuITKXHWPe6e1VbRqpJEe+wziK+LXzOmekysy5PAHRDT9cFtEZKyVjnELFoSeS0oqVsz+2xLmBE2mbYdm9O6+sLf81MW2BZ1zZSyzwK0jJnMCNacsssW2CoFnTbHG3R2+Ib6zDm94smYoC2ofIaX4PoNRBFtswGgtmCs6KloFRqteRYqHVtG1crVcE4jyAtK5XKuk7tuZ3D+bahHJUt9VZCN+JCh/WhbZUtCqlbVBrBhb6lvi3CW0QWVPX1oV53+vYZ1UJaF+IyUXLeHlhw3rcHfw2WArVSq2zR7uiGAbrudddqyZSUSHFti5kztcp23y24QChlC5wSqVrwHkLoX7OMtO2N5kLJ8fVl+2583UHWeay1LfCqsp0ILQuKbceYLi1TlQxiyKnt+qoFMW2xqlasdZRSWOeJtCyotgwltj1j6DzOtyBULa+boZTUMtl2PIqYrQxogZi2I/k1aKxDjGxHhSBSUY0gGWMEYwwmBFzo2rG0ZTgRSxhP+O3ZvpwA7nD7junyRK2Frt/zV+kd3379BxjXIcZxGkeOu5GsSqmC2HbRChhrKWqoVTFVqCIIirGCloq121ldldEaLJkudBjj28stBYyhVkErOGvobKHG37CWHeru8QasPuCkYsIt3o8E5wDdAmsiJsWHgaoZyjPL9A+gid3hX2PcyDJ9RPSMQcj2DTGDk2d0/Q3i7kn1RMkPOFOoMmLMiM+/QuQNMX+k0JHNG7w5ks0AJN7JbwnhkWlNaA1EHUhVmeUPqEDnMn23x7ojKSklPRHswqwd/e49qlAUrAFrIa6lPb8XpLasGYtijZBKYVoyFSHlTPAerRUj4KzFbpk2lkywtn3GGhRQrTgrDN5gBGJMvMwrORdSXHHGEGzFSuV3333P+k//junlmTAM5Jhw6zxtyUKIy0S/H1vR5jusDYR+oDqPt8JgHaW2Ast5R8kwhIBKpZSK95ZlWdFa8cEhVYlZCd5BiXhRel9w1lHtyHV6QsqC9TtKBd+NqCYEz1FfYPiWpAJ5T89HuiCo6dtxUAWMZX/YUfNK8AOxZLQI3t/g6yPCf6bUE3234OWFIXRc8oBLC719og4BrYqpP5DVoMZAdYyhcHIGw2ee10KuiZgjQX6N736Ck477MLOo41jBisGYwjX1PCRP1Ipqhw93BAeHoSDxiVoTTu5ZVRiHQBc6RCrP54njccAZsEjbYFqZrwv7XU9dE6MNGITrEhlCwDkLtMU/9oGoymXNlKL0w4AVEAMpV1LK+K5DNXHoe1w/klIm5UxOkc5VHh7P5ApGlZILxhhyTrgUl60AcizTExw8vusxLnDa7wneYm2HGDAiOOswthWKBMFZQ1bFOUEMhF4oueJ9O2JCZ2mnjceWjOhErSspDmA7vJ0JfL+d4fdIOOH6r5D0j4g8sbj3+PE9d+YB0q/IzNT+X1FN4HL5QEoWKxfi8iuqeHIJVArGB7xZEfNEyS2TDV3A1o5pmTCaUTF4mzH5kVV3YDqkvnAIEVMvWGdxGby13A3PgDK4X7PvRxRHXSPGWpwNpKKsTOzMSmeOWHdCTIcrj4z2idAvXNdKNic6t6NzDkHw3uKcZ1nOhNBjrcc7S9GKCR2aMuMwoNpeuQuBofMYY2jJuZC1Is5hiyUTOR5Gqla0VIoUrLFU6ykYMoKaTDWGVAsJQ47KUi1qOgxgrGBdgFpxxhhUla4b0Bxf28TdMNKFgFbIYth5RxcCzjvWmDAI1llUK8YIQmvVjE1IbxFRvHWkonTeQi2gMAj0sqLpeyJvSHLA6UyQiPWPVCZU3oG5wfGBffc12R6w5hcc64TWZ9b8n5jlW5z5QNYjVTyDPeOsw/uOy+JRSfTBUetKLIq4gSqQsmJ9j6uOORaCEcbdgSUHEBhtpnNKKgGtgrU9x8FxM8LT9cquq3gnvEyZ0PU4I2RaZ9ML1HwmZgFzQvUTN8OFg/sRxJHNDSbvSLXVNy1ADCk+sd919P0RY1r3My0LYoTdYaDWyppyq8PWhHWeLnicNUgVSi3EXNk7GLXDO0OtBrXK4OC8TEylYoxjLYWcFMRgfdcahloJqWB8t3WL9hW6cC505NS+VMQSgieEjuAd3jmwjlIFHwKlwnSdORxPmFqpUtl1HakoKWUQWgGFkPKZdXnheHqDswPWQIwdvevZ57/E9xeWOjLXG0R+SsePjEFZ5xeC/UTMgeATxn3Hxd1i7FvS+p6j+R1GfoT1SnIjsayY+plcytbeGozdMTjFybXtNGeY655J3xKrBXUEI3jXoyVzOjjc0l7aqbMoQrAwzRM3g3B36Pg8Z/a7IztfiGrwvUNqbtdeMtZUtBqCudKHF7x/IRbDTs5435GzsvI1wzhgVZCtaF3mzyAr97ffsB93PDxfSQgZjw+C1kouCe88tcI4WJw1jH3XOhAxLDmx81smN4YueOJ2TMwx451DgTVFSqnQBXLOBDdwvU6UlHhzOvDp8TNSy2u3ZmzAfQF8xBis67DW0XcdfdcRQiBXIXhP6LpWO8wrKRfcVpdobW0x0irklDKHXc/lmpB6ZZo+0Q9vscZgLWQcZrjn2I+4WKnrhbmc+GG546QPHG3k3Q08Pn9HJGDKP+J1x+d1wGLo+4XeQhiumGT4cdpx7GagspSCMyuGEWscBgjWcD8YPj28UFPlup7ZdxlJz7zpdxwHOPaeO1+pNYIBzRFKYddBLM/YdeUoPaYI/W7kelkwYnDeE1XBGDKZVJXgKoNVhm4mxcLQVSoLrrunzzPn+AHpfkLoPGV+ZNUXxN7iQuDhsnCOytAFMJndbsCJ4TJNjL0neE9KDfzaDR0xF0pVeteTSkVjIoQOEfCuMi2JNWb2Y08qrQgupTKtrayYYyt4x97jjfKbcWAuBQHSOtPv9rgvII8AYi3GGkr9PdgzuEDXuZaag2M3WuYYSbWyC32rnEXoQtgQSIvFIHYg9DdovmJkRiSwrBe+vRt4mU44GzD1E8EUrBGmqbJGxwNvcNMDznmsVqgLJv97bPwWlcTaGW4GcHZgKAUtETE9xz7yODvWtDKYHwha8HLmCLgM/+Ik9J0SHIjpEdc3xNdYSkkNWMpnxHj86Q1aUgP5Ykasx4WxtbO1Ir3lEiPOD3z69EIRmJPifcfzeuB0utB5cN5jEawIU7ni+TuM/oTb8ecs0/es63eMu59i7IGUW/vtvZBK5jCOBGc4jAPGCtMSiXkh+IAxoBU670laWWKhIuRScc6w6zyn3cAPzxc+nWecs+QKXWiZwTpHShGDYkn0RrhOVwYfWKThIloy/XDA8c/gZdkg1lwrqQqughUhF6Uay3VdsdYR2lsmqdKFjhjbee+sYY6JDHRdRyzCEDylLFATzhau85WYVh7Ucze+4zi8YOzM+337zI/Xe1Z9S9TKYCcOvefhHHm3f2RJC3FN+H2g85BK4pt7eLoUxDgGU3m5PjGGnrf7nrc3XzM6S+8tJa8btqAgDoxgcJQScdZTNaMmgLGQEpSVim2pXSMk8KZSrSO4wLE3rKXi7w48Xq788nlmdzOyRE/KhbkmlMBh6DDOM10XrLEEszA//iW4yDDc0w8nhv6EtZ5QK9SZooX92JDsOSaWmBHjWGI71m9PPVRBgSpCUlppUBveMqeMThNzKhx2O3JKdF2DHuKa6bxBqsUbxzRlHtOE1NY9NSi+gqlQFftv/+yPKDnjQiCtC/XdLxj3R6oYxBqM9YTgSKngvcWHBq2noqy5UCtkrRgDXQgsqXAYRwxC7z0u9BgJOAvOCGucQFeMwMvq8Vb59tZj6hOOGW8brlHNHd7Aocv0YaRqIqsSfGA3WAbnsK5jnhd665ivF74ehJ+dev7w7S1fv72jMwXvKlUTIgm04sOItQY0Iwrk1olA67qs7TAYEIdztnVuzkEu1BwbAtmWhiAwdJbb/ci7U8dynTmMEaVQpdUIY7D87uxYY2EXhNuDQ8oHTLjH93+ACTfEXKmaKfN3SF3A7kml4SEIKIL3jq5r1Mbj8wWs5zKv9J3HWbt1kxXFUCpYYzgvkaJgnDD4VhR3wSEl8+7uQEyZ8xJ5eL5ymWZyjsQPf0ucr1jfQdV2xDTUrD30ru+42fVMKhTAuoZ6dl0PUrHWNthEG7RcAGOENSnB/75/nmOiDwEpwjDu0WxJuaOmM2gEI2ix/BDfIi+G990E9SPOzBy6iafrI4t/x8tcCH7hZY3EVBjEMZcBt75QEtwf7hmsxZ0GrGSkgjgLGrGimCIgtmEz/Q5jOrTMlDxRpYBxGNM1stIKpcxoXjDSahExjrwuLfFoRaRixGKkUsuMZjBu4G6/Z+8da8l8Ohe+O1/o+h2/zB1TFL469Hx76/lxSiQcOb1wnj/C1hTU+R8Zwxk3/ClzrMDCfm85HW5bwWkNPz69sKyK9YE1Zax1xFKJq6Lk1ixYcKZ1LGJs48+yYJw0bESE7DwfPl8ouRBL4bAfuZxbZrUuoFpwoUNLbkeMGENOCYDd2JFSwvkev7VAxlgqQiwKpZJTYxaNCFqVKoaxD6gISmWKiSleqXVl7EdiVMR1DfSye9Bn1pJxtifGzO+eBj6sO/7V+xvy8gmk0PuM61ael46aCjlfqBuE/fj5iTffvuF0sthacCYjOLQYcl6pFGwFckZFEOPwfocWIcYr1lh8f8L6ccN4Kuv8hNYVTVc0Lw3ux6A5bS18C46aZ0rNGOOIy4wNHmMzNb0QrMNJZny34+5g+KtfT3yYR06nHe9uYGHlOq/sQoexii8zGgRfP0L/kcRXvKwDtWbq+j1LONFHzzRPPF4uLLnjeLzlGiPeOJTKj08XarXshtBwHmMQI8TcupfBG7RW1lJaJtTCy5KoVTDWo1UYnMPsdjw9P2PsF7KzcUL2v/6LP210e4ogQrz7lxxPtzjvGYeBoe/wIVCxjdTaoPE+hAYc9YFd3xGcZVoiWStV2r+XMrWUieEalawVawNOKlIj+9BhJYHpEXdgXZ4ZQyGWSCwOVxVv4OkyMw4jKS0EEX7xzS2nocMDaKKWjJaE5kjXHXF2QHMCLVg7UDVREfrxlr6/xbmh8Rqup8QXdJ2oaWadnjCYFgipoKlsmRI0RkAx4sgxUWMmLxOa2wZy1iEVjCgGxYvw9nRk5wquWt68Gfn46cLOw/0Apy4zpZkSE3b5j1Q1rObnGAq+/JbOJ7RYljhxnhbEnnB+wCCEvjHQWYU1K10XcEZwzlJUEYHOGTpnWVJBqxCTcplmFOF5WllzQWthXVZ2g+fpfGWeF8r3f8s6X18ZcWetIxNfO5AlV4pWROuGbsKyRsQ5OuNIqohtRBdVsAbWNeJMxbJSqgUJVAS1ezAz8/UDPtxgwhHBksoeZ56pvHAYj1ymzxRVVGZSAWN6MJbjfqAPno8Pz5AN78YDf/L1Lb6uWJ0ap1YbOaY1YXxAacHiuo6ohXaQN8QxxQvICyWVRgOcP4BGNCtimw6maGOoxVjIK6qZ9TKzLjNoQxifHx8ptTQCLlXu39/jO0/Xd/j9DsTinGFvHD9/a5Cu42k+8/a4Y+w7duHCrx8eiclzCBnfK5c8EeL/w24ITNWzpBswiSKBbrilCyO5LFiTEeu45oqzluM4NM4LEKktk2fFGtOO/qK8XK8YsVjreH6aKLXirSFrYUmRD5+u1ELj21JCBEpJeDvgvugyvmgNnLOUWhB0K0QzxgWoUKqSStkItxYj85LovCfmFdITloroW5YsZFUIe5yNmPxbOnNDVMM8zXjboWnF8MxpWEh54jpd+BwTh7GjVuGcOj4+ruyHG77aKz9/fwPz00b3tyNRqsWYgMVuAVMxtVDmFfJKWvMr6HO9PDSaAEOJC1pS00/kit/vcC6wTBdqUgzC5fmZ6/XKsixozfTjCRtXfB9Yp5V1SWiyfP7hE7vdiH1zT2dGkErNEUOi942J9ruez+czZPi8Zp7nDlMTOztjQmBJGe8f0eTZ7X6BSQPYG1y4aRjP9AErCenvOOzuKBopRTnd7LjMC7k0sYoRmFIir4ZclFgKc6p0DqytKJXgPSUnLtPCWpS0FCh564Aae/yFNXavQpkmDmGJSiwVq5UlF0ws9NLaXcEiAsuyYsSgIlgjfD7PeAteBV+vrMs/gH+LsQeWNRPciRhfSPFXUC0kR4oenCOlC6ILUi9UTaSiaA2MIbDMiaqFb/aGX7w/kS4/ojlSS6aiaG6/S4oYF3DBM9y9BzGUNBGXeZPeGHKKiIANe6yHXDPS9azzgkpBkxJLRGPi5fMzAkzzFa0G2w0468F4bHDEuCKuwxKxxrLGmbg+Y3zP4Y1BrFDygiYwUqEknLG8PZ24rBe+fzizrIGbvScEwxQTJWeCsxBOPJ1XfH8k+B2uXrhcP5Fygu6ew3ALGnEmcRhGghVq55li4bysXKaVNSYUQQvkWjn0A2PvWWLEe09JieuyEFMh54pWUFVyiazzlRznJp9wviGpqgXVjDGWpJU5K8FWqimIUUJXqSjGCLVU+s5TSztO8sYrYCrVHinrhSAzcfk1+PdE2aP0iHtPzRWvv6GzCmroXMDLQqUQs1LVcHe6Y50nSqocB9ibF/743Tvi4295+fQJ73uWmLFOeXl6IS4J33ek5ZGhH7mvhuFwIq4XlnVlXVeGfo+Y1qXJYqlZ0JpBBTBYI5ATJUNaFubpgjiH8Q6Lp9JTMeQ8tzbYDhi3thfuOrphz/TyiYcfPrDbd4zHEy4I1lpyfMaGHdb0jYtyhm9uDsjjxNh1vEwz51mwRjGu5zpd2O++oWC4Pv8D3gmdH/D9V4T+LaqJl/OV4Pf0wTTxT630oXVQcykolpwzu85jncEbs/17wVpFi2nZ1pl2FHlHqk1KGecrtW6yUeuw/+bP/oh1vmwiHrje/iGnmxNd17Pre8aupyI435RVZdMhdGbCcaEkxdmeLjh86ClF0PWBnfsRVwtLDVTj2guWPbVaAp85ukd24cr9jgYsRWFJjuenMz99d0dNL7w/eH52dyA/f+T7X/4Tnz49cJ0SBQ8SWFPBdjsqTZbw/PwMapleHpinC2vMrDHy8vxCmpskMl4v5NSAQSuBdZrISbm8PHF++sy8LCxrxoaRSofmRDUN/yklUdQg0ghO3/X4LjQdl6nkOPP08MDt7QnrLcYKYk2DBkpqMsOidMFwewzEDCkJu3HEhpEpCr1LSH5knj4i6YVqR9R+xfHwNcv8xMvzrxAJqHR4I5wOIzFmxAhP52uTdVrPYej46mZg37dOZYmRvEkVwyZTtAbENqVeKZkSVy5//+8wzhL6Pd24x+XUFFfW+6aKKoVOIFg2sUpGMczXzN3+gBXbUmHxiL5g8pU+gLVHjA2s9kjtfkLNHzmGj3gJnGthv/+ac7RkviX0R0L9GyT+E8sSsBkO/S1PzwteHNenT/zp+z33o0HKRCqJJQdcf8ewG9ECT88Xai1YC9Za1tXg+xuuc0JLbFlNKstSiTEz1ciSClYKlIJYyOmLqqtxUFogDEdqmUmlqapULBpXhnFkcEfWNW1dS8MLUioYEXJp7xAtLNOEHx01aVOoiaVuLbQYQZPFhIH7fUewV65F+O13PxCcpdgMCMH0aPeOGH5CP74jzZ+Q/COGivUj11U5jFBSInjL87RwHAeSKmAIBnZjA+icFx6n1Pg2Y0ALwVuc6bACcY4YDKsqNoQmN/ShyTH/9R//hFISoWutX3n3Cw6HA9U4otJAJioYoXeWXRfw3lGNZ0mJOD0RpMnujA2sGGbtKHLgzfDM16cVyQuaC8ENnHY7vBu4vnzg1J2xYlvfnxRUuBuu/Jt/+Z67vkOXZ6aXz3z+9JklVrwfqKrEGMmlHXmoYDbpY9e14hbrKCqUrDhrN3W8R9UipkdFWHPFdUfG3T2lNgbX+gMpa2Nz/YDQOrr9bkc/nOj7wybJg5wK1ni06KZ3VyDR+UBcC/fv3jUUdFPBG3FoyYipGAyaC8ZZjLM8nK+8rILWQtHciE85sJi/YCkjZfqI0c8YmZlW4TpHglO+ur9t2JAYYm4NRUqFx+cXjuNILqnJL7Xyw/OZOSmossaIs4Kqsq6RaVmIMbMuK/XDX9GN+1cXwVakNoq3lEQVQ9KKKQVjK1EVK4LZ9KnBGfLW9cxlR/XvWPInvD6Sp0zRE4UOGb/lbAy78nfs7Uf6euFlPTP690zrJsCpha4PXK8rVir/4s2BP/n6Dxg1UuPKep15elzIGhAmprnR985axMBuv6MLTS+RYqLrAun5hZKUrI2VLJrRKjjjQdrZW4rDWYc1DjD44FlX0FopVdEtCI+nHTddT4or1gTEOMImlB73e8QYBlWm6YyxPbUo1+cX3r+75fL8zHjaNXlmWSjiEXHNilArlpm8RrAjPSvrHEkieBc4GqX3Slr+BmvGTdMCUStFbvHBcth/xZIKnRPO00oVw7RGUm5Sz+dp2tT6C2LguNvROU9KiZlK5wxrbfWLNfZVzW6dJ3RDcyKk1NrcTV28+T8gV/BiWnTWTM6ezgtD6HDOsi4rUZWKww33OPGY+B2DT5zPD/juDbV6kvmaH9bI2+4fOdkLw/IE9TtiuSHmhX5wvFxXOmvobeFPvjpwEEVrYnp54nyOqDrO52dKWVr9YncthQaL26wM0PCJ4D32emWaGx1fasUajzOg1Wy62SauZtNir+vS0GCtIAXQ5gehtkJvF5oMwhi0rlAdPgRUBSgt24SelJTLtYFSKS1Yu6eUuolvPKpg+x397o7r83dUCqIV8sKbvecnp5W//lAYdz1nXcjlCe8vVOlBYCqC2vfY7lsO+6/Ravj444eGFLs9tRqW5cw1KTkpz1PGOUtwDucN1lQMli4YBMeua2jp7X7g0Ft+uS5YKyTVV6U+0FTtxv7eLFVFEGl0sq0VodHHY9dxHDv0C2RblF3neHMz8nw2qFSQF479TOETfQi4cCSt7/luLgz5/+Wbw4S1T5h+Zlorj5OhrCtfDYU/ev9TxroyP1+wzhDXibgqRTPGOdYIMS44N2BcT9c5nGskYkyF4A0lR+Zp3lwhBpEM0oRAVZteRTeiLedMrV88M42Uax4bsxmODFVb+2dd2NjuRlQ2IbYBaZaKlJemHi+KdR5tDBXO9S34ALEd+5uftaLaOOL1I2l5pHOOJUW+2Xd8PhYuGrjfd9zsDU/TTNEV60bO6T1+/C9J2TFfHij6BOI53PyUh0vkMi2EbqAfPNFUUi70wdF5x1qUkgrPZSU4QRSuSyLGiGjBiGkF6yYwz2mFCtY5XKUSuqEBZTQF04bLNbcDhiFYdr3HO1hjO25ElSE4cikUPOre8ZIsoysMpoA+U+YZ52+Z5Ru0RqydOfRQ08Qqe0qKrJdHbu7fcDs4yvSMmILmwvX5mYeHZ6pUMJbD4Ya4FPq+Y7fbbwxsJefCujYhtOaFUpQW1i19ppTQWgl+IGsDk7quo5TSugwqMTbuxVq/nf+Gokroe8S4pr8oGzdDyzK1KkULOadX/4vxDieO4+n4aqSqkinZEsaBZT5zGO8Ydl9R8kKKT61BwHE8nvi3h8pvHmaOx7GFmFWWdeKqX+G7P8GlCau/Yy1CcXd8fnrCdm8I4chIU62NXtiFQEy6Bae2ek1a7fKYV8bQUTfP07ourOuXE8Fs5F7aDGiukXVfKtYvNsCKvNoTixYezxN931ErXNeECqiCl8plimhVVIUqI+v8QL/riatSCcS4ooxU/44qf09wlvvTkUPxhHLF2IFv706U5bHZAGsT4+6PBx6frqRaWacnRALOBmKMOB8Z+r4hohtoVlWbS85Ia2M3baV1HUnXJmxyDiuGnLVhFHmhC4FgHLFkrG32Da3t+a01rQCmYqQ56GQzTHkvpDlSa6aUihbB2bGlcutfHXFZMyKBUhKmRtLymbTOWNMQYM2x0QW60BnHT+8Dv/n8hJod3hnenu7IzyMm/xXT+plV7jD9nzPpiWiPfP+SGdwTtkQsE/OqJHPHSzQsqbDvOvrg+fRyJeWMMcq0pGaLKMplWtASKSm/OgXF2FdXoftiJ4ybq6p5PMFIs/ZZBLXCskbO80rSQqVhATlnFMBszrey4kxESmDwhWm9MM1XxO8Zhj1r9Fxkxrgjzgo33crNzT0731OWGRE2913F2nUp9QAAIABJREFU9QEXhJKb3k21IK7g3I6qwvm64Kyh9QRNFZdSQbVi3aYUyxWlHYm1VkyV31soaeRWS6uCM4ZUEgYH1SIVUox03YBIs4N+MX1pbbIGYxrmgFaiFrwP9J3DdzvCOCDGUlLB9x05RwY/kNOV+fJraokgoVHsArWWZhPVTGeEx3nlzftbXqYfyfEBoSJ24Brf0LPj3c2B3gkfvv9HfHjB2oyYnoUbpLesOVMVlnUmzle0pmZuE4+3HgT63jEtC1oMzjqS8MrmlpzIKbYuRksmzldCPzQxzZaevbUMnafrA7uhY40ZZyzeG+Y1EYInZkU3FjNVociRrIEyv9BZoQSL8Ei5fk8NHc5mbH/DX/6Hv+Snh8jP378HTUjT22/tIsQ4Y73DlMgw7nCh2RDH3UgurSX23qC12Q2ddU1Q1HWUtDSEkYrzprGszlA2B2Gl4JylCwO5tNZQxCK1/t4LbC3rOqOq3N3eg0k0x2ijHLQ262O1DsqKSDt2vA3oZh0oJeK7kfHwBhDS0uorLZXleqUfe4zryOsVg6BpwVjhfuxYY+Jvf/kBsZXglNN+JE6O3kNePnKJv6a3F96FK0UgFcGFN3j/LdYP+MsLlQnShHVQtYFr1oYW2JshK1fFWkMtbDxVa9pFDDmtOC0F3VzzYnZb/aEMzrALluBtqzmk7TprIF0/4HXC6AGjBhf21FqI5Zmb+5+zPv8WZ1cEZQx7XP41o1/57mHl2J8oT79i7xP3h1tEF3Jem+aiNkzEuNYpjH2PpsR1zdjBtNqgtF3snGwMpeCMYr1F1HM4HHh5WtsOV2lmaSuo5s1O2rJDyQV1rd1tBWtz9Bux7XhVRRWcFV6ePyMC427fitBqKLkQXEfeIICUnltn1YFzpuEZZKoJKErXHZinT5RcEDzejVgfkLphNHnCGgsm4FUZQ2H+tPLm7sR+8ASv3O8qO/3AdR2p9Zlr2nM4HfjwLKh7x67/BlMrojOdeSbm1BR9YSRkB6V1qV/ceM1r0zaSsXbLurlZS50jzTOO7Sgx1m8KpOb2Ntsx0ipc19K4MVsqPHNwE54zO2cx4plWQy0ry9OZod+zzhe8OxPzI+jKqleCs3z4+MA3dyM/vb/hzb7j1fBaQUxF8Ijp6XYed15Zlh8auXR+oh9PFL3QdTu87xqOIWB8peSVdZ6b/cE5ZFO059z6FrGmdWC2yRpizKQU8d41BZVt1xLJLVhLC5h1WdFasMYhXLdbNZSiWCfNXI1gjaFowlQPtIyk2+gL77vWRldIacb7VmSXtG73Wjf4vmyaEsPd6PnZXeExKk+60sWV++OJTmZ6F1l0IKWvSNwhXcCYAGXGUMkV+n7POA70/ZGneaE3FeKKF8tuDExTZFrTBmVALNpQc82IsVixJLPgmlHXtBkTtAr+Cy8D4F3TO2qFUpQuOKp7R5HvCHVq2L5VjM8c/bkBL/Yta41YMxLkBZFWRbtamRbl4eHMz97c4LynkjA2NHrce3JMCBbjA6c3b0lx5fHxhZQia5zowh7NM+K2uRrVUFLi/HJu5mvvMMY3YU+OdF2zCqTSJP6GSioJqtsyUjN4sZGWiIApjZis20gH07CiaZ6xrh1BKSsSK33XNxecNRjjmxnJtsWuIvhuR8oJK3WzrB6wfgQspZwJ4cRy+YGKYM2AsYakGUPhZ1/d8P1/fuI07Nl3zVsrxlNq4WX1VBtwCHtzxXaC9T3GDeTapikojseXCamV4BxGwGglbxbNWDJGhJQTtWy93zZ75MvUBNfaxVactK62+WRiyQy1UjRjrWCMJ5UmRLH+SGQE/cRgJqpeCLZgNTEMsOoLh/1ATk3A0jPirWVdIzVl3r95yzhug2kq1NhEKrLtOGsVsT2+61FVQugZxjtSyRRVUlIqV9Y4YY0npYyxht1uwDj7pQRlXa+sS9zsjZZSmhDIiGwL/WVmRjM5e+9epxo0S0QzKzViT1hKoZQGIOVS6bwn5+bit9binWXY3xJ2PbW2nVi2gj/HK9Z6hv071vnC6e3PePrx78lpQUwgL83qWU0TSUutWFf4xfs9q+txVrguV6oV5iRN18sDKoU3d98w7t7yvMCSK2YrFFIprDnhnCeXZrjPVVvjUevWBtemt0Vfa4+q2roaMbg2OMZubvmClvpa5StQagOdVBUnlbz+iEXA7JjqO5KpHOUze/mM4YqWKzejo4uex3VhKcqcMsegONtxCgvBZjpLm1fBNqGobrWF70nxivcBkcA0Z9DCulzohj0lLYhprrRGlClaK9a14qpxJW0QivOekp5JZWqiHR+aGKqara7ajjb5csoJIQRCGNsiUVubXppWwtg2OUhoR3DeJieJGIZhwHqP7ULLiNWiKFIy54d/QlU53v4hKc2keCUuE9buyPHcpippJmyOa6WJjjWt3HTCPzw9I92OaV54c3ugD4qbLc96Sym3zNNEKj+w6I4sA2IMKSmPl4WscJ0mpLSOrrYCa6snDSqmNQhVNvXd7yckbS5JeZ1so69DSOrGWwjB2O2CMHQdzgZsfcDnv2Oo36Na+CHe8WP9Y3T8c/rd12C/YZ6+4xh+4BQu5Or4PHX8+pPjuBsxkrHGN19pWdsAkza3CvEdrj8gxuP6PX/4X/xX3Lz5BtXI0+cPaG5p0RhpZFl7VrzzGBtQhZRaCs2qG+o6bLMxCmZDDBvF0CYdad20LgpIwPsRpKMah5iOrt8RfE/oerwf6IY9oTNN7LxOTUtj27yTFEuT7ZkvqrWIlsaVYIT1/IkQeubnH1ivP1LLDDW/mrFVM4il74+IWLy32BLJMTOEAW8qDiUYT11+x3z9Sy7TPxEVjGs0RIwJLcqubwhw8B7nHEM/vE6NautbsaL0zmHMhv8g2wyVVna438/Uak4ykS3tUHEi9GFTr2+7zIRbVnHs+TWSfktdnrHuPbmc+P56Io1/Tijfc9ifCOaJNS7cDU329zB/z9C9o3cWtLKmBe+7VsxpG2LiugMpxtZ2Wsfu+Harvg2Pnz+RUlNf+WARZ9FV2R/3BN+36T61tMlA1pJLRqwlxzaVIOVMybUp4zbltrUWtixU1LJEw7Re+fjDI3d3B+5PPYij60fiS2wwQBW866gqiESAhkbGQpwS1lZu3t3S724bzpFHvNsjYhmO90xPD9tB1rJQrYL3Aa0rYgPOdsT5gt0kBfd7z4uCDxZjMtclAp+a0Mv8IcP+zwjdPcVYnGxFuWrz5XgH1hBJJC2Nic/6ind9cTKUc95mvrj2Tmhgoqu1ojk2faY2Mav7wt5ucLGxFmccqnUbEDOC/1Os+4Bcvmcwv6Gm75u8XivX4viUdxzDwt1QuT8O/PjpI9/cH3HG4GijnsQ0aX0tGfM6yK1ZEJ0fqWpRKxjXUcpKUd0WtOEV4zjS9YawzT1r2QFqbdhGlUDOCXEDSluISlvAZmUo1NrazsbJOJaY+fd//Tv+t//j77m/DfxP//1/w8++vsF7oR/GVrw1kB/vK30/bsP9FO8dOSneB6zrKQXG4z16VqbzJ/rjzSaQHrh9+57z43eUvBD6nnV52PigSlxftgXMVCrHQfjx0xOfrj1raSzjOAwcd7dcr7cMuxu0wrrEFhw0K2ypyhgcRYSSSzNvbyz3mhVog3imqFzW9n5d6DdQMG0hvM0n+zJuSjAE6xi8p/NtJxrbTNlrLHjn20gm0/GiX/GsPyWzx7rEMfyO0fyKo/k7brqPiCiP15WHx2dyTgQbcNRmETCCxbYZXXndiqPaBuSVAjUhRKwxpDSRUtPB5lza2VkqJTexUMNFwutoK2sdWj1//fef+Z//l/+V//3/+hvEuG2UFNvAuMapmE1dFbqAsULfW375288khY+fI//n//2fSG1OHsa0GqXWgpZCXAspRubrhevlwrpNJ/Q+4LoB5x215jbD7XDz/xH1Jr2WZeeZ3rO63Z3uNtHciGzJFEmJRZYoUVRJsquzyhYMGEbBI8MDDwz/Ic/tX+CRDbgA2bCrbBQMyC5DlEqiSInJJjMiIyPidqfZ3Wo9+Pa9GuQgkUDEzXP32etb7/e+z7usA1pW58847d+TYmS1fULOJ2AixBFlBBlVkiwTC5rKrvFz5DRpUmmo6y2bbsPzM/GkztOEMRqrNboUdI4YJQ/HtqtZV45VU+OMwWKWz0jiHSiYQiAVuYbbZTuekyiv9kFeV0qTU6BSmrZyKAO6REIKxKIp2mG0/IJSUdyfJkyZaRxAR+8VVT1hy5esupphOKB1pqj8+Iv7+INP0dM7NDIjFG0gLXA6o1CqwVYbYhwZhxNNs8KPe/x4WAbYRWlV5RFOZ6sGrc0yP2WMscxz4vZm4r/7H/4VQVX87//Xz/n9713R1tDVFQrRLBRya7HWoY3GVZAS/NGPvsNPfnG32Aka2ZVovcw8GW0s/XBgHkZSjjRNRdPtZClmRB/JMZA04EdimFlvXy5m5oHkZ8bhns3ZJcPpDSkfsNoQcyKMJ+rukhwirurwwZNz5vmuwU8Vzy6eUBvPlAuvbt6T4kQZNVm94LxtCSmQYsb7gfuDp3Idq/WOlBWbrsKHyDAHVFZkmwheyXJTKYpW4opbGG0pBKxQBg3GKvw4oRSEGGmso3bLN91aUi5YLTNKzgUfEjWBRt+jVKKrDbFsMPo5J98TUfjBUylNbQxd3dE6xzRGQpr+PrJgeDTSaKMpKZGCx1YdpQRu37xmPPXM3hMWlKaQGGWRVnKWYwSNsYp5njkeR/6Pf/tTSrE4bfjB9z6icpbaKSpXkWICI9tKpSS7qhH8Ui6a73zziv/yP/8DDseJH33/JRrRTWIWf4lSEa1q6lqhjAh8qIwxiIw+HGm2a+puQwoBUy3wmvFAv3+HUhlrNP3hPTneC7wnZar2guF0RBtHSYoYxK2mjeZs3fH57cBb9vjQi5LsKmp1Q8meMN5znC1FnzHFTKZjt33Cqt1StOMwSd7Hx8gcHhazy45LydGdk1giUhTgnfezuNqVsiJmGS3J/lxotSIk2W6mGGmqBPlAiZk0jIAllp6pvMUCSq3F3R0/QOe3rMxIU3nC5Alo+uPXnPYWSqBxK8gzqizqIX9PBpznW1JJuGbDPJ6YjnsOd0dSkXu50hUpZVJKqNpRUZMTIpAZI1fGOPEbnz7l/N9fc36x5l/84adoIpWtRfBTCm1WgogqjpT3pOzxU6Tu1tQrzR/9zkuOx56m8iidSUmu6TFMDMNBQCxKk3OkqerHTLBKGpUduTi0a1BqxhhHf/cl4+EaSNhmi9IVOhdgTUiattmScsFVW4lFao0yVh5+FamtZaUCQYkDbN3WnK1rTmPPjT8ns6HbvCTqLVWBrGpKKUwxcxyOxKw59J6Ul11XjOQYFg/MAgheEJzTsBdr5zhifvib33jUQYKf4JMfUle1+DuVoXaOxskV0lnLNB8ge1T2OD1jVcYZkaVTmAlRYhB5+pLaFGJKhFTojOHpzsmQq6BkhbOdyMyohVAoYDptxVta1R2UGT8OHPsTyjYyqxS5Dj6YluVWnnG2IniP1pnNumHTrvn+ty55cl5oayPRDBTOfcDzD37Iqrmi/+oAlRCRWJhfCg9F5gCr5QMVaG9g6E+yutcCiasqh1VxsQPIUbc+O+fs6hPqds3h5nPi7MlhRGlHvT5ffl4r6qWp2Zx/hJ97QLNanxHD9EhhJgvawlYNsx84xlq0nywazGnODN5S6BmmA/PsMabBmgbjHJWztHWFj5n9MKNlPCdRUGWRN0ohhFnYcu9/xnDck5KkLS2Aqyr8HJazR5Y3MRVmPC5YuqYGZTBVjaOimIGKgTAfAYfSI8F7nJmo7ETwA8puyLlHac3QD1yuI1olrBIvqF7mEqUcyQ8o58ghUa03xCBgmJgMStfMKRNLhVPCEbNaQdZoNdEfb8kp0202lGWPIMaomR9875K6svKBJr9oPTNGT8RxJL695/7Nl7RGU1xZhjbxdsQ4UzIMg0crg6sMMYblKJE3ny6aeewZU8TVG7QpdI1ltVvjXEMplnb3AWHoCXGi21yKcrpI2ko72u2OlCOr7RX98YZhuCPHibo+E8l7WZ7GOFNXjmnvef60BSKznzGmoisjvkgOJ3DDYT/i6ue06ysa21A7x+gi66YmlwTJEceJYAomi9uOIjcoMT+VBaduBf9gnKOMGW0tOUv2ZQwerSqKUqSSsRj8HJenecsQapLdErOn2EhKe5zeU5s9NvY4PYlFXxtcUXz0bE3jGnkwlh/IuJowHh+9sMpYUkzy9JKhVMJbtTWbbUUuotCknDAolDJoXbBuRQyJiR6NkV0LhbYGpROUSMqTvCmzZRpvuX33t4S7CXORyFoIQyi5NXjviTGJy8wKKC4u849zDUZnUhiIYVx472usFd779uwc7Rx+HqlXkjFuN5cYZ/DTgTAPqCKKbrs5E4P0cCToenHeCwU5l0KKnqqRP3s8vae2hjmMfH2XsHaNcx1Nd0bdriHtcM1TfHZctmdEZYgJRh/xqfDu0BOTJ8ZM7SyxpGXQf+Du60dW/MPNzjonbxCz4KaqpmNeNHmtZbLNKeODfDObqiLlgk+BHCXOoEoSXT9rZjaoaFi7A6YEUi6gKygjXXXOg9sgFy3XzrTkgq0jxwgYjG1wtdjzope1vdGKMJ/wIYBxrJuGGGZSEVaaVlYyJTnjo0ctnhbvBb8kD6om5SLmHO2Z/BtiHSkqyPbTtMsvJS6ej4dl4BLe1HK0lZwpWqFMgy6WyghRUBvLqltjbEPVXpBNt/hSDQqHrQWL2WyuSCkQpxMpB+IgeoNxlrG/R5XEavdEjpySmKd7dLdDW8vZbsdvfthy9DCGjrFccD99RNU+x9UNmIrDNHEKE2fbNVopxhSIITPMiTlEQir4EBZWu0jvMgyLHyTFKCjwpdRBlhaqYF1FLpaJIiSeRY59XOYtuEyjZbvrVKTkPcQ9ioAOE/VqQ6Gm94kzB9bWTCHx7HyH0aK3yP1bP2KhWcD22hpy0gvLXT3itG3lODvfUjnH/eG4bBMi1mnZlyznfoiFnBBfiFqSKjmRk6yhUBnR4tLiQAOlozzEZHIOeB8wiwr78MUxy/KvPDYvFGIMhJAWu4FoMLZqxHhTIIRA11bkNOPHkTDdyjU4CPGH4gm+p2hDVa8er9MrrUlBrsVhOqBMlH1SmoCIKhZnDTWJrh257/+OWp3YD0DznPthklYH6/AhEmPCx0RRApLxBXEE5rjcZMXfk5bPWylBfxvrlmB7lm3ug1qqivg/Hn0hRYDwPmpcSrROsExKFypzxn2YsGam4TXn3YBze/ppRVVPkndNkctVQ2tE6zeqlvhmmghhhqTRSCi6lEzRkZRGtN3gqg2okaruKNmT/AmdhQ6crcNUookoZbBW9ijGGqyzsq9ZGiVY9gss13O9yMkF2cJaZR4jDqXIjibFLP/dgk5iTTRV9VgYEKN8mPJNszjdktIgFsWuAW2Zxj0pDOQ4U0pkGu6wrpMShCgWB2XE0zKPI4oBP9wtMY6M0QunXZfHHRO5EFPm65sTm3WHVYl1e0sd/5qjf4tNl5zvvsUU5BhxztGi6KcJp+VNZ7SRXJMSI1AJ5bFpwilDXP5NG0laWhHI4uNbwiww+SlErFKMQZ7iEBOH/kRtCxdri48FX60gK6z/mTB884Qrr9EUUq7YdJe8uTVs1ImPtzXoxRRdMqbawtLpIqmz/HhtlF88GFfjmhXkS+bxgNY3Io2raqneEDnay/8IJYtvU8bzhRMv1H5CENW0WL1QkxQxyoejtXDitRHPRi5Zjia9wO6jWiRsQVlJtjfLt32Gudxx/vSKzcVLst7wqy9OsidKkQ8/vKJuJlIYULYVPIXVxGCwriGGiabbMg53NKtzkbmThzJRokepRPAHjGmZ/ciDLDHOs3DfEgT/nkbdYk3LdPMe23xEyFsiLQlFSFA5gxqzbJgXiL/V4veJMaApj2/uB6pUTgErVjwnauaCnKJonNVUrkIZTUiZKgWUGRmO79kYSxzvee4SK5eo2gil4jQZNrUjmw3HYWJ/mpn8GS8udyg1AV7oxdU5dXvBcHyPcYt/I0GJAbfqiH4geU+9vSB4T0wTVbPiyfMPePf2DdM8sVqtZOdhDMY4eSMRlxYVvTQjPBw1MoQpnUl5XJRUJX+pypTixJdCppSENWLsNcqQciKTyb6gSOQ8Q86E8UhOM7komvVz9sOWv/zlgV+9ecvhVLDasNudU/RPsfnE97634zvf/phVW5PzSOVajKmx1UAYB6Z+z2Z7gZ/uadbnjEOPQtxpWmtylPRhYywXnSEpKTDwWTPlDU1TcTh5lD5wd/PXGNMxxbW8MdtnGLujc5rDJMRrShG3XRGPj7yg0mOIzhgrntQwT0sqP6JyQvwjUtHhjMKnxFxg1awoZoduLdfDPSZpyHd4ej7YnVjpiUsnusGYGta2ZU6Q0x0X2w1hPuLa7XKVNIRwoum2TP3tYlqWJZSfjsvQ1hJnT9NtOFzfUlmNqwxXLz7ifn+QmMbilywZCVMXtdBxynJlKzRVQzZlQRqILpPy4ulQko2LixdFK4s1TmyERgvpUSlK1hTiopjKjFGUYgia9/cbfvLjyOCvUabBWvngu67C3x4xBoJXfPGnX/Ov/83X/P7vf8z3vvuUi7NqaWyosVXh4vknWNsSfSOVKgMoW0n6fjn6CoWYM3VdKLbjfkh48zFHrsjmCamNpBwY40Qskv9BJYppMMayag39FPGliGVyWQ7mBQacFGhrF8FMSp3M9z99St2slrM3wMt/QNU0uKp5LJupnVsg/oaCw9bnVNWOw2gZ0pa5rBlyTVrKgBpn2K0qVs5Rl8Dldk3txC+g0eQSsVa+STH2yw0hP/7CtXWULDcDowoleZStQCVOhxv8OFHUI0NLinNyIaZZtIrFU2WNxii7LPQe7veLxIyCYlFKyoX0wl57cIcVJem0OcpGNZeCT4kpQF8Mt33D376t+ckXO3w5w1YtpShpvagaYpIsTVVVy7fSEbPhF1/s+eLLAzFGvvHpFSlMhOlAzomq3UmeOHj5HNQSAtNOgkha8eXdxJv7geN4kmtqgpAsPoyEOGKUYYyFkBxZN2jTUUxNTIW2cvgg3T55sYTFGBfT9UIWev2XYldM0rVjeSAsl4JPo5xDy+tWL+bVegH5pxSotEfPN5T0CpMSvtQMsWOMa67HExs70piZ1vTUJjKOJ+pD4cmmxRog6yWY5CQ0tIhGD4YhV62w9Zocksjap6MUHGmLbTcYpbD2nlIETuu9l2C1EuBJXlxxMQdRWm3ElmoZvaR8oKglgqk0BkPK4HNimjLGFLQVxtjsYQgJdGBOkdupcHOA/qg43ncMp5ZuJfREax2mWrghzmGdIcwTIYTlgRQvQgHeXHvu/u/XvL+75V/8k8/kNlQS0+kaYzQxDNTdlrmflyFbo7RDWc3lzlKMZoqekDXO3DHwgmjWaF1hqxV1CahYmEPBGYg+YJRit9pgjearmyNh6MX/oQ1Z+FXiy5knVGuYxwltNFZpLQ4jU4h+glRoFDRGAj11ZTFK4YPHqMg8vcHyFsuXNMZiS0tt1kTfA5PctUPNuzlhdcKPDsXA5aZBFQsqo6nIcYKkxbQ7vEOblqq6JMwjqAHnWnnqu3P8dBBnOY6MwTYt05Awdk2cTvgwkkrAuYqqbvExUFdbaUEIEWUtp3lGoQhpXj4Mx2YjhuZpEE9rRGGwpGA5nkb2vearuyPDOBODoqiaFDvyXBODpWlaQNggZe6x2i03JHG1CdUxM49BAL7LskxCZ4W//qvAcPgJf/KffEajNCV7StYkH5jpAYfWZak/gzmcmGNi0zrcXLidZM1QfE90jUACVcV2ragrx3GYaSqDj4ngo7wx/AxFTNnTJJtipeWo0UozhxlXCxkSo7Elp0cbWk4RjcIqTWW1pOWB2lqygsY5kr5gHANVebMAVjZM3tPaRG0GLDOUEZISEnipJaATRmIRtoapWkoMFCXClFnsdiiNIuOHG+ai0a4iJYdxDl3EYea6Hf00M4REP85yE9CKr+89fQzcDz2VUVy2NVbDum348n3P25seaouqE/ve48KGf/w7L3j2ovDjn73m3c0tt30gzpZ+yPS+sDKOner4LG54oVvqasffxcDnaSYXLZlgJ2+kkgXplHNinufFFqAk1W+dmHFcBSoslW6aYR55f7/jX/1v7/iX/9l3qOmp64Y+CvsshRldCS4co+mniTf3im1XsVvVnJ2tGaKiv37LPEJd/x5gGSfPZtWw6xoqZ5hjYlQzc/BYZ6ic/Bh15ZjnmZQyD+EnqUqLoArRz5jf/uwlzXqHUkpsbh//HnXlqOuKlBWrtmG7bjBLzUTIFdnsOOVnBPUCb18weQXlgDNg7BbSxKo2wkF1aypVeL5R1HVHyXGhAFvCPEodWfKURbPL4SgeTQvGNnINrtZgG4oqixg18/7+a/7i1Vv+6s0tv7oN/PWbzM9fe97uM+8Pii9vFV9eB15/daT/cubJXPhH/+w3efJkx9vecvf5e6affMUn3/0h3/r4iidna6Y48eYmoorh5eqCT3rHZ2XHB9WOM+PolOEiWTYRpmxIzj22ZyqlljBSXtgjhlzERilhKZnB3JKDrpzDWMv9/sTNzcT+MPDt77xEqYSratlFhV7KmBR4v6foM6JyDL4wzTPjdOTQDwxTJKQjmKe45lzyPD5IhNYorFGyOgAO/UhWShx3i84VY1qqYxPxl/9O2qlSJIQRa1y9ZCE0ru5Ii8weE1ASwzzzzGygZOmPUYkpQmBDKjMmZdbdJRZFcpbJ39DoozyJ6imncUWOp0WJlQRbmHtQDutWUAKlVGhdk/yBkieUtfjgcWoGU0h5IMUTlESOA8oEUjlilOM015j6isq1bJ6sqJ0Mwk3KPN/fcnHzmupK8Vv/6XdwF/CXXx54ve/pnp4z//zA3/z3f8rzbz1l+xsX/PF3v8eke9SyAAAgAElEQVQPP1a8/tUN+aueVeOos8UltSTPFM5ENrXhpU/8xTzxKw1zzljjiIhAl1LGOUPymaLTY0Wq9x6t9YIRLcxjWAZoxU9+ume3+jl/8sefgVZ05y8pN5GSR4KfSCUzFEM/TsQ40nSWru1gLhwTGL0GFfBhxtXCiU8p42ePtpaurXn19hYfC4dpJi3lDWoRFNVDM3Dh8edVwqZrHi2HSikMsGpqcsm0dQsUhmnkctsxzydqMg0DNt1SKY8tE2sGapPRueDsexJ2iVQHvv9x4NWXk7xZ8kIqXtBIpQRyHkgx4OOAdbKTSBSM06Q8oHLEx4lShCIQcmCeC+9uMv34KY15RlO/pFGOVV2jw0h7+oKz8AWfPM+8+A++yeW3n3E7XfPz94E//XcHTkpxfT/yrqr5vD/wm3/+BS//6i10lrquaOs1bbWipsJp+egoBl1kX+Fj5On5ln88T6zuev5coJzknKirDopimsTjmcg0tajV3s/CNPGeqnKEsFyHoyekyP/3F9dsVpY/+J2nzPOR8XhH3WzJ84GsNUOccNYSigS35jlw8k+J6iNcuyPQkXKmtZZTPxNzwRrN7c2Ry92K0+xlzogJrcpjUE4ge1JoYJaqNG0sxtVYtRgqUgxSYrcA2erWYVTibLUmhJlxHJmG98JxjzOdOeJUpK0myEdqZxjnyFxarHlC5WaS7/nyduLWr5ijoqFAEdpgiZEURgHilofzOlFUkgcHSXZpNAXBhM/zwDB73t1k3h0+o9n8PslqfIg0VcXZ5mv+8DcG0t17njz/kHbdQt1ymDN/8YuG/+XHW3LZgP6Sw+0tMSraqyv+7KuvWfX3fKN3/ODyU56cvcAsXgyiOOxLWrQTa5bKr0zV1PzOs5oxKX56v8day6nvUWjarsFqjY/SUpEWtbqUgjJCp865MM8BWxmBEvvM//pvfs39qz/nt761YjjeUdktOYzUT87Qq4qUZW9jbKGqFE/sHtd7kv6IPS8xTY1Vivth5tgPqCX7Mt2dJISmHvK5wkDRWrQjtSisxpgl/6ywrsY+xOzU0m7woKZZJeFoHyJdUzPEyH6SIhqrCsZuGYNnDBFXPec4VGh9ATmzqa9Z6QPVbsOv3/f4onl7e8+LjSz6VFpk3RKWCJusng2KlA8SJDfLXiQZcpYmg/vDicMw83evfoPo/kNilCVjQZZZ3/nI8/KlJj97hjY7Xr+z/PtftXz1vmIML3neiaw+ecdo7vmNTz5gnkfMyxe8fvUKNyf+8fklbbtGpUTygawlUEZm2dEIqVkXxCaoNX+wXlF84vNpZNV1+BAWG6R84LlIBEE/tncrqsrJPkcvCbeMvB3mwE9/qfn4ZcTPiXncE4PHJU3aGsb6gkAg14ldt6HtDE09kfJPOUvv+GL4Jkpd4OeyGMGU7NRyYtPWAhN87LqT5KR6sFss3cjRzwsGQosOkmLAVfUSw5PXlzQaGVpniRlytpyfXfH25g2ozBQiIReSvsCZhs6CTUdW7p6L9ZFxnLjbH3Eaahe56yde7nYU4pLekutVjAHjCirPpAg59eIu04WcG8Ay+URKmX4MfPn+jFP8hxitqJuOGBKqchhV8/nrHZ++OHAcOv7qF1s+f9VgnByTlYPtpiHlxOG45en2gpzjowutqiuakKVhskiWVpGWlH9ZUv3C3DBaE+YR13RkBZvo+ee7jrWf+PE4Ypv6sSA9hIBT9u9jpoulIKiItVoGyJSWTLRiniOHXKNUQ7e20mA+DaSYmO4PxF1Hvd0wTrdcH07s1i0xV/jkwChCBO1vaEtcyhVbMCtKsQzDKA+pKkuwPMpD/8Cmy/mxMV0q6hY/SCl5aWHUhFIErF9g8p7KVUtm0+DUTKPuhEemV2i9pVaBJn7Fyr7DqiPbuiF5Ac9crB0hQaMNThtCFk6n0XmJOso3SJXl6lcGQSaUglYbquYMsmL2cHe45e5oedf/gKa9YJoCIc48f3bBOI9U1nEaLP/jv27oug0+GDYbxzCM7M62pJSIMVJX8PLqBVX5iuvrrwBDXdWcbXZc5cyqqSlkkperHlr4IuKmZwmYSw9tSQmNIc8BXSI/3HX07/b8Mhew9nGpF5fCR/lSSG+cUg9ma2mFslZJdpnEB0/bJdwF1jU0WgiJdSnMYSQPDTRPSO6COR0xVpBPc7rg/PJjinacM3N8dwOqkNSS1S2gYlp+F2HRPxaA3wLhSdFjnZQ9mnaFVctyRpxlFckofC7y1igKnwpt4xDGnce1HzCXFmc17fgLGvU5uUycxomrteN8vaTmteF4HEjsOMyKN8d3rNWRl5fnoBI57cXBlHtKKlAMOc0oOowFrVpimIghMvgTo2/4/N1Tkn4JxfDJR894d3PL69dvCF7RrRqMVvi4ZsUGPx1RWt4IMUqh35Qi3arBTz1VVXNxds5uu+Pnn3+OKopNLBIkdwZTO+I4i6HbpMU6oEkhUjX1QgIolBAxdU2KoHLi95+cMd7c8abU0nq90I1YVMtUMuM4UlcObSU0X1UOSmToTxhmvvvZmlJGEc1SwpgaFKSsqIwc85vNhzz7+J9yN43Mw68Zp1swmf7wc5J+yYfPPuR2UIyThKWg0DjxiVityWhaq3Ftw6wh+EL0ZUGiWqKfpFq+lLwAU9Ii6BRCgt4HaTOKkSkEDIaqfUa3eokxFaH/O1I5ch2u6PMlCsM8H7nvT3x5e8fd6URRBh9aat2w7VZU1RLYLiMwQ5mXOSSR4lGGpKoWNzCyZRznE8Pk+fpOcTd8E2tbLi52vH1/TSmZ1WpHVVfs1iuM0VxenHHsB9pVw267ISWpTXOVw2jLZr1Zgt+Bs+2O06nn8uIcP89Ui2+lLMOx1hq1lB2ANIMbrZknuXkVVVDGEGYJeBul6VThj87WbO72OAtVVS1Rgizb0xBp65qUItM0oIF+6Lm+veH5ueWf/MM1T84yMfjFHypHgFgRA6okQpjo79/y1Rd/R4wtuvtdwuoPcat/wHr7MZtuhaZw1lU0lWFdV4+5G9nfSFfM2abh+dmGdds8riqUMthFq1FKY1NcXoNRENOqgDXy+o8lM8bF1fRw188z66biZnpKT43iBptGnm4bWlf4ar8H5cAkpK31mkRhnAObtkKrEyUN0hZBQusiWVxTCQIp+8UzqwlhFpZpgCF8i932Cit9hPgY2W239MeJ9apGG7g43+Eqx6k/0XWVsLiW9L5RkkG9vrnDe0nubbbn+BC4uDjnzavXDFoc3qoICE87AwZUFLDbPPTYqkIrJ7sqpJNXK5ZjUaHIrFLhTz76gP/pi1f4JxfkJGv1lJIoxjnj/US3arBKoq9tZfijH2y4XE9o5Vl1a5HssyfGKOF0ELxWkt9NPn5BffFNIppCg6p2uALTHAkJPnyyY1Vb5lg4nGTDm9xClMpJjOpZeK21c0zTJIyVqlmQEEg1u7EVZeFHKCPTtl3Op1wUXV2jUUQvdgBXtdjmuahvFHR6x6ujRpOo3TljOud4nanLXjypuuHbT17TNkDMFFWW4LAX5JFrl6tkIMY96C0qR0II9NPM3aHh5D9AAa1r2O+PWGu4vzvw7Oo5yXtOp5FpChirCd4zHCRLK6rt4g1JhabuePv2C3ScOPUnmrZhHAeaqib0M9lHjBOgTMkJXbsldVio2powB/QCv4s+SHtCkTzuQ2uXc5qti/xHV0/4n69vsdsNbVPjQyB4CTBtNh0pSdcOGZ5uCp3rMdYQfKJyYuAWiI88kIW89OTK27ComcPhLdkcqWzHuul4ez/QuJq2Nkxz5NluzX4KrLuK+2PPHGHyhco6wZgGCEZQENKcbmUeXYqfbfQTdbsi+lky/UWCqGrxhACM84yqa6Yo5pnT5OV8SgrnHI264LwOpBy4PbaEQXEx/Iq1nUnVjhcvFZuuJwWHeYQXpUWQqdDaENMkf7ep0UbEuxATpzFzffgmZ2ef0I8TzjmOx4Fus8atDX6aqG2FcVJzOo4jeeGWnoaJ43HkxYszGutIzuJjpq42tN0lp9NRAlAlc31/xzfMRipelSZrJYTmIS7OMnFZUQQZaSuLNsLUSDFhVFhSagZURKuKl5uG/7h6yv95dyQugLySC9M4UleGtgGdZ37vu2s+ulIoNYgPx1VSLaYLlZF5R1tDmjJV1eHTSNu2VBefEbZPGKaBvv8bhvwGqz8lZ8u+D2zaBoXUuc6xUDsrQlplMCWzaWqC04x+YvSzjKJLbMTVjRjKZSXuhDeaEyzwFaEEyqvzOEVSQbwRJYmAlCbOynu+2/0tv/3ic1rzinF2NIcbnu//H87tHS4faOI1DHtMEYxk8DNKSVBaKU1Kor1oHFo5jF2TYpJFXonkWDOHj7m5uRUuiJL6jP44kGJmOE0cDidiCEx+QhshBVlrF5hc4nSaSSkyjKJkPnvynK7dcHe356MPP6Ztu0VzKeKlLYocMyWJyhhmacSIs19W9+UxRD4NAyongp8wRpx5Ck0JGRUjH+D5L370CS/PHLVKTMd7/DThh5lOj/zxj8745CpjTVoIBXrhhC2xDiU+2xj84ucd0BYSnqY7Y7t5Rl21hPnA/d1f4m//LSruSSmjVOE0jkvEMmO1wOvWTY0xmvth4M3dnvvTKDiMxcGfUlo0m4IWTobYsnJOjy6jiLQVLYERfJBlji2eM33Hd5qf8FsXP0bFn/CrtwfeDB9z6p9RH3/NqikoFTDO4oyi33vu3/dMp0ROhqIajN1BKThrUCWQ89J0nYKQfHJknAJf3z7nfrREFB+8vGK16qR0EKnzCClx6Ae8z9KbguVsdwZkrp4+RWlNP81o7bi725Nj4uZmTz/JzWboe069QGYv6hajpOVA5UiKM7nEpeggkTIoZ3GuWiDDWQSvklFZEAtmiYBSAqpkaqM523/Nf/tf/YD/5r/+bf75P/2AWhc6F/mDH1xytn3Yfs8L5C4saHS9GLQSMXpx7NsWMJArJp843v+cuT+w6S5Yr18Qi2MM77i/+X/J4UhYfp6F049zlrZycsuMhcMw08+BVB4Y7Sy0hfCIf7Di7JJJPyePVouza9nNpFywpqCIWP+KtX5P53pu+z1fnzb48gO8usSmwKX/My4vN/i5x9gGiiyuSIrhqBlOnm7b8fzDjSAOFtZoTMIoy4AqUd4eqWaaK17fXdGtd2gM+33P23fXrDZrVquGX/zyFVXluLp6yv39HqU0Pnia+pykFW+vryk5sttsOfQjddOw2nTc3t8zeaE6fv7LX5JKInrP7mqNskqYqrNMt36c0cbh6oZ5EoNSXUv7ZI4Bo8UMlBFlVWtNKhFjxfytNHDMpPtbPnx5zst/+bv80e99g+m4Z93C3c3PBbWgNAZLXXeEkMWLaiwsAXO0DMpKW3zU6HrLPA0c3/2cT77xuzx98j2MWpF0pOmekdjSVI67YWLymfvjyLZrKBS5+hbAmEeIjOSBldyechbqNWvZ5ooLKwiW6AG9XFimcmlTpESygXuesM+f0psagyOFIzrNtO9/zGXzFlA09foRqiLnsuAolVKMB8/1V/ecXYrhmBIfjzLZyQCmJWXN3fGMbv1NhiliK8Pd/rgYkuF0GqirmhBnhrEXG0BWzJPn+vqOzaplv+/54MMX9KcDq9UZOSU0ibatmDijNK30tU2J1lXURokvQsvnIA0PZVndFyEm90F66uYB65askKvIwWOtlY2t0igl7raYIyYbxl/f0jw5w49HLreankTfD1TVCpzw6cvye1DaSm18LpQ8y+1SmSV1YGl1hVrt2H3wA2J1xTBKZ99HH/2A3ovF4NXtka/v7ni775mjiGGDn3HWcuwnfAr4KL8bcYxnqZ9COm6in4Rnoo2hpAQKsfYpaeG2VjIyLGEhZVtm9YnAZEoERoJ/T0l7OmO5NG8J0xFnLFnbZVsrZ5mchzLdG2OZh8DbcebsiadbL+HtJa+i7JoQxanez8/oB0/brpmW4j9jLXEB9rddxWW3pe97nj674HgYKdGKVa5yaKU4HgaU0tzc3PPi6pK2qbm4OOOwhy/eB853a5yF1lo2riHOHqskmW2speSCDzN115FKxlknjVJ1jbJAjvJzPexclBaMBTLUSoOsZv83N2x/85ucffQRYTox+yPWJ8I8Evz49/CWIlGOrATWq0wR7liQZL4yGqUSx/tXTPUHtM/P0M6SfCZmOM2F+9Hzi6/vmXOCopYHrDD6zDDJkhBtBFcRM1qFhdFflqCcIgVPEkymGHW1sWglE6xGJvOy3N0rY3DGsF3VWGNwylIZQ9Ve4lbfAq+obcaYinE6Pt6CHvCS1pol8JyJPghkLmZOfQW0aFNh7Iq63ZKyIReFrlra1Qu6pdnB+8A8zThtub/bUwqPf+6Tp5dohM1hK7nJ3N4daLqKGCKVlR7f46lnvz+hUGy3O6pqx7u37zgejxSt8CEBy5LKOXnj6AdubKGkLMFzo8FKHw1KEWOWbzvyJgghLkirShzjuaCy4fDqHc1qi+s2rC9e4qpKxDfj0LaQ0kxY2B1aO5q2QympPMmlEFLEh0Czu+Liw98l12cMIXNzdyvcNldxcxo5TpFYNHMQ2E18qCRRiLyuWQodJQNc8oLfRmZOvUDsllNEPabQZBjLKGOonIhM1mgqY2gqK1SgIpkJW21RZiNO8Pk9VklSv203gqA09pH5/rjFZIlWYiS8TUPOFnSFrTpS1hhbYUzDav2SX7860XUd4+jxPuKDpx8H6rrGOUPlKhF3SiH6yDzPGG0WfEVFiuLnbLuGkgo313uMqyRFB5xdPBf8VNXgbCXuLdG0xZey4CBzlurVvAxuJSZKDJDzUg1rRXFNslNSSsS8FGTwLmGmeMX+r18ThwMxeZRWNOuWqq4wrkabDqUctqrIMTEMe8bxhNKZwiTpQQxudc4+KeoX38e7KyItrtnRdBtuTiPv70+8vb1n8qPcehYEuUQmhFOWl2VpXgZtHoPwGmNE93FLRYwuy/1cmBVS9+WMwhn9iIV21jAH6RAJUTa5Sj2Euwtj3jL6QG1rrHGPbiZra5xzywMoiO9MkobFnJjHeQHLWQqGnJ1M6aqhPzne7zX3d/fsdhvq2rHb7bDWMo2jSMFktqsVw6nneBypnCMEz/3xyC++eM00B+qm4ub2HusMMWV+/cXXnPqZeQ6ksuL93YFx9DjjFiq4Xq6Y8pnIbUIRvPhMp34Qq0IulJiJcyDEgJ+Gx88wBGlKyDlIq5QGrS3x7cjNq2vqZo11LdvLKwrSfSdvb8089QzDnuF0vWSAZ3JWxKww7Yb27AX6/Bt8+f4VTR0436w42245zoH9aSIkmJO8KbSSE6BEyCmI+rq8CUXKkKE6LnaAuDR5xjDj6k7KEMQxLdYzhfShlCJSNkXyJcdhYrNacxrlrLJK0VWW41hkGk4nqk5W1iUs07sqS3pfnlZnawG45EQqEZVEnQyzQGNNJSzTlOSh/NnnI9psyMA4jbjKMo7iqDLW0HU1q7ZbviFCMXx+9YR3724gw9WTp5yGiXEOXOzWmKVK7TGcXeDDFx/z1Rcv6E/vaJTCVBVKF3JM8pCgly+NYMhRGtwCw1uQ1dlHQZVri1Li8TDGEqaIrRQxJ6wWBZZiCPcTRhtWu5eUPLA9+5qb8ddYnTkc3tEP9xTtqOot2Jp+HojunNX5J6yff4Nkz3n65BvY057j4Zq7u1esNi8pWVFZS91U5HGSuMQyQmqt8DFS18KmzQ/7pawezUM5mcVuKl5hY4VVpsuCHXoAwRklFOK4PGU5J8EqhLBw2GFVW7rKCAIi3LOuX2MaxTD1xOXt8vBPUzdyC8iZsjCwHqxuWlfcvS/MsyJGSNFhzYqUO7643kqqv6q4vz1itaVrGzbLHHR+dsb9/YHXX72X9gJnefP1W2JMrFYtbevo+5FxnDHWMk+e1aqTbuC+Zxpnphm+/70fMU0TicxUPJhMyoG5Fw+GSESCqLAL4RGgaVrSsstIOYKRo0sbsxTtSJ63qqUJqiD+i9NXb4XmGHpO91+iTGR9vsP7PcZBriqiMUTX0itLXH1I9+k/4q75gLT6Br254raHfm558ey3+OTDb8n+xFo26+4xa7xadWSlKA+beiM3Mbl3CCxHKbmpaXnJUVmzBNgelQ5syXmpwBTjkHoQVbRM40bLk9lWTgJFSrFqHTnN1OkrTP4JlYP9vWKDUAGcq2THopSUDhWJPtplEHZWPw7B45zposVl+Z802jGHisMpoW3GVoZV23A6DmhT2Kwu+fiDS+5ur3ny7IL4YOjRluv7W5qmZrfbokrh6vmlXEOVYrtacXd3IKfMi6un9MPAME0YapqmoTHSDlGWYi5Kxlgr5OOiFn65sGSNNvhxJodIUtC0NWGOqCLLOK3zEtEUeI02DxTGwvHzV6ScmYavON79BEyLV4F0tubWVOyrZ7iimYrmycsf0T75Dm9u3uHDyJdvvsJWl6zPnHzpknDrfcykojgNM9PsyQWOQy9vdxQ5RmHT8wgPWlKJSkxMWlYfJZdFAwlUtpUWjAfDUAwzrqoIGUzJuJKonUiy1lgq5/AxoWsjf1H2YDWh/jZ+msH/Ga1+j9Na4kcG4tJbG0smlbTMH8u5rg3FKOaYmWPN027zyAKb4jO01UzzTF2vCElMvU5r9vsTH3/0kqsX57x5d0OMgtTcH45cvXjK6dTT1I66qnjetXz+i1fM44Sqa+Z5ZhgGctqyXTfE7ChFYH0+xaXQccF0l4K2iuhlYC05krzgJ1huA7py1E1N8F46emtDKuIdscYyTAPWCVJUcjIa1zmUVczzNcXA5O95N8Dnx453wxPqZkNjwRAJwxH71V+h7XMuLz+jqxTDOOLnka5ZU1c1Ywj0k2cMhZtDT7/MirKd11j0wmstSD5OJAVieszlKgUGFuC/+JOt2zGPvVAOUxJrnbGOUHi8O7dLuj9l6CcvJaAKcluD6qjaz8BGBnXivrtjO91TKRbndlqWWUp6dxdyX84L6ts4eVhcTYxBBCKliblwGDRt24GC2/s9dVXTteaR/rfbNvz0Z79inBONc0yT9L5s1mvW3YrT8UhTOW6urzk727BqBLK7Pd8SUsJYS/CBXDJn5zs+ePltDm9+yuADVHphr1do6yAtR2sl+VhdWYrOaG1JaIzVjGNY8OVO+CVF9iBWSztoKlC0RulE/awlzve05x9x++or3p4yrwZDKB3nZ59gbEWIE+dnzyAFMoX15orNaosuiafrS76+6zkOnsyJfppR2hFTYPKZEBLOaDBSjtRUgvOurNzKrIE8ZjyZ0UfMYlKHIn1+3hN9eCy51DnLw/HgKtPLt8gai0+ZKWQZ0nKUqlSjGWcPxi7QFktUBvXk+1yf/SGnAlmZZStoKMU8FiU6V+OMoyhFUWCbivrJhlnDFGUhqHTD3Z0nLmbp7WYtZ6sqzCGx3qzRWvPByxfc3x346OMXdKtatpvO4aeRtmk4HE4yV5XCzd2en//yFa/eXDPHzP1+wFUV4zgRfCIX6IeZMUZSUuS8xCd9EDDewnR/bLxcNrIpRvrjAaUSVVORYlhmNtFHlFZLj4xFGYNX0L40DNNbbvdvedU3fH56ymw/pWrPqfQtOgc2qyucWdM2T3nx/HtoU/Pm7c+5P13jo0RMtbEMc2JVN1xuOi63LZ++uKQxhXXj2LYtq9qhtehau3X3qGvJHCitXSxZmIzkkyUCsySZrZMZRC3r7AdWpoDiMuMse4jJi3nGGHFIOSuTMEbhvaetayptmfyK+9VnpLCn9QOVU4utXjQSpR2hzKALzdphVg0HZTD2CVPSoDzOrklLDUeImmPvaSp5AFIJDNPM3aFnGnqqpubrr68ppeBDhiKT+uk0obXGh8AcMilm1uuWw2kWv8UinoknI1O5FUUpphiJrlAZKzimIJtulCaGQE4yAZrKoW1mOvWSPtysRHPJQVCYPpKMhK2Tj2QVsU1DCnA63XD75Xv2ZcvPrltss6Nig9KZMH9NKm9x9QofIodhpFufk+LE5D374xe8u37L+cW3WG/OFh+KUBCthhA855sN2hgO47gw1URN9bOnIFC7kv5/qt5sWbYrvc77Zru67HZzGgBVqGKVSFaRIimTlB2WTEY4LCqsC9vh93D4tfQqvrMcvJBIF1kdCgc4zW4yc3Wz9cW/zi45cIM4CAC5c68159+M8Y1NgVqEWiAclc8FrcF6/2LTsGXTIMZloR16+cVvz5B3lrbpRFe55cmmmHDGkQusKZJLobeZ89MvKGYgv/2fOccz89M/YvM/cquudKZluY6YnLCNwbWG6uEpJXJzZIyaV75njZHKwjC8wrrMvESa1tH3PcsUuI4jTWP59OnCeH7aTjVP6z3X+UI/tIzjlRATd7cnHi9X0Xf4DqULP/3RDd98+4G8gVNSTLRNy/2rO77/tZfRM5slsVbiml7QVmWrUdhw5CLRFPJ5WBK1asDJTshKNaiNY5kDysK6jKRaeDhb3lvLsx4wfo+zEoMe4kypHq0KXos9VdvMN+/+C94dsLbDWse6zEzLlbbbse87jC5MITNNAW8Up77FWk3fGGKq7PoGrzXXNfJwHQUguGEf8mbnED+ujCWatmfOkbJhL6xcBUoyTbbT4/MpooHBW0ItUBWDbwkxQM2kjfFecmSKT+jmB3TNHqU1S7ashz+kLolrzrj1SsNvaX1mf3/D4xx4KgZtLdMc2DUaVR2Pa4PXMOysFKZFows8P5+5O93wdBnZ73c8Pj2hasE7QwyJxjte3Z24PF84n2fO15m4iXoOu47rdZUa4QSH48B37x4YpxGlFeO80raScWfLBrrbBmFt121tbUUZYaVIq29QaMbLIg9OBe+aTWFn0c5QNciBYlBWHAKRwnfPFvPVD3BZvVgeUlk3RX+Dcx1KKxo/sK4zujxR04rzBw7DK5Z2z253y37f8zyuW0qowTqH1wqtI6pCY0XB1liRchyHhttDz2UOzPOCtYZaxBbAMnMAACAASURBVKloUYQq7kDftszj04vn2Pqmp+SE0qIFMNu9tO10yTnTtY66CUga70UbuQXwdU2H0b0MY2KRFEqniElh2z8G05Cp5PHvqYdf8Zu1sqojbetwKlKAQwNzmrmuhl3jcObCPEMt0ulo7ajAcb/n8jzinOZPfv4v+PUvf8u7d++xjeV+GNj1nvEqq2xrLH3nJD3aRow1/OKff8MSMsd9T4yRxktxNwwHagGvBKmpjQZtKHHTSJBp+o6wKenyljzRtA3juILRzMuCNWIb0FZwoWKMDrS7EyVVTKNp7wd0NxDnEa0S6ETRGaM9jT8xtIctX6/FGkdRkvfdecM37/4LKIdzPWu1nC8r3ltiTBtzXuwlbesl2sUZxmnl9e2Bh8vEod0kk84xh4izBqfBGVjCjNri2Kn1ZfWirfOkGLFOHN1G6U00JKvgWDIxyRcVo8SAzVFW3vqz4myaebpOL8lPzlkOxy9odm9phhuMLuyGFfyeMXassXI7tJJAWWaszqwx4p1mjQuFCd90jNOEd47GN0zzQqmFaZ7JpfCbX3/Dfj/w6tU9YU2EmDHG0LaCcHz16sTd7YlPD88ii2w9NzdHrPXcnI4SNqQ0rRcemXcW5SxiLJTVgLYa7SzKWPGsFFGY11IJS2CdZwlWrhrnHM576XYolDXivcW5LZrMakJN2NYQ5gshzNT4gKkjYPCuw3ElhI+A4dOn97y5/5Kb0w/Z7e4Bh/N71lz4p2/+iafzMyFlrFbcHncc9wOWyv1BSIpaa2KS6e/jeSQlkXCqWvBW0TpF7w1D66AWiX7ZlpIxrBvjTX+OJKsSAyFpPIKkVLxI/Oo2PMvb3dy3HbkUUsp4L2jMqmS7ugTJlclFoskpAW9m1mK4rJFYCneDRdcr52nG6MTQtYRcGecrIUe+P0+kNLOmRIgrKSeGYaCUwul4wGjLze0Nr1/fbRNBxW++eccaE9dpxjnHb7/5jm+//8jN3Ylh6Mi5cDzteXV7Yhon9vsjT88XDqc90/QEqjKvC5pAXKTIVVajGrelWMobFdaVdYn4VgpnKugq2tw1CMejVkFXlALWtxIT32rswaEHT9NkwWr0HYMvtL7F1Cs1P6PqTNd4rFVM00hJBmN65lWzP/yIr776S17f/4S26TjsevrO403FWc1u19N5Yanmsu1hamVexfjeOMPNaUfTOLw1GKVonMgkc5EZSC2FHERiWUuRLoZasb6FihyNFYySZyeXii5V2Bxa9JiSrwreWkqq7LpO4kGcZa0Zr/3LwClnizMtmMBlNfRWYdXMh+dAKppD20iBlBTOVZz1TM2XdMPCMA8M3SCO+pjJMfP8eAWT+fDR0neivJ7GmefLxD//9h2H3Y6UYdh1YkgPAe0t+6Hnw6cHnp5GUJlYErenIx8/fuC7d7/CZBlDx1TwRmyKSmuawRIWCTyKSpK9qzECw4txiyWrzNMoWKuc0aWgVEYZI/pVMkllxibTtB1KRXqfUarBK4VzJ7QaCPM3LOuFeX5P07wWOpJyONOzP3jWbbTfND051830XSVybBWT+cfLlTUIWWnzf2KtnHA+F9YYMV2/Ic+FVRaLdK3S9vJ7x52IlouMo60XDeSmQ63bDkYUVRvtD4nFCEnYpHenPSGXl/yRlDMxBWqptI3fTqDCdP3AkjxOa049XOdRsu6NofFaxEk2Y60lV4X2im44sYTAeZooKRFCpt1a3VrhOo4sS8I3HdpqQS2tiW9+946Pn87M08S6Rrz1jJeJEGaWZeV4PJBS5PJ85TqOGKc4Hfd4wFcI2pA2bHdNmfHhkRwCaVwhJqES5FWum1JJIRBjfIH4ag0YR1WwxEBC8gC193DXU2xPVvc0do8ynjmuAvcxb+iGn+CcY9d33Ny8ousOHPYn1jXQNi23t/cYVVCqMAwDS5BB2hLLFhUvi7e2cRx3Pft9z2HXc+g6YhBDuZAJMo3zLFsrPcUsXVjeHMVaBEObVMNsEWBs8rPP4coCTNn6Ghn6bIu2ZdM0TkugazwxiXhYBkSGmLeYs5So6SI7l9DRe0fMAbAY5emceunTlZYorKocyll8d0vX7rDWsT8eiHEVjyuG62Xk7u6OD5+e+O233/P8dOYw7FjXiDENXd8SUmK3H9BWlmYpZqzWPDw+Ya3j6x9+iXUOSuXDxw/oWGnahiUVlnEWiG1eSatEaKzTVcbUWWwJzlmct2ir6XsJBNJKkVfxvozzAspQs3rJlqnHV0KQNjf0p3/NEhUhVWoNTPOMMicOh59hdM9p9xXHw1d4d2Q/HHl4eibEgHY96ypmt3FJfHyaiEl+Nkpl1zZQYdc2OCvems6JEMx7x+A9u8bLqbcmLtdZlPibOF1mVmx/ptFqQ1CK5V8GRBpkPL5tAdP2tnxmmLeNpXEyUY0pSXpA+v1SS0CJcmSl8JGQK9rcEmpHqRqtWzJ7lHvFh/GeX31MzKlhCkJZjnHCusiuH0ip8Px0ZlnFE3M47Dkcjnz/3Ucen65437DbHblMKzFklnml5Mhhv2McJ3Gsl8put6PpBArXuIb9rqWmxKu7Pcs0sWtarhsjJeVI03VobRmGHc5Y+v0gLWtVrEvmfL5ux7LfjveN+ryurPOC1QqDDB+996whMdy/phQNJXG+PtJ2r9FK8fD4K0ouWN1wc/NDDqev+Pb9d1yuE9oaht0J7XZ8/+kTyxo5HA4sQXZCxjZQNF3j5BSNiZgzD5crMcmI3VojS7kit0NGMcVE2MRhasuQESuK+r15SimJRa21EMNKM+xE07HJz3IubCYzQTbUgnOarpHUp618ZV4FrZRKJuVC4zVrFBe58l9wOhjGp18SowDf5txyjTd8WnaoOmGqxk4PnPaWUDuWMNJ0QvZ5fLqib/egxHqQcuX29kRMK8si1bb//EZbLfuPTRl2d3eLM5rHcmFeA23Tsc4fuDsdWOaZvmsYx4+s08SdtVCqtHkqS4eCwqpKTAHrNGEZaZqekhW1rqxLoOaNsaG1CLC1petaGmvAipsvoVhCQlWNSpW+70lZUUpLYzPOdFg38fbVz3n3/tttXL9jngNTvrDrdmjj6fsTjfc0zpMz3PaWEDNP48TQ7bnZdzycF5x1sg7JmTkExjVsN4RiXiPvn0Y+PU8bl1+WdGz1pkUQ6LYRBbxOMW4WB/0y+xA254ajVXUzUclV44198ZpOS8A7x65v6TYhjaLitrZwXCJVd4yXJ9YwcU0D5/SKMd2wlnuS6sA07Nornck8jq95fzkSyoAfBrpjx27YM44Tu6Hn/v6WYdcyTiM1F47Hw/a0Wy7XJ/a7lmHwzNMMtTJeL6zLgveW42nH+XLlB199IWkV1nE5n/nw/j1pnijTyqlpaVqP7hpUK/4W4yyukexgbwS8nze5Yc5Zsmm0JuVIRdMPA26LTclFkAtziCzK8errv8Y3b1gW0OaG2+MPMUWxswmnHnj3/a8otePheeRyfaIfBvzmGzr2ntvjXlKmpokYpJ4Aae/nNXEeV5SGeQmA5v2nZ0pVnMcFraFrDK13dI3bYrpkah43NZlCyUxMqU2wXdDrLEst10ggjmPLtt9Uz7UWJGtGilnBERisMVhrNqSzRqlCYw2N99RaaLzDGU1NM9d5phv+EO2+JnNkf/gz2nZgOP0I035J1xSc11TliNkTk+V5OnP/gxva1rMbTqzLyu++e8eHjx9FlKQ1z89nns4jSlcOhx0xJYa+ofENpVYeH88M+55S4OnpzPU6EVNgXhY+PT5hrOb121v2+z2FxDVc+VifeS5XTOvQjQT8qE2NlkqiakUueVvCaZS12Kbh9tU91npqEjO09V6CDFMS3ujdW0x/IpaBaZ5J6wOn3X4zSa1QA8+Xb7hOV4q5JdWEMQpvK8/nj2glYujWO7xztK0jxs/BB4rrnPj+4UJIhSkEPjxdhFaI1J7GWEnP0nLuG7N5ef6r+kO8UelFL1JrQacYsK6ROBBtUEYUt1WJoLVuyQgiQTOsMYluoFRuDvvfK820pXUSZExFdKdZNKfD/itc0zFNT+wOP+N4fIVyd1yngnInPq1fMOUG74U3ugaNtp721NEeG2ISb+luL+iGcQmEmJmmha7zrOtCrYrvPj6ijeH2Zi9e3FIYp4VlDXRtSwyR0/HAOF23NQH8+tffYG3l3/6vf8rf/p//gX/3f/wdf/h3f0jZMBC1ZOqa8a7Bty1N22CdtNelFrwxcp0UULHSaAslE6bNhZ9kLuRPt5tk0+Ibzxq+FxqQu2EOipR2fP3Df01Isof5+us/pWSF3yJEvnv/jfh0SkHVijH/fy59KonLsvL+4ZnnccIZJXS3VLHGEFPkPK88TivP0yKTcCWNR+M8xiic1cQYXp6FLeTQv0Sal5xeUhBliadeZIfzIljfpnHblFVtXo1Nf0pliQs5JeZFctm6pqfvjhQM07Jyc/eHTMnyOEZ2uxvapkEbD/YL1nLAdT/Ce5E1LqmwlMTXf/QD9ocerSwfPj7y6u5OuO9Vczqd2HcNx92eUiretVznhWHfUFWm73t2+56mkSIRbeh3A223o+1kV/Htd+/5n/7dj/hX/+Zr+tvMVN6xdiuXUkm6SvyZMSitSWt6WfANQ4e3jrxKW5/iitGQUpQppGWzTCbBO9zeoTdjknedZMjMC4fjn7O//SuGw9ekOnD3+icY1wiGVBtSMTT9Hdo2jPNCCJGu9aQsv4P7047TvsNbTe89fdvRGM9x17NrHd5pvLXEVMFYvvnwzLpNnY0Wtqv6rC+sQtv+LEFVWmObrhdZWskvWsRS60sSVNmU7Z8fmnGpDO3nFGtN4z3WGqbLiPeWrnWEVF+0mRo4DB0xGpYs0oKQwKlM38oXZft7zk8joe5Y1gmlRDOyhMy+cexvZQ8S00rXe4w98P77Bw7HPW1juTnumeeVh8cHagmstydykQnrw8czXef57v17nLc8PD7w+vWRxrX88le/YY7vmdzP+U+/eiSblYdLR/jtmR/vb8iPZ2pN5FoI1wm8pW17zk/PKA3LvFJLxuUEWSSVSinKJsLKyN8bIA0dulRSsVgcd7s/4P72Ncs6odVrqm549xz4/nkmRzgepElQruJdg3P3UBV9K/XNvISXOBRHoWsbkRuqSsiJVDJabyFBNdE2jjEkGquJpRKj7HiM2R6ez7u3FHBNL3WIa0RRJhBgLWSZKu0tWdTQZQvSbJ1C6006p60wxQqklEhGS4xqLcQkQ5jL9cr93S3jMqIy6O2uvDvuBOAC234l83CZGLofEWIh4USv6hpMKZyv3/Lqi9eka+Y6Tjw8nHFWM+y6LTBIMU4zX335mq9/8JbvP3xkDgFvpbBMUTgjQ+M57CwpZbRqGMeRrh/4wU//JbUxPERPWDoelgFjJ6q6EGOk81ZS3I2GAiGsOC/iZWOMCIOzWAmafcs4jqAdISfipoVxriEfTlhnOOxuuenvUOmCtw5FzxIWlBv4h999h1aau+MepTRGwXWOdM7JSwl8eLxQ0SjjGOfwwkIdl8jjdaQUtuLVcLmO3B+PWGPYdRo9Kazd83xd0Aq8hjVmls2jL6WI3phlCAL981Luc9KhHDuQ6xbhpSCUxHEviqRCIcaEMVo2t8aQPusba2UJUSLTrWVZF4lTL5XXdzdYo7hcJ3JJpJy4Oe5oO0socFkr1zVimh9R9QGtGqHgxDN0DtsamqblMiV2++PmP5EJ6+P5Qs6Jd9+9J+fMzenAGiLOWm5u9pxOPU3ruY4T77//SAhBhELe8eb+p0IiMBdKndntbjjedVSdpN1M8ib71oPRLHHler1u2lSF9YLc9l46t5Bkmqx0QeuK1pBQ3Ly5x1tNZw1vTid2/V6K2AwRxf/9i18zrSveWWJKnMeJnEXt9TjOjGtkXiNrzC81oDGG5/OVx/PMeV5R2nLa7eicZ5pnhs4zh4VUAksoLKsAe7zReC2iZafZBqLSBlsryrjPnhkLMvWslY0NJlJ4tem7jYZxXnk2F7q2hSiFa0wSmuesFdbE84Wu8zgj3lnvHbVUGmu4PR14/+mRWhStF7wiRf67n54e8a6RoY1uMLVyOn2N1ntinJnziUsMHN7seXqcWdaZd99/QG9BygCn04FXr06M40TOmffvP9G1HSi4nEf6vuHh+sz1suKbVvS3RlT789Xj+oBrDdpG2sZw03j8wZHfe8q8bjMYKc5zzRi3LcNUoYaIs4pYG0JYUUaYIqlKeFHNlfDFHU3XcE2ZPI8YfeR0esXHpwtVW/7puwu/+fAoulMtcaRzqsS4gFI8nC9cxll2O6Ww61vY3AZKDZRama/xpagu28u9BulQrHHMQa68XBXOWtpGfEoxF4wCrxRRbcED+TPHvcgVUze4GVUWdWKRlLxcMByHlmWNGOe32K5EjNIz0/ZbvpvekqAXWu9xiFVzrplcZlLO2w8kDIwYCsPgOAyizv7u8Zm1aKqG8xxR+kqJM63f4b3A2E53A9N0IcbA6WbHeDlz3O+4XCY+fHwkpkTftdzenLhOM+O88uHhgX9x/CGn4x5nW1KOxFiIWU65ru14/KQ4velo+59ibUO9XtBKEZPgLSXoxmCVpiS2SLPIsgTspjed14BC4Y0m1kIsFW0tSisOf/6vMM7jcsAYxWVcqSYyZcVvv3/gH99d2Q87Ma1p+Ob9Jxqj+cGbe6ZFJtxTSFhTWWPiPM54J1k+bWMkUUIr2s23o5XCNQ325cEWcF3KW+JWTuSaOV8X5iVitGA46gbu+5y7k+KK/ex8E6tgpiqoZMCRc+GyJvqqOO53FNQWsSn/w9YK/6vWStu2NM7QN/IB5mXl0PdM80zXt9wcdtRciSmKCKlrKDmy3+0kDDk9EVKk8xqjJTTRmYa2HfBehnN2Z2g76UiEc95zuV5pmobny0Lfy1JquG8lsDgVXOOw3vJmf8/1uvCf/+Ef+Iv/4b/lP//jP1Mz7HYDn77tefPqLzgcviamyJzeEsYPojJzDuM08zRTa8EZh1Iyi8hEalRUpH4zSqOdJq9BBo9WEA7Nm3usVgzeMOOp2vA8LvzDuyd+9+lZJJ9JZIrnxzNOWbq2kSK1Kk5DT4qB/dBJivaaUErqvVIzIYlnupTfExFJWThkTgsfLQQaC2vW1GJ5nq6kFGm9Zl3Z/j1eILq1iC7E/Dd/9DVQWKcZ2zSor/4l3llxt1dFxgjPTyl2XcOaRNIfUqRkGYjlJLK8nIXaY7Tgqvf9sHlMshida0Up+5JJv9/1klFS4ePziEbozlqJAdsg+s9UCpd55c2rW+J1JSyFeZ2wur5AYGVoJ8FAHz58wlnPhw+PvHn9in/8xa9oG48xEo70dH7kep0EDmwNMa7sb07c3X3BsoyQngn/8GvSpxHnPCpnrNMs81YXlLpRD5wIpIzDe7FWiBdaGGc4ixp6Xv3bvwHnuEwTxnmUhqc5882nM1UpYspUpUilMriGP3h7zxoyl0kwmc4o3tyfUGT61qG1wjvLGiNaibtgnoPIQak0RtE1DcaIAcwqRddJqse+64gxUZLk/uYUsVtAQc6Z8Ov/JNvcJLkxNqdIRrawJSXY9CAoJcF+yCzgeZIUa+8aSY1qNMuysKaMs47r5YL3Daf9IAuo5wuPl2dqlgIubSnUOQb6rqExhufLgtHwdFlIOXPcd9gtO+46jQxdT4grOVaWlDCN4fj6QE3w7fcrMReOQ8c6r7TOMoeV1jQS+b4lSkzzzPG45//95W/44s1rrLM8n5/R2rCuQQhHURGCYppWnNH43R1pf8uaPxFzpISCtrKRpcisQ2kFxv4eyqcUBTFx5VJQzpIVpMOepMCkTCpgqyIXuC6B1jmpH1Il10IOmXZoiWnB6kq/6zkMLZbKZRwJITGtMnhbQ9hiWwpD13F3c5D3riZ671nCyr7vpSOtIu5aYkaruPlgxL+kzWczvEg5askoY9G6EpYZW7LoC3zbvfgyc/3MjaloU2mdYdd1XOeFvbI03uCcQhWPLlC3xd24zDyPM8deevXXNzd44LvHM0/PE+u6bjsBS9807HY7xmkhbabhvuvJMRAzKGOZlhWUCHNK0Xz76YnbY8eXxqF05Te/+ZbYFPrdbsMoWFJIxCXgrGZeZnH0FVFxr2sg2888FM398cD1fOV8UdTS4azBase4VpLkdQuXzIqzDqXRVsKCQhB+qbYOYxUxROZZYHDaWkJJjOPK6//w77HeUlUhpkTbicJsmlf2racouCwrOSa0UjydR3785o7bvSKkSAgru8MOVxyP8SISZaX48Q/e8PB0ERpSKaS84owRJHdML6FFIUbBZiIhjSFHmYaXQggRXSU71xq9ReZuvFfhjwthSCjCLTnJEaW0ItWCq0WSDbRCaegbwSqWUqRTccKSUErR9zvKNKK1oWka1hj47TfveHVz4On5ibu7e1LumKaZlBYuU5ahTpQHq3Ge6+UsHzzJMb1rWwqRHMW0lUohmYIfLDfHnun2huenBzRwuSr2u45QEre3J67jlePNQMmVftjjzpaPD5+wBl6/vhe32VbbnG5eY00jUr1tNG19h2o88zRhtaMxQkD4fL93W73DCz5LYkgzEEIkqsyndeL17S3OWdAO7xP7oeP7xyv7riXVyrunM1rBV69ueHPc8Xyd+fjpga5pUUZhtWaaZ7kejVy5yxp49/0HKoqQpChNRaJWrNWgM07D43mksZqHObAmGZI5Z9FaHpKQM1ZBiHEDJcvUXNdCTgHj3OdBmZENZBRdg64Kg6a10vvHmFC9RmvwG5crZrCq4rz8c6h0bctlWlkWgeH5xnKdI7enGwkr1Ia7wx7vbjlfL6AV5/W6Ya8yy5qoKOFlbLsBrSzFyLrcODlVvnj7GrVGvsj3NE6zG3reffc9/dCyrCvOOoZhhy+JdY3EsMI2xPNNRwyFvm/Z7waatuHDh0c+fv+eH/zwhhAil/MjMWnyumKNETfdhsJQiKQhXzPd0G3fRaRqRf08QNzy965tw93bt7im5boE+r7d5i9WZioh0Tcebx2tqZx2DVZXnD8yLgvLstD2A8eh5zrOWC0v67xUmZwGWehpJBZlWgOxZEpSZKOwtmCr2nDhEaUyVasXEqMKcYua88SchDRU65ZwkQGNZcugN9aJCmRb+2rAWrmnxlUUUs44rDG0jUMX0V/GmOm7jhgCWMkg8Vaycx/PzzRNy77vCcmxbmiIWuT0WdYVbwxTiKw54o3CKEvbWKZlQeseo5BNaq4sIeGd5bwsHN4eCEvipt6QQsBaw+PTM7eng1gmk9zbTjus1psj0L7oNCtK3qIwczh2vP3yjjXJINC1N5wLuKpEMliEQN1ZDwVMYwW7GVdKrhirSTVv4t9CVHBeF05//eekqnl4POO7TorRGnBaUyobxLcyNJYYIx8ezwxdh1KacQ44Y1Cl8PR8pvUN3untF3qk8R41LbS14rTm6Tpj9YbDyhmFIVfPvMp+zWlond/oQhmvFX7nqakQskKrKoHRld+nlpciSYLONTJQcf7zolf+qtA3DamKqFURWLOCNVMwHPuONUR0FRXadZ23aepK3+43S0Al5sgcFnKqNFZRVMU6y2ANxjq8l3jOUiJt22O0YZwC8xpIOeBMgyGTi/DNns4Xbr98jdk13LiWX/zil3St4fuPD6giUoXdvmNdE37n6bueXvdM80LbNjw8Xrgzmvr0zPGw4/vvPvH4dOVnf/UTlK4YWuyreyqKUg1ZwVISNVasVtJS+s+cDSSLTwkvLeTInBO/fvrIfTtQimQir2HjtVeY1nUTXYkOV2mNcY7rPDOtQqBOJdM2Hd5vYY9FfC8pFUqBZY3EGHAGDrsjUDabbCSsQk3unED4qlK8Pu1YQuY8C9HaGvn9msbz8XJhClkkktuYXRtLqRlb6+9D94w15BfxUGWNhZgLO++3QtJQMKAtTglct2wmqq61LMXSWJH/r+tK33SyqEqZ1rdc40TnRTIARtjlSWwPvfdc54VSxX+jtWKN8rqvIUiIT0popTmPM9MaUI382Zu396zTxOPTlet04e3bN1ynEecs33z7O9p2YDfIG7w+Xzke9/RdCyXx4f0HrG/oh4bjvmOcM8Z07L/+EY9W4wqknLBf3DM9PsG0YDfjulaaxjpKgVQqpaxc08pvz8/4P/tTvvzjnzGtK6ZpmdeI0xrrNbeHHeM80znL4B2XccZh6duWxjvmWRCVH58ujFdN17XEFAFDDDJsQ1X2XU/XyrVrrWGcJ2qB+33L7XFPSDKO+DxWUIpN1wshK1Cah/PEEgtpE4VJnk3CGEsqSQZlLwzmjapqzSYgoXJZFnpncI0XKVvImxqpUqqYfucYebgGGufwzpCrxnxOjlCakjM5iVbVaMvQe8IaSUmgac5aSqkvd2GplcNuYFoz85zRRhaHjRdqoTaG94/PHIcejKVcZqY18ur1HdfLyNOTmKV2+56UT2htub+/YbfvCCGzG7oNNQWnvWJZnxijTCG990zLQn//msubV+y/eUc28PP//d+jQuT9P/2Scrny/Hjh47vvMCFArqQoHcJ34yM3f/kXfPU3f8fx7ZcsqWB04TR0DK2j1MKSCuMqZvCboePVccAYRS6FaZlZY9yoQJv5HUF9aSpd21NKEvVc63l8PtNtvFeq4rjv2HeeOQQZbNZCYy1r2pKtrGWdA6HCeF3IORHS5nvaNuAgZUfJE1Zru6150wsWUag8kErGVEks0rluy6e6wVbFJ1M3HLXgHaQoDSmJs78WDruevAouQSuBwtQqffbQtbCslFJx3qKqzBiMUngr42vrHCktW3ChAy1KqI/PF7q+R2lo9i3pY8GqyhdfvOHx8cw4SltdUTjvaFpPWCZaC0+PHxl6xX//V3/AzbHln3/zjt9MlofLFWuF+LeUwo//t/+Fb//jfyR9+ITpd6j7hi+/eAsl8YNSiNPCNF755pe/JiyB4XDkT+9vSTc/hG5PLIXTocd7txEiMynDw/NIqfUcwAAAIABJREFUTUk8PEXayaZxjNO8De8infU03tF6xxozVYk3aE2Bfd9QSuH9wxOH3UDjPGsIWxi2ZY0yXUVB6zRLzlxG4btdp0W4+0HmIjlJ3VS280HgN7I6SSFi/urnP5Eg3lmMQuqLP8Fah9uCf71zKC2iE1F3lM07I2r4XMsWq5lZooQPWSNWimVeUNZQkU0vFQ47cfGvSVK+2aBvu84TYhK/6NY+r2GW7WgMKAVN08lboDVoRUwy6NJGc/10xVCZplVOsqZhWRdijgzDADXTNYZPH9/x53/yBf/j3/4JzgTGaeHjZebuq69pGmGwe+9Yl5V+f6Tc3/Dx+QPvP33ih3/4U9CGrAzVWFTb0OyP3P/wh7z6+mvMzS2/eI68+cGPOOwGjDF0TcO6fS8Kcegdhoah7Uibxygn4aBqbVjWwNA5hq6lMfpFqJ02L63ZuGJLWNDKMPQtKSXabgtstprGOdKGMF3XQKrwNE6kIpvhNYjyPcQkuQw5i+A8RMo3f//CiI3rivnLP/6xaDOen3CuJb/9Gc57rDNY6zdJu6ZvxUqotNkowhpvJRdekIqZ67xirJa5v7NYrckoWV0XcI1nXlYRBmvJZ62CJSUXSVAQo5ZYQPu2o3FmkzWCNk6SIbQsqFJODF2HNpoUA/N5pOtkq/p8HWlazx/86EseH5/Zd5U/+snA3/6bn/HF2z3TeGYcA1MsPCbP/nTCWMc4r5uiH0IMHO5fcfzJH3N8+xW//vZ7dNtirXvJvElF8TwHfvu88N2iORxvOO13KLQEP+a8wePkoa+lEnLhsgTO15kQ4zZLgpg2M1njqKnQNBIhFlN5ERtrIxaGppHfjTcaay3zvFJqQVOZQxafUk4U4NsPj1zmyJKl1vjM4Q8hvlwpMQZSjNTf/b3wQbaRh/0sUA3LzO5Gy9h9k5blklE4VK2sQWRquUoF3Taa1mq6pqWkRNEyhKlFTFZ926BqJeVKLgpnDOM4MXQta5TTQ1tD3lxhWWla3xBywhk4bwVr37TcHPacrxLjrlCs6ypAXgUfHh8Y2ha/8xzcHb/55bccdjeUMdO1O+KaKGnlb/67P8LozOV6JeXMOE3YpuNKw+5mIOfCh6dHnFHY7aE97AaWMPMcM1+9eos9veLjvPDNZcGbAlU8yEusfPnmK45Ws+886xIxjaJtGpSGcUlMa6SiiDHANkl13pI3GWMMYqX0zpHidiqjUdrSNvWF5iySzkDTSDbgGiLWCn1pCYHmdCCsgb51xBS5zpGCJJnbbWdl3OdGQItctIgeShtJGFebeV9bI6N2YzfLIFX4VkCtentDMo3brgkg5rxBaTNLVC8Zu1RRMi0hwbbaTynind2kbYrGS3EoZJtCNYoQFtqmp/GbFGBJ7JqOuxtLjpk1JdqmEcFLylTEspCSzFRiLMwq4IHjcaA7NrRNQ3MehY5MQ8qGv/+H31Fr4OPDwn7vuFye+Mmf/jnN/sA8zjxdRlCKu8MNKUX+6be/5uc//QPe3NzyPC68+/jEcb+ja3t2/UDfeknwNIo1JLSqYrqKkaqN+GVDIsXCp8sssJYKQ9cQU5HpKpW+b2VAVRTTOqOQdjmmwON1xChN3U6KnETW6H0jzPwYKbUyLVLUKqV4PF9prKHzHd5t+K8q5OfrPDMviaEVSlTvDdd53Ta4dsvN1XyGK2tjMX/24y9wjScsV5p+R/ny53jnaRtP1ULUscbhrHlBOH9GN+eUmIJQ9ayWHzDlRN1ELUop+kaGcKDoW4fa2mUAowzGWppGDrIlRCENokhbN2OtYY2bf6NK2lXO8oDpKuFBwmNt0Np9Tosm50QMiXEayQXevZ94/xB4ugamZDm9/RK337OExHVaqUpx2HU4Z/j0/MyHxyfeP51p2obb4wFjZMu87zxKy4koUadiELNWhEIhZR4vIw9TYAqJ7z48MYaIQZT+96c9RsGytZs115cGsvWyoogxyiAxSGcYQiGsKyVnFDIaF5uppubMfrcjxUDnPYetW7IaYk7cHnqGztM3Tvy4QZyQcWt/pyWKPiRl0YD89v/Z9EFiIrOfwarGiJmmZFntf8ZQqaoouWzBh3LvVurLhzOf5/slo1F46yhZriS3JTOsQZTepVqssTJI8z2gOV+eGafK7c2JOUZqVTxdJ7xRuMZx6FuGrsNbWfvn1jNOQQxdWm8RHJFcK4GK2g0YFPf7nufHZ3KI+JgpBo43Bxrv2O0HdruWJa3klLmsEWrmZr+xQa3j1e0tt8cD379/4NuaeH13T+s90xZiNM4LXeNpvUBexnEihUjOhVQUbS+zi6bx1GWlb7wYlkqmdYbTrufpInICZxUxi75314uWJYZE5xxt47E6oUxD46SAv14Fr+ksqG1Msb87iF7FGpxWOOuwQaSDIURu9x3TvPLmNHBdJL1qXgPGGsxm1chRC3rqv4pxta7tJCet7V5qj5LlQlFovBGxstEaZzUhV5x1MoBBUiLWNeAbGcPnqshV0ALGVM5TIGwx5eO80jSy8Ho4P9M27dZzez49XphjousaliiT2utl5Hmc0VXRdS0FkdnZnWFdF5TaVuvacJ0W1M7ION1ZtDe8PX5J6xRrymirNxGyTHevy8o4j6Qq1+Zx6Mlo1iBV2NB3KAV3tzc8XkfO88plWnjQWgZ7jWUOWY5kMuO4cGw9yyb7i0HqgMFb9t39Rg1yPI/jpikVHv48zyRv6TpPa61MSTcURd+0GxZM9KHn67TJLAulJKz2G6ID1riFGMUsMoNNQFSKLE5SjNucSlTvpXiqEsmAVkqueyUwZW3sRmnU2LbfMZ0f8E0v1TRlayELjRZ1mTHiMEOJospbRamaphVw/2fzlFaaEBPeGmGFhABakzcBbFwWnB2EK+4b1ijaBK8LzjuWlLmMkyzoqkRzxFxkahvSy33qrKXWhr7bcn5jJgLnccK5xLHfYTvH87QwZ2kVVZLs2hAyfetZc0J5RxhXdn2P0prffXrEbcCcN3c3rMtKXBdUlWNdG4dBbdm6wp+/zAlNwetK2zXs/IFTrXw6zygFrfdclpV1WdBGcZ4jxhi80ew6T9N4nBXosOTxeVyQ1btCXshSCjGKJMIajXcaquxlzuNMLtA2TsIRNjmAiZk1iAjoZi/CLOs005q2kCglDUQsGCX0aKk/Ms4PLPOIajW2aXvOn97hN7q/s2obmCCq9a2lxIjYdVzjZtMz2weXt7JsmfaN9y/eTrdxJmIqtE7TNFKLeN8ILsFC6+SXrJWiayxH2/E0jlynFWM03ov0LscouE3vaJ2VBdmGjTbG0bZ7lnXhvCzEywUzKZy2+CymMGtluJcpJJWIKTOtM7313B52hJgk/KgkQpQAxF3b4FxFacMSI4+XCWrhbevFKP08ch5X4rLwo7dHlpQYrwu2bfnm/YPgJBbZwv7kqzfEnOga2X7fHncsy0LjNsxGETJySJk1Z/kZNcQ10jYN0/kq0SaNo3Xmxex02vfiPtCa8yQPU7eBgysQo5Chvv10EZKUsaRYWHPZSgtFLbIu+ZzaqbQRZXstWK01KQoFULQAv+eBoJRks23wdylk5D4Mq/C8lTKULTPKGMOaI1YbpnUllcyuadj1RTJ3t7dvCZJy3bUtOa0S+LN5XhvvsHNl37UCdi2ZvCVhpyREH0pljommlaJUfU6jUXKfplqIobCQaVzesuRkqdY4Q12lEHx12vHV7UmYXkrmKqFA3WIS6raZ7rqWLll2rSeFVVRzVNrGoseZvmlZtnSH87wSLjPeifP+uN/TNg0fHs+0jadrPd4ZPj6dyVUx+MJcxO4alpU1ZFIVr8tnaOD5OqJK5dXtkZyy0JOrtKVLENDLkhS+aXm6jOggV5CEMEjIctFOou5T4OMUuE4ywfZWxvi5iFj9c+FdsgitbE4SgrORHGTVK4NX8XzWSk2V4uV/Zp3bylf5AruuJcaVoWvFTTavqFpRRhZpqxLioO8bGcwARhuOhwFyodvteTpPeO+pRXYLKMNp3/P++SyY7lLBWkqt7Nqekuo2Cs6bp0PELkPrsU5znQJLkWjzaVnRWtMaJ0isWl9CpI+7geu8kEqVMKKNj2KtETYsFeeNRKxby7wUWtfx4fHM25ujJCwMHdPzM96dmGPB+RbXKsK6MlgHQGM1t/c3fHo+k1KQE1ML0DcVw5oy0xKJ2wvVesu8rJJoFSKNb1ANrKtQFj9dZoxWXOcFpTX3xz1PTyOVKnkx1wXvLM/jRAyBu9OJaV0pFC7TyrhE2SDLkkUY+elz/Hsmx/D7TvOv/+SnrMuIa8Splt/8jL7vcM5hrRXgi5E21lgJFMoFdl1DiomwpUPXnEVorBR3x4FSxTsqHGBeOqG28eTtTm+ssEKv87qlIxWex4mh78ULvDFJqaJgM1rTOkvbyGfTSpFSFlzk9owf+5YQCgW9RRtIcicbGrNuRWlVinlJfHiaNjN4lGvRGoa2wRlEj4EQl2tKNE0jcwM013kRwvMaMFQ+PV/QW1xqXFd2Qy8Lr5IZWuncQqrcHoZNkZc4dN22PZXP8xn3tcZE33mMVtzudxLGpBV+A+WlDS2xpi0ethSWsIF+t593ColPl5mQKktMhFSItTAviVykE1XbKVlLlbFCLky/+L+2ba4MzGwMC9aJ4lkIQ2K1VErhjdkg9Ooly67UJMd9lLc3lAylshZNuI7UUnh1HBjnWToOo1hW4YtL/Kk487Sq2P3AEiOpQA4FbRRN41G10liRDqSSwTuWtDnY51W0ocbQOpEMohTzsuC947rEF91mquL8q+X33hDzOXaswhSioDxLxTRW3Hito3WaoW3Y96046bVmaBxP44yzjrZxG3bTst8bHj5EfNuz2/UM2z5nXiMhV/quEWzXlkb56TJxu+9pXMMaZlI1VBQ3+4ElyHhbGcsyTxvySx78EDJLTVueHMRUUcrwOM2oSUKdS0h4JzutKQSMNqCFJtRY9/JAGSMFe61ymudcEP6eYKfWeaTpBnIM2JRkHp+TxKJ+7qu10i/BhEpVrHNYo+mNlZ69VPZtQ1hkY6qV5LqGlMilcrPfMy0BY6BthD5UaiYmgciXDL97/0EQTluOmlQyCmO0XIdK01vxoBotp1UqkM4XmkYCglOqHIaeQ9+RamVZJYP3dt8xr5ZxWWm7RnL0tNk6hpVl/bxSr9SSmNeEVhZnLE/nEWcGwqopKKZleZlPdI17QYC+fz7TNJZCYdgNKGANkSkkzteJtmkZc8Iaw7wEhq4jZfju4YxRhk8Pj5xuThJ1tp7xTiQH83rGe09KmXdLkG9GGaZp3ATGRkC/FEKSSao24mnSS6DfZjNV1ZcY+Vw3U36VBandgg5qzRQKa4lsO13iukopYT1WoTYyEJQy0xgrX6T+TBySs1tklhq1xXFVrYRKs7HLGy/TuZAL4zrjt9iv6f9r6mxibFvTuv57v9dae1fVqXP6dtNABxpRmoY0QhsNJiYGUVQS0WiMARKjjh05dOrMmSMTBpgYozEGYpyQmKgEY8QQEEEaRKWF0Lf73ns+qvbea63328Hz7n36TO5N5aTq1Nrr/Xie5////dedECbhljU1SuGI6iMYwBnm6YBRnVzEGN66XKyMFm/wYfLMzXOcphEPP5hpWlPIMptBLmzGGGnb98bjwfHiKHTFa8qBtpptNXz2haFW5K6UM8c5oLVh2zeM0TydZXv2zkh7vHa23NBdtl/nhNWatwtVDS/QOBJrEz1FGSvSez9K7CT9BTp7zhyOB7QGheIwzeKNKZU7L1y0mDKn5zO1VZZpYZ6WW6KEprOEQPSNVPSwripSbZTaZYDZB0ysy/BTQqIEGaaGpCINfY/Vopy7okNrThjrsdcSQGlNThE3sAFaybi4a+neyQOWdjNdDMQxCfC/1c40eepWcVZTcmOPhclbXj7esw0Z3TwJH3wKTiD5WnEXAq03rNFsqtBqZQqe5xJxzjI5OzSsk9CBkmbPMtfwTnO/BDSKxTsueyLXxhIC1o7LpXdsWwQD3jku24btjRd3D4RgqKWxJ0nQzrny8sUdOScuaxezc3PsseC9EAumaeJgJKDn3evX6JZ48fjIIQiy4vmyi36jNZqSD+jpfKbVzmGaBPxiFPOsmZ0mt8YeRY2ecsFqqEVo1krJ2L91ceFTK0Z1Hh8fmL1j33deHie2XAZVTjJfOkjMmFJ0pcfvJgLlydphv2x8E3SM3vogDYn952bmblXkRGqkQIGcRa13ShsTPqWJJUvmSZF2uNKK2hSBwUJdd+GfBwnViVWMweueub87sG6ROQRyk3zbnJNcWJskUJmR0yqDIs1xDigl7XtlDTnvzFMQluolorVinoSuWHPh1YsjL1pj26XqcdZw2Ta2bcMawxwc1hq5XHvHm6cnQggsYaJ2xb5LW3qaAi/vj/R+5rJl9phwzlH2yBSCVE29czd7juaBu8NMGQ8z5sKrhyPq+YyaJow1vH0+c5hnJh+ElDCO05gKKBlvKCV3lJISjw93tN65bJE1phtuq9XEEjyHeSbGyOV8ppTCshyGblicBa2IfMA5yx4LzhsJdqoKoyqvjkdKq1xKoo4MOwk2NOQsWlQXJpyfUdpgfvB7voNWM8aK1kB/2/fjQqB0hfcObwRuX1u/he3GIoASpRUx5hsuUym5PyilpUM4snNzLgPB2EkpjzNVbu2tXuvuIsM7I9Q9hVQ8rTapgIDLvhP3zLrtYj1oshK80WxxZx4fAhqsVQTvOCwT8+Swxg543QgLarLaYsrsSQzRKSWMlkrHOVHAz2EieHuTYGol6vpSK85Y1iIVwpYkZeG6i715OrHGwpYST+cLW0x8/PbEFguXLVJLJ9aMGamU275zOErFsqXMukt/43iYxX3v3Oh+FvYc0drxwatHjNFc9iIB1kZjlZTkf/h7/5ftk6/xmc9+llgyz2/e8m9+5p9wef0RH3z222hXj0+/Wkklbi3/v1+l0wnzUeJOfugL3yFhhlpkZuFzXwJ9TUlwaCs4IrSiMThmkjEtJGWaWDJ9GAGGDEKAlFISKiQ70xwCtYq6yll76/Zpawne0WtHK8nonYMb7vQmtABrURimYJkny/P5jHN+rEB5KXOpPK8X9j3zfD7RUbx9OrHtYhjvcKsUnNYsk0xPaxcURfByES+5isuyyuo+zIGYJBFj8oG3z2e2PZIrvDmtlFzpyvD6eWXPdajh5V5wRZvTOsHLc3UjflUrkV2W2piniTXuIrrSMjANYQJgWSZBa18htyiCMaBEZKW0JjiDMnJV+N//8zf46q//Eqd3H6P8xPHxFb/4736ev/m3f4q0Jn7pP/4C3/WFL9GGRjCXTM6ZWjPpq78qs7kg+TRWupvmBpApA+yuEDlhrp2uZQ7Te8UYiYxQRervYC1PpzPOSn+jlpEYoaWxpTAwzr7eOss8U6qgupWC0znydD7zcJx5ebfIS6ACa8w4A0uQ3kQpFdUz3gSet5XZWYKDNqLcS6n0mmmjtNXWctkivWuxYmQpdVGaScvF8927M8sSiE9nghcdhlay8ygQ5/yeSDGiBwjOoPj2z7xivVwkLVTBy4cj9EZMwmJL2XBYFvK2EaMYpu4mz3GeREl22bAUPni8x6jOum60qQqYb7BfQWFrpbZKLpYYC7k27g6ThF97i3eWqhreyZ3xo+fK23Pkq7/5y/zET/5dvvaNj/jd3/kKj9/2XZxef8hv/ebv8J9+7l/yvV/+MmhwCI6q875y7a1hnRcCNl5U7aLrtNQckS8zmOwVO0IghLwrA51t31AIsVhrzeF4T+ky4OvI5XHbVpy1BKuIJROskYwS54c6vY72fsE50b4+n8+iXndhSPML7JXznjkeJrSzBO95fLjnoVbSmAW9u6y8uLuXCXIHax01tVtylDEaPyLZ6TLcmx8nzhepph6OR9web6xzpbqo57ViWcRQ3lrj4W7hfIl8/aNPOC4TvRbm4Fj3jDGdx+PE/d3C81kiS7zz3C1Ie92akYKdeTgMVMYk+ozlMKGRjur9YYKuOe+CZtBaBpSHeeF5Xcm5ij2lVi6XwquHRdz6vXNwirhdyDnz1T/8hBxXchLdifcT/+Ff/wwPLx75kR//azyVwZ3rRYKNjCb3K3pKRgrOz5gvf/G7pDJRA6L6uT8+OooObSze+9FskoCaVip5pE6X1ganvdFrJZVKRW7PYgSWEiuVyhTsaDHrIeip1CquPIVi8ob7ZcENIG/KGbqA/p8uFy575LRuXLYNY9UQBDsZhSs9GKhVYi5s5zAv5JJpA0nhnOHpJMfOtkWeT2ehEI0ZVK3iz/HWUuugTDuD9+4mlDbmmmBt0Vpxd3fHmopQe4xmmf1AZEs3tJTMYfZi9zASmXoNRqhFvD+5SCpDLkWSs4N0UJ0xtCaplLU2Ykw4H6hdGn7WStbL82UTPsiYcz3lznndeff6G/z2r/03vvO7v5s3r98RTOZH/8ZPs66RNx+/5oPPfadcAkbsR4qJUgvx934FFyZyXJnmI1ZrUUaVoQPoA9nch46gD04WSpOTmI/bLv2RLRaskTQoeZBSg19qQgHOyL3Ae0cqhSl4zqtMO2tr0ukbjTE9kjD1KL6OyzxCmEV1VmrB6HHc1IyuIkXYo7jTjgcLWjF7UdjPXjO7Iw04b4mUCp96+RKrDOu6Mk2By/nE4TgTrOKDx5dchg5WG41F9C0xjvAkJZPq02VHAU+nE2jPx+/O9Nb5lpcPvHkWEfI5jvFlb0ze4pwToXUVPITWiik4nIKYFM/rxjxJeGJrDVRjmi0zIgP03vF8uhCjTFg7kGJksnKP2lLhtCWe90wsnc9/6U9Cy/zaL/57fvhH/gI//89/lp/6+/+AbA788I//dX7hX/0sh9//HJ/6zGdRvVNrHyml+iYWusoPrTYCEak5SpUyyi7nRgq1ljF5mAS+knJldhNaVazxpFzxI3jYGlEhrbHgzFgpA0ew7Zm7uXBYZmjDQW+ln7BtohOpm2gv9NhhGhWtw6gYDFuM9CYZ870rLrtUONTO7D29F7Yo6Ulvn8883h/w1lNO6+CKyu90f7dgTceoGW0s94eJ1ioxF7lsx8K+R4r3cg+pwiZ9/eEzRkMvhccXD5x2KUWPIdBaZS+NhiLmxME7Hu8PclyVTMmRaXIDCQXruvHqxYFpEn1psJbTGmnOcT5f0APC631g2xPGaO7uZoyWBayRz2KLO6nCh+edWOSzQmu+8iu/wue/8Ef42te/wfd9//fS3UIuEvHy+S/8oODHr020Ac0VxflIfBjaVKsQzQYjoFCNNwg1evatkVOi6eHJMAZjOl7LzVzTWbxjy51p9PVrFxOUNQoTHDmDtxMdOJ0vgkaaxM8BCDahtmEWd5K2aBDda2tD6t8JTnysl03cfpJno1icH3wLx3nN1BalmrhEVF+pdLaUqOdnUqp866sHnJVZ5rbtnM5nDoeDuOq2nd4UYRqBxC7wtJ3oHayzmN5xk3Qg350uEn4YPPseybXTVGUJsv0bI4rx1pvobrt0nJXW7ArenndyLbw4zHgnU+TLnvFeslyUNhJ23CRI0lrhxXsvFaC1hbvF8+YS6aeIpnN+fubXf/k/c/7wK/y5v/V3+LX/8l+lV9Wlg6u74nd/6zf40z/2lym9YRD8du3S++pDc8z4uu1IDWyco0QZvEnjRI+HLlL4WhtNKfYccUahpiCj8945rwJOMUaDaoQRBR6coza5BFktR4k3An8tpTBNnpzlLmKsxU0O1TW5RFKppJJZdymJ/TVdicyeK9Z2coMtJrYiGITW5Iw/R9EzSN6JwGO0krr/YRH7ZbCG++OMt5Z3pxXjLDFKk2majLjrreG0rQLS6VBqJ+4XvNEUHQghYJQR2vNB9KylN7QyHCfHZd8xRpT3PjicEdnltssRvO8ZbTVvTxvPl42745HDcRYD9roxefm9lzDjnGdPidoab56kgtIjTar3Tt5W/u2/+GcoNr74A1/iM3/qJ9HzK/7oF7+Pn/un/xjMkeXxFX/wf77Cj/zFH6UfHgVC2OqQHWqxcg6gchtaHNuqTAitC/RaKaM2rrWjahse1op3ch9QVUntXqL4RbWSraoWylCbq0FmBlGbb2nElffOed/xzqN6o+1Qmhiyt/OJt2eJgc9pxVkZSPWm6NsuE8xacS7Qa+PptA0ZpMyfBPjW8U4QVkrB63eJ4zLz4jhTqsJZsYfWLJ3ekiqpCG1nMop5mcitc1lXHg6BXBX3i+F+EanAhx99Qi+FhmNPO84aPv3qXqQJqmOUAO1yTmwxsm776L9ITwSNyCdLEnKjC8zBcl43Goo3T09opOV/XALz5FkvG4/3E5o2ZilIMdAkqnXPUuX97m/9d/7sX/oxXnz6W+lGTFq1wotv+Rx/7x/+I776lf/BcW588a/8BMUd2Pd0i7+9osa06jcgjmAw6zV5Wzqk1k/kIcFvYyh3/VN6RRVhqE/O0buM5i9rxFvRKqRayanc7IGnPWKTmHpyKVjdMMpISjZQ6zZK0YbRMrFkYJ+6AtOlq9pap6UicVq1M/kwAos0rUoH0ahh8DaGXCveTzKJ7td4jE4rhlYyk5eX9rLvBKsFep8y94cFrQ21G16fI7or9pw4Tg6jO4vX7E2xxcjd8Y7PfPCKd6czx8MCg7pkjSWXxjw5llkmwKctkUdq6DIFmnJsuYpYp1em4IQBPwtTrJaCsXJZf3G/cJi8WDdHKsNxmkYnW/Pm+cKeC3/sB/4EW4amRehkr4NWpVH+nu/58p8ZVWWnFdnlmhIBVcxycnTkOJeh4wDc9d4wxtF7RauhdVQIh9O8N0RZoyl9yBBHpltO4r7qaDEn184cJnISX0VtjbtlwfpGTInJGoIVcbLREniYSkV1mZ3cAHDWkVrnaA1KyXnuBjh2nvzAP/ZrMrRoYZ1iCWJmylUoQClllhB4vkhPQvys4wJcMq129i4UQecc5yTb6v0y4bLYKWJW3N8t7NuaEgKXAAAPyUlEQVSOsxpzPHDvPQp48/QsoqWYxswK9ngBNG9PzyzLIuWn0Wwpct52nrdEzIXJKr7lZeC0ZaYK94eARsTDOngsnVIbl5xJuWINOB+ERdIyWrvRp3KUXsnN0nW7JZW29p5A2Qbv9irpuC7K4DREhUGKEqss2jhy2tHGUXMU6+X1xlqLCJI1ImQVr2jHDv1AKXI/OW+71OreoREtZx3onl4hloRGurIxilfEalntp7QNgazYvVqDptptCGitSPRr62gaLw8LRjWs0qhe2dZtmI461lrKUNRcLpW8SANKjeZSpxFL4uFu4fmy4ZxMMsMUKFmoRh+/fUtrnSk4UfJ7T311T0qZFBOHZaFWCNZwfHxBTImKppRGzlGkEJOMAlLKLPOEs4Y3p8pHb55x1lFRbHEXBu3QmxqjeL5cpL9iDU9rlvI8jMwdJSx7O0iIXTm+9uHHHJeJz37qkY/fXQDFZRdz9+Q95JF3qxXWaFqpWCPa2N7eL27bG80M1IfWmHGt0F1K87xvTId70cYKB0K2q5ITjUZFxMmdkYuiFIkksNgmmGmlxZbpjEXrRiziEBdDtnhKnRkiFaVkXjIwSLnkoY2QM7V1JSN/ayi9chwXSac7zkm26zJiSHrTdK3FagEYq9FoatWk3FimwF4KMVcu+4bqgvMc6aFsqfDR84q3RoZezmAQRAJ0LtvG7389YbXmuAj58ZO3J14ePft+4dXLO94+C8ri7niQB240qTSUFvbXXirTNKPdxB9+8o5aC8oa7ADVzsEyOWnArSmzTB5vNU1lrA3DlqBRRrOnhDWO03qmKxkb/P7XP6F04eprYHFqjD0cKWYeJo/S8jld1oQ3hslp0BM5Vybj5YJax+fcpY3AoG3XIsNbpfU3o7jfWwB7l5xcMX43nHWo4QXRxkDMQ8muKL2ghgpaK0l71kq+Lv8VzmpvUhmF0G/hzcYYuViOGI2YBcu4r6tMVZXi6bwxOZm2OqN5cVwwqo+mjiLthVIK8ywZLpddwoVSypJfJ1oZFJ3n0wZKMXmHUZLIpZQMuq7yRaMNzknqVu+N87rhVacU6cb20XL/8N3Kb//B129SgqdLZPKa+8MR7zzrurHuQjvIWVi0rYFzBtW1cN3p3C+T6HONkkj1ASTOpXDZy/AVSSVXSuO0S6kcU+Zu8jwcAy+Bp23n3WXHz45l9GWCVtAMe6psMcpRF8XHQ++3JDGjNL1ndJf3wLowrCsOq0TSJAhMpVCdgcyugiHokFvDa0NXkgQRvB0Qtga6C4apy4RXIdPL4QWnqCrdzzGO7r0NIrOVnaiLQKbVMlIkpb2vxccgZWKp5NokHGdYJi7nCy8e7khNsJ29NS6XFe8NtVQR3nSZdqJkSz8uE0ZLh/cYPE9akQvMk0j9zjWylUwqkYfjEbpIGD7/7Z/Cym+Gs46vvT7x1W98TBmX6TwMS3vuXF6fxKju5FzXug93m6JrCE7Mac5agnO33cIo8f6U3rFovLccgoBuU8pi1moCfdmzNCJLKZwuTaqkUli8o7RRKRrw2rJ4i+qKtXfOW5RZi9QCErcm/4d3lhKjGPiHy1IpLdNcRpidGVO8XBtulDoKWOOGMwdabhTT8VbkhNoMGaFWt0umd/Km65EYAaJz7a0jh1bHjGqlj21dUNoakF3DO4tqomBTCtxksClK5FmqFCrTdVtumtm7IaHTCBhY5HS1dawWpkjrBWU0U/CUlNhTwlnFliKvTwkNxJpJCbxVHJtoLHqHX/1ff8B3fPol0+T4xts3PJ8j+3D0S+fZoFUT6JuVbmlvFlTBaEdYgjDNxi7MEA4rCS5GqyY5e23IAkeCKMD5vI77VIYmz8wFCzQua+b+bpHki64I08SHr5/GQtcYJT6jGDMPsxi615ilAWY0ucpdTtFRQ9V3tbRI47TKEXPtwYseVPSpDKCLN9yy14wxtApbLXhjb5HeOe03ucDVhASSFd9Gjq5O0pChJbR247VoI7UAelXkJlqKnCp+UI20UYKl0iKeVoNzlnvltO6SbGCF3JOK7A5b2qGYwV8tkgWsDW+fVtwuiKsleLpSnHfR0UrTT8B0a8q8eZau8TUE8Pc+ektO4kvxfiI4yxoLtQipWmstxKTWcEbxeJQR/xYTe85ipezC9GhNXPq5FBRCss5JLJHdGbaY8daSUhIpI0gneDS5YxREph0DvWCG0zAmFmfkDpYK3kykmDE0rIKjV6ybXAdSrVJOd0WjsQTL5dK4xsOYcexbsfk7sTUMH4iiDS9KxYwhWclZbA/jniL/WJliWi0QOsEnignnfciytJCL7fSe8U5SMb21aKqsCO/xwaMQo1ZMCTNKNejMTrNFaQ4ZDb0V0avUPsjGSVZKrmjVMdawx0gubZTqneMy44NjXXeskv5KbVJKtlbGYNLQdRuRJXJ5o3MTAV0ZHXuULV9rMZXNI4HKOUss0g/RvaFa5X4SI9RlT0JOQjF5z54TTmlJpNRKQLZDamiMwqggRCENRmmcnUlF0F0ikBKpxJ6qAPuNGLEWb3FW7nMlJ9oIzr5siZjrsGkqShZ2qgb2VilF3+6f18pWaS0viHUObb3sAq2im7xxpcsPr7XgjKP2KuKQLizvVosMewZCqdMxXeHGsCfXBqqTy34Txa67pCTo3jFACHK608Z21+FustQ6qHzIjMhqmWB2a0BDzg3rZEbTBv7aWamc9ix+F2+EydF6l+nrUOX2IWwqreG0lPStldGs68I215opaHJu0KRKuLFAjLkJf50xOBR+8nhrueyZpDrrlpitoTeRIF5XPCB+XSMLwCrpVCs9dupWxDMzjO3v9bVR0jeqKMuuhrWWFbMz0CrBac4xSiNSyWTdKsF5pzIY7gNzJXcUxu/XRMXO1d1QB5myIMwowFox/FKbtMFrEWdYKZJG3RsauXs0JbsL7WbSlF+wdbox8g9mNKOaGKLoDKdeZ3Z2SAESGmmOydVNGm50aFUuU2qgsGq9xqXJCnf2ijfopMFV3VPCGT38H405eJpV1CRdSGUsWvVxLBmosJfEfZioQ+ZQe6VVUFR5mMMqsQQvXtfe8coQiyZoi7bSrZ2NtPKz6RzmwOWys22RZRFHwEdPz9KANHIcfvDijhhXvPPUXtCaQTAw7HuiVNHwWht4PgspYK/S3V68Q7eO0nJQb3u6IcDXMfIXl977PkdrcnToXgXx0CvKigRB9c5kFaeUB4JbFn/eL9ic0q3mFVe3GJs7GhtA907vDo1M+pSS6kBc4VJutquGhE4rBd3ckO/LKjVdrJcpRYzSvE0Zb4ecWnn2lHmxHEYahCLlsQ2WKtl4AzF9nfWYAV6rTY4xFNI5rX1oUwuzN6gu6G5rIFgBzjbVcUF4q7Nz1CqzF2ulSqtVTObWAEVepMkbdG83n/Cl7uInBVIpzD5w3hJtl5yVdTQS97yj1koX+x7Pl11kDlrz4SdveVw8Ne+0q8cIjVIV1RV7FBBdZx1Q4TIWmsKphhllc2+duEsTrrRGrQptlRz5DWKtY2SiqXXIN3rFAXvJ7CkR40YLYXzWbeTeNHLcsDluhHmRxsmoYra0Y1slEHDOycR1JBgNfxBNq3GmQsPcsnQbULLsHEbLA8+q37ZliwFdiAlqy5xXI1ShpwsAh2CwymC0Gb0YOWpylS2SMU/wVsxLvY4wozY0tAP2Zrtl7Yac5AV7SgWrNVNwbBdR5V+ure3Bum6VocfV1KpGpEgWLpsWeUAasV4K8N6yp8TpssO47Clg8RN7zdwdAm/jLnzTXKE2SklkOjo49CQNv5il7G+9CX7DOagV3Tq1S39J1UJritYUa68cvBY68nDmGyMBDG30UK6e6DpYHkJKlGaYblJV5lrZdkFbvXleOe+Xa9NINEKlYHNc0ebTcp9oDZ2jBOC0ThuQEWfdoPkUutZy59Dc5IVXXYZCyeUSwVqGyfHqMPHJ0zNaNT49Bz5+d0YZM1rz/abWZhwysRt20a2glayANDylarSGZeAkqQfL5Dlay9ZELG1VxXqLUpWgRtu+1tEKj0yjQeONlhy3lATwW0V/UQfdZ+/DszuU5MaLz+SSpF9zDVqSWxJYZdBaXlRGdfKUo1R0TXDizlmCsQMgp4n7Kr0G1VA1S7WG5bRuOCtdbOcMqjZeeEVqnecYKQUafsSuVdnMht5DCNdtiLXqCIhqKNFVUar823PK1BFru64bT4PyoIwV1dpo2au/+oPfSbi7w08zznuM86Jq7p0cd2oRm8BV3Hw9ir65A3stlVtrwpWoRQAkXLux/SbZV8pgXcA4L13Z1ilFRs/XMOerHqGPKgbkZ13VTte50U397QIuTLdqrGRRcNUcB4zNY6yAga8l/XUrlZRpfesFSQ+j3n6+fC2P43X8/YFokjmK5zquoHfMgAC3Vmi1UHK6RpzfRDitVrR1+DBLykbv1JLGI9C0WojbRdK8jSXMR6EvDMXfdRxfizznkosc7dZirX3f+ByGuOuf6/+Li8FIuECO1DIqtuFwsD5g3SRFy0//+R+SsBoXcD6MQLsmaG6FCFOG1fAqDdBKhES1JNK+keOFWoVDZlzAWC/8CeNu4+NSMq3K0dNrGalPjms0/BWV0Mdc6PoyiuJevket5fbh9xHw7MJ0u//UazBja8O/KxWYUgY/LVjnbvekWousmPGwGDjyUsSXqm4UP3ULTerjRee6WNR1AHbNum+83+sYTahBirQOfQUFDiSmXAbr7XvKyu03mYU28n3N4Iy0Wm5HuTFuJFWOl12bm4G+Xxdqq7KIh/Pv+uFfP+dWKyWn20ZQciTHjdbKeLYz1rpJmiJaZnp96EBuF1eujTT5ZnXQiK6r0k8zYTneokRKTqR9peZEHytFUr0DKizUkYTNOB/znrC24YPkxaoR7JtTlGOPfqP9XCPkW5EXzLoO6eotff9QjQ+3r7mRKi6r8jx2iHbLp78+dAYtWmlFWI435bkQhyWuw1h7K/9qSePvjxcFQXe1gXayzqGNBABRC3vcbj9HjPBiNbEujEVoxovdB59MStocd+LlRMnSJrc+SLatztysteqb0yrbrVvbB5z/an7ro6l5Ggvs/Y5oxgvVcX5BaTWSUCPWTxKtlbeVOFTdYZ4I0yRvGo2Wo/QTRg2u1bVrOjJHvkkuUHO65fC21m5vd94vlBLF7T4dCMvd7SgrKY7dSHaA6/dQSr9nwg9IrQQuWnyYZdpchqqtdUraqCWJXWM64MJ8E0CXlMlpl/uEczgf0MbdDMsikBr46laGcUijrbT7hbwjO6gZ+b/Xo4iBJjcuYJ2/xan025FScC5gvRxHvXVaFby4sXZ0LUV7WsaxeFN7KY1fjkz6/rYrtFropdz6OtejpBe5R8luBphvQnMZJy/i1Sl51aLWMp6/KAt7a9KXUYZpvuf/A3odtCaPyZYiAAAAAElFTkSuQmCC")
                                            , t = new ji({
                                            map: e
                                        })
                                            , n = new Ds(136 / 157 * 2,2)
                                            , i = new wr(n,t);
                                        i.position.set(-640, 2, -249.95),
                                            i.visible = !1,
                                            s.scene.add(i),
                                            j_(this, N_, {
                                                dispose: () => {
                                                    Q_(this, JC, "f").scene.remove(i),
                                                        n.dispose(),
                                                        t.dispose(),
                                                        e.dispose()
                                                }
                                                ,
                                                update: () => {
                                                    i.visible = !Q_(this, L_, "f").isEnabled
                                                }
                                            }, "f")
                                    }
                            }
                            dispose(e=!0) {
                                var t, n, i, r, a;
                                Q_(this, n_, "f").setCursorHiddenWhenInactive(!1),
                                    Q_(this, jC, "m", z_).call(this, !1),
                                    Q_(this, x_, "f").dispose(),
                                    Q_(this, r_, "f").removeChangeListener(Q_(this, k_, "f")),
                                null === (t = Q_(this, y_, "f")) || void 0 === t || t.dispose(),
                                    j_(this, y_, null, "f"),
                                e && Q_(this, qC, "f").clear(),
                                    Q_(this, KC, "f").clearMountains(),
                                    Q_(this, S_, "f").dispose(),
                                null === (n = Q_(this, T_, "f")) || void 0 === n || n.dispose();
                                for (const e of Q_(this, C_, "f"))
                                    null === (i = e.car) || void 0 === i || i.dispose(),
                                        e.car = null,
                                    null != e.carId && (Q_(this, YC, "f").deleteCar(e.carId),
                                        e.carId = null),
                                        e.replay = null;
                                window.removeEventListener("keydown", Q_(this, P_, "f")),
                                    window.removeEventListener("keyup", Q_(this, R_, "f")),
                                    Q_(this, L_, "f").dispose(),
                                null === (r = Q_(this, N_, "f")) || void 0 === r || r.dispose(),
                                null === (a = Q_(this, D_, "f")) || void 0 === a || a.dispose()
                            }
                            update(e) {
                                var t, n, i, r, a, s, o, l, c, h, d, u, p, f, m;
                                let g;
                                if (g = null == Q_(this, T_, "f") || Q_(this, L_, "f").isEnabled || this.isPaused || Q_(this, B_, "f") || null != Q_(this, y_, "f") ? 0 : e,
                                this.isPaused || null != Q_(this, y_, "f") || Q_(this, B_, "f")) {
                                    null != Q_(this, T_, "f") && (Q_(this, T_, "f").isPaused = !0,
                                        Q_(this, T_, "f").audioVolume = 0,
                                        Q_(this, T_, "f").update(g));
                                    for (const e of Q_(this, C_, "f"))
                                        null != e.car && (e.car.isPaused = !0,
                                            e.car.audioVolume = 0,
                                            e.car.update(g));
                                    null === (u = Q_(this, w_, "f")) || void 0 === u || u.setVisible(!Q_(this, B_, "f"))
                                } else {
                                    if (null != Q_(this, T_, "f")) {
                                        if (Q_(this, T_, "f").update(g),
                                            Q_(this, L_, "f").isEnabled)
                                            Q_(this, T_, "f").isPaused = !0,
                                                Q_(this, T_, "f").audioVolume = 0;
                                        else {
                                            Q_(this, T_, "f").isPaused = !1,
                                                Q_(this, T_, "f").audioVolume = 1;
                                            const c = Q_(this, S_, "f").getControls();
                                            (c.up || c.down) && (Q_(this, T_, "f").hasStarted() || Q_(this, T_, "f").start()),
                                                Q_(this, T_, "f").hasStarted() && !Q_(this, T_, "f").hasFinished() ? xC() : kC(),
                                            Q_(this, T_, "f").hasStarted() || Q_(this, __, "f") && (Q_(this, i_, "f").show(Q_(this, ZC, "f").get("Invalid replay detected!") + "\n\n" + Q_(this, ZC, "f").get("An opponent most likely used cheats"), Q_(this, ZC, "f").get("Ok"), ( () => {
                                                    Q_(this, i_, "f").hide()
                                                }
                                            )),
                                                j_(this, __, !1, "f"));
                                            const h = Q_(this, C_, "f").reduce(( (e, t) => e + t.loadedFrames), 0)
                                                , d = Q_(this, C_, "f").reduce(( (e, t) => e + t.maxFrames), 0);
                                            let u;
                                            u = d > 0 ? h / d : 1,
                                            null === (t = Q_(this, u_, "f")) || void 0 === t || t.update(Q_(this, T_, "f"), e),
                                            null === (n = Q_(this, p_, "f")) || void 0 === n || n.update(u),
                                            null === (i = Q_(this, m_, "f")) || void 0 === i || i.update(Q_(this, T_, "f")),
                                            null === (r = Q_(this, g_, "f")) || void 0 === r || r.update(Q_(this, T_, "f")),
                                            null === (a = Q_(this, f_, "f")) || void 0 === a || a.update(Q_(this, T_, "f")),
                                                Q_(this, T_, "f").hasStarted() && !Q_(this, T_, "f").hasFinished() && Q_(this, E_, "f") ? Q_(this, T_, "f").getSpeedKmh() < 50 ? (j_(this, A_, Q_(this, A_, "f") + e, "f"),
                                                null === (o = Q_(this, w_, "f")) || void 0 === o || o.setVisible(Q_(this, A_, "f") > 2.25)) : (null === (l = Q_(this, w_, "f")) || void 0 === l || l.setVisible(!1),
                                                    j_(this, A_, 0, "f")) : (null === (s = Q_(this, w_, "f")) || void 0 === s || s.setVisible(!0),
                                                    j_(this, A_, 0, "f"))
                                        }
                                        Q_(this, T_, "f").getTime().numberOfFrames >= cv.maxFrames && Q_(this, jC, "m", O_).call(this),
                                        null === (c = Q_(this, D_, "f")) || void 0 === c || c.updateCar(Q_(this, T_, "f"))
                                    }
                                    for (const e of Q_(this, C_, "f"))
                                        if (null != e.car) {
                                            if (!e.hasEnded) {
                                                const t = null === (h = Q_(this, T_, "f")) || void 0 === h ? void 0 : h.getTime().numberOfFrames;
                                                if (null != t) {
                                                    for (let n = e.car.getTime().numberOfFrames + 1; n <= t; n++) {
                                                        const t = null === (d = e.replay) || void 0 === d ? void 0 : d.replay.getFrame(n);
                                                        if (null == t) {
                                                            e.hasEnded = !0,
                                                                e.car.setVisible(!1);
                                                            break
                                                        }
                                                        e.car.setCarState(t)
                                                    }
                                                }
                                                e.car.update(g)
                                            }
                                            e.hasEnded || Q_(this, L_, "f").isEnabled ? e.car.audioVolume = 0 : e.car.audioVolume = .35
                                        }
                                    Q_(this, jC, "m", V_).call(this),
                                        Q_(this, L_, "f").update(e)
                                }
                                null === (p = Q_(this, N_, "f")) || void 0 === p || p.update(),
                                    Q_(this, KC, "f").update(Q_(this, qC, "f")),
                                    Q_(this, XC, "f").update(g, Q_(this, JC, "f").camera, Q_(this, qC, "f").sunDirection),
                                    Q_(this, $C, "f").update(e, !1, Q_(this, JC, "f"), Q_(this, t_, "f")),
                                    Q_(this, JC, "f").update(null !== (m = null === (f = Q_(this, T_, "f")) || void 0 === f ? void 0 : f.getPosition()) && void 0 !== m ? m : new An, Q_(this, qC, "f").sunDirection)
                            }
                        }
                    ;
                    var q_, K_, X_, Z_ = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    }, J_ = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    };
                    class $_ {
                        constructor(e) {
                            if (K_.set(this, void 0),
                            null != e) {
                                if (!Number.isInteger(e))
                                    throw new Error("Seed must be an integer");
                                J_(this, K_, e % Z_(q_, q_, "f", X_).length, "f")
                            } else
                                J_(this, K_, 0, "f")
                        }
                        next() {
                            var e;
                            return J_(this, K_, (e = Z_(this, K_, "f"),
                                ++e), "f"),
                            Z_(this, K_, "f") >= Z_(q_, q_, "f", X_).length && J_(this, K_, 0, "f"),
                                Z_(q_, q_, "f", X_)[Z_(this, K_, "f")]
                        }
                    }
                    q_ = $_,
                        K_ = new WeakMap,
                        X_ = {
                            value: [.12047764760664692, .19645762332790628, .5525629082262744, .41272626379209965, .7795036003541387, .13367266027110114, .7999601557377349, .9519714253374205, .1735048382917752, .7513367084489158, .6531386724839523, .9026427867068505, .8543272738216994, .11176849958868162, .6705698284858437, .26628732081296946, .31140322993719605, .45170300835470933, .12615515120247944, .0610638094525735, .291990923385425, .4613983868623317, .6615759832726253, .4373182881232056, .7432890501246443, .39316710322388837, .49444122821563297, .5994296685114344, .060050119050233386, .4165885432422003, .43974364800990084, .1628314496954224, .05787972729968116, .225388541259955, .6075775236386991, .8908354370882479, .47072983115144584, .7662003453186828, .20651036895645647, .03724062137286044, .17110277274376795, .7626426077793496, .8372112804261309, .8761690804447455, .13887024930406633, .8287513367412203, .9794446290917873, .807658524448803, .8465629116398186, .5187285629536083, .33962953580139277, .9798419666114342, .6777071959103609, .5388899884934379, .7863389168762325, .4274591420924474, .25631366937500566, .5695289062505289, .026841382754547727, .18267938207996903, .9853642975717878, .24428485895234409, .5322028747608949, .9655065842019517, .043810183244384016, .541216190236913, .05897981610006209, .2849168541804703, .5349823008832073, .9655676144971486, .22831812764497283, .7698701658704175, .4103995069939841, .25782763124411856, .8490222628872495, .39280879489916987, .31999467883347554, .2860820872456349, .9684928577493004, .9973831481899462, .2930912094664657, .4847128131859766, .7218400909709828, .40407009594106236, .7059298060123587, .45362146566562744, .4640974655488792, .16076769483252273, .5989453525750241, .585759299589679, .9417035568973537, .20117930667657413, .5777873180244959, .1991854396549344, .8743781441651348, .624666386634513, .38720573630932886, .9967931526923675, .49817894572849486, .24585267823751833, .8639168275132305, .2865624029759799, .6163605496913385, .5864748073339972, .8781049154377354, .7497547608938613, .7864098057445887, .0334170452332867, .4875588105294657, .6737395339380896, .21851121231639659, .2923739650597854, .6073797612662293, .41823228947229896, .8531029420136382, .3260916332061783, .6306262204574675, .5268576689601923, .3516570914484707, .8659366375222706, .8447448461834428, .3794548980890986, .9832775904115916, .8442256760399809, .3006550591973338, .9718660619781394, .5103245035851833, .794319831388071]
                        };
                    const eI = $_;
                    var tI, nI, iI, rI, aI, sI, oI, lI, cI, hI, dI, uI, pI = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, fI = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    class mI {
                        constructor(e) {
                            tI.add(this),
                                iI.set(this, void 0),
                                rI.set(this, by.Summer),
                                aI.set(this, void 0),
                                sI.set(this, void 0),
                                oI.set(this, void 0),
                                lI.set(this, void 0),
                                cI.set(this, null),
                                pI(this, iI, e, "f"),
                                pI(this, aI, new Fs({
                                    depthWrite: !1
                                }), "f"),
                                pI(this, sI, new Fs, "f"),
                                pI(this, oI, new wr(new Ds(6 * yu.maxViewDistance,6 * yu.maxViewDistance),fI(this, aI, "f")), "f"),
                                fI(this, oI, "f").rotation.x = -Math.PI / 2,
                                fI(this, oI, "f").renderOrder = -3,
                                e.scene.add(fI(this, oI, "f")),
                                pI(this, lI, new wr(new Ds(120,120),fI(this, aI, "f")), "f"),
                                fI(this, lI, "f").rotation.x = -Math.PI / 2,
                                fI(this, lI, "f").receiveShadow = !0,
                                fI(this, lI, "f").renderOrder = -2,
                                e.scene.add(fI(this, lI, "f")),
                                fI(this, tI, "m", uI).call(this, by.Summer)
                        }
                        clearMountains() {
                            null != fI(this, cI, "f") && (fI(this, cI, "f").material.dispose(),
                                fI(this, cI, "f").geometry.dispose(),
                                fI(this, iI, "f").scene.remove(fI(this, cI, "f")),
                                pI(this, cI, null, "f"))
                        }
                        generateMountains(e) {
                            this.clearMountains();
                            const {vertices: t, offset: n} = nI.createMountainVertices(e)
                                , i = new sr;
                            i.setAttribute("position", new Ki(new Float32Array(t),3)),
                                i.computeVertexNormals();
                            const r = new wr(i,fI(this, sI, "f"));
                            r.position.copy(n),
                                r.receiveShadow = !0,
                                fI(this, iI, "f").scene.add(r),
                                pI(this, cI, r, "f")
                        }
                        static createMountainVertices(e) {
                            const t = new eI
                                , n = Math.max(200, 160 + Math.max(Math.abs(e.max.x - e.min.x) * yb.partSize / 2 * Math.SQRT2, Math.abs(e.max.y - e.min.y) * yb.partSize / 2 * Math.SQRT2))
                                , i = new jt((e.min.x + (e.max.x - e.min.x) / 2) * yb.partSize,(e.min.y + (e.max.y - e.min.y) / 2) * yb.partSize);
                            if (n > 4500)
                                return {
                                    vertices: [],
                                    offset: new An
                                };
                            const r = Math.floor(n / 10)
                                , a = [];
                            for (let e = 0; e < r; ++e) {
                                const e = [];
                                for (let n = 0; n < 8; ++n)
                                    0 == n || 7 == n || 1 == n && t.next() < .5 ? e.push(0) : e.push(t.next());
                                a.push(e)
                            }
                            const s = 100
                                , o = [];
                            for (let e = 0; e < a.length; ++e) {
                                const t = e / a.length * Math.PI * 2
                                    , i = (e + 1) / a.length * Math.PI * 2
                                    , r = a[e];
                                let l;
                                l = e + 1 < a.length ? a[e + 1] : a[0];
                                for (let e = 0; e < r.length - 1; ++e) {
                                    const a = n + 100 * e
                                        , c = n + 100 * (e + 1);
                                    o.push(Math.cos(t) * a, r[e] * s, Math.sin(t) * a),
                                        o.push(Math.cos(i) * a, l[e] * s, Math.sin(i) * a),
                                        o.push(Math.cos(i) * c, l[e + 1] * s, Math.sin(i) * c),
                                        o.push(Math.cos(t) * a, r[e] * s, Math.sin(t) * a),
                                        o.push(Math.cos(i) * c, l[e + 1] * s, Math.sin(i) * c),
                                        o.push(Math.cos(t) * c, r[e + 1] * s, Math.sin(t) * c)
                                }
                            }
                            return {
                                vertices: o,
                                offset: new An(i.x,0,i.y)
                            }
                        }
                        getMountainVertices() {
                            if (null == fI(this, cI, "f"))
                                return [];
                            const e = fI(this, cI, "f").geometry;
                            if (!(e.attributes.position instanceof Ki))
                                throw new Error("Vertices must use BufferAttribute");
                            return Array.from(e.attributes.position.array)
                        }
                        getMountainOffset() {
                            return null == fI(this, cI, "f") ? new An : fI(this, cI, "f").position.clone()
                        }
                        raycast(e) {
                            const t = e.intersectObject(fI(this, lI, "f"));
                            if (t.length > 0)
                                return t[0];
                            if (null != fI(this, cI, "f")) {
                                const t = e.intersectObject(fI(this, cI, "f"));
                                if (t.length > 0)
                                    return t[0]
                            }
                            return null
                        }
                        update(e) {
                            e.environment != fI(this, rI, "f") && fI(this, tI, "m", uI).call(this, e.environment);
                            const t = new An
                                , n = new wn
                                , i = new An;
                            fI(this, iI, "f").camera.matrix.decompose(t, n, i),
                                fI(this, oI, "f").position.set(t.x, 0, t.z);
                            const r = fI(this, iI, "f").getLightTarget();
                            fI(this, lI, "f").position.set(r.x, 0, r.z),
                                fI(this, lI, "f").visible = fI(this, lI, "f").position.manhattanDistanceTo(fI(this, oI, "f").position) < 8e3
                        }
                    }
                    nI = mI,
                        iI = new WeakMap,
                        rI = new WeakMap,
                        aI = new WeakMap,
                        sI = new WeakMap,
                        oI = new WeakMap,
                        lI = new WeakMap,
                        cI = new WeakMap,
                        tI = new WeakSet,
                        hI = function(e) {
                            let t;
                            switch (e) {
                                case by.Summer:
                                    t = new Wi(3495480);
                                    break;
                                case by.Winter:
                                    t = new Wi(12240856);
                                    break;
                                case by.Desert:
                                    t = new Wi(11171394)
                            }
                            return t
                        }
                        ,
                        dI = function(e) {
                            let t;
                            switch (e) {
                                case by.Summer:
                                    t = fI(this, nI, "m", hI).call(this, e);
                                    break;
                                case by.Winter:
                                    t = new Wi(9805741);
                                    break;
                                case by.Desert:
                                    t = fI(this, nI, "m", hI).call(this, e)
                            }
                            return t
                        }
                        ,
                        uI = function(e) {
                            pI(this, rI, e, "f"),
                                fI(this, aI, "f").color.copy(fI(nI, nI, "m", hI).call(nI, e)),
                                fI(this, sI, "f").color.copy(fI(nI, nI, "m", dI).call(nI, e))
                        }
                    ;
                    const gI = mI;
                    var vI = n(2915)
                        , wI = {};
                    wI.styleTagTransform = u(),
                        wI.setAttributes = l(),
                        wI.insert = s().bind(null, "head"),
                        wI.domAPI = r(),
                        wI.insertStyleElement = h();
                    t()(vI.A, wI);
                    vI.A && vI.A.locals && vI.A.locals;
                    var AI = n(2927)
                        , yI = {};
                    yI.styleTagTransform = u(),
                        yI.setAttributes = l(),
                        yI.insert = s().bind(null, "head"),
                        yI.domAPI = r(),
                        yI.insertStyleElement = h();
                    t()(AI.A, yI);
                    AI.A && AI.A.locals && AI.A.locals;
                    var bI, xI, kI = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, EI = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    bI = new WeakMap,
                        xI = new WeakMap;
                    const SI = class {
                            constructor(e, t, n) {
                                bI.set(this, void 0),
                                    xI.set(this, void 0),
                                    kI(this, bI, e, "f"),
                                    kI(this, xI, document.createElement("div"), "f"),
                                    EI(this, xI, "f").className = "loading-ui",
                                    e.appendChild(EI(this, xI, "f"));
                                const i = document.createElement("p");
                                i.textContent = t.get("Loading") + "...",
                                    EI(this, xI, "f").appendChild(i);
                                const r = document.createElement("div");
                                EI(this, xI, "f").appendChild(r);
                                const a = document.createElement("div");
                                r.appendChild(a);
                                const s = document.createElement("div");
                                a.appendChild(s),
                                    n.addProgressListener((e => {
                                            s.style.width = (100 * e).toString() + "%"
                                        }
                                    ))
                            }
                            fadeOut(e) {
                                EI(this, xI, "f").classList.add("fade-out"),
                                    setTimeout(e, 250)
                            }
                            dispose() {
                                EI(this, bI, "f").removeChild(EI(this, xI, "f"))
                            }
                        }
                    ;
                    var MI = n(1643)
                        , TI = {};
                    TI.styleTagTransform = u(),
                        TI.setAttributes = l(),
                        TI.insert = s().bind(null, "head"),
                        TI.domAPI = r(),
                        TI.insertStyleElement = h();
                    t()(MI.A, TI);
                    MI.A && MI.A.locals && MI.A.locals;
                    var CI, _I, II, PI, RI, LI, NI, DI, BI, UI, zI, OI, FI, WI, HI, VI, GI, jI, QI, YI, qI, KI = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, XI = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    _I = new WeakMap,
                        II = new WeakMap,
                        PI = new WeakMap,
                        RI = new WeakMap,
                        LI = new WeakMap,
                        NI = new WeakMap,
                        DI = new WeakMap,
                        BI = new WeakMap,
                        UI = new WeakMap,
                        zI = new WeakMap,
                        OI = new WeakMap,
                        FI = new WeakMap,
                        CI = new WeakSet,
                        WI = function() {
                            XI(this, DI, "f").className = "hidden"
                        }
                        ,
                        HI = function() {
                            XI(this, DI, "f").className = "settings-menu"
                        }
                        ,
                        VI = function() {
                            XI(this, BI, "f").innerHTML = "",
                                XI(this, CI, "m", GI).call(this, XI(this, II, "f").get("Gameplay")),
                                XI(this, CI, "m", QI).call(this, XI(this, II, "f").get("Units"), [{
                                    title: XI(this, II, "f").get("Metric"),
                                    value: "false"
                                }, {
                                    title: XI(this, II, "f").get("Imperial"),
                                    value: "true"
                                }], Jo.ImperialUnitsEnabled),
                                XI(this, CI, "m", QI).call(this, XI(this, II, "f").get("Reset hint"), [{
                                    title: XI(this, II, "f").get("Disabled"),
                                    value: "false"
                                }, {
                                    title: XI(this, II, "f").get("Enabled"),
                                    value: "true"
                                }], Jo.ResetHintEnabled),
                                XI(this, CI, "m", QI).call(this, XI(this, II, "f").get("Ghost car"), [{
                                    title: XI(this, II, "f").get("Disabled"),
                                    value: "false"
                                }, {
                                    title: XI(this, II, "f").get("Enabled"),
                                    value: "true"
                                }], Jo.GhostCarEnabled),
                                XI(this, CI, "m", QI).call(this, XI(this, II, "f").get("Default camera"), [{
                                    title: XI(this, II, "f").get("Default"),
                                    value: "false"
                                }, {
                                    title: XI(this, II, "f").get("Cockpit"),
                                    value: "true"
                                }], Jo.DefaultCameraMode),
                                XI(this, CI, "m", QI).call(this, XI(this, II, "f").get("Cockpit camera mode"), [{
                                    title: XI(this, II, "f").get("Hold"),
                                    value: "false"
                                }, {
                                    title: XI(this, II, "f").get("Toggle"),
                                    value: "true"
                                }], Jo.CockpitCameraToggle),
                                XI(this, CI, "m", QI).call(this, XI(this, II, "f").get("Checkpoints"), [{
                                    title: XI(this, II, "f").get("Off"),
                                    value: "off"
                                }, {
                                    title: XI(this, II, "f").get("Bottom"),
                                    value: "bottom"
                                }, {
                                    title: XI(this, II, "f").get("Top"),
                                    value: "top"
                                }], Jo.Checkpoints),
                                XI(this, CI, "m", QI).call(this, XI(this, II, "f").get("Timer"), [{
                                    title: XI(this, II, "f").get("Off"),
                                    value: "off"
                                }, {
                                    title: XI(this, II, "f").get("Bottom"),
                                    value: "bottom"
                                }, {
                                    title: XI(this, II, "f").get("Top"),
                                    value: "top"
                                }], Jo.Timer),
                                XI(this, CI, "m", QI).call(this, XI(this, II, "f").get("Speedometer"), [{
                                    title: XI(this, II, "f").get("Off"),
                                    value: "off"
                                }, {
                                    title: XI(this, II, "f").get("Bottom"),
                                    value: "bottom"
                                }, {
                                    title: XI(this, II, "f").get("Top"),
                                    value: "top"
                                }], Jo.Speedometer),
                                XI(this, CI, "m", GI).call(this, XI(this, II, "f").get("Language")),
                                XI(this, CI, "m", QI).call(this, null, [{
                                    title: "",
                                    value: "ar"
                                }, {
                                    title: "Deutsch",
                                    value: "de-DE"
                                }, {
                                    title: "English",
                                    value: "en-US"
                                }, {
                                    title: "Espaol",
                                    value: "es-ES"
                                }, {
                                    title: "Franais",
                                    value: "fr-FR"
                                }, {
                                    title: "Italiano",
                                    value: "it-IT"
                                }, {
                                    title: "",
                                    value: "ja-JP"
                                }, {
                                    title: "",
                                    value: "ko-KR"
                                }, {
                                    title: "Polski",
                                    value: "pl-PL"
                                }, {
                                    title: "Portugus (BR)",
                                    value: "pt-BR"
                                }, {
                                    title: "Portugus (PT)",
                                    value: "pt-PT"
                                }, {
                                    title: "",
                                    value: "ru-RU"
                                }, {
                                    title: "Trke",
                                    value: "tr-TR"
                                }, {
                                    title: "",
                                    value: "uk-UA"
                                }, {
                                    title: "",
                                    value: "zh-CN"
                                }, {
                                    title: "",
                                    value: "zh-TW"
                                }], Jo.Language),
                                XI(this, CI, "m", GI).call(this, XI(this, II, "f").get("Graphics")),
                                XI(this, CI, "m", QI).call(this, XI(this, II, "f").get("Car shadow"), [{
                                    title: XI(this, II, "f").get("Off"),
                                    value: "0"
                                }, {
                                    title: XI(this, II, "f").get("Low"),
                                    value: "1024"
                                }, {
                                    title: XI(this, II, "f").get("Medium"),
                                    value: "2048"
                                }, {
                                    title: XI(this, II, "f").get("High"),
                                    value: "4096"
                                }], Jo.CarShadowQuality),
                                XI(this, CI, "m", QI).call(this, XI(this, II, "f").get("Track shadow"), [{
                                    title: XI(this, II, "f").get("Off"),
                                    value: "false"
                                }, {
                                    title: XI(this, II, "f").get("On"),
                                    value: "true"
                                }], Jo.TrackShadowEnabled, ( () => {
                                        XI(this, LI, "f").generateMeshes()
                                    }
                                )),
                                XI(this, CI, "m", QI).call(this, XI(this, II, "f").get("Clouds"), [{
                                    title: XI(this, II, "f").get("Off"),
                                    value: "false"
                                }, {
                                    title: XI(this, II, "f").get("On"),
                                    value: "true"
                                }], Jo.CloudsEnabled),
                                XI(this, CI, "m", QI).call(this, XI(this, II, "f").get("Particles"), [{
                                    title: XI(this, II, "f").get("Off"),
                                    value: "false"
                                }, {
                                    title: XI(this, II, "f").get("On"),
                                    value: "true"
                                }], Jo.ParticlesEnabled),
                                XI(this, CI, "m", QI).call(this, XI(this, II, "f").get("Skidmarks"), [{
                                    title: XI(this, II, "f").get("Off"),
                                    value: "false"
                                }, {
                                    title: XI(this, II, "f").get("On"),
                                    value: "true"
                                }], Jo.SkidmarksEnabled),
                                XI(this, CI, "m", QI).call(this, XI(this, II, "f").get("Render scale"), [{
                                    title: "25%",
                                    value: "0.25"
                                }, {
                                    title: "50%",
                                    value: "0.5"
                                }, {
                                    title: "100%",
                                    value: "1"
                                }, {
                                    title: "150%",
                                    value: "1.5"
                                }, {
                                    title: "200%",
                                    value: "2"
                                }], Jo.RenderScale),
                                XI(this, CI, "m", QI).call(this, XI(this, II, "f").get("Anti-aliasing (requires restart)"), [{
                                    title: XI(this, II, "f").get("Off"),
                                    value: "false"
                                }, {
                                    title: XI(this, II, "f").get("On"),
                                    value: "true"
                                }], Jo.Antialiasing),
                                XI(this, CI, "m", GI).call(this, XI(this, II, "f").get("Audio")),
                                XI(this, CI, "m", YI).call(this, XI(this, II, "f").get("Sound effect volume"), Jo.SoundEffectVolume),
                                XI(this, CI, "m", YI).call(this, XI(this, II, "f").get("Music volume"), Jo.MusicVolume),
                                XI(this, CI, "m", YI).call(this, XI(this, II, "f").get("Checkpoint volume"), Jo.CheckpointVolume),
                                XI(this, CI, "m", GI).call(this, XI(this, II, "f").get("Controls")),
                                XI(this, CI, "m", jI).call(this, XI(this, II, "f").get("Vehicle")),
                                XI(this, CI, "m", qI).call(this, XI(this, II, "f").get("Accelerate"), sx.VehicleAccelerate),
                                XI(this, CI, "m", qI).call(this, XI(this, II, "f").get("Brake"), sx.VehicleBrake),
                                XI(this, CI, "m", qI).call(this, XI(this, II, "f").get("Turn left"), sx.VehicleTurnLeft),
                                XI(this, CI, "m", qI).call(this, XI(this, II, "f").get("Turn right"), sx.VehicleTurnRight),
                                XI(this, CI, "m", qI).call(this, XI(this, II, "f").get("Checkpoint reset"), sx.VehicleCheckpointReset),
                                XI(this, CI, "m", qI).call(this, XI(this, II, "f").get("Start reset"), sx.VehicleStartReset),
                                XI(this, CI, "m", qI).call(this, XI(this, II, "f").get("Cockpit camera"), sx.VehicleCockpitCamera),
                                XI(this, CI, "m", jI).call(this, XI(this, II, "f").get("Editor")),
                                XI(this, CI, "m", qI).call(this, XI(this, II, "f").get("Rotate part"), sx.EditorRotatePart),
                                XI(this, CI, "m", qI).call(this, XI(this, II, "f").get("Height modifier"), sx.EditorHeightModifier),
                                XI(this, CI, "m", qI).call(this, XI(this, II, "f").get("Delete part"), sx.EditorDelete),
                                XI(this, CI, "m", qI).call(this, XI(this, II, "f").get("Move forwards"), sx.EditorMoveForwards),
                                XI(this, CI, "m", qI).call(this, XI(this, II, "f").get("Move backwards"), sx.EditorMoveBackwards),
                                XI(this, CI, "m", qI).call(this, XI(this, II, "f").get("Move left"), sx.EditorMoveLeft),
                                XI(this, CI, "m", qI).call(this, XI(this, II, "f").get("Move right"), sx.EditorMoveRight),
                                XI(this, CI, "m", qI).call(this, XI(this, II, "f").get("Rotate view left"), sx.EditorRotateViewLeft),
                                XI(this, CI, "m", qI).call(this, XI(this, II, "f").get("Rotate view right"), sx.EditorRotateViewRight),
                                XI(this, CI, "m", qI).call(this, XI(this, II, "f").get("Move down"), sx.EditorMoveDown),
                                XI(this, CI, "m", qI).call(this, XI(this, II, "f").get("Move up"), sx.EditorMoveUp),
                                XI(this, CI, "m", qI).call(this, XI(this, II, "f").get("Test track"), sx.EditorTest),
                                XI(this, CI, "m", qI).call(this, XI(this, II, "f").get("Pick part"), sx.EditorPick),
                                XI(this, CI, "m", jI).call(this, XI(this, II, "f").get("Spectator")),
                                XI(this, CI, "m", qI).call(this, XI(this, II, "f").get("Move forwards"), sx.SpectatorMoveForwards),
                                XI(this, CI, "m", qI).call(this, XI(this, II, "f").get("Move backwards"), sx.SpectatorMoveBackwards),
                                XI(this, CI, "m", qI).call(this, XI(this, II, "f").get("Move left"), sx.SpectatorMoveLeft),
                                XI(this, CI, "m", qI).call(this, XI(this, II, "f").get("Move right"), sx.SpectatorMoveRight),
                                XI(this, CI, "m", qI).call(this, XI(this, II, "f").get("Speed modifier"), sx.SpectatorSpeedModifier),
                                XI(this, CI, "m", jI).call(this, XI(this, II, "f").get("Other")),
                                XI(this, CI, "m", qI).call(this, XI(this, II, "f").get("Hide UI"), sx.ToggleUI),
                                XI(this, CI, "m", qI).call(this, XI(this, II, "f").get("Pause"), sx.Pause),
                                XI(this, CI, "m", qI).call(this, XI(this, II, "f").get("Toggle FPS counter"), sx.ToggleFpsCounter),
                                XI(this, CI, "m", qI).call(this, XI(this, II, "f").get("Toggle spectator camera"), sx.ToggleSpectatorCamera)
                        }
                        ,
                        GI = function(e) {
                            const t = document.createElement("h2");
                            t.textContent = e,
                                XI(this, BI, "f").appendChild(t)
                        }
                        ,
                        jI = function(e) {
                            const t = document.createElement("h3");
                            t.textContent = e,
                                XI(this, BI, "f").appendChild(t)
                        }
                        ,
                        QI = function(e, t, n, i) {
                            var r;
                            const a = null !== (r = XI(this, OI, "f").get(n)) && void 0 !== r ? r : XI(this, RI, "f").getSetting(n)
                                , s = document.createElement("div");
                            if (s.className = "setting",
                            null != e) {
                                const t = document.createElement("p");
                                t.textContent = e,
                                    s.appendChild(t)
                            } else
                                s.classList.add("wrappable");
                            const o = document.createElement("div");
                            o.className = "button-wrapper",
                                s.appendChild(o);
                            const l = [];
                            for (const {title: e, value: r} of t) {
                                const t = document.createElement("button");
                                t.className = r == a ? "button selected" : "button",
                                    t.textContent = e,
                                    t.addEventListener("click", ( () => {
                                            XI(this, PI, "f").playUIClick();
                                            for (const e of l)
                                                e.className = "button";
                                            t.className = "button selected",
                                                XI(this, OI, "f").set(n, r),
                                                XI(this, RI, "f").updateSettings(Array.from(XI(this, OI, "f"))),
                                            null != i && i()
                                        }
                                    )),
                                    o.appendChild(t),
                                    l.push(t)
                            }
                            XI(this, BI, "f").appendChild(s)
                        }
                        ,
                        YI = function(e, t, n=0, i=1) {
                            var r;
                            let a = parseFloat(null !== (r = XI(this, OI, "f").get(t)) && void 0 !== r ? r : XI(this, RI, "f").getSetting(t));
                            Number.isNaN(a) && (a = 0);
                            const s = document.createElement("div");
                            s.className = "setting";
                            const o = document.createElement("p");
                            o.textContent = e,
                                s.appendChild(o);
                            const l = document.createElement("input");
                            l.type = "range",
                                l.min = (20 * n).toString(),
                                l.max = (20 * i).toString(),
                                l.value = (20 * a).toString(),
                                l.addEventListener("input", ( () => {
                                        const e = parseFloat(l.value) / 20;
                                        XI(this, OI, "f").set(t, e.toString()),
                                            XI(this, RI, "f").updateSettings(Array.from(XI(this, OI, "f")))
                                    }
                                )),
                                s.appendChild(l),
                                XI(this, BI, "f").appendChild(s)
                        }
                        ,
                        qI = function(e, t) {
                            var n, i, r;
                            const a = document.createElement("div");
                            a.className = "setting";
                            const s = document.createElement("p");
                            s.textContent = e,
                                a.appendChild(s);
                            const o = document.createElement("div");
                            o.className = "button-wrapper",
                                a.appendChild(o);
                            const l = null !== (n = XI(this, FI, "f").get(t)) && void 0 !== n ? n : XI(this, RI, "f").getKeyBindings(t)
                                , c = document.createElement("button");
                            c.className = "button key-binding",
                                c.textContent = null !== (i = l[0]) && void 0 !== i ? i : "",
                                c.addEventListener("click", ( () => {
                                        XI(this, PI, "f").playUIClick(),
                                            XI(this, CI, "m", WI).call(this);
                                        const e = t => {
                                                "Escape" == t.code || "Tab" == t.code || "Enter" == t.code && null != document.activeElement && document.activeElement != document.body || (XI(this, NI, "f").hide(),
                                                    l[0] = t.code,
                                                    c.textContent = t.code,
                                                    XI(this, CI, "m", HI).call(this),
                                                    window.removeEventListener("keydown", e),
                                                    t.preventDefault())
                                            }
                                        ;
                                        window.addEventListener("keydown", e),
                                            XI(this, NI, "f").showConfirm(XI(this, II, "f").get("Press any key...\n\nPress [Escape] to cancel."), XI(this, II, "f").get("Cancel"), XI(this, II, "f").get("Clear"), ( () => {
                                                    XI(this, CI, "m", HI).call(this),
                                                        window.removeEventListener("keydown", e)
                                                }
                                            ), ( () => {
                                                    c.textContent = "",
                                                        l[0] = null,
                                                        window.removeEventListener("keydown", e),
                                                        XI(this, CI, "m", HI).call(this)
                                                }
                                            ))
                                    }
                                )),
                                o.appendChild(c);
                            const h = document.createElement("button");
                            h.className = "button key-binding",
                                h.textContent = null !== (r = l[1]) && void 0 !== r ? r : "",
                                h.addEventListener("click", ( () => {
                                        XI(this, PI, "f").playUIClick(),
                                            XI(this, CI, "m", WI).call(this);
                                        const e = t => {
                                                "Escape" == t.code || "Tab" == t.code || "Enter" == t.code && null != document.activeElement && document.activeElement != document.body || (XI(this, NI, "f").hide(),
                                                    l[1] = t.code,
                                                    h.textContent = t.code,
                                                    XI(this, CI, "m", HI).call(this),
                                                    window.removeEventListener("keydown", e),
                                                    t.preventDefault())
                                            }
                                        ;
                                        window.addEventListener("keydown", e),
                                            XI(this, NI, "f").showConfirm(XI(this, II, "f").get("Press any key...\n\nPress [Escape] to cancel."), XI(this, II, "f").get("Cancel"), XI(this, II, "f").get("Clear"), ( () => {
                                                    XI(this, CI, "m", HI).call(this),
                                                        window.removeEventListener("keydown", e)
                                                }
                                            ), ( () => {
                                                    h.textContent = "",
                                                        l[1] = null,
                                                        window.removeEventListener("keydown", e),
                                                        XI(this, CI, "m", HI).call(this)
                                                }
                                            ))
                                    }
                                )),
                                o.appendChild(h),
                                XI(this, BI, "f").appendChild(a)
                        }
                    ;
                    const ZI = class {
                            constructor(e, t, n, i, r, a, s) {
                                CI.add(this),
                                    _I.set(this, void 0),
                                    II.set(this, void 0),
                                    PI.set(this, void 0),
                                    RI.set(this, void 0),
                                    LI.set(this, void 0),
                                    NI.set(this, void 0),
                                    DI.set(this, void 0),
                                    BI.set(this, void 0),
                                    UI.set(this, void 0),
                                    zI.set(this, new Map),
                                    OI.set(this, new Map),
                                    FI.set(this, new Map),
                                    KI(this, _I, e, "f"),
                                    KI(this, II, t, "f"),
                                    KI(this, PI, n, "f"),
                                    KI(this, RI, i, "f"),
                                    KI(this, LI, r, "f"),
                                    KI(this, NI, a, "f"),
                                    KI(this, DI, document.createElement("div"), "f"),
                                    XI(this, DI, "f").className = "settings-menu",
                                    e.appendChild(XI(this, DI, "f"));
                                const o = document.createElement("h2");
                                o.textContent = t.get("Settings"),
                                    XI(this, DI, "f").appendChild(o),
                                    KI(this, BI, document.createElement("div"), "f"),
                                    XI(this, BI, "f").className = "container",
                                    XI(this, DI, "f").appendChild(XI(this, BI, "f")),
                                    KI(this, zI, new Map(i.getSettings()), "f"),
                                    XI(this, CI, "m", VI).call(this);
                                const l = document.createElement("div");
                                l.className = "button-wrapper",
                                    XI(this, DI, "f").appendChild(l);
                                const c = document.createElement("button");
                                c.className = "button cancel",
                                    c.innerHTML = '<img class="button-icon" src="images/cancel.svg"> ',
                                    c.append(document.createTextNode(t.get("Cancel"))),
                                    c.addEventListener("click", ( () => {
                                            n.playUIClick(),
                                                i.updateSettings(Array.from(XI(this, zI, "f"))),
                                                r.generateMeshes(),
                                                s()
                                        }
                                    )),
                                    l.appendChild(c);
                                const h = document.createElement("button");
                                h.className = "button reset",
                                    h.innerHTML = '<img class="button-icon" src="images/reset_settings.svg"> ',
                                    h.append(document.createTextNode(t.get("Reset"))),
                                    h.addEventListener("click", ( () => {
                                            n.playUIClick(),
                                                KI(this, OI, XI(this, RI, "f").defaultSettings(), "f"),
                                                i.updateSettings(Array.from(XI(this, OI, "f"))),
                                                KI(this, FI, XI(this, RI, "f").defaultKeyBindings(), "f"),
                                                r.generateMeshes(),
                                                XI(this, CI, "m", VI).call(this)
                                        }
                                    )),
                                    l.appendChild(h);
                                const d = document.createElement("button");
                                d.className = "button apply",
                                    d.append(document.createTextNode(t.get("Apply"))),
                                    d.innerHTML += ' <img class="button-icon" src="images/apply.svg">',
                                    d.addEventListener("click", ( () => {
                                            n.playUIClick(),
                                                i.updateSettings(Array.from(XI(this, OI, "f"))),
                                                i.saveSettings(),
                                                i.setKeyBindings(Array.from(XI(this, FI, "f"))),
                                                r.generateMeshes(),
                                                t.language = i.getSetting(Jo.Language),
                                                s()
                                        }
                                    )),
                                    l.appendChild(d),
                                    window.addEventListener("keydown", KI(this, UI, (e => {
                                            "Escape" == e.code && (s(),
                                                e.preventDefault())
                                        }
                                    ), "f"))
                            }
                            dispose() {
                                XI(this, _I, "f").removeChild(XI(this, DI, "f")),
                                    window.removeEventListener("keydown", XI(this, UI, "f"))
                            }
                        }
                    ;
                    var JI = n(5586)
                        , $I = {};
                    $I.styleTagTransform = u(),
                        $I.setAttributes = l(),
                        $I.insert = s().bind(null, "head"),
                        $I.domAPI = r(),
                        $I.insertStyleElement = h();
                    t()(JI.A, $I);
                    JI.A && JI.A.locals && JI.A.locals;
                    var eP = n(6657)
                        , tP = {};
                    tP.styleTagTransform = u(),
                        tP.setAttributes = l(),
                        tP.insert = s().bind(null, "head"),
                        tP.domAPI = r(),
                        tP.insertStyleElement = h();
                    t()(eP.A, tP);
                    eP.A && eP.A.locals && eP.A.locals;
                    var nP = n(5086)
                        , iP = {};
                    iP.styleTagTransform = u(),
                        iP.setAttributes = l(),
                        iP.insert = s().bind(null, "head"),
                        iP.domAPI = r(),
                        iP.insertStyleElement = h();
                    t()(nP.A, iP);
                    nP.A && nP.A.locals && nP.A.locals;
                    var rP = function(e, t, n, i) {
                        return new (n || (n = Promise))((function(r, a) {
                                function s(e) {
                                    try {
                                        l(i.next(e))
                                    } catch (e) {
                                        a(e)
                                    }
                                }
                                function o(e) {
                                    try {
                                        l(i.throw(e))
                                    } catch (e) {
                                        a(e)
                                    }
                                }
                                function l(e) {
                                    var t;
                                    e.done ? r(e.value) : (t = e.value,
                                        t instanceof n ? t : new n((function(e) {
                                                e(t)
                                            }
                                        ))).then(s, o)
                                }
                                l((i = i.apply(e, t || [])).next())
                            }
                        ))
                    };
                    let aP = null
                        , sP = null
                        , oP = null
                        , lP = null
                        , cP = null;
                    function hP(e, t) {
                        return rP(this, void 0, void 0, (function*() {
                                for (; null != cP; )
                                    yield cP;
                                const n = function(e, t) {
                                    return new Promise((n => {
                                            const i = setTimeout(( () => {
                                                    null != aP && null != sP && null != oP && null != lP || (sP = document.createElement("canvas"),
                                                        sP.width = 200,
                                                        sP.height = 200,
                                                        oP = new yu(sP,null,!1,!0),
                                                        lP = new Po(-1,1,1,-1,.1,1e4),
                                                        lP.position.set(1e3, 1e3, 1e3),
                                                        lP.lookAt(0, 0, 0),
                                                        lP.zoom = .5,
                                                        lP.position.add(new An(.1,.3,0)),
                                                        lP.updateProjectionMatrix(),
                                                        oP.scene.add(lP),
                                                        oP.setCamera(lP),
                                                        aP = new yw(null,{
                                                            position: new An,
                                                            quaternion: new wn
                                                        },null,null,oP,null,null,null,null),
                                                        aP.update(0)),
                                                        aP.setColors(e),
                                                        oP.update(new An, new Ay),
                                                        n(sP.toDataURL())
                                                }
                                            ), 25);
                                            t.addCancelCallback(( () => {
                                                    clearTimeout(i),
                                                        n("")
                                                }
                                            ))
                                        }
                                    ))
                                }(e, t);
                                let i;
                                cP = n;
                                try {
                                    i = yield n
                                } finally {
                                    cP = null
                                }
                                return i
                            }
                        ))
                    }
                    var dP, uP, pP = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    }, fP = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    };
                    dP = new WeakMap,
                        uP = new WeakMap;
                    const mP = class {
                            constructor() {
                                dP.set(this, !1),
                                    uP.set(this, [])
                            }
                            cancel() {
                                if (!pP(this, dP, "f")) {
                                    fP(this, dP, !0, "f");
                                    for (const e of pP(this, uP, "f"))
                                        e()
                                }
                            }
                            get isCancelled() {
                                return pP(this, dP, "f")
                            }
                            addCancelCallback(e) {
                                pP(this, uP, "f").push(e),
                                pP(this, dP, "f") && e()
                            }
                        }
                    ;
                    var gP, vP;
                    !function(e) {
                        e[e.Uninitialized = 0] = "Uninitialized",
                            e[e.Ok = 1] = "Ok",
                            e[e.TestFailed = 2] = "TestFailed",
                            e[e.AssetsFailed = 3] = "AssetsFailed"
                    }(gP || (gP = {})),
                        function(e) {
                            e[e.Pending = 0] = "Pending",
                                e[e.Verified = 1] = "Verified",
                                e[e.Invalid = 2] = "Invalid",
                                e[e.InvalidDuplicate = 3] = "InvalidDuplicate",
                                e[e.InvalidManual = 4] = "InvalidManual"
                        }(vP || (vP = {}));
                    var wP, AP, yP, bP, xP, kP, EP, SP, MP, TP, CP, _P, IP, PP, RP, LP, NP, DP, BP, UP, zP, OP, FP, WP, HP, VP, GP, jP, QP = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, YP = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    class qP {
                        constructor(e, t, n, i, r, a, s, o, l, c, h) {
                            wP.add(this),
                                yP.set(this, void 0),
                                bP.set(this, void 0),
                                xP.set(this, void 0),
                                kP.set(this, void 0),
                                EP.set(this, void 0),
                                SP.set(this, void 0),
                                MP.set(this, void 0),
                                TP.set(this, void 0),
                                CP.set(this, void 0),
                                _P.set(this, void 0),
                                IP.set(this, void 0),
                                PP.set(this, void 0),
                                RP.set(this, void 0),
                                LP.set(this, void 0),
                                NP.set(this, void 0),
                                DP.set(this, null),
                                BP.set(this, !1),
                                UP.set(this, void 0),
                                zP.set(this, 0),
                                OP.set(this, 0),
                                FP.set(this, null),
                                WP.set(this, null),
                                HP.set(this, []),
                                QP(this, yP, t, "f"),
                                QP(this, bP, n, "f"),
                                QP(this, xP, i, "f"),
                                QP(this, kP, r, "f"),
                                QP(this, EP, a, "f"),
                                QP(this, SP, s, "f"),
                                QP(this, MP, c, "f"),
                                QP(this, TP, h, "f"),
                                QP(this, UP, o.isOfficialTrack(t) || o.isCommunityTrack(t), "f"),
                                QP(this, CP, e, "f"),
                                QP(this, _P, document.createElement("div"), "f"),
                                YP(this, _P, "f").className = "leaderboard",
                                e.appendChild(YP(this, _P, "f"));
                            const d = document.createElement("h2");
                            d.textContent = n.get("Leaderboard"),
                                YP(this, _P, "f").appendChild(d);
                            const u = document.createElement("h3")
                                , p = nu.replace(/(\d+\.\d+)\.\d+/, "$1");
                            u.textContent = n.get("Version") + " " + p,
                                YP(this, _P, "f").appendChild(u),
                                QP(this, IP, document.createElement("div"), "f"),
                                YP(this, IP, "f").className = "container",
                                YP(this, _P, "f").appendChild(YP(this, IP, "f")),
                                QP(this, PP, document.createElement("div"), "f"),
                                YP(this, PP, "f").className = "loading-spinner-container",
                                YP(this, IP, "f").appendChild(YP(this, PP, "f"));
                            const f = document.createElement("div");
                            f.className = "loading-spinner",
                                YP(this, PP, "f").appendChild(f),
                                YP(this, wP, "m", VP).call(this, !1),
                                QP(this, NP, document.createElement("div"), "f"),
                                YP(this, NP, "f").className = "pages",
                                YP(this, _P, "f").appendChild(YP(this, NP, "f")),
                                YP(this, wP, "m", jP).call(this);
                            const m = document.createElement("div");
                            m.className = "button-wrapper",
                                YP(this, _P, "f").appendChild(m);
                            const g = document.createElement("button");
                            g.className = "button back",
                                g.innerHTML = '<img class="button-icon" src="images/back.svg"> ',
                                g.append(document.createTextNode(n.get("Back"))),
                                g.addEventListener("click", ( () => {
                                        r.playUIClick(),
                                            l()
                                    }
                                )),
                                m.appendChild(g),
                                QP(this, RP, document.createElement("button"), "f"),
                                YP(this, RP, "f").className = "button icon-button first",
                                YP(this, RP, "f").innerHTML = '<img class="button-icon" src="images/pin.svg">',
                                YP(this, RP, "f").disabled = !0,
                                YP(this, RP, "f").addEventListener("click", ( () => {
                                        r.playUIClick(),
                                            null != YP(this, WP, "f") ? YP(this, WP, "f").scrollIntoView({
                                                behavior: "smooth"
                                            }) : null != YP(this, FP, "f") && (QP(this, zP, YP(this, FP, "f"), "f"),
                                                YP(this, wP, "m", jP).call(this),
                                                YP(this, wP, "m", VP).call(this, !0))
                                    }
                                )),
                                m.appendChild(YP(this, RP, "f")),
                                QP(this, LP, document.createElement("button"), "f"),
                                YP(this, LP, "f").className = "button only-verified",
                            YP(this, UP, "f") || YP(this, LP, "f").classList.add("disabled"),
                                YP(this, LP, "f").textContent = YP(this, bP, "f").get("Only verified"),
                                YP(this, LP, "f").innerHTML += '<img class="button-icon" src="images/verified.svg">',
                                YP(this, LP, "f").addEventListener("click", ( () => {
                                        r.playUIClick(),
                                            QP(this, UP, !YP(this, UP, "f"), "f"),
                                            YP(this, UP, "f") ? YP(this, LP, "f").classList.remove("disabled") : YP(this, LP, "f").classList.add("disabled"),
                                            QP(this, zP, 0, "f"),
                                            QP(this, OP, 0, "f"),
                                            YP(this, wP, "m", jP).call(this),
                                            YP(this, wP, "m", VP).call(this, !1)
                                    }
                                )),
                                m.appendChild(YP(this, LP, "f"))
                        }
                        dispose() {
                            var e;
                            null === (e = YP(this, DP, "f")) || void 0 === e || e.cancel(),
                                YP(this, CP, "f").removeChild(YP(this, _P, "f"))
                        }
                        static getPositionSuffix(e) {
                            if (e <= 0 || !Number.isInteger(e))
                                throw new Error("Position must be a positive integer.");
                            const t = e % 100;
                            if (t >= 11 && t <= 13)
                                return "th";
                            switch (e % 10) {
                                case 1:
                                    return "st";
                                case 2:
                                    return "nd";
                                case 3:
                                    return "rd";
                                default:
                                    return "th"
                            }
                        }
                    }
                    AP = qP,
                        yP = new WeakMap,
                        bP = new WeakMap,
                        xP = new WeakMap,
                        kP = new WeakMap,
                        EP = new WeakMap,
                        SP = new WeakMap,
                        MP = new WeakMap,
                        TP = new WeakMap,
                        CP = new WeakMap,
                        _P = new WeakMap,
                        IP = new WeakMap,
                        PP = new WeakMap,
                        RP = new WeakMap,
                        LP = new WeakMap,
                        NP = new WeakMap,
                        DP = new WeakMap,
                        BP = new WeakMap,
                        UP = new WeakMap,
                        zP = new WeakMap,
                        OP = new WeakMap,
                        FP = new WeakMap,
                        WP = new WeakMap,
                        HP = new WeakMap,
                        wP = new WeakSet,
                        VP = function e(t) {
                            var n;
                            null === (n = YP(this, DP, "f")) || void 0 === n || n.cancel();
                            const i = new mP;
                            QP(this, DP, i, "f"),
                                YP(this, IP, "f").innerHTML = "",
                                YP(this, IP, "f").appendChild(YP(this, PP, "f")),
                                QP(this, WP, null, "f"),
                                setTimeout(( () => {
                                        if (!i.isCancelled) {
                                            const n = 20
                                                , r = YP(this, zP, "f") * n;
                                            YP(this, xP, "f").getLeaderboard(YP(this, EP, "f").getCurrentUserProfile().tokenHash, YP(this, yP, "f"), r, n, YP(this, UP, "f")).then(( ({total: a, entries: s, userEntry: o}) => {
                                                    if (!i.isCancelled) {
                                                        QP(this, OP, Math.ceil(a / n), "f"),
                                                            YP(this, wP, "m", jP).call(this);
                                                        for (let e = 0; e < s.length; e++) {
                                                            const {id: t, name: n, time: a, carColors: o, verifiedState: l, isSelf: c} = s[e]
                                                                , h = r + e + 1;
                                                            YP(this, wP, "m", GP).call(this, h, n, a, o, l, c, t, i)
                                                        }
                                                        if (YP(this, xP, "f").determinismState == gP.Ok && (null != o ? (QP(this, FP, Math.floor((o.position - 1) / n), "f"),
                                                            YP(this, RP, "f").disabled = !1,
                                                        t && null != YP(this, WP, "f") && YP(this, WP, "f").scrollIntoView(),
                                                            YP(this, TP, "f").call(this, o)) : (QP(this, FP, null, "f"),
                                                            YP(this, RP, "f").disabled = !0,
                                                            YP(this, TP, "f").call(this, null)),
                                                            !YP(this, BP, "f"))) {
                                                            QP(this, BP, !0, "f");
                                                            let n = null;
                                                            null != o && (n = {
                                                                time: o.time,
                                                                recordingId: o.id
                                                            }),
                                                                YP(this, SP, "f").syncRecord(YP(this, EP, "f").profileSlot, YP(this, yP, "f"), n).then((n => {
                                                                        "Upload" == n && YP(this, wP, "m", e).call(this, t)
                                                                    }
                                                                )).catch((e => {
                                                                        console.warn(e)
                                                                    }
                                                                ))
                                                        }
                                                    }
                                                }
                                            )).catch((e => {
                                                    if (!i.isCancelled) {
                                                        const e = document.createElement("p");
                                                        e.className = "error-message",
                                                            e.textContent = YP(this, bP, "f").get("Error: Failed to load leaderboard"),
                                                            YP(this, IP, "f").appendChild(e)
                                                    }
                                                    console.error(e)
                                                }
                                            )).finally(( () => {
                                                    i.isCancelled || YP(this, IP, "f").removeChild(YP(this, PP, "f"))
                                                }
                                            ))
                                        }
                                    }
                                ), 500)
                        }
                        ,
                        GP = function(e, t, n, i, r, a, s, o) {
                            const l = document.createElement("button");
                            l.className = "button main",
                            a && QP(this, WP, l, "f"),
                                l.addEventListener("click", ( () => {
                                        YP(this, kP, "f").playUIClick(),
                                            YP(this, HP, "f").some((e => e.recordingId == s)) ? (QP(this, HP, YP(this, HP, "f").filter((e => e.recordingId != s)), "f"),
                                                l.classList.remove("selected"),
                                                YP(this, MP, "f").call(this, YP(this, HP, "f"))) : YP(this, HP, "f").length < 10 && (QP(this, HP, YP(this, HP, "f").concat([{
                                                name: t,
                                                recordingId: s,
                                                isSelf: a
                                            }]), "f"),
                                                l.classList.add("selected"),
                                                YP(this, MP, "f").call(this, YP(this, HP, "f")))
                                    }
                                )),
                                YP(this, IP, "f").appendChild(l),
                            YP(this, HP, "f").some((e => e.recordingId == s)) && l.classList.add("selected");
                            const c = document.createElement("div");
                            c.className = "image-container",
                                l.appendChild(c);
                            const h = document.createElement("img");
                            h.className = "show",
                                h.src = "images/car_thumbnail_placeholder.png",
                                c.appendChild(h);
                            const d = document.createElement("img");
                            hP(i, o).then((e => {
                                    d.src = e,
                                        h.classList.remove("show"),
                                        d.classList.add("show")
                                }
                            )).catch((e => {
                                    console.error(e)
                                }
                            )),
                                c.appendChild(d);
                            const u = document.createElement("img");
                            u.className = "checkmark",
                                u.src = "images/checkmark.svg",
                                l.appendChild(u);
                            const p = document.createElement("div");
                            p.className = "left",
                                l.appendChild(p);
                            const f = document.createElement("p");
                            f.className = "position",
                                f.textContent = e.toString(),
                                p.appendChild(f);
                            const m = document.createElement("span");
                            m.textContent = AP.getPositionSuffix(e),
                                f.appendChild(m);
                            const g = document.createElement("p");
                            g.textContent = Vx.formatTimeString(n),
                                p.appendChild(g);
                            const v = document.createElement("div");
                            v.className = "right",
                                l.appendChild(v);
                            const w = document.createElement("p");
                            w.className = "name-container",
                                v.appendChild(w);
                            const A = document.createElement("span");
                            if (A.className = "name",
                                A.textContent = t,
                                w.appendChild(A),
                                a) {
                                const e = document.createElement("span");
                                e.className = "self",
                                    e.textContent = "(" + YP(this, bP, "f").get("You") + ")",
                                    w.appendChild(e)
                            }
                            const y = document.createElement("p");
                            r == vP.Pending ? (y.innerHTML = '<img src="images/state_pending.svg">',
                                y.prepend(document.createTextNode(YP(this, bP, "f").get("Pending"))),
                                y.className = "verified-state pending") : r == vP.Verified ? (y.innerHTML = '<img src="images/state_verified.svg">',
                                y.prepend(document.createTextNode(YP(this, bP, "f").get("Verified"))),
                                y.className = "verified-state verified") : r == vP.InvalidDuplicate ? (y.innerHTML = '<img src="images/state_invalid.svg">',
                                y.prepend(document.createTextNode(YP(this, bP, "f").get("Duplicate"))),
                                y.className = "verified-state invalid") : (y.innerHTML = '<img src="images/state_invalid.svg">',
                                y.prepend(document.createTextNode(YP(this, bP, "f").get("Invalid"))),
                                y.className = "verified-state invalid"),
                                v.appendChild(y)
                        }
                        ,
                        jP = function e() {
                            YP(this, NP, "f").innerHTML = "";
                            const t = document.createElement("button");
                            let n;
                            t.className = "button",
                                t.textContent = "<",
                                YP(this, zP, "f") > 0 ? t.addEventListener("click", ( () => {
                                        YP(this, kP, "f").playUIClick(),
                                            QP(this, zP, YP(this, zP, "f") - 1, "f"),
                                            YP(this, wP, "m", e).call(this),
                                            YP(this, wP, "m", VP).call(this, !1)
                                    }
                                )) : t.disabled = !0,
                                YP(this, NP, "f").appendChild(t),
                                n = YP(this, zP, "f") < 1e3 - Math.ceil(3.5) ? 7 : YP(this, zP, "f") < 1e5 - Math.ceil(2.5) ? 5 : 3;
                            const i = Math.max(0, YP(this, zP, "f") - Math.floor(n / 2));
                            for (let t = i; t < i + n; ++t) {
                                const n = document.createElement("button");
                                n.textContent = (t + 1).toString(),
                                    t >= YP(this, OP, "f") ? (n.className = "button page",
                                        n.disabled = !0) : t == YP(this, zP, "f") ? n.className = "button page selected" : (n.className = "button page",
                                        n.addEventListener("click", ( () => {
                                                YP(this, kP, "f").playUIClick(),
                                                    QP(this, zP, t, "f"),
                                                    YP(this, wP, "m", e).call(this),
                                                    YP(this, wP, "m", VP).call(this, !1)
                                            }
                                        ))),
                                    YP(this, NP, "f").appendChild(n)
                            }
                            const r = document.createElement("button");
                            r.className = "button",
                                r.textContent = ">",
                                YP(this, zP, "f") + 1 >= YP(this, OP, "f") ? r.disabled = !0 : r.addEventListener("click", ( () => {
                                        YP(this, kP, "f").playUIClick(),
                                            QP(this, zP, YP(this, zP, "f") + 1, "f"),
                                            YP(this, wP, "m", e).call(this),
                                            YP(this, wP, "m", VP).call(this, !1)
                                    }
                                )),
                                YP(this, NP, "f").appendChild(r)
                        }
                    ;
                    const KP = qP;
                    var XP, ZP, JP, $P, eR, tR, nR, iR, rR, aR, sR, oR, lR, cR, hR = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, dR = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    ZP = new WeakMap,
                        JP = new WeakMap,
                        $P = new WeakMap,
                        eR = new WeakMap,
                        tR = new WeakMap,
                        nR = new WeakMap,
                        iR = new WeakMap,
                        rR = new WeakMap,
                        aR = new WeakMap,
                        sR = new WeakMap,
                        oR = new WeakMap,
                        lR = new WeakMap,
                        XP = new WeakSet,
                        cR = function() {
                            dR(this, lR, "f").length > 0 ? (dR(this, rR, "f").classList.remove("no-opponents"),
                                1 == dR(this, lR, "f").length ? dR(this, rR, "f").textContent = dR(this, ZP, "f").get("{0} opponent selected", [dR(this, lR, "f").length.toString()]) : dR(this, rR, "f").textContent = dR(this, ZP, "f").get("{0} opponents selected", [dR(this, lR, "f").length.toString()])) : (dR(this, rR, "f").classList.add("no-opponents"),
                                dR(this, rR, "f").textContent = dR(this, ZP, "f").get("Select opponents to race against from the leaderboard on the left"),
                                dR(this, iR, "f").appendChild(dR(this, rR, "f")))
                        }
                    ;
                    const uR = class {
                            constructor(e, t, n, i, r, a, s, o, l, c, h, d, u, p, f) {
                                var m;
                                XP.add(this),
                                    ZP.set(this, void 0),
                                    JP.set(this, void 0),
                                    $P.set(this, void 0),
                                    eR.set(this, void 0),
                                    tR.set(this, void 0),
                                    nR.set(this, void 0),
                                    iR.set(this, void 0),
                                    rR.set(this, void 0),
                                    aR.set(this, void 0),
                                    sR.set(this, void 0),
                                    oR.set(this, null),
                                    lR.set(this, []),
                                    hR(this, ZP, t, "f"),
                                    hR(this, JP, n, "f"),
                                    hR(this, $P, e, "f"),
                                    hR(this, eR, f, "f"),
                                    hR(this, tR, p, "f"),
                                    hR(this, nR, document.createElement("div"), "f"),
                                    dR(this, nR, "f").className = "track-info",
                                    e.appendChild(dR(this, nR, "f"));
                                const g = r.getRecord(i.profileSlot, c);
                                hR(this, aR, new KP(dR(this, nR, "f"),c,t,n,a,i,r,d,u,(e => {
                                        hR(this, lR, e, "f"),
                                            dR(this, XP, "m", cR).call(this)
                                    }
                                ),(e => {
                                        null == e || null != g && !e.time.lessOrEqual(g.time) ? (T.textContent = t.get("No record"),
                                            T.classList.add("no-record")) : (T.textContent = Vx.formatTimeString(e.time) + " - " + e.position.toString() + KP.getPositionSuffix(e.position),
                                            T.classList.remove("no-record"))
                                    }
                                )), "f"),
                                    hR(this, iR, document.createElement("div"), "f"),
                                    dR(this, iR, "f").className = "side-panel",
                                    dR(this, nR, "f").appendChild(dR(this, iR, "f"));
                                const v = document.createElement("h2");
                                v.textContent = o.name,
                                    dR(this, iR, "f").appendChild(v);
                                const w = document.createElement("canvas");
                                w.width = h.width,
                                    w.height = h.height;
                                const A = w.getContext("2d");
                                null == A ? console.error("Failed to get 2D context for thumbnail canvas") : A.drawImage(h, 0, 0);
                                const y = document.createElement("div");
                                y.className = "thumbnail",
                                    y.appendChild(w),
                                    dR(this, iR, "f").appendChild(y);
                                const b = document.createElement("button");
                                let x;
                                switch (b.className = "button share",
                                    b.innerHTML = '<img src="images/share.svg">',
                                    b.addEventListener("click", ( () => {
                                            a.playUIClick(),
                                                dR(this, nR, "f").className = "hidden";
                                            const e = l.toExportString(o);
                                            hR(this, oR, new wx(e,( () => {
                                                    var e;
                                                    null === (e = dR(this, oR, "f")) || void 0 === e || e.dispose(),
                                                        hR(this, oR, null, "f"),
                                                        dR(this, nR, "f").className = "track-info"
                                                }
                                            ),null,!1,t,a,d,s), "f")
                                        }
                                    )),
                                    y.appendChild(b),
                                    l.environment) {
                                    case by.Summer:
                                        x = "images/summer.svg";
                                        break;
                                    case by.Winter:
                                        x = "images/winter.svg";
                                        break;
                                    case by.Desert:
                                        x = "images/desert.svg"
                                }
                                const k = document.createElement("img");
                                k.className = "environment",
                                    k.src = x,
                                    y.appendChild(k);
                                const E = document.createElement("div");
                                E.className = "track-author",
                                    E.textContent = t.get("Author") + ": " + (null !== (m = o.author) && void 0 !== m ? m : t.get("Unknown")),
                                    dR(this, iR, "f").appendChild(E);
                                const S = document.createElement("div");
                                S.className = "divider",
                                    dR(this, iR, "f").appendChild(S);
                                const M = document.createElement("div");
                                M.className = "personal-best-title",
                                    M.textContent = t.get("Personal best"),
                                    dR(this, iR, "f").appendChild(M);
                                const T = document.createElement("div");
                                T.className = "personal-best",
                                    null != g ? (T.textContent = Vx.formatTimeString(g.time),
                                        T.classList.remove("no-record")) : (T.textContent = t.get("No record"),
                                        T.classList.add("no-record")),
                                    dR(this, iR, "f").appendChild(T);
                                const C = document.createElement("div");
                                C.className = "divider",
                                    dR(this, iR, "f").appendChild(C);
                                const _ = document.createElement("div");
                                _.className = "opponents-title",
                                    _.textContent = t.get("Opponents"),
                                    dR(this, iR, "f").appendChild(_),
                                    hR(this, rR, document.createElement("div"), "f"),
                                    dR(this, rR, "f").className = "opponents-container",
                                    dR(this, iR, "f").appendChild(dR(this, rR, "f")),
                                    dR(this, XP, "m", cR).call(this);
                                const I = document.createElement("button");
                                I.className = "button play",
                                    I.innerHTML = '<img src="images/play.svg">',
                                    I.prepend(document.createTextNode(t.get("Play"))),
                                    I.addEventListener("click", ( () => {
                                            if (a.playUIClick(),
                                                l.hasStartingPoint()) {
                                                const e = dR(this, lR, "f");
                                                if (e.length > 0)
                                                    dR(this, tR, "f").call(this, dR(this, JP, "f").getRecordings(e.map((e => e.recordingId))).then((t => {
                                                            if (t.some((e => null == e)))
                                                                throw new Error("Failed to load at least one recording.");
                                                            return t.filter((e => null != e)).map(( (t, n) => ({
                                                                recording: t.recording,
                                                                carColors: t.carColors,
                                                                name: e[n].name,
                                                                time: t.time,
                                                                isSelf: e[n].isSelf
                                                            })))
                                                        }
                                                    )));
                                                else {
                                                    const e = r.getRecord(i.profileSlot, c);
                                                    if (null != e) {
                                                        const t = i.getCurrentUserProfile();
                                                        dR(this, eR, "f").call(this, [{
                                                            recording: e.recording,
                                                            carColors: t.carColors,
                                                            name: t.nickname,
                                                            time: e.time,
                                                            isSelf: !0
                                                        }])
                                                    } else
                                                        dR(this, eR, "f").call(this, [])
                                                }
                                            } else
                                                dR(this, nR, "f").classList.add("hidden"),
                                                    s.show(t.get("Track is missing starting point"), t.get("Ok"), ( () => {
                                                            dR(this, nR, "f").classList.remove("hidden")
                                                        }
                                                    ))
                                        }
                                    )),
                                    dR(this, iR, "f").appendChild(I),
                                    window.addEventListener("keydown", hR(this, sR, (e => {
                                            "Escape" == e.code && (u(),
                                                e.preventDefault())
                                        }
                                    ), "f"))
                            }
                            dispose() {
                                dR(this, aR, "f").dispose(),
                                    dR(this, $P, "f").removeChild(dR(this, nR, "f")),
                                    window.removeEventListener("keydown", dR(this, sR, "f"))
                            }
                        }
                    ;
                    var pR = n(5140)
                        , fR = {};
                    fR.styleTagTransform = u(),
                        fR.setAttributes = l(),
                        fR.insert = s().bind(null, "head"),
                        fR.domAPI = r(),
                        fR.insertStyleElement = h();
                    t()(pR.A, fR);
                    pR.A && pR.A.locals && pR.A.locals;
                    var mR, gR, vR, wR, AR, yR, bR, xR, kR, ER, SR = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, MR = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    gR = new WeakMap,
                        vR = new WeakMap,
                        wR = new WeakMap,
                        AR = new WeakMap,
                        yR = new WeakMap,
                        bR = new WeakMap,
                        xR = new WeakMap,
                        kR = new WeakMap,
                        mR = new WeakSet,
                        ER = function(e, t) {
                            const n = MR(this, AR, "f").getUserProfile(e)
                                , i = document.createElement("div");
                            i.className = "slot";
                            const r = document.createElement("button");
                            if (r.className = "button main",
                            e == MR(this, AR, "f").profileSlot && r.classList.add("selected"),
                                r.addEventListener("click", ( () => {
                                        MR(this, wR, "f").playUIClick();
                                        for (const e of MR(this, bR, "f"))
                                            e.classList.remove("selected");
                                        r.classList.add("selected"),
                                            t(e)
                                    }
                                )),
                                i.appendChild(r),
                                MR(this, bR, "f").push(r),
                            null != n) {
                                const e = document.createElement("div");
                                e.className = "image-container",
                                    r.appendChild(e);
                                const t = document.createElement("img");
                                t.className = "placeholder show",
                                    t.src = "images/car_thumbnail_placeholder.png",
                                    e.appendChild(t);
                                const i = document.createElement("img");
                                hP(n.carColors, MR(this, kR, "f")).then((e => {
                                        i.src = e,
                                            t.classList.remove("show"),
                                            i.classList.add("show")
                                    }
                                )).catch((e => {
                                        console.error(e)
                                    }
                                )),
                                    e.appendChild(i);
                                const a = document.createElement("p");
                                a.className = "name",
                                    a.textContent = n.nickname,
                                    r.appendChild(a)
                            } else {
                                const e = document.createElement("div");
                                e.className = "image-container",
                                    r.appendChild(e);
                                const t = document.createElement("img");
                                t.className = "show",
                                    t.src = "images/car_thumbnail_placeholder.png",
                                    e.appendChild(t);
                                const n = document.createElement("p");
                                n.className = "name empty",
                                    n.textContent = MR(this, vR, "f").get("Empty"),
                                    r.appendChild(n)
                            }
                            MR(this, yR, "f").appendChild(i)
                        }
                    ;
                    const TR = class {
                            constructor(e, t, n, i, r, a) {
                                mR.add(this),
                                    gR.set(this, void 0),
                                    vR.set(this, void 0),
                                    wR.set(this, void 0),
                                    AR.set(this, void 0),
                                    yR.set(this, void 0),
                                    bR.set(this, []),
                                    xR.set(this, void 0),
                                    kR.set(this, new mP);
                                const s = document.getElementById("ui");
                                if (null == s)
                                    throw new Error("UI element not found");
                                SR(this, gR, s, "f"),
                                    SR(this, vR, e, "f"),
                                    SR(this, wR, t, "f"),
                                    SR(this, AR, n, "f"),
                                    SR(this, yR, document.createElement("div"), "f"),
                                    MR(this, yR, "f").className = "profile-selection",
                                    MR(this, gR, "f").appendChild(MR(this, yR, "f"));
                                const o = document.createElement("div");
                                o.className = "top-bar",
                                    MR(this, yR, "f").appendChild(o);
                                const l = document.createElement("h2");
                                l.textContent = e.get("Profiles"),
                                    o.appendChild(l);
                                for (let e = 0; e < 3; e++)
                                    MR(this, mR, "m", ER).call(this, e, a);
                                const c = document.createElement("div");
                                c.className = "bottom-bar",
                                    MR(this, yR, "f").appendChild(c);
                                const h = document.createElement("button");
                                h.className = "button",
                                    h.innerHTML = '<img class="button-icon" src="images/back.svg"> ',
                                    h.append(document.createTextNode(e.get("Back"))),
                                    h.addEventListener("click", ( () => {
                                            t.playUIClick(),
                                                i()
                                        }
                                    )),
                                    c.appendChild(h);
                                const d = document.createElement("button");
                                d.className = "button right",
                                    d.innerHTML = '<img class="button-icon" src="images/import.svg"> ',
                                    d.append(document.createTextNode(e.get("Import"))),
                                    d.addEventListener("click", ( () => {
                                            t.playUIClick(),
                                                r()
                                        }
                                    )),
                                    c.appendChild(d),
                                    window.addEventListener("keydown", SR(this, xR, (e => {
                                            "Escape" == e.code && (i(),
                                                e.preventDefault())
                                        }
                                    ), "f"))
                            }
                            dispose() {
                                MR(this, kR, "f").cancel(),
                                    MR(this, gR, "f").removeChild(MR(this, yR, "f")),
                                    window.removeEventListener("keydown", MR(this, xR, "f"))
                            }
                        }
                    ;
                    var CR = n(6474)
                        , _R = {};
                    _R.styleTagTransform = u(),
                        _R.setAttributes = l(),
                        _R.insert = s().bind(null, "head"),
                        _R.domAPI = r(),
                        _R.insertStyleElement = h();
                    t()(CR.A, _R);
                    CR.A && CR.A.locals && CR.A.locals;
                    class IR {
                        constructor(e=HR.createToken(), t=HR.defaultNickname, n=Iu.random()) {
                            this.token = e,
                                this.nickname = t,
                                this.carColors = n
                        }
                        get tokenHash() {
                            return (0,
                                ly.sha256)(this.token)
                        }
                        clone() {
                            return new IR(this.token,this.nickname,this.carColors)
                        }
                    }
                    const PR = IR;
                    var RR, LR, NR, DR, BR, UR, zR, OR = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, FR = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    class WR {
                        constructor(e) {
                            var t;
                            RR.add(this),
                                NR.set(this, void 0),
                                DR.set(this, void 0),
                                BR.set(this, void 0),
                                OR(this, NR, e, "f"),
                                OR(this, DR, null !== (t = FR(this, NR, "f").loadUserProfileSlot()) && void 0 !== t ? t : 0, "f"),
                                OR(this, BR, FR(this, RR, "m", zR).call(this, FR(this, DR, "f")), "f")
                        }
                        static createToken() {
                            let e = "";
                            try {
                                const t = new Uint8Array(32);
                                crypto.getRandomValues(t),
                                    e += t.toString()
                            } catch (e) {}
                            try {
                                e += crypto.randomUUID()
                            } catch (e) {}
                            if (0 == e.length)
                                throw new Error("Failed to generate user token");
                            return (0,
                                ly.sha256)(e)
                        }
                        createProfile(e, t, n, i) {
                            return !!this.isValidToken(t) && (FR(this, NR, "f").saveUserProfile(e, t, n, i),
                            null != FR(this, NR, "f").loadUserProfile(e))
                        }
                        isValidToken(e) {
                            return !(!/^[0-9a-f]*$/.test(e) || 64 != e.length)
                        }
                        hasDuplicateToken(e) {
                            var t;
                            for (let n = 0; n < 3; n++)
                                if ((null === (t = FR(this, NR, "f").loadUserProfile(n)) || void 0 === t ? void 0 : t.token) == e)
                                    return !0;
                            return !1
                        }
                        firstOccupiedProfileSlot() {
                            for (let e = 0; e < 3; e++)
                                if (null != FR(this, NR, "f").loadUserProfile(e))
                                    return e;
                            return null
                        }
                        firstFreeProfileSlot() {
                            for (let e = 0; e < 3; e++)
                                if (null == FR(this, NR, "f").loadUserProfile(e))
                                    return e;
                            return null
                        }
                        deleteProfileSlot(e) {
                            FR(this, NR, "f").deleteAllRecords(e),
                                FR(this, NR, "f").deleteUserProfile(e)
                        }
                        setProfileSlot(e) {
                            if (!Number.isSafeInteger(e) || e < 0)
                                throw new Error("Profile slot is invalid");
                            OR(this, DR, e, "f"),
                                OR(this, BR, FR(this, RR, "m", zR).call(this, FR(this, DR, "f")), "f"),
                                FR(this, NR, "f").saveUserProfileSlot(FR(this, DR, "f"))
                        }
                        setNickname(e, t=FR(this, DR, "f")) {
                            let n;
                            n = t == FR(this, DR, "f") ? FR(this, BR, "f") : FR(this, RR, "m", zR).call(this, t),
                                n.nickname = e,
                                FR(this, NR, "f").saveUserProfile(t, n.token, n.nickname, n.carColors)
                        }
                        setCarColors(e, t=FR(this, DR, "f")) {
                            let n;
                            n = t == FR(this, DR, "f") ? FR(this, BR, "f") : FR(this, RR, "m", zR).call(this, t),
                                n.carColors = e,
                                FR(this, NR, "f").saveUserProfile(t, n.token, n.nickname, n.carColors)
                        }
                        get profileSlot() {
                            return FR(this, DR, "f")
                        }
                        getCurrentUserProfile() {
                            return FR(this, BR, "f").clone()
                        }
                        getUserProfile(e) {
                            if (e == FR(this, DR, "f"))
                                return this.getCurrentUserProfile();
                            {
                                const t = FR(this, NR, "f").loadUserProfile(e);
                                return null == t ? null : new PR(t.token,t.nickname,t.carColors)
                            }
                        }
                        syncUserProfile(e) {
                            const t = this.getCurrentUserProfile();
                            e.getUser(t.token).then((e => {
                                    if (null == e)
                                        return;
                                    const n = this.getCurrentUserProfile();
                                    n.token == t.token && n.nickname == t.nickname && n.carColors.serialize() == t.carColors.serialize() && (this.setNickname(e.name),
                                        this.setCarColors(e.carColors))
                                }
                            )).catch((e => {
                                    console.error(e)
                                }
                            ))
                        }
                    }
                    LR = WR,
                        NR = new WeakMap,
                        DR = new WeakMap,
                        BR = new WeakMap,
                        RR = new WeakSet,
                        UR = function(e) {
                            const t = LR.createToken()
                                , n = LR.defaultNickname
                                , i = Iu.random();
                            FR(this, NR, "f").saveUserProfile(e, t, n, i)
                        }
                        ,
                        zR = function(e) {
                            null == FR(this, NR, "f").loadUserProfile(e) && FR(this, RR, "m", UR).call(this, e);
                            const t = FR(this, NR, "f").loadUserProfile(e);
                            return null == t ? new PR : new PR(t.token,t.nickname,t.carColors)
                        }
                        ,
                        WR.defaultNickname = "Anonymous";
                    const HR = WR;
                    function VR(e) {
                        return new Blob([e]).size
                    }
                    var GR, jR, QR, YR, qR, KR, XR, ZR, JR, $R = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, eL = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    jR = new WeakMap,
                        QR = new WeakMap,
                        YR = new WeakMap,
                        qR = new WeakMap,
                        KR = new WeakMap,
                        XR = new WeakMap,
                        ZR = new WeakMap,
                        GR = new WeakSet,
                        JR = function() {
                            let e = eL(this, qR, "f").value;
                            return /\S/.test(e) || (e = "Anonymous"),
                                e
                        }
                    ;
                    const tL = class {
                            constructor(e, t, n, i, r, a, s, o, l) {
                                GR.add(this),
                                    jR.set(this, void 0),
                                    QR.set(this, !1),
                                    YR.set(this, void 0),
                                    qR.set(this, void 0),
                                    KR.set(this, null),
                                    XR.set(this, null),
                                    ZR.set(this, void 0);
                                const c = document.getElementById("ui");
                                if (null == c)
                                    throw new Error("UI element not found");
                                $R(this, jR, c, "f"),
                                    $R(this, YR, document.createElement("div"), "f"),
                                    eL(this, YR, "f").className = "nickname",
                                    eL(this, jR, "f").appendChild(eL(this, YR, "f"));
                                const h = document.createElement("h1");
                                h.textContent = e.get("Nickname"),
                                    eL(this, YR, "f").appendChild(h),
                                    $R(this, qR, document.createElement("input"), "f"),
                                    eL(this, qR, "f").type = "text",
                                    eL(this, qR, "f").placeholder = HR.defaultNickname,
                                    eL(this, qR, "f").spellcheck = !1,
                                    null != r ? eL(this, qR, "f").value = r : null != i && i.nickname != eL(this, qR, "f").placeholder && (eL(this, qR, "f").value = i.nickname),
                                    eL(this, YR, "f").appendChild(eL(this, qR, "f")),
                                    eL(this, qR, "f").focus(),
                                    eL(this, qR, "f").addEventListener("input", ( () => {
                                            let e = eL(this, qR, "f").value;
                                            for (; VR(e) >= 50; )
                                                e = e.substring(0, e.length - 1);
                                            eL(this, qR, "f").value = e
                                        }
                                    )),
                                    eL(this, qR, "f").addEventListener("keydown", (e => {
                                            "Enter" == e.code && (o(eL(this, GR, "m", JR).call(this)),
                                                e.preventDefault())
                                        }
                                    ));
                                const d = document.createElement("p");
                                d.textContent = e.get("Choose a nickname to be shown in the leaderboard. Your nickname can be changed at any time."),
                                    eL(this, YR, "f").appendChild(d);
                                const u = document.createElement("button");
                                u.className = "button delete",
                                    u.innerHTML = ' <img class="button-icon" src="images/delete.svg"> ',
                                    u.append(e.get("Delete")),
                                    u.addEventListener("click", ( () => {
                                            t.playUIClick(),
                                                a(eL(this, GR, "m", JR).call(this))
                                        }
                                    )),
                                    eL(this, YR, "f").appendChild(u);
                                const p = document.createElement("button");
                                p.className = "button",
                                    p.innerHTML = '<img class="button-icon" src="images/export.svg"> ',
                                    p.append(e.get("Export")),
                                    p.addEventListener("click", ( () => {
                                            var e;
                                            t.playUIClick(),
                                                s(eL(this, GR, "m", JR).call(this), null !== (e = null == i ? void 0 : i.token) && void 0 !== e ? e : "")
                                        }
                                    )),
                                    eL(this, YR, "f").appendChild(p);
                                const f = document.createElement("button");
                                f.className = "button",
                                    f.textContent = e.get("Ok"),
                                    f.addEventListener("click", ( () => {
                                            t.playUIClick(),
                                                o(eL(this, GR, "m", JR).call(this))
                                        }
                                    )),
                                    eL(this, YR, "f").appendChild(f),
                                null != i && n.getUser(i.token).then((n => {
                                        const r = 1 == (null == n ? void 0 : n.isVerifier);
                                        !eL(this, QR, "f") && r && ($R(this, KR, document.createElement("button"), "f"),
                                            eL(this, KR, "f").className = "button nickname-verifier-button",
                                            eL(this, KR, "f").textContent = e.get("Verifier"),
                                            eL(this, KR, "f").addEventListener("click", ( () => {
                                                    t.playUIClick(),
                                                        l(i.token)
                                                }
                                            )),
                                            eL(this, jR, "f").appendChild(eL(this, KR, "f")))
                                    }
                                )).catch((e => {
                                        console.error(e)
                                    }
                                )),
                                null != (null == i ? void 0 : i.tokenHash) && ($R(this, XR, document.createElement("p"), "f"),
                                    eL(this, XR, "f").className = "nickname-user-token",
                                    eL(this, XR, "f").textContent = e.get("User ID") + ": " + i.tokenHash,
                                    eL(this, jR, "f").appendChild(eL(this, XR, "f"))),
                                    window.addEventListener("keydown", $R(this, ZR, (e => {
                                            "Escape" == e.code && (o(eL(this, GR, "m", JR).call(this)),
                                                e.preventDefault())
                                        }
                                    ), "f"))
                            }
                            dispose() {
                                eL(this, jR, "f").removeChild(eL(this, YR, "f")),
                                null != eL(this, KR, "f") && eL(this, jR, "f").removeChild(eL(this, KR, "f")),
                                null != eL(this, XR, "f") && eL(this, jR, "f").removeChild(eL(this, XR, "f")),
                                    window.removeEventListener("keydown", eL(this, ZR, "f")),
                                    $R(this, QR, !0, "f")
                            }
                        }
                    ;
                    var nL = n(7818)
                        , iL = {};
                    iL.styleTagTransform = u(),
                        iL.setAttributes = l(),
                        iL.insert = s().bind(null, "head"),
                        iL.domAPI = r(),
                        iL.insertStyleElement = h();
                    t()(nL.A, iL);
                    nL.A && nL.A.locals && nL.A.locals;
                    var rL, aL, sL, oL = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, lL = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    rL = new WeakMap,
                        aL = new WeakMap,
                        sL = new WeakMap;
                    const cL = class {
                            constructor(e, t, n, i, r) {
                                rL.set(this, void 0),
                                    aL.set(this, void 0),
                                    sL.set(this, void 0);
                                const a = document.getElementById("ui");
                                if (null == a)
                                    throw new Error("UI element not found");
                                oL(this, rL, a, "f"),
                                    oL(this, aL, document.createElement("div"), "f"),
                                    lL(this, aL, "f").className = "user-export",
                                    lL(this, rL, "f").appendChild(lL(this, aL, "f"));
                                const s = document.createElement("textarea");
                                s.value = n,
                                    s.readOnly = null == r,
                                    s.placeholder = "Paste user token here...",
                                    lL(this, aL, "f").appendChild(s);
                                const o = document.createElement("div");
                                o.className = "bar",
                                    lL(this, aL, "f").appendChild(o);
                                const l = document.createElement("button");
                                if (l.className = "button",
                                    l.innerHTML = '<img class="button-icon" src="images/back.svg"> ',
                                    l.append(document.createTextNode(t.get("Back"))),
                                    l.addEventListener("click", ( () => {
                                            e.playUIClick(),
                                                i()
                                        }
                                    )),
                                    o.appendChild(l),
                                null != r) {
                                    const n = document.createElement("button");
                                    n.className = "button right",
                                        n.innerHTML = '<img class="button-icon" src="images/import.svg"> ',
                                        n.append(document.createTextNode(t.get("Import"))),
                                        n.addEventListener("click", ( () => {
                                                e.playUIClick(),
                                                    r(s.value)
                                            }
                                        )),
                                        o.appendChild(n)
                                } else {
                                    const n = document.createElement("button");
                                    n.className = "button right",
                                        n.innerHTML = '<img class="button-icon" src="images/copy.svg"> ',
                                        n.append(document.createTextNode(t.get("Copy"))),
                                        n.addEventListener("click", ( () => {
                                                e.playUIClick();
                                                try {
                                                    navigator.clipboard.writeText(s.value).catch((e => {
                                                            console.error(e)
                                                        }
                                                    ))
                                                } catch (e) {
                                                    console.error(e)
                                                }
                                            }
                                        )),
                                        o.appendChild(n)
                                }
                                window.addEventListener("keydown", oL(this, sL, (e => {
                                        "Escape" == e.code && (i(),
                                            e.preventDefault())
                                    }
                                ), "f"))
                            }
                            dispose() {
                                lL(this, rL, "f").removeChild(lL(this, aL, "f")),
                                    window.removeEventListener("keydown", lL(this, sL, "f"))
                            }
                        }
                    ;
                    try {
                        if (void 0 !== window.BroadcastChannel) {
                            const e = new window.BroadcastChannel("polytrack-single-instance");
                            e.addEventListener("message", (t => {
                                    "new-instance" == t.data && hL && e.postMessage("conflict"),
                                    "conflict" == t.data && (hL = !1)
                                }
                            )),
                                e.postMessage("new-instance"),
                                window.addEventListener("beforeunload", ( () => {
                                        e.close()
                                    }
                                ))
                        }
                    } catch (e) {
                        console.error(e)
                    }
                    let hL = !0;
                    function dL() {
                        let e;
                        switch (Zd) {
                            case "kodub":
                            case "electron":
                            case "capacitor":
                            case "jest":
                                e = "https://www.kodub.com/apps/polytrack";
                                break;
                            case "itch":
                                e = "https://kodub.itch.io/polytrack";
                                break;
                            case "armorgames":
                                e = "https://armorgames.com/polytrack-game/19464";
                                break;
                            case "gato":
                                e = "https://gato.us/game/poly-track";
                                break;
                            case "crazygames":
                                e = "https://www.crazygames.com/game/polytrack";
                                break;
                            case "poki":
                                e = "https://poki.com/en/g/polytrack";
                                break;
                            case "y8":
                                e = "https://www.y8.com/games/poly_track"
                        }
                        return e
                    }
                    var uL, pL, fL, mL, gL, vL, wL, AL, yL, bL, xL, kL, EL, SL, ML, TL, CL, _L, IL, PL, RL, LL, NL, DL, BL, UL, zL, OL, FL, WL, HL, VL = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, GL = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    pL = new WeakMap,
                        fL = new WeakMap,
                        mL = new WeakMap,
                        gL = new WeakMap,
                        vL = new WeakMap,
                        wL = new WeakMap,
                        AL = new WeakMap,
                        yL = new WeakMap,
                        bL = new WeakMap,
                        xL = new WeakMap,
                        kL = new WeakMap,
                        EL = new WeakMap,
                        SL = new WeakMap,
                        ML = new WeakMap,
                        TL = new WeakMap,
                        CL = new WeakMap,
                        _L = new WeakMap,
                        IL = new WeakMap,
                        PL = new WeakMap,
                        RL = new WeakMap,
                        LL = new WeakMap,
                        NL = new WeakMap,
                        uL = new WeakSet,
                        DL = function(e, t, n, i, r, a, s, o, l) {
                            return new Ck(GL(this, gL, "f"),e,t,n,i,r,a,s,!1,( () => {
                                    GL(this, bL, "f").hide(),
                                        GL(this, uL, "m", OL).call(this),
                                        GL(this, uL, "m", WL).call(this)
                                }
                            ),( (s, c, h, d, u) => {
                                    GL(this, bL, "f").hide();
                                    const p = () => {
                                            var e;
                                            GL(this, bL, "f").show(),
                                            null === (e = GL(this, xL, "f")) || void 0 === e || e.dispose(),
                                                VL(this, xL, null, "f")
                                        }
                                        , f = e => {
                                            var t;
                                            null === (t = GL(this, xL, "f")) || void 0 === t || t.dispose(),
                                                VL(this, xL, null, "f"),
                                                l(s, c, h, e)
                                        }
                                        , m = g => {
                                            var v;
                                            null === (v = GL(this, xL, "f")) || void 0 === v || v.dispose(),
                                                VL(this, xL, null, "f"),
                                                o.determinismState != gP.Ok ? a.show(e.get("Cannot load recordings due to non-determinism"), e.get("Ok"), ( () => {
                                                        VL(this, xL, new uR(GL(this, gL, "f"),e,o,r,n,t,a,s,c,d,u,i,p,m,f), "f")
                                                    }
                                                )) : g.then((e => {
                                                        l(s, c, h, e)
                                                    }
                                                )).catch(( () => {
                                                        a.show(e.get("Failed to load recordings"), e.get("Ok"), ( () => {
                                                                VL(this, xL, new uR(GL(this, gL, "f"),e,o,r,n,t,a,s,c,d,u,i,p,m,f), "f")
                                                            }
                                                        ))
                                                    }
                                                ))
                                        }
                                    ;
                                    VL(this, xL, new uR(GL(this, gL, "f"),e,o,r,n,t,a,s,c,d,u,i,p,m,f), "f"),
                                        GL(this, uL, "m", FL).call(this)
                                }
                            ))
                        }
                        ,
                        BL = function e(t, n, i, r, a, s, o, l, c, h, d, u, p, f, m) {
                            for (const e of GL(this, _L, "f"))
                                GL(this, CL, "f").removeChild(e);
                            VL(this, _L, [], "f");
                            for (const e of GL(this, PL, "f"))
                                GL(this, IL, "f").removeChild(e);
                            VL(this, PL, [], "f");
                            const g = document.createElement("button");
                            g.className = "button button-image",
                                g.innerHTML = '<img src="images/customize.svg">',
                                g.addEventListener("click", ( () => {
                                        n.playUIClick(),
                                            u()
                                    }
                                ));
                            const v = document.createElement("p");
                            v.textContent = t.get("Customize"),
                                g.appendChild(v),
                                GL(this, CL, "f").appendChild(g),
                                GL(this, _L, "f").push(g);
                            const w = document.createElement("button");
                            w.className = "button button-image",
                                w.innerHTML = '<img src="images/editor.svg">',
                                w.addEventListener("click", ( () => {
                                        n.playUIClick(),
                                            p()
                                    }
                                ));
                            const A = document.createElement("p");
                            A.textContent = t.get("Editor"),
                                w.appendChild(A),
                                GL(this, CL, "f").appendChild(w),
                                GL(this, _L, "f").push(w);
                            const y = document.createElement("button");
                            y.className = "button button-image",
                                y.innerHTML = '<img src="images/settings.svg">',
                                y.addEventListener("click", ( () => {
                                        n.playUIClick(),
                                            GL(this, uL, "m", zL).call(this),
                                            GL(this, uL, "m", FL).call(this),
                                            VL(this, kL, new ZI(GL(this, gL, "f"),t,n,r,a,d,( () => {
                                                    var g;
                                                    null === (g = GL(this, kL, "f")) || void 0 === g || g.dispose(),
                                                        VL(this, kL, null, "f"),
                                                        GL(this, bL, "f").dispose(),
                                                        VL(this, bL, GL(this, uL, "m", DL).call(this, t, n, l, s, o, d, c, h, f), "f"),
                                                        GL(this, uL, "m", UL).call(this, t),
                                                        GL(this, uL, "m", e).call(this, t, n, i, r, a, s, o, l, c, h, d, u, p, f, m),
                                                        GL(this, uL, "m", OL).call(this),
                                                        GL(this, uL, "m", WL).call(this)
                                                }
                                            )), "f")
                                    }
                                ));
                            const b = document.createElement("p");
                            b.textContent = t.get("Settings"),
                                y.appendChild(b),
                                GL(this, CL, "f").appendChild(y),
                                GL(this, _L, "f").push(y);
                            const x = document.createElement("button");
                            x.className = "button button-image",
                                x.innerHTML = '<img src="images/helmet.svg">',
                                x.addEventListener("click", ( () => {
                                        n.playUIClick(),
                                            GL(this, uL, "m", zL).call(this);
                                        const e = (i, a) => {
                                                VL(this, ML, new cL(n,t,a,( () => {
                                                        var e;
                                                        null === (e = GL(this, ML, "f")) || void 0 === e || e.dispose(),
                                                            VL(this, ML, null, "f"),
                                                            r()
                                                    }
                                                ),(n => {
                                                        var a;
                                                        null === (a = GL(this, ML, "f")) || void 0 === a || a.dispose(),
                                                            VL(this, ML, null, "f"),
                                                            o.hasDuplicateToken(n) ? d.show(t.get("You cannot have duplicate user profiles"), t.get("Ok"), ( () => {
                                                                    e(i, n)
                                                                }
                                                            )) : o.isValidToken(n) ? h.getUser(n).then((a => {
                                                                    null != a ? o.createProfile(i, n, a.name, a.carColors) ? (o.setProfileSlot(i),
                                                                        GL(this, bL, "f").refresh(),
                                                                        r()) : d.show(t.get("Failed to create user profile"), t.get("Ok"), ( () => {
                                                                            e(i, n)
                                                                        }
                                                                    )) : d.show(t.get("This user profile does not exist on the server"), t.get("Ok"), ( () => {
                                                                            e(i, n)
                                                                        }
                                                                    ))
                                                                }
                                                            )).catch((r => {
                                                                    console.error(r),
                                                                        d.show(t.get("Failed to download user profile from the server"), t.get("Ok"), ( () => {
                                                                                e(i, n)
                                                                            }
                                                                        ))
                                                                }
                                                            )) : d.show(t.get("User token is invalid"), t.get("Ok"), ( () => {
                                                                    e(i, n)
                                                                }
                                                            ))
                                                    }
                                                )), "f")
                                            }
                                            , i = (e, a) => {
                                                var s;
                                                null === (s = GL(this, EL, "f")) || void 0 === s || s.dispose(),
                                                    VL(this, EL, null, "f");
                                                const l = o.getUserProfile(e);
                                                VL(this, SL, new tL(t,n,h,l,a,(n => {
                                                        var a;
                                                        null === (a = GL(this, SL, "f")) || void 0 === a || a.dispose(),
                                                            VL(this, SL, null, "f"),
                                                            d.showConfirm(t.get('Are you sure you would like to delete "{0}"?', [n]), t.get("Cancel"), t.get("Confirm"), ( () => {
                                                                    i(e, n)
                                                                }
                                                            ), ( () => {
                                                                    var t;
                                                                    o.deleteProfileSlot(e),
                                                                    e == o.profileSlot && (o.setProfileSlot(null !== (t = o.firstOccupiedProfileSlot()) && void 0 !== t ? t : 0),
                                                                        GL(this, bL, "f").refresh()),
                                                                        r()
                                                                }
                                                            ))
                                                    }
                                                ),( (r, a) => {
                                                        var s;
                                                        null === (s = GL(this, SL, "f")) || void 0 === s || s.dispose(),
                                                            VL(this, SL, null, "f"),
                                                            d.showConfirm(t.get("Are you sure you want to display your private key?") + "\n\n" + t.get("DO NOT SHARE THIS KEY WITH ANYONE."), t.get("Cancel"), t.get("Confirm"), ( () => {
                                                                    i(e, r)
                                                                }
                                                            ), ( () => {
                                                                    VL(this, ML, new cL(n,t,a,( () => {
                                                                            var t;
                                                                            null === (t = GL(this, ML, "f")) || void 0 === t || t.dispose(),
                                                                                VL(this, ML, null, "f"),
                                                                                i(e, r)
                                                                        }
                                                                    ),null), "f")
                                                                }
                                                            ))
                                                    }
                                                ),(t => {
                                                        var n;
                                                        if (null === (n = GL(this, SL, "f")) || void 0 === n || n.dispose(),
                                                            VL(this, SL, null, "f"),
                                                        t != (null == l ? void 0 : l.nickname)) {
                                                            o.setNickname(t, e);
                                                            const n = o.getUserProfile(e);
                                                            null != n && h.submitUserProfile(n.token, n.nickname, n.carColors).catch((e => {
                                                                    console.warn(e)
                                                                }
                                                            ))
                                                        }
                                                        o.setProfileSlot(e),
                                                            GL(this, bL, "f").refresh(),
                                                            r()
                                                    }
                                                ),(e => {
                                                        var t;
                                                        null === (t = GL(this, SL, "f")) || void 0 === t || t.dispose(),
                                                            VL(this, SL, null, "f"),
                                                            m(e),
                                                            GL(this, uL, "m", OL).call(this)
                                                    }
                                                )), "f")
                                            }
                                            , r = () => {
                                                VL(this, EL, new TR(t,n,o,( () => {
                                                        var e;
                                                        null === (e = GL(this, EL, "f")) || void 0 === e || e.dispose(),
                                                            VL(this, EL, null, "f"),
                                                            GL(this, uL, "m", OL).call(this)
                                                    }
                                                ),( () => {
                                                        var n;
                                                        null === (n = GL(this, EL, "f")) || void 0 === n || n.dispose(),
                                                            VL(this, EL, null, "f");
                                                        const i = o.firstFreeProfileSlot();
                                                        null == i ? d.show(t.get("You need a free user profile slot to import a new user profile"), t.get("Ok"), ( () => {
                                                                r()
                                                            }
                                                        )) : e(i, "")
                                                    }
                                                ),(e => {
                                                        i(e, null)
                                                    }
                                                )), "f")
                                            }
                                        ;
                                        r()
                                    }
                                ));
                            const k = document.createElement("p");
                            k.textContent = t.get("Profile"),
                                x.appendChild(k),
                                GL(this, CL, "f").appendChild(x),
                                GL(this, _L, "f").push(x);
                            const E = document.createElement("button");
                            E.className = "button button-image",
                                E.innerHTML = '<img src="images/play.svg">',
                                E.addEventListener("click", ( () => {
                                        n.playUIClick(),
                                            GL(this, uL, "m", zL).call(this),
                                            GL(this, uL, "m", FL).call(this),
                                            GL(this, bL, "f").show()
                                    }
                                ));
                            const S = document.createElement("p");
                            if (S.textContent = t.get("Play"),
                                E.appendChild(S),
                                GL(this, CL, "f").appendChild(E),
                                GL(this, _L, "f").push(E),
                                window.electron) {
                                const e = document.createElement("button");
                                e.className = "button small",
                                    e.innerHTML = '<img src="images/quit.svg">',
                                    e.appendChild(document.createTextNode(" " + t.get("Quit"))),
                                    e.addEventListener("click", ( () => {
                                            var e;
                                            n.playUIClick(),
                                            null === (e = window.electron) || void 0 === e || e.quit()
                                        }
                                    )),
                                    GL(this, IL, "f").appendChild(e),
                                    GL(this, PL, "f").push(e)
                            }
                            {
                                const e = document.createElement("button");
                                e.className = "button small",
                                    i.isFullscreen ? (e.innerHTML = '<img src="images/windowed.svg">',
                                        e.appendChild(document.createTextNode(" " + t.get("Windowed")))) : (e.innerHTML = '<img src="images/fullscreen.svg">',
                                        e.appendChild(document.createTextNode(" " + t.get("Fullscreen")))),
                                null != GL(this, NL, "f") && i.removeFullscreenChangeListener(GL(this, NL, "f")),
                                    i.addFullscreenChangeListener(VL(this, NL, ( () => {
                                            i.isFullscreen ? (e.innerHTML = '<img src="images/windowed.svg">',
                                                e.appendChild(document.createTextNode(" " + t.get("Windowed")))) : (e.innerHTML = '<img src="images/fullscreen.svg">',
                                                e.appendChild(document.createTextNode(" " + t.get("Fullscreen"))))
                                        }
                                    ), "f")),
                                    e.addEventListener("click", ( () => {
                                            n.playUIClick(),
                                                i.toggleFullscreen().catch((e => {
                                                        console.error(e)
                                                    }
                                                ))
                                        }
                                    )),
                                    GL(this, IL, "f").appendChild(e),
                                    GL(this, PL, "f").push(e)
                            }
                        }
                        ,
                        UL = function(e) {
                            GL(this, AL, "f").innerHTML = "";
                            const t = document.createElement("a");
                            t.href = "https://www.kodub.com",
                                t.target = "_blank",
                                t.textContent = "kodub.com - " + e.get("Version") + " " + nu,
                                GL(this, AL, "f").appendChild(t);
                            const n = document.createElement("a");
                            n.href = "https://opengameart.org/content/sci-fi-theme-1",
                                n.target = "_blank",
                                n.textContent = 'OpenGameArt.org "Sci-fi Theme" by Maou (CC-BY 4.0)',
                                GL(this, AL, "f").appendChild(n),
                                GL(this, AL, "f").appendChild(document.createElement("br"));
                            const i = document.createElement("a");
                            i.href = "https://www.kodub.com/privacy/polytrack",
                                i.target = "_blank",
                                i.textContent = "Privacy Policy",
                                GL(this, AL, "f").appendChild(i)
                        }
                        ,
                        zL = function() {
                            var e;
                            null === (e = GL(this, TL, "f")) || void 0 === e || e.classList.add("hidden"),
                                GL(this, CL, "f").classList.add("hidden");
                            for (const e of GL(this, PL, "f"))
                                e.classList.add("hidden");
                            null != GL(this, wL, "f") && (GL(this, wL, "f").className = "hidden"),
                                GL(this, AL, "f").className = "hidden"
                        }
                        ,
                        OL = function() {
                            var e;
                            null === (e = GL(this, TL, "f")) || void 0 === e || e.classList.remove("hidden"),
                                GL(this, CL, "f").classList.remove("hidden");
                            for (const e of GL(this, PL, "f"))
                                e.classList.remove("hidden");
                            null != GL(this, wL, "f") && (GL(this, wL, "f").className = "discord-link"),
                                GL(this, AL, "f").className = "info"
                        }
                        ,
                        FL = function() {
                            GL(this, vL, "f").className = "hidden"
                        }
                        ,
                        WL = function() {
                            GL(this, vL, "f").className = "logo"
                        }
                        ,
                        HL = function() {
                            const e = GL(this, fL, "f").getBounds()
                                , t = new jt((e.min.x + (e.max.x - e.min.x) / 2) * yb.partSize,(e.min.y + (e.max.y - e.min.y) / 2) * yb.partSize);
                            GL(this, RL, "f").position.set(t.x + 250 * Math.cos(GL(this, LL, "f")), 100, t.y - 250 * Math.sin(GL(this, LL, "f"))),
                                GL(this, RL, "f").rotation.y = GL(this, LL, "f") + Math.PI / 2
                        }
                    ;
                    const jL = class {
                            constructor(e, t, n, i, r, a, s, o, l, c, h, d, u, p, f, m, g) {
                                uL.add(this),
                                    pL.set(this, void 0),
                                    fL.set(this, void 0),
                                    mL.set(this, void 0),
                                    gL.set(this, void 0),
                                    vL.set(this, void 0),
                                    wL.set(this, void 0),
                                    AL.set(this, void 0),
                                    yL.set(this, null),
                                    bL.set(this, void 0),
                                    xL.set(this, null),
                                    kL.set(this, null),
                                    EL.set(this, null),
                                    SL.set(this, null),
                                    ML.set(this, null),
                                    TL.set(this, void 0),
                                    CL.set(this, void 0),
                                    _L.set(this, []),
                                    IL.set(this, void 0),
                                    PL.set(this, []),
                                    RL.set(this, void 0),
                                    LL.set(this, Math.random() * Math.PI * 2),
                                    NL.set(this, null),
                                    VL(this, pL, n, "f"),
                                    VL(this, fL, r, "f");
                                const v = document.getElementById("ui");
                                if (null == v)
                                    throw new Error("UI element not found");
                                if (VL(this, mL, v, "f"),
                                    VL(this, gL, document.createElement("div"), "f"),
                                    GL(this, gL, "f").className = "menu",
                                    GL(this, mL, "f").appendChild(GL(this, gL, "f")),
                                    VL(this, vL, document.createElement("img"), "f"),
                                    GL(this, vL, "f").src = "images/logo.svg",
                                    GL(this, vL, "f").className = "logo",
                                    GL(this, gL, "f").appendChild(GL(this, vL, "f")),
                                    function() {
                                        let e;
                                        switch (Zd) {
                                            case "kodub":
                                            case "jest":
                                                e = [/\.kodub\.com$/];
                                                break;
                                            case "electron":
                                            case "capacitor":
                                                return !1;
                                            case "itch":
                                                e = [/itch\.io$/, /itch\.zone$/];
                                                break;
                                            case "armorgames":
                                                e = [/^19464\.cache\.armorgames\.com$/];
                                                break;
                                            case "gato":
                                                e = [/^gato-files-prod\.s3\.amazonaws\.com$/];
                                                break;
                                            case "crazygames":
                                                e = [/\.crazygames\.com$/];
                                                break;
                                            case "poki":
                                                e = [/\.poki\.com$/, /\.poki-gdn\.com$/];
                                                break;
                                            case "y8":
                                                e = [/\.y8\.com$/]
                                        }
                                        return !e.some((e => e.test(location.hostname)))
                                    }()) {
                                    VL(this, TL, document.createElement("div"), "f"),
                                        GL(this, TL, "f").className = "warning-message",
                                        GL(this, TL, "f").textContent = e.get("It seems like you are playing an unofficial version of {0}. For the most up-to-date version please visit the original source:", ["PolyTrack"]);
                                    const t = document.createElement("a");
                                    t.href = dL(),
                                        t.textContent = dL(),
                                        GL(this, TL, "f").appendChild(t),
                                        GL(this, gL, "f").appendChild(GL(this, TL, "f"))
                                } else
                                    VL(this, TL, null, "f");
                                VL(this, bL, GL(this, uL, "m", DL).call(this, e, t, s, c, a, d, o, l, m), "f"),
                                    VL(this, wL, document.createElement("a"), "f"),
                                    GL(this, wL, "f").className = "discord-link",
                                    GL(this, wL, "f").href = "https://www.kodub.com/discord/polytrack",
                                    GL(this, wL, "f").target = "_blank",
                                    GL(this, wL, "f").innerHTML = '<img src="images/discord.svg">',
                                    GL(this, gL, "f").appendChild(GL(this, wL, "f")),
                                    VL(this, AL, document.createElement("div"), "f"),
                                    GL(this, AL, "f").className = "info",
                                    GL(this, gL, "f").appendChild(GL(this, AL, "f")),
                                    GL(this, uL, "m", UL).call(this, e),
                                    VL(this, CL, document.createElement("div"), "f"),
                                    GL(this, CL, "f").className = "main-buttons-container hidden",
                                    GL(this, gL, "f").appendChild(GL(this, CL, "f")),
                                    VL(this, IL, document.createElement("div"), "f"),
                                    GL(this, IL, "f").className = "bottom-buttons",
                                    GL(this, gL, "f").appendChild(GL(this, IL, "f")),
                                    GL(this, uL, "m", BL).call(this, e, t, n, h, r, c, a, s, o, l, d, p, f, m, g),
                                    i.hasLoaded() ? GL(this, uL, "m", OL).call(this) : (GL(this, gL, "f").classList.add("loading-screen"),
                                        VL(this, yL, new SI(GL(this, gL, "f"),e,i), "f"),
                                        i.addCompleteListener(( () => {
                                                GL(this, gL, "f").classList.remove("loading-screen");
                                                const t = GL(this, yL, "f");
                                                null == t || t.fadeOut(( () => {
                                                        t.dispose(),
                                                            hL ? l.determinismState == gP.Ok ? GL(this, uL, "m", OL).call(this) : l.determinismState == gP.AssetsFailed ? (GL(this, uL, "m", FL).call(this),
                                                                d.show(e.get("Non-deterministic game assets found.") + " " + e.get("Some leaderboard features are disabled.") + "\n\n" + e.get("Please try clearing your browser cache."), e.get("Ok"), ( () => {
                                                                        GL(this, uL, "m", WL).call(this),
                                                                            GL(this, uL, "m", OL).call(this)
                                                                    }
                                                                ))) : (GL(this, uL, "m", FL).call(this),
                                                                d.show(e.get("Computer determinism check failed.") + " " + e.get("Some leaderboard features are disabled.") + "\n\n" + e.get("Please try another browser or device."), e.get("Ok"), ( () => {
                                                                        GL(this, uL, "m", WL).call(this),
                                                                            GL(this, uL, "m", OL).call(this)
                                                                    }
                                                                ))) : d.showNoButtons(e.get("You already have another instance of PolyTrack open.") + "\n\n" + e.get("Please switch to that tab or window to continue."));
                                                        for (let e = 0; e < GL(this, _L, "f").length; e++) {
                                                            const t = GL(this, _L, "f")[e];
                                                            t.classList.add("button-spawn"),
                                                                t.style.animationDelay = (.3 + .1 * e).toString() + "s"
                                                        }
                                                    }
                                                )),
                                                    VL(this, yL, null, "f")
                                            }
                                        ))),
                                u && (GL(this, uL, "m", zL).call(this),
                                    GL(this, uL, "m", FL).call(this),
                                    GL(this, bL, "f").show()),
                                    VL(this, RL, new Ir(70,1,.5,yu.maxViewDistance), "f"),
                                    n.scene.add(GL(this, RL, "f")),
                                    GL(this, uL, "m", HL).call(this)
                            }
                            dispose() {
                                var e;
                                GL(this, mL, "f").removeChild(GL(this, gL, "f")),
                                    GL(this, bL, "f").dispose(),
                                null === (e = GL(this, xL, "f")) || void 0 === e || e.dispose(),
                                    VL(this, xL, null, "f"),
                                null != GL(this, NL, "f") && GL(this, pL, "f").removeFullscreenChangeListener(GL(this, NL, "f"))
                            }
                            get camera() {
                                return GL(this, RL, "f")
                            }
                            update(e) {
                                VL(this, LL, GL(this, LL, "f") + .05 * e, "f"),
                                    GL(this, uL, "m", HL).call(this)
                            }
                        }
                    ;
                    var QL, YL, qL, KL, XL, ZL, JL, $L, eN, tN, nN, iN, rN, aN, sN = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, oN = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    YL = new WeakMap,
                        qL = new WeakMap,
                        KL = new WeakMap,
                        XL = new WeakMap,
                        ZL = new WeakMap,
                        JL = new WeakMap,
                        $L = new WeakMap,
                        eN = new WeakMap,
                        tN = new WeakMap,
                        nN = new WeakMap,
                        iN = new WeakMap,
                        rN = new WeakMap,
                        QL = new WeakSet,
                        aN = function() {
                            oN(this, qL, "f").loadTrackData(oN(this, ZL, "f").getRandomOfficialTrackData()),
                                oN(this, qL, "f").generateMeshes(),
                                oN(this, KL, "f").generateMountains(oN(this, qL, "f").getBounds());
                            let e = null;
                            const t = oN(this, qL, "f").getID();
                            if (null != t) {
                                const n = oN(this, JL, "f").getRecord(oN(this, nN, "f").profileSlot, t);
                                null != n && (e = n.recording)
                            }
                            if (null != e) {
                                const t = oN(this, qL, "f").getStartTransform();
                                if (null == t)
                                    throw new Error("Start transform is null");
                                sN(this, rN, new yw(oN(this, YL, "f"),t,e,null,oN(this, eN, "f"),oN(this, tN, "f"),oN(this, KL, "f"),oN(this, qL, "f"),oN(this, $L, "f")), "f"),
                                    oN(this, rN, "f").audioVolume = 0,
                                    oN(this, rN, "f").start()
                            }
                        }
                    ;
                    const lN = class {
                            constructor(e, t, n, i, r, a, s, o, l, c, h, d, u, p, f, m, g, v, w, A) {
                                QL.add(this),
                                    YL.set(this, void 0),
                                    qL.set(this, void 0),
                                    KL.set(this, void 0),
                                    XL.set(this, void 0),
                                    ZL.set(this, void 0),
                                    JL.set(this, void 0),
                                    $L.set(this, void 0),
                                    eN.set(this, void 0),
                                    tN.set(this, void 0),
                                    nN.set(this, void 0),
                                    iN.set(this, void 0),
                                    rN.set(this, null),
                                    sN(this, YL, e, "f"),
                                    sN(this, qL, t, "f"),
                                    sN(this, KL, n, "f"),
                                    sN(this, XL, i, "f"),
                                    sN(this, ZL, r, "f"),
                                    sN(this, JL, l, "f"),
                                    sN(this, $L, u, "f"),
                                    sN(this, eN, c, "f"),
                                    sN(this, tN, h, "f"),
                                    sN(this, nN, o, "f"),
                                    sN(this, iN, new jL(a,h,c,f,t,o,l,d,p,r,u,s,m,g,v,w,A), "f"),
                                    c.setCamera(oN(this, iN, "f").camera),
                                    f.hasLoaded() ? oN(this, QL, "m", aN).call(this) : f.addCompleteListener(( () => {
                                            oN(this, QL, "m", aN).call(this)
                                        }
                                    ))
                            }
                            dispose() {
                                var e;
                                null === (e = oN(this, rN, "f")) || void 0 === e || e.dispose(),
                                    oN(this, iN, "f").dispose(),
                                    oN(this, qL, "f").clear(),
                                    oN(this, KL, "f").clearMountains()
                            }
                            update(e) {
                                var t, n, i;
                                null === (t = oN(this, rN, "f")) || void 0 === t || t.update(e),
                                    oN(this, iN, "f").update(e),
                                    oN(this, KL, "f").update(oN(this, qL, "f")),
                                    oN(this, XL, "f").update(e, oN(this, eN, "f").camera, oN(this, qL, "f").sunDirection),
                                    oN(this, tN, "f").update(e, !0, oN(this, eN, "f"), oN(this, $L, "f")),
                                    oN(this, eN, "f").update(null !== (i = null === (n = oN(this, rN, "f")) || void 0 === n ? void 0 : n.getPosition()) && void 0 !== i ? i : new An, oN(this, qL, "f").sunDirection)
                            }
                        }
                    ;
                    var cN = n(5437)
                        , hN = {};
                    hN.styleTagTransform = u(),
                        hN.setAttributes = l(),
                        hN.insert = s().bind(null, "head"),
                        hN.domAPI = r(),
                        hN.insertStyleElement = h();
                    t()(cN.A, hN);
                    cN.A && cN.A.locals && cN.A.locals;
                    var dN, uN, pN, fN, mN, gN, vN, wN, AN, yN, bN = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, xN = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    uN = new WeakMap,
                        pN = new WeakMap,
                        fN = new WeakMap,
                        mN = new WeakMap,
                        gN = new WeakMap,
                        vN = new WeakMap,
                        wN = new WeakMap,
                        AN = new WeakMap,
                        dN = new WeakSet,
                        yN = function() {
                            const e = Math.max(.01, Math.min(window.innerWidth, 1.4375 * window.innerHeight) / 1150);
                            xN(this, fN, "f").style.transform = e < 1 ? "scale(" + e.toString() + ")" : ""
                        }
                    ;
                    const kN = class {
                            constructor(e) {
                                dN.add(this),
                                    uN.set(this, !1),
                                    pN.set(this, void 0),
                                    fN.set(this, void 0),
                                    mN.set(this, void 0),
                                    gN.set(this, void 0),
                                    vN.set(this, void 0),
                                    wN.set(this, null),
                                    AN.set(this, null),
                                    bN(this, pN, document.createElement("dialog"), "f"),
                                    xN(this, pN, "f").className = "hidden",
                                    document.body.appendChild(xN(this, pN, "f")),
                                    bN(this, fN, document.createElement("div"), "f"),
                                    xN(this, pN, "f").appendChild(xN(this, fN, "f")),
                                    bN(this, mN, document.createElement("p"), "f"),
                                    xN(this, fN, "f").appendChild(xN(this, mN, "f")),
                                    bN(this, gN, document.createElement("button"), "f"),
                                    xN(this, gN, "f").className = "button",
                                    xN(this, gN, "f").addEventListener("click", ( () => {
                                            e.playUIClick();
                                            const t = xN(this, wN, "f");
                                            this.hide(),
                                            null != t && t()
                                        }
                                    )),
                                    xN(this, fN, "f").appendChild(xN(this, gN, "f")),
                                    bN(this, vN, document.createElement("button"), "f"),
                                    xN(this, vN, "f").className = "button",
                                    xN(this, vN, "f").addEventListener("click", ( () => {
                                            e.playUIClick();
                                            const t = xN(this, AN, "f");
                                            this.hide(),
                                            null != t && t()
                                        }
                                    )),
                                    xN(this, fN, "f").appendChild(xN(this, vN, "f")),
                                    window.addEventListener("keydown", (e => {
                                            this.isOpen && "Escape" == e.code && (null != xN(this, wN, "f") && xN(this, wN, "f").call(this),
                                                this.hide(),
                                                e.stopImmediatePropagation(),
                                                e.preventDefault())
                                        }
                                    )),
                                    window.addEventListener("resize", ( () => {
                                            xN(this, dN, "m", yN).call(this)
                                        }
                                    )),
                                    xN(this, dN, "m", yN).call(this)
                            }
                            get isOpen() {
                                return xN(this, uN, "f")
                            }
                            show(e, t, n) {
                                bN(this, uN, !0, "f"),
                                    xN(this, pN, "f").className = "message-box message",
                                    xN(this, pN, "f").showModal(),
                                    xN(this, mN, "f").textContent = e,
                                    xN(this, gN, "f").textContent = "",
                                    xN(this, vN, "f").textContent = t,
                                    xN(this, gN, "f").blur(),
                                    xN(this, vN, "f").blur(),
                                    bN(this, wN, n, "f"),
                                    bN(this, AN, n, "f")
                            }
                            showConfirm(e, t, n, i, r) {
                                bN(this, uN, !0, "f"),
                                    xN(this, pN, "f").className = "message-box confirm",
                                    xN(this, pN, "f").showModal(),
                                    xN(this, mN, "f").textContent = e,
                                    xN(this, gN, "f").textContent = t,
                                    xN(this, vN, "f").textContent = n,
                                    xN(this, gN, "f").blur(),
                                    xN(this, vN, "f").blur(),
                                    bN(this, wN, i, "f"),
                                    bN(this, AN, r, "f")
                            }
                            showNoButtons(e) {
                                bN(this, uN, !0, "f"),
                                    xN(this, pN, "f").className = "message-box no-buttons",
                                    xN(this, pN, "f").showModal(),
                                    xN(this, mN, "f").textContent = e,
                                    xN(this, gN, "f").textContent = "",
                                    xN(this, vN, "f").textContent = "",
                                    xN(this, gN, "f").blur(),
                                    xN(this, vN, "f").blur(),
                                    bN(this, wN, null, "f"),
                                    bN(this, AN, null, "f")
                            }
                            hide() {
                                bN(this, uN, !1, "f"),
                                    xN(this, pN, "f").className = "hidden",
                                    xN(this, pN, "f").close(),
                                    xN(this, mN, "f").textContent = "",
                                    xN(this, gN, "f").textContent = "",
                                    xN(this, vN, "f").textContent = "",
                                    bN(this, wN, null, "f"),
                                    bN(this, AN, null, "f")
                            }
                        }
                    ;
                    var EN, SN, MN, TN, CN = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    }, _N = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    };
                    EN = new WeakMap,
                        SN = new WeakMap,
                        MN = new WeakMap,
                        TN = new WeakMap;
                    const IN = class {
                            constructor() {
                                EN.set(this, 0),
                                    SN.set(this, 0),
                                    MN.set(this, []),
                                    TN.set(this, [])
                            }
                            hasLoaded() {
                                return CN(this, SN, "f") == CN(this, EN, "f")
                            }
                            getProgress() {
                                return CN(this, SN, "f") / CN(this, EN, "f")
                            }
                            addResource() {
                                var e;
                                _N(this, EN, (e = CN(this, EN, "f"),
                                    ++e), "f")
                            }
                            loadedResource() {
                                var e;
                                _N(this, SN, (e = CN(this, SN, "f"),
                                    ++e), "f");
                                for (const e of CN(this, MN, "f"))
                                    e(this.getProgress());
                                if (this.hasLoaded())
                                    for (const e of CN(this, TN, "f"))
                                        e()
                            }
                            addProgressListener(e) {
                                CN(this, MN, "f").push(e)
                            }
                            addCompleteListener(e) {
                                CN(this, TN, "f").push(e)
                            }
                            preloadImage(e) {
                                this.addResource();
                                const t = new Image;
                                t.addEventListener("load", ( () => {
                                        this.loadedResource()
                                    }
                                )),
                                    t.addEventListener("error", ( () => {
                                            console.error("Failed to preload image: " + e)
                                        }
                                    )),
                                    t.src = e
                            }
                        }
                    ;
                    var PN, RN, LN, NN, DN, BN, UN, zN, ON = function(e, t, n, i) {
                        return new (n || (n = Promise))((function(r, a) {
                                function s(e) {
                                    try {
                                        l(i.next(e))
                                    } catch (e) {
                                        a(e)
                                    }
                                }
                                function o(e) {
                                    try {
                                        l(i.throw(e))
                                    } catch (e) {
                                        a(e)
                                    }
                                }
                                function l(e) {
                                    var t;
                                    e.done ? r(e.value) : (t = e.value,
                                        t instanceof n ? t : new n((function(e) {
                                                e(t)
                                            }
                                        ))).then(s, o)
                                }
                                l((i = i.apply(e, t || [])).next())
                            }
                        ))
                    }, FN = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, WN = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    RN = new WeakMap,
                        LN = new WeakMap,
                        NN = new WeakMap,
                        DN = new WeakMap,
                        BN = new WeakMap,
                        PN = new WeakSet,
                        UN = function(e, t, n, i) {
                            return ON(this, void 0, void 0, (function*() {
                                    var r, a;
                                    if (WN(this, LN, "f").determinismState != gP.Ok)
                                        return;
                                    const s = WN(this, NN, "f").getUserProfile(e);
                                    if (null == s)
                                        return;
                                    const o = e.toString() + "_" + t
                                        , l = (null !== (r = WN(this, DN, "f").get(o)) && void 0 !== r ? r : 0) + 1;
                                    WN(this, DN, "f").set(o, l);
                                    const {uploadId: c} = yield WN(this, LN, "f").submitLeaderboard(s.token, s.nickname, s.carColors, t, n, i);
                                    WN(this, DN, "f").get(o) == l && (null === (a = WN(this, NN, "f").getUserProfile(e)) || void 0 === a ? void 0 : a.token) == s.token && WN(this, RN, "f").saveRecord(e, s.tokenHash, t, c, n, i, WN(this, LN, "f").determinismState)
                                }
                            ))
                        }
                        ,
                        zN = function(e, t, n) {
                            return ON(this, void 0, void 0, (function*() {
                                    var i, r;
                                    if (WN(this, LN, "f").determinismState != gP.Ok)
                                        return;
                                    const a = WN(this, NN, "f").getUserProfile(e);
                                    if (null == a)
                                        return;
                                    const s = e.toString() + "_" + t
                                        , o = (null !== (i = WN(this, DN, "f").get(s)) && void 0 !== i ? i : 0) + 1;
                                    WN(this, DN, "f").set(s, o);
                                    const l = yield WN(this, LN, "f").getRecordings([n]);
                                    if (l.length < 1 || null == l[0])
                                        throw new Error("Record not found");
                                    const c = l[0];
                                    if (WN(this, DN, "f").get(s) == o && (null === (r = WN(this, NN, "f").getUserProfile(e)) || void 0 === r ? void 0 : r.token) == a.token) {
                                        const i = this.getRecordTime(e, t);
                                        if (null == i || c.time.lessThan(i)) {
                                            WN(this, RN, "f").saveRecord(e, a.tokenHash, t, n, c.time, c.recording, WN(this, LN, "f").determinismState);
                                            for (const e of WN(this, BN, "f"))
                                                e()
                                        }
                                    }
                                }
                            ))
                        }
                    ;
                    const HN = class {
                            constructor(e, t, n) {
                                PN.add(this),
                                    RN.set(this, void 0),
                                    LN.set(this, void 0),
                                    NN.set(this, void 0),
                                    DN.set(this, new Map),
                                    BN.set(this, []),
                                    FN(this, RN, e, "f"),
                                    FN(this, LN, t, "f"),
                                    FN(this, NN, n, "f")
                            }
                            addRecordChangedCallback(e) {
                                WN(this, BN, "f").push(e)
                            }
                            removeRecordChangedCallback(e) {
                                const t = WN(this, BN, "f").indexOf(e);
                                t >= 0 && WN(this, BN, "f").splice(t, 1)
                            }
                            setRecord(e, t, n, i) {
                                const r = WN(this, NN, "f").getUserProfile(e);
                                if (null != r) {
                                    WN(this, RN, "f").saveRecord(e, r.tokenHash, t, null, n, i, WN(this, LN, "f").determinismState),
                                        WN(this, PN, "m", UN).call(this, e, t, n, i).catch((e => {
                                                console.warn(e)
                                            }
                                        ));
                                    for (const e of WN(this, BN, "f"))
                                        e()
                                }
                            }
                            syncRecord(e, t, n) {
                                return ON(this, void 0, void 0, (function*() {
                                        if (WN(this, LN, "f").determinismState != gP.Ok)
                                            return null;
                                        const i = this.getRecord(e, t);
                                        return null != i && (null == n || i.uploadId != n.recordingId && i.time.lessThan(n.time)) ? (yield WN(this, PN, "m", UN).call(this, e, t, i.time, i.recording),
                                            "Upload") : null != n && (null == i || i.uploadId != n.recordingId && n.time.lessThan(i.time)) ? (yield WN(this, PN, "m", zN).call(this, e, t, n.recordingId),
                                            "Download") : null
                                    }
                                ))
                            }
                            getRecordTime(e, t) {
                                const n = this.getRecord(e, t);
                                return null == n ? null : n.time
                            }
                            getRecord(e, t) {
                                const n = WN(this, NN, "f").getUserProfile(e);
                                return null == n ? null : WN(this, RN, "f").loadRecord(e, n.tokenHash, t, WN(this, LN, "f").determinismState)
                            }
                        }
                    ;
                    var VN, GN, jN, QN, YN, qN, KN, XN, ZN, JN, $N, eD = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, tD = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    GN = new WeakMap,
                        jN = new WeakMap,
                        QN = new WeakMap,
                        YN = new WeakMap,
                        qN = new WeakMap,
                        VN = new WeakSet,
                        KN = function(e, t) {
                            return tD(this, VN, "m", ZN).call(this, "tracks/official/" + e, t)
                        }
                        ,
                        XN = function(e, t) {
                            return tD(this, VN, "m", ZN).call(this, "tracks/community/" + e, t)
                        }
                        ,
                        ZN = function(e, t) {
                            return t.addResource(),
                                new Promise((n => {
                                        const i = new XMLHttpRequest;
                                        i.overrideMimeType("text/plain"),
                                            i.onreadystatechange = () => {
                                                if (4 == i.readyState && 200 == i.status) {
                                                    t.loadedResource();
                                                    const e = eb.fromExportString(i.responseText);
                                                    if (null == e)
                                                        throw new Error("Failed to load bundled track");
                                                    const {trackMetadata: r, trackData: a} = e;
                                                    n({
                                                        id: a.getId(),
                                                        trackMetadata: r,
                                                        trackData: a,
                                                        thumbnail: a.createThumbnail(),
                                                        saveTime: null
                                                    })
                                                }
                                            }
                                            ,
                                            i.open("GET", e, !0),
                                            i.send()
                                    }
                                ))
                        }
                        ,
                        JN = function(e) {
                            return new Promise((t => {
                                    setTimeout(( () => {
                                            const n = tD(this, YN, "f").loadCustomTrack(e);
                                            if (null != n) {
                                                const {trackMetadata: e, trackData: i, saveTime: r} = n
                                                    , a = {
                                                    id: i.getId(),
                                                    trackMetadata: e,
                                                    trackData: i,
                                                    thumbnail: i.createThumbnail(),
                                                    saveTime: r
                                                };
                                                t(a)
                                            } else
                                                t(null)
                                        }
                                    ))
                                }
                            ))
                        }
                        ,
                        $N = function() {
                            for (const e of tD(this, qN, "f"))
                                e()
                        }
                    ;
                    const nD = class {
                        constructor(e, t) {
                            VN.add(this),
                                GN.set(this, []),
                                jN.set(this, []),
                                QN.set(this, []),
                                YN.set(this, void 0),
                                qN.set(this, []),
                                eD(this, YN, t, "f");
                            Promise.all(["summer1.track", "summer2.track", "summer3.track", "summer4.track", "summer5.track", "summer6.track", "summer7.track", "winter1.track", "winter2.track", "winter3.track", "winter4.track", "desert1.track", "desert2.track", "desert3.track", "desert4.track"].map((t => tD(this, VN, "m", KN).call(this, t, e)))).then((e => {
                                    eD(this, GN, e, "f")
                                }
                            )).catch((e => {
                                    console.error(e)
                                }
                            ));
                            Promise.all(["alpine_ascent.track", "arabica.track", "clay_temples.track", "hyperions_sanctuary.track", "las_calles.track", "winter_hollow.track"].map((t => tD(this, VN, "m", XN).call(this, t, e)))).then((e => {
                                    eD(this, jN, e, "f")
                                }
                            )).catch((e => {
                                    console.error(e)
                                }
                            ));
                            const n = tD(this, YN, "f").getAllCustomTrackNames();
                            if (null != n) {
                                const e = [];
                                for (const t of n)
                                    e.push(tD(this, VN, "m", JN).call(this, t));
                                Promise.all(e).then((e => {
                                        eD(this, QN, e.filter((e => null != e)).sort(( (e, t) => {
                                                var n, i;
                                                return (null !== (n = t.saveTime) && void 0 !== n ? n : -1 / 0) - (null !== (i = e.saveTime) && void 0 !== i ? i : -1 / 0)
                                            }
                                        )), "f")
                                    }
                                )).catch((e => {
                                        console.error(e)
                                    }
                                ))
                            }
                        }
                        saveCustomTrack(e, t) {
                            const n = new Date;
                            if (tD(this, YN, "f").saveCustomTrack(e, t, n)) {
                                const i = {
                                    id: t.getId(),
                                    trackMetadata: e,
                                    trackData: t,
                                    thumbnail: t.createThumbnail(),
                                    saveTime: n.getTime()
                                }
                                    , r = tD(this, QN, "f").findIndex((t => t.trackMetadata.name == e.name));
                                return r >= 0 ? tD(this, QN, "f")[r] = i : tD(this, QN, "f").unshift(i),
                                    tD(this, VN, "m", $N).call(this),
                                    !0
                            }
                            return !1
                        }
                        deleteCustomTrack(e) {
                            if (tD(this, YN, "f").deleteCustomTrack(e)) {
                                const t = tD(this, QN, "f").findIndex((t => t.trackMetadata.name == e));
                                if (t >= 0) {
                                    const e = tD(this, QN, "f")[t];
                                    tD(this, YN, "f").deleteAllRecordsForTrack(e.id),
                                        tD(this, QN, "f").splice(t, 1)
                                }
                                return tD(this, VN, "m", $N).call(this),
                                    !0
                            }
                            return !1
                        }
                        checkCustomTrackNameExists(e) {
                            return tD(this, QN, "f").some((t => t.trackMetadata.name == e))
                        }
                        addCustomTracksChangedListener(e) {
                            tD(this, qN, "f").push(e)
                        }
                        removeCustomTracksChangedListener(e) {
                            const t = tD(this, qN, "f").indexOf(e);
                            t >= 0 && tD(this, qN, "f").splice(t, 1)
                        }
                        isCommunityTracksEmpty() {
                            return 0 == tD(this, jN, "f").length
                        }
                        isCustomTracksEmpty() {
                            return 0 == tD(this, QN, "f").length
                        }
                        forEachTrack(e) {
                            this.forEachOfficialTrack(e),
                                this.forEachCommunityTrack(e),
                                this.forEachCustomTrack(e)
                        }
                        forEachOfficialTrack(e) {
                            for (const t of tD(this, GN, "f"))
                                e(t.id, t.trackMetadata, t.trackData, t.thumbnail)
                        }
                        forEachCommunityTrack(e) {
                            for (const t of tD(this, jN, "f"))
                                e(t.id, t.trackMetadata, t.trackData, t.thumbnail)
                        }
                        forEachCustomTrack(e) {
                            for (const t of tD(this, QN, "f"))
                                e(t.id, t.trackMetadata, t.trackData, t.thumbnail)
                        }
                        getRandomOfficialTrackData() {
                            return tD(this, GN, "f")[Math.floor(Math.random() * tD(this, GN, "f").length)].trackData
                        }
                        isOfficialTrack(e) {
                            return tD(this, GN, "f").some((t => t.id == e))
                        }
                        isCommunityTrack(e) {
                            return tD(this, jN, "f").some((t => t.id == e))
                        }
                    }
                        , iD = new WeakMap;
                    class rD extends uo {
                        constructor(e) {
                            super(e),
                                this.decoderPath = "",
                                this.decoderConfig = {},
                                this.decoderBinary = null,
                                this.decoderPending = null,
                                this.workerLimit = 4,
                                this.workerPool = [],
                                this.workerNextTaskID = 1,
                                this.workerSourceURL = "",
                                this.defaultAttributeIDs = {
                                    position: "POSITION",
                                    normal: "NORMAL",
                                    color: "COLOR",
                                    uv: "TEX_COORD"
                                },
                                this.defaultAttributeTypes = {
                                    position: "Float32Array",
                                    normal: "Float32Array",
                                    color: "Float32Array",
                                    uv: "Float32Array"
                                }
                        }
                        setDecoderPath(e) {
                            return this.decoderPath = e,
                                this
                        }
                        setDecoderConfig(e) {
                            return this.decoderConfig = e,
                                this
                        }
                        setWorkerLimit(e) {
                            return this.workerLimit = e,
                                this
                        }
                        load(e, t, n, i) {
                            const r = new mo(this.manager);
                            r.setPath(this.path),
                                r.setResponseType("arraybuffer"),
                                r.setRequestHeader(this.requestHeader),
                                r.setWithCredentials(this.withCredentials),
                                r.load(e, (e => {
                                        this.parse(e, t, i)
                                    }
                                ), n, i)
                        }
                        parse(e, t, n= () => {}
                        ) {
                            this.decodeDracoFile(e, t, null, null, gt, n).catch(n)
                        }
                        decodeDracoFile(e, t, n, i, r=vt, a= () => {}
                        ) {
                            const s = {
                                attributeIDs: n || this.defaultAttributeIDs,
                                attributeTypes: i || this.defaultAttributeTypes,
                                useUniqueIDs: !!n,
                                vertexColorSpace: r
                            };
                            return this.decodeGeometry(e, s).then(t).catch(a)
                        }
                        decodeGeometry(e, t) {
                            const n = JSON.stringify(t);
                            if (iD.has(e)) {
                                const t = iD.get(e);
                                if (t.key === n)
                                    return t.promise;
                                if (0 === e.byteLength)
                                    throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
                            }
                            let i;
                            const r = this.workerNextTaskID++
                                , a = e.byteLength
                                , s = this._getWorker(r, a).then((n => (i = n,
                                new Promise(( (n, a) => {
                                        i._callbacks[r] = {
                                            resolve: n,
                                            reject: a
                                        },
                                            i.postMessage({
                                                type: "decode",
                                                id: r,
                                                taskConfig: t,
                                                buffer: e
                                            }, [e])
                                    }
                                ))))).then((e => this._createGeometry(e.geometry)));
                            return s.catch(( () => !0)).then(( () => {
                                    i && r && this._releaseTask(i, r)
                                }
                            )),
                                iD.set(e, {
                                    key: n,
                                    promise: s
                                }),
                                s
                        }
                        _createGeometry(e) {
                            const t = new sr;
                            e.index && t.setIndex(new Ki(e.index.array,1));
                            for (let n = 0; n < e.attributes.length; n++) {
                                const i = e.attributes[n]
                                    , r = i.name
                                    , a = i.array
                                    , s = i.itemSize
                                    , o = new Ki(a,s);
                                "color" === r && (this._assignVertexColorSpace(o, i.vertexColorSpace),
                                    o.normalized = a instanceof Float32Array == !1),
                                    t.setAttribute(r, o)
                            }
                            return t
                        }
                        _assignVertexColorSpace(e, t) {
                            if (t !== gt)
                                return;
                            const n = new Wi;
                            for (let t = 0, i = e.count; t < i; t++)
                                n.fromBufferAttribute(e, t),
                                    nn.toWorkingColorSpace(n, gt),
                                    e.setXYZ(t, n.r, n.g, n.b)
                        }
                        _loadLibrary(e, t) {
                            const n = new mo(this.manager);
                            return n.setPath(this.decoderPath),
                                n.setResponseType(t),
                                n.setWithCredentials(this.withCredentials),
                                new Promise(( (t, i) => {
                                        n.load(e, t, void 0, i)
                                    }
                                ))
                        }
                        preload() {
                            return this._initDecoder(),
                                this
                        }
                        _initDecoder() {
                            if (this.decoderPending)
                                return this.decoderPending;
                            const e = "object" != typeof WebAssembly || "js" === this.decoderConfig.type
                                , t = [];
                            return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")),
                                t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))),
                                this.decoderPending = Promise.all(t).then((t => {
                                        const n = t[0];
                                        e || (this.decoderConfig.wasmBinary = t[1]);
                                        const i = aD.toString()
                                            , r = ["/* draco decoder */", n, "", "/* worker */", i.substring(i.indexOf("{") + 1, i.lastIndexOf("}"))].join("\n");
                                        this.workerSourceURL = URL.createObjectURL(new Blob([r]))
                                    }
                                )),
                                this.decoderPending
                        }
                        _getWorker(e, t) {
                            return this._initDecoder().then(( () => {
                                    if (this.workerPool.length < this.workerLimit) {
                                        const e = new Worker(this.workerSourceURL);
                                        e._callbacks = {},
                                            e._taskCosts = {},
                                            e._taskLoad = 0,
                                            e.postMessage({
                                                type: "init",
                                                decoderConfig: this.decoderConfig
                                            }),
                                            e.onmessage = function(t) {
                                                const n = t.data;
                                                switch (n.type) {
                                                    case "decode":
                                                        e._callbacks[n.id].resolve(n);
                                                        break;
                                                    case "error":
                                                        e._callbacks[n.id].reject(n);
                                                        break;
                                                    default:
                                                        console.error('THREE.DRACOLoader: Unexpected message, "' + n.type + '"')
                                                }
                                            }
                                            ,
                                            this.workerPool.push(e)
                                    } else
                                        this.workerPool.sort((function(e, t) {
                                                return e._taskLoad > t._taskLoad ? -1 : 1
                                            }
                                        ));
                                    const n = this.workerPool[this.workerPool.length - 1];
                                    return n._taskCosts[e] = t,
                                        n._taskLoad += t,
                                        n
                                }
                            ))
                        }
                        _releaseTask(e, t) {
                            e._taskLoad -= e._taskCosts[t],
                                delete e._callbacks[t],
                                delete e._taskCosts[t]
                        }
                        debug() {
                            console.log("Task load: ", this.workerPool.map((e => e._taskLoad)))
                        }
                        dispose() {
                            for (let e = 0; e < this.workerPool.length; ++e)
                                this.workerPool[e].terminate();
                            return this.workerPool.length = 0,
                            "" !== this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL),
                                this
                        }
                    }
                    function aD() {
                        let e, t;
                        function n(e, t, n, i, r, a) {
                            const s = a.num_components()
                                , o = n.num_points() * s
                                , l = o * r.BYTES_PER_ELEMENT
                                , c = function(e, t) {
                                switch (t) {
                                    case Float32Array:
                                        return e.DT_FLOAT32;
                                    case Int8Array:
                                        return e.DT_INT8;
                                    case Int16Array:
                                        return e.DT_INT16;
                                    case Int32Array:
                                        return e.DT_INT32;
                                    case Uint8Array:
                                        return e.DT_UINT8;
                                    case Uint16Array:
                                        return e.DT_UINT16;
                                    case Uint32Array:
                                        return e.DT_UINT32
                                }
                            }(e, r)
                                , h = e._malloc(l);
                            t.GetAttributeDataArrayForAllPoints(n, a, c, l, h);
                            const d = new r(e.HEAPF32.buffer,h,o).slice();
                            return e._free(h),
                                {
                                    name: i,
                                    array: d,
                                    itemSize: s
                                }
                        }
                        onmessage = function(i) {
                            const r = i.data;
                            switch (r.type) {
                                case "init":
                                    e = r.decoderConfig,
                                        t = new Promise((function(t) {
                                                e.onModuleLoaded = function(e) {
                                                    t({
                                                        draco: e
                                                    })
                                                }
                                                    ,
                                                    DracoDecoderModule(e)
                                            }
                                        ));
                                    break;
                                case "decode":
                                    const i = r.buffer
                                        , a = r.taskConfig;
                                    t.then((e => {
                                            const t = e.draco
                                                , s = new t.Decoder;
                                            try {
                                                const e = function(e, t, i, r) {
                                                    const a = r.attributeIDs
                                                        , s = r.attributeTypes;
                                                    let o, l;
                                                    const c = t.GetEncodedGeometryType(i);
                                                    if (c === e.TRIANGULAR_MESH)
                                                        o = new e.Mesh,
                                                            l = t.DecodeArrayToMesh(i, i.byteLength, o);
                                                    else {
                                                        if (c !== e.POINT_CLOUD)
                                                            throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
                                                        o = new e.PointCloud,
                                                            l = t.DecodeArrayToPointCloud(i, i.byteLength, o)
                                                    }
                                                    if (!l.ok() || 0 === o.ptr)
                                                        throw new Error("THREE.DRACOLoader: Decoding failed: " + l.error_msg());
                                                    const h = {
                                                        index: null,
                                                        attributes: []
                                                    };
                                                    for (const i in a) {
                                                        const l = self[s[i]];
                                                        let c, d;
                                                        if (r.useUniqueIDs)
                                                            d = a[i],
                                                                c = t.GetAttributeByUniqueId(o, d);
                                                        else {
                                                            if (d = t.GetAttributeId(o, e[a[i]]),
                                                            -1 === d)
                                                                continue;
                                                            c = t.GetAttribute(o, d)
                                                        }
                                                        const u = n(e, t, o, i, l, c);
                                                        "color" === i && (u.vertexColorSpace = r.vertexColorSpace),
                                                            h.attributes.push(u)
                                                    }
                                                    c === e.TRIANGULAR_MESH && (h.index = function(e, t, n) {
                                                        const i = n.num_faces()
                                                            , r = 3 * i
                                                            , a = 4 * r
                                                            , s = e._malloc(a);
                                                        t.GetTrianglesUInt32Array(n, a, s);
                                                        const o = new Uint32Array(e.HEAPF32.buffer,s,r).slice();
                                                        return e._free(s),
                                                            {
                                                                array: o,
                                                                itemSize: 1
                                                            }
                                                    }(e, t, o));
                                                    return e.destroy(o),
                                                        h
                                                }(t, s, new Int8Array(i), a)
                                                    , o = e.attributes.map((e => e.array.buffer));
                                                e.index && o.push(e.index.array.buffer),
                                                    self.postMessage({
                                                        type: "decode",
                                                        id: r.id,
                                                        geometry: e
                                                    }, o)
                                            } catch (e) {
                                                console.error(e),
                                                    self.postMessage({
                                                        type: "error",
                                                        id: r.id,
                                                        error: e.message
                                                    })
                                            } finally {
                                                t.destroy(s)
                                            }
                                        }
                                    ))
                            }
                        }
                    }
                    var sD, oD, lD, cD, hD, dD = function(e, t, n, i) {
                        return new (n || (n = Promise))((function(r, a) {
                                function s(e) {
                                    try {
                                        l(i.next(e))
                                    } catch (e) {
                                        a(e)
                                    }
                                }
                                function o(e) {
                                    try {
                                        l(i.throw(e))
                                    } catch (e) {
                                        a(e)
                                    }
                                }
                                function l(e) {
                                    var t;
                                    e.done ? r(e.value) : (t = e.value,
                                        t instanceof n ? t : new n((function(e) {
                                                e(t)
                                            }
                                        ))).then(s, o)
                                }
                                l((i = i.apply(e, t || [])).next())
                            }
                        ))
                    }, uD = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    class pD {
                        constructor() {
                            sD.add(this),
                                oD.set(this, new Map),
                                lD.set(this, new Map)
                        }
                        init(e) {
                            return dD(this, void 0, void 0, (function*() {
                                    const t = new gl
                                        , n = new rD;
                                    n.setDecoderPath("lib/draco/"),
                                        t.setDRACOLoader(n);
                                    const i = (r = ["models/blocks.glb", "models/pillar.glb", "models/planes.glb", "models/road.glb", "models/road_wide.glb", "models/signs.glb", "models/wall_track.glb"],
                                        Promise.all(r.map((e => {
                                                return n = e,
                                                    new Promise((e => {
                                                            t.load(n, (t => {
                                                                    e(t)
                                                                }
                                                            ))
                                                        }
                                                    ));
                                                var n
                                            }
                                        ))));
                                    var r;
                                    const a = new Fs({
                                            vertexColors: !0
                                        })
                                        , s = t => dD(this, void 0, void 0, (function*() {
                                                var n, r, s;
                                                if (e.addResource(),
                                                    uD(this, oD, "f").has(t.id))
                                                    throw new Error("Track part types have same Id");
                                                const o = {
                                                    configuration: t,
                                                    colors: new Map(t.colors.map(( ({id: e}) => [e, null]))),
                                                    physicsShapeVertices: null
                                                };
                                                uD(this, oD, "f").set(t.id, o);
                                                const l = yield i;
                                                function c(e, t, n, i, r, a) {
                                                    const s = l.find((t => t.scene.name == e));
                                                    if (null == s)
                                                        throw new Error('Scene "' + e + '" does not exist');
                                                    const o = s.scene.getObjectByName(t);
                                                    if (null == o)
                                                        throw new Error('Mesh "' + t + '" does not exist in scene "' + e + '"');
                                                    let c;
                                                    if (0 == o.children.length) {
                                                        const e = o
                                                            , t = h(e, a);
                                                        e.updateMatrixWorld(!0),
                                                            t.applyMatrix4(e.matrix),
                                                            c = [t]
                                                    } else {
                                                        c = o.children.map((e => h(e, a))),
                                                            o.updateMatrixWorld(!0);
                                                        for (const e of c)
                                                            e.applyMatrix4(o.matrix)
                                                    }
                                                    let d = -1 / 0;
                                                    if (i)
                                                        for (const e of c)
                                                            for (let t = 0; t < e.attributes.position.array.length; t += 3)
                                                                d = Math.max(d, e.attributes.position.array[t + 1]);
                                                    for (const e of c) {
                                                        if (e.applyMatrix4((new Kn).makeScale(n ? -1 : 1, i ? -1 : 1, r ? -1 : 1)),
                                                        n || i || r) {
                                                            const t = e.index;
                                                            if (null != t)
                                                                for (let e = 0; e < t.count; e += 3) {
                                                                    const n = t.getX(e)
                                                                        , i = t.getX(e + 1)
                                                                        , r = t.getX(e + 2);
                                                                    t.setXYZ(e, n, r, i)
                                                                }
                                                            else {
                                                                const t = e.attributes.position;
                                                                for (let e = 0; e < t.count; e += 3) {
                                                                    const n = e
                                                                        , i = e + 1
                                                                        , r = e + 2
                                                                        , a = t.getX(n)
                                                                        , s = t.getY(n)
                                                                        , o = t.getZ(n)
                                                                        , l = t.getX(i)
                                                                        , c = t.getY(i)
                                                                        , h = t.getZ(i)
                                                                        , d = t.getX(r)
                                                                        , u = t.getY(r)
                                                                        , p = t.getZ(r);
                                                                    t.setXYZ(n, a, s, o),
                                                                        t.setXYZ(i, d, u, p),
                                                                        t.setXYZ(r, l, c, h)
                                                                }
                                                            }
                                                        }
                                                        i && e.translate(0, d, 0)
                                                    }
                                                    return c
                                                }
                                                function h(e, t) {
                                                    const n = e.material;
                                                    if (!(n instanceof zs))
                                                        throw new Error("Material is not a MeshStandardMaterial");
                                                    let i, r, a;
                                                    if (Object.prototype.hasOwnProperty.call(t, n.name)) {
                                                        const e = new Wi(t[n.name]);
                                                        i = e.r,
                                                            r = e.g,
                                                            a = e.b
                                                    } else
                                                        i = n.color.r,
                                                            r = n.color.g,
                                                            a = n.color.b;
                                                    const s = e.geometry.clone()
                                                        , o = new Float32Array(s.attributes.position.array.length);
                                                    for (let e = 0; e < o.length; e += 3)
                                                        o[e + 0] = i,
                                                            o[e + 1] = r,
                                                            o[e + 2] = a;
                                                    return s.attributes.color = new Ki(o,3),
                                                        s
                                                }
                                                let d = null;
                                                for (const e of t.colors) {
                                                    const i = [];
                                                    for (const [a,o,l] of t.models) {
                                                        const t = c(a, o, null !== (n = null == l ? void 0 : l.flipX) && void 0 !== n && n, null !== (r = null == l ? void 0 : l.flipY) && void 0 !== r && r, null !== (s = null == l ? void 0 : l.flipZ) && void 0 !== s && s, e.colors);
                                                        for (const e of t)
                                                            i.push(e)
                                                    }
                                                    const l = ul(i, !0).toNonIndexed();
                                                    l.computeVertexNormals();
                                                    const h = fl(l)
                                                        , u = new wr(h,a);
                                                    o.colors.set(e.id, u),
                                                    null != d || (d = l)
                                                }
                                                if (null == d)
                                                    throw new Error("Physics geometry is missing");
                                                if (!(d.attributes.position instanceof Ki))
                                                    throw new Error("Vertices must use BufferAttribute");
                                                o.physicsShapeVertices = new Float32Array(d.attributes.position.array),
                                                    e.loadedResource()
                                            }
                                        ))
                                        , o = yield Promise.all(Ny.map((e => s(e)))).then(( () => dD(this, void 0, void 0, (function*() {
                                                return yield uD(this, sD, "m", hD).call(this)
                                            }
                                        ))))
                                        , l = (e, t, n=null) => {
                                            let i = uD(this, lD, "f").get(e);
                                            null == i && (i = new Map,
                                                uD(this, lD, "f").set(e, i)),
                                            null == n && (n = (e, t) => e.x == t.x && e.y == t.y && e.z == t.z && e.rotation == t.rotation && e.rotationAxis == t.rotationAxis),
                                                i.set(t, n)
                                        }
                                    ;
                                    l(IA.BlockSlopeUp, IA.SlopeUp),
                                        l(IA.BlockSlopeUp, IA.SlopeUpLeftWide),
                                        l(IA.BlockSlopeUp, IA.SlopeUpRightWide),
                                        l(IA.BlockSlopeUp, IA.PlaneSlopeUp),
                                        l(IA.BlockSlopedUp, IA.Slope),
                                        l(IA.BlockSlopedUp, IA.SlopeLeftWide),
                                        l(IA.BlockSlopedUp, IA.SlopeRightWide),
                                        l(IA.BlockSlopedUp, IA.PlaneSlope),
                                        l(IA.BlockSlopeDown, IA.SlopeDown),
                                        l(IA.BlockSlopeDown, IA.SlopeDownLeftWide),
                                        l(IA.BlockSlopeDown, IA.SlopeDownRightWide),
                                        l(IA.BlockSlopeDown, IA.PlaneSlopeDown),
                                        l(IA.BlockSlopeDownLong, IA.SlopeDownLong),
                                        l(IA.BlockSlopeDownLong, IA.SlopeDownLongLeftWide),
                                        l(IA.BlockSlopeDownLong, IA.SlopeDownLongRightWide),
                                        l(IA.BlockSlopeDownLong, IA.PlaneSlopeDownLong),
                                        l(IA.BlockSlopeUpLong, IA.SlopeUpLong),
                                        l(IA.BlockSlopeUpLong, IA.SlopeUpLongLeftWide),
                                        l(IA.BlockSlopeUpLong, IA.SlopeUpLongRightWide),
                                        l(IA.BlockSlopeUpLong, IA.PlaneSlopeUpLong),
                                        l(IA.BlockSlopeVerticalTop, IA.WallTrackTop),
                                        l(IA.BlockSlopeVerticalInnerCornerTop, IA.WallTrackTopInnerCorner),
                                        l(IA.BlockSlopeVerticalInnerCornerBottom, IA.WallTrackBottomInnerCorner),
                                        l(IA.BlockInnerCorner, IA.WallTrackMiddleCorner);
                                    const c = (e, t) => e.x == t.x && e.y == t.y && e.z == t.z && e.rotation == t.rotation && e.rotationAxis == t.rotationAxis || e.x == t.x && e.y == t.y + 3 && e.z == t.z && e.rotation == t.rotation && (e.rotationAxis == RA.YPositive && t.rotationAxis == RA.YNegative || e.rotationAxis == RA.YNegative && t.rotationAxis == RA.YPositive || e.rotationAxis == RA.XPositive && t.rotationAxis == RA.XNegative || e.rotationAxis == RA.XNegative && t.rotationAxis == RA.XPositive || e.rotationAxis == RA.ZPositive && t.rotationAxis == RA.ZNegative || e.rotationAxis == RA.ZNegative && t.rotationAxis == RA.ZPositive);
                                    return l(IA.BlockSlopeVerticalBottom, IA.PlaneSlopeVerticalBottom, c),
                                        l(IA.BlockSlopeVerticalBottom, IA.WallTrackBottom, c),
                                        l(IA.BlockSlopeVerticalBottom, IA.SlopeUpVertical, c),
                                        l(IA.BlockSlopeVerticalBottom, IA.SlopeUpVerticalLeftWide, c),
                                        l(IA.BlockSlopeVerticalBottom, IA.SlopeUpVerticalRightWide, c),
                                        l(IA.BlockSlopeVerticalCornerBottom, IA.WallTrackBottomCorner),
                                        l(IA.BlockSlopeVerticalCornerTop, IA.WallTrackTopCorner),
                                        l(IA.BlockSlopeToVertical, IA.PlaneSlopeToVertical),
                                        l(IA.BlockSlopeToVertical, IA.WallTrackSlopeToVertical),
                                        l(IA.HalfBlock, IA.HalfBlock, ( (e, t) => e.rotation == (t.rotation + 2) % 4 && e.x == t.x && e.y == t.y && e.z == t.z && e.rotationAxis == t.rotationAxis)),
                                        l(IA.HalfBlock, IA.HalfPlane, ( (e, t) => e.rotation == (t.rotation + 2) % 4 && e.x == t.x && e.y == t.y && e.z == t.z && e.rotationAxis == t.rotationAxis)),
                                        l(IA.HalfBlock, IA.QuarterBlock, ( (e, t) => e.rotation != t.rotation && (e.rotation + 1) % 4 != t.rotation && e.x == t.x && e.y == t.y && e.z == t.z && e.rotationAxis == t.rotationAxis)),
                                        l(IA.HalfBlock, IA.QuarterPlane, ( (e, t) => e.rotation != t.rotation && (e.rotation + 1) % 4 != t.rotation && e.x == t.x && e.y == t.y && e.z == t.z && e.rotationAxis == t.rotationAxis)),
                                        l(IA.QuarterBlock, IA.QuarterBlock, ( (e, t) => e.rotation != t.rotation && e.x == t.x && e.y == t.y && e.z == t.z && e.rotationAxis == t.rotationAxis)),
                                        l(IA.QuarterBlock, IA.HalfPlane, ( (e, t) => e.rotation != t.rotation && e.rotation != (t.rotation + 1) % 4 && e.x == t.x && e.y == t.y && e.z == t.z && e.rotationAxis == t.rotationAxis)),
                                        l(IA.QuarterBlock, IA.QuarterPlane, ( (e, t) => e.rotation != t.rotation && e.x == t.x && e.y == t.y && e.z == t.z && e.rotationAxis == t.rotationAxis)),
                                        l(IA.HalfPlane, IA.HalfPlane, ( (e, t) => e.rotation == (t.rotation + 2) % 4 && e.x == t.x && e.y == t.y && e.z == t.z && e.rotationAxis == t.rotationAxis)),
                                        l(IA.HalfPlane, IA.QuarterPlane, ( (e, t) => e.rotation != t.rotation && (e.rotation + 1) % 4 != t.rotation && e.x == t.x && e.y == t.y && e.z == t.z && e.rotationAxis == t.rotationAxis)),
                                        l(IA.QuarterPlane, IA.QuarterPlane, ( (e, t) => e.rotation != t.rotation && e.x == t.x && e.y == t.y && e.z == t.z && e.rotationAxis == t.rotationAxis)),
                                        l(IA.WallTrackTopInnerCorner, IA.WallTrackCeilingCorner, ( (e, t) => {
                                                let n;
                                                switch (e.rotationAxis) {
                                                    case RA.YPositive:
                                                        n = new An(0,1,0);
                                                        break;
                                                    case RA.YNegative:
                                                        n = new An(0,-1,0);
                                                        break;
                                                    case RA.XPositive:
                                                        n = new An(1,0,0);
                                                        break;
                                                    case RA.XNegative:
                                                        n = new An(-1,0,0);
                                                        break;
                                                    case RA.ZPositive:
                                                        n = new An(0,0,1);
                                                        break;
                                                    case RA.ZNegative:
                                                        n = new An(0,0,-1);
                                                        break;
                                                    default:
                                                        throw new Error("Invalid rotation axis")
                                                }
                                                return e.rotation == t.rotation && e.x + 3 * n.x == t.x && e.y + 3 * n.y == t.y && e.z + 3 * n.z == t.z && e.rotationAxis == t.rotationAxis
                                            }
                                        )),
                                        l(IA.WallTrackTopInnerCorner, IA.WallTrackCeilingPlaneCorner, ( (e, t) => {
                                                let n;
                                                switch (e.rotationAxis) {
                                                    case RA.YPositive:
                                                        n = new An(0,1,0);
                                                        break;
                                                    case RA.YNegative:
                                                        n = new An(0,-1,0);
                                                        break;
                                                    case RA.XPositive:
                                                        n = new An(1,0,0);
                                                        break;
                                                    case RA.XNegative:
                                                        n = new An(-1,0,0);
                                                        break;
                                                    case RA.ZPositive:
                                                        n = new An(0,0,1);
                                                        break;
                                                    case RA.ZNegative:
                                                        n = new An(0,0,-1);
                                                        break;
                                                    default:
                                                        throw new Error("Invalid rotation axis")
                                                }
                                                return e.rotation == t.rotation && e.x + 3 * n.x == t.x && e.y + 3 * n.y == t.y && e.z + 3 * n.z == t.z && e.rotationAxis == t.rotationAxis
                                            }
                                        )),
                                        l(IA.WallTrackBottomInnerCorner, IA.WallTrackFloorCorner),
                                        l(IA.WallTrackBottomInnerCorner, IA.WallTrackFloorPlaneCorner),
                                        o
                                }
                            ))
                        }
                        isPartCombinationAllowed(e, t) {
                            const n = uD(this, sD, "m", cD).call(this, e.id, t.id);
                            if (null == n ? void 0 : n(e, t))
                                return !0;
                            const i = uD(this, sD, "m", cD).call(this, t.id, e.id);
                            return !!(null == i ? void 0 : i(t, e))
                        }
                        getPhysicsParts() {
                            var e, t;
                            const n = [];
                            for (const {configuration: i, physicsShapeVertices: r} of uD(this, oD, "f").values()) {
                                if (null == r)
                                    throw new Error("Part model has not been loaded yet");
                                n.push({
                                    id: i.id,
                                    vertices: r,
                                    detector: i.detector,
                                    startOffset: null !== (t = null === (e = i.startOffset) || void 0 === e ? void 0 : e.toArray()) && void 0 !== t ? t : null
                                })
                            }
                            return n
                        }
                        hasPart(e) {
                            return uD(this, oD, "f").has(e)
                        }
                        getPart(e) {
                            const t = uD(this, oD, "f").get(e);
                            if (null == t)
                                throw new Error('Track part with the id "' + e.toString() + '" does not exist');
                            return t
                        }
                        getAllParts() {
                            return Array.from(uD(this, oD, "f").values())
                        }
                        getPartStartOffset(e) {
                            var t, n;
                            const i = uD(this, oD, "f").get(e);
                            if (null == i)
                                throw new Error('Track part with the id "' + e.toString() + '" does not exist');
                            return null !== (n = null === (t = i.configuration.startOffset) || void 0 === t ? void 0 : t.clone()) && void 0 !== n ? n : null
                        }
                        getPartTypesWithDetector(e) {
                            const t = [];
                            for (const [n,i] of uD(this, oD, "f").entries())
                                null != i.configuration.detector && i.configuration.detector.type == e && t.push(n);
                            return t
                        }
                        getStartPartTypes() {
                            const e = [];
                            for (const [t,n] of uD(this, oD, "f").entries())
                                null != n.configuration.startOffset && e.push(t);
                            return e
                        }
                        getCategoryMesh(e, t) {
                            let n, i;
                            switch (e) {
                                case ky.Special:
                                    n = this.getPart(IA.Start);
                                    break;
                                case ky.Road:
                                    n = this.getPart(IA.Straight);
                                    break;
                                case ky.RoadTurns:
                                    n = this.getPart(IA.TurnShort);
                                    break;
                                case ky.RoadWide:
                                    n = this.getPart(IA.OuterCornerWide);
                                    break;
                                case ky.Plane:
                                    n = this.getPart(IA.Plane);
                                    break;
                                case ky.Block:
                                    n = this.getPart(IA.Block);
                                    break;
                                case ky.WallTrack:
                                    n = this.getPart(IA.WallTrackBottom);
                                    break;
                                case ky.Pillar:
                                    n = this.getPart(IA.PillarShort);
                                    break;
                                case ky.Sign:
                                    n = this.getPart(IA.SignArrowLeft)
                            }
                            switch (t) {
                                case by.Summer:
                                    i = CA.Summer;
                                    break;
                                case by.Winter:
                                    i = CA.Winter;
                                    break;
                                case by.Desert:
                                    i = CA.Desert
                            }
                            const r = n.colors.get(i);
                            if (null == r)
                                throw new Error("Category mesh is not loaded");
                            return r
                        }
                    }
                    oD = new WeakMap,
                        lD = new WeakMap,
                        sD = new WeakSet,
                        cD = function(e, t) {
                            var n;
                            const i = uD(this, lD, "f").get(e);
                            return null == i ? null : null !== (n = i.get(t)) && void 0 !== n ? n : null
                        }
                        ,
                        hD = function() {
                            return dD(this, void 0, void 0, (function*() {
                                    const e = Object.values(IA).filter((e => "string" != typeof e));
                                    let t = !0;
                                    for (const n of e) {
                                        const e = uD(this, oD, "f").get(n);
                                        if (null == e)
                                            throw new Error("Part with id " + n.toString() + " does not exist");
                                        const i = e.physicsShapeVertices;
                                        if (null == i)
                                            throw new Error("Part model with id " + n.toString() + " has not been loaded yet");
                                        const r = yield window.crypto.subtle.digest("SHA-256", i)
                                            , a = Array.from(new Uint8Array(r)).map((e => e.toString(16).padStart(2, "0"))).join("");
                                        a != e.configuration.checksum && (console.error("Part id " + n.toString() + " " + IA[n] + " checksum mismatch: " + a + " != " + e.configuration.checksum),
                                            t = !1)
                                    }
                                    return t
                                }
                            ))
                        }
                    ;
                    var fD = n(9207)
                        , mD = {};
                    mD.styleTagTransform = u(),
                        mD.setAttributes = l(),
                        mD.insert = s().bind(null, "head"),
                        mD.domAPI = r(),
                        mD.insertStyleElement = h();
                    t()(fD.A, mD);
                    fD.A && fD.A.locals && fD.A.locals;
                    var gD, vD, wD = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    }, AD = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    };
                    gD = new WeakMap,
                        vD = new WeakMap;
                    const yD = class {
                            constructor() {
                                gD.set(this, document.getElementById("transition-layer")),
                                    vD.set(this, null)
                            }
                            trigger(e) {
                                const t = wD(this, gD, "f");
                                if (null == t)
                                    throw new Error("Failed to find transition layer");
                                null == wD(this, vD, "f") && (t.style.opacity = "1",
                                    setTimeout(( () => {
                                            if (null != wD(this, vD, "f")) {
                                                const e = wD(this, vD, "f").call(this);
                                                null == e ? (t.style.opacity = "0",
                                                    AD(this, vD, null, "f")) : e.catch((e => {
                                                        console.error(e)
                                                    }
                                                )).finally(( () => {
                                                        t.style.opacity = "0",
                                                            AD(this, vD, null, "f")
                                                    }
                                                ))
                                            }
                                        }
                                    ), 250)),
                                    AD(this, vD, e, "f")
                            }
                        }
                    ;
                    var bD, xD, kD, ED, SD = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, MD = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    bD = new WeakMap,
                        xD = new WeakMap,
                        kD = new WeakMap,
                        ED = new WeakMap;
                    const TD = class {
                            constructor(e, t, n) {
                                bD.set(this, void 0),
                                    xD.set(this, void 0),
                                    kD.set(this, new jt(100 * Math.random(),100 * Math.random())),
                                    ED.set(this, new jt(100 * Math.random(),100 * Math.random())),
                                    SD(this, bD, t, "f"),
                                    n.addResource();
                                const i = (new vo).load("images/clouds.jpg", ( () => {
                                        n.loadedResource()
                                    }
                                ));
                                i.wrapT = re,
                                    i.wrapS = re;
                                const r = new Us(1e6,5,2,0,2 * Math.PI,0,Math.PI)
                                    , a = new Sr({
                                    defines: {
                                        CLOUDS_ENABLED: t.getSettingBoolean(Jo.CloudsEnabled)
                                    },
                                    uniforms: {
                                        scrollA: {
                                            value: MD(this, kD, "f")
                                        },
                                        scrollB: {
                                            value: MD(this, ED, "f")
                                        },
                                        sampler: {
                                            value: i
                                        },
                                        cloudDensity: {
                                            value: .6
                                        },
                                        cloudLight: {
                                            value: new An(.75,.75,.75)
                                        },
                                        sunPosition: {
                                            value: new An
                                        }
                                    },
                                    vertexShader: "\n\t\t\t\tvarying vec3 fPos;\n\t\t\t\t\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewPosition;\n\t\t\t\t\tgl_Position.z = 0.0;\n\t\t\t\t\tfPos = position;\n\t\t\t\t}\n\t\t\t",
                                    fragmentShader: "\n\t\t\t\tvarying vec3 fPos;\n\n\t\t\t\tuniform vec2 offset;\n\t\t\t\tuniform vec2 scrollA;\n\t\t\t\tuniform vec2 scrollB;\n\t\t\t\tuniform sampler2D sampler;\n\n\t\t\t\tuniform float cloudDensity;\n\t\t\t\tuniform vec3 cloudLight;\n\n\t\t\t\tuniform vec3 sunPosition;\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\t#ifdef CLOUDS_ENABLED\n\t\t\t\t\t\tfloat c00 = texture2D(sampler, vec2(fPos.x / ((fPos.y + 0.06) / 0.1) - scrollB.x * 0.981, fPos.z / ((fPos.y + 0.06) / 0.1) - scrollB.y * 1.041) + scrollA).r;\n\t\t\t\t\t\tfloat c10 = texture2D(sampler, vec2(fPos.x / ((fPos.y + 0.06) / 0.1) + scrollB.x * 0.821, fPos.z / ((fPos.y + 0.06) / 0.1) - scrollB.y * 0.951) + scrollA).r;\n\t\t\t\t\t\tfloat c01 = texture2D(sampler, vec2(fPos.x / ((fPos.y + 0.06) / 0.1) - scrollB.x * 1.043, fPos.z / ((fPos.y + 0.06) / 0.1) + scrollB.y * 0.899) + scrollA).r;\n\t\t\t\t\t\tfloat c11 = texture2D(sampler, vec2(fPos.x / ((fPos.y + 0.06) / 0.1) + scrollB.x * 0.901, fPos.z / ((fPos.y + 0.06) / 0.1) + scrollB.y * 1.045) + scrollA).r;\n\t\t\t\t\t\tfloat cloud = min(1.0, max(0.0, (c00 + c10 + c01 + c11) / 4.0 - (1.0 - cloudDensity)) * 3.0);\n\n\t\t\t\t\t\tvec3 cloudColor = vec3(min(1.0, (c00 + c10 + c01 + c11) / 4.0 - (1.0 - cloudDensity)) * 4.0 + cloudDensity) * cloudLight;\n\t\t\t\t\t\tfloat cloudIntensity = cloud * min(1.0, max(0.0, fPos.y * 2.0 / 1000000.0));\n\t\t\t\t\t#else\n\t\t\t\t\t\tvec3 cloudColor = vec3(0.0);\n\t\t\t\t\t\tfloat cloudIntensity = 0.0;\n\t\t\t\t\t#endif\n\t\t\t\t\t\n\t\t\t\t\tvec3 horizonColor = vec3(255.0 / 255.0, 255.0 / 255.0, 255.0 / 255.0);\n\t\t\t\t\tvec3 zenithColor = vec3(5.0 / 255.0, 140.0 / 255.0, 255.0 / 255.0);\n\t\t\t\t\tfloat h = pow(clamp(fPos.y / 1000000.0, 0.01, 1.0), 0.2);\n\t\t\t\t\tvec3 skyColor = zenithColor * h + horizonColor * (1.0 - h);\n\n\t\t\t\t\tvec3 normal = normalize(-fPos);\n\t\t\t\t\tfloat sun = pow(max(0.0, max(0.0, dot(normal, sunPosition)) - 0.999), 4.0) * 60000000000.0;\n\t\t\t\t\tvec3 sunColor = vec3(20.0 * sun, 20.0 * sun, 19.0 * sun);\n\n\t\t\t\t\tgl_FragColor = vec4((skyColor * (1.0 - cloudIntensity) + cloudColor * cloudIntensity) * max(vec3(0.0), vec3(1.0) - sunColor) + sunColor, 1.0);\n\t\t\t\t}\n\t\t\t"
                                });
                                a.side = 1,
                                    a.depthWrite = !1,
                                    SD(this, xD, new wr(r,a), "f"),
                                    MD(this, xD, "f").renderOrder = -3,
                                    MD(this, xD, "f").matrixAutoUpdate = !1,
                                    MD(this, xD, "f").updateMatrix(),
                                    e.scene.add(MD(this, xD, "f"))
                            }
                            update(e, t, n) {
                                MD(this, bD, "f").getSettingBoolean(Jo.CloudsEnabled) ? (MD(this, kD, "f").x += .00226 * e,
                                    MD(this, kD, "f").y += .001646 * e,
                                    MD(this, ED, "f").x += .001752 * e,
                                    MD(this, ED, "f").y += .001057 * e,
                                1 != MD(this, xD, "f").material.defines.CLOUDS_ENABLED && (MD(this, xD, "f").material.defines.CLOUDS_ENABLED = !0,
                                    MD(this, xD, "f").material.needsUpdate = !0)) : 0 != MD(this, xD, "f").material.defines.CLOUDS_ENABLED && (MD(this, xD, "f").material.defines.CLOUDS_ENABLED = !1,
                                    MD(this, xD, "f").material.needsUpdate = !0);
                                const i = n.getSunPosition();
                                MD(this, xD, "f").material.uniforms.sunPosition.value.copy(i.negate()),
                                    MD(this, xD, "f").position.copy(t.position),
                                    MD(this, xD, "f").updateMatrix()
                            }
                        }
                    ;
                    var CD, _D, ID, PD, RD, LD, ND, DD, BD, UD, zD, OD, FD, WD, HD, VD = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, GD = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    class jD {
                        constructor(e) {
                            CD.add(this),
                                ID.set(this, void 0),
                                VD(this, ID, null == e ? {
                                    getItem: e => window.localStorage.getItem(e),
                                    setItem: (e, t) => {
                                        window.localStorage.setItem(e, t)
                                    }
                                    ,
                                    removeItem: e => {
                                        window.localStorage.removeItem(e)
                                    }
                                    ,
                                    getAllKeys: () => Object.keys(window.localStorage)
                                } : e, "f")
                        }
                        migrate() {
                            GD(this, CD, "m", DD).call(this)
                        }
                        saveRecord(e, t, n, i, r, a, s) {
                            if (!Number.isSafeInteger(e) || e < 0)
                                throw new Error("Profile slot is invalid");
                            try {
                                let o;
                                o = s == gP.Ok ? GD(_D, _D, "f", BD) + e.toString() + "_default_" + n : GD(_D, _D, "f", BD) + e.toString() + "_undeterministic_" + n,
                                    GD(this, ID, "f").setItem(o, JSON.stringify({
                                        uploadId: i,
                                        tokenHash: t,
                                        frames: r.numberOfFrames.toString(),
                                        recording: a.serialize()
                                    }))
                            } catch (e) {
                                console.error(e)
                            }
                        }
                        loadRecord(e, t, n, i) {
                            if (!Number.isSafeInteger(e) || e < 0)
                                throw new Error("Profile slot is invalid");
                            try {
                                let r;
                                r = i == gP.Ok ? GD(_D, _D, "f", BD) + e.toString() + "_default_" + n : GD(_D, _D, "f", BD) + e.toString() + "_undeterministic_" + n;
                                const a = GD(this, ID, "f").getItem(r);
                                if (null == a)
                                    return null;
                                const s = JSON.parse(a);
                                if ("object" != typeof s)
                                    return null;
                                if (!("uploadId"in s))
                                    return null;
                                let o;
                                if (null == s.uploadId)
                                    o = null;
                                else if (o = Number.parseInt(s.uploadId, 10),
                                    !Number.isSafeInteger(o))
                                    return null;
                                if (!("tokenHash"in s))
                                    return null;
                                const l = s.tokenHash;
                                if ("string" != typeof l)
                                    return null;
                                if (l != t)
                                    return null;
                                if (!("frames"in s))
                                    return null;
                                const c = Number.parseInt(s.frames, 10);
                                if (!Number.isSafeInteger(c))
                                    return null;
                                const h = new xp(c);
                                if (!("recording"in s))
                                    return null;
                                const d = cv.deserialize(s.recording);
                                return null == d ? null : {
                                    uploadId: o,
                                    time: h,
                                    recording: d
                                }
                            } catch (e) {
                                console.error(e)
                            }
                            return null
                        }
                        deleteAllRecords(e) {
                            if (!Number.isSafeInteger(e) || e < 0)
                                throw new Error("Profile slot is invalid");
                            try {
                                const t = GD(this, ID, "f").getAllKeys();
                                for (const n of t)
                                    n.startsWith(GD(_D, _D, "f", BD) + e.toString() + "_") && GD(this, ID, "f").removeItem(n)
                            } catch (e) {
                                console.error(e)
                            }
                        }
                        deleteAllRecordsForTrack(e) {
                            for (let t = 0; t < 3; t++)
                                try {
                                    GD(this, ID, "f").removeItem(GD(_D, _D, "f", BD) + t.toString() + "_" + e)
                                } catch (e) {
                                    console.error(e)
                                }
                        }
                        saveCustomTrack(e, t, n) {
                            const i = t.toExportString(e);
                            try {
                                return GD(this, ID, "f").setItem(GD(_D, _D, "f", UD) + e.name, JSON.stringify({
                                    data: i,
                                    saveTime: n.getTime()
                                })),
                                    !0
                            } catch (e) {
                                return console.error(e),
                                    !1
                            }
                        }
                        loadCustomTrack(e) {
                            let t, n;
                            try {
                                const i = GD(this, ID, "f").getItem(GD(_D, _D, "f", UD) + e);
                                if (null == i)
                                    return null;
                                const r = JSON.parse(i);
                                if ("string" != typeof r.data)
                                    return null;
                                if ("number" != typeof r.saveTime)
                                    return null;
                                t = r.data,
                                    n = r.saveTime
                            } catch (e) {
                                return console.error(e),
                                    null
                            }
                            const i = eb.fromExportString(t);
                            return null == i ? null : {
                                trackMetadata: i.trackMetadata,
                                trackData: i.trackData,
                                saveTime: n
                            }
                        }
                        deleteCustomTrack(e) {
                            try {
                                return GD(this, ID, "f").removeItem(GD(_D, _D, "f", UD) + e),
                                    !0
                            } catch (e) {
                                return console.error(e),
                                    !1
                            }
                        }
                        getAllCustomTrackNames() {
                            let e;
                            try {
                                e = GD(this, ID, "f").getAllKeys()
                            } catch (e) {
                                return console.error(e),
                                    null
                            }
                            return e.filter((e => e.startsWith(GD(_D, _D, "f", UD)))).map((e => e.substring(GD(_D, _D, "f", UD).length)))
                        }
                        saveUserProfileSlot(e) {
                            if (!Number.isSafeInteger(e) || e < 0)
                                throw new Error("Profile slot is invalid");
                            try {
                                GD(this, ID, "f").setItem(GD(_D, _D, "f", zD), JSON.stringify(e))
                            } catch (e) {
                                console.error(e)
                            }
                        }
                        loadUserProfileSlot() {
                            try {
                                const e = GD(this, ID, "f").getItem(GD(_D, _D, "f", zD));
                                if (null != e)
                                    try {
                                        const t = JSON.parse(e);
                                        if (!Number.isSafeInteger(t) || t < 0)
                                            throw new Error("Profile slot is invalid");
                                        return t
                                    } catch (e) {
                                        console.error(e)
                                    }
                            } catch (e) {
                                console.error(e)
                            }
                            return null
                        }
                        saveUserProfile(e, t, n, i) {
                            if (!Number.isSafeInteger(e) || e < 0)
                                throw new Error("Profile slot is invalid");
                            try {
                                GD(this, ID, "f").setItem(GD(_D, _D, "f", OD) + e.toString(), JSON.stringify({
                                    token: t,
                                    nickname: n,
                                    carColors: i.serialize()
                                }))
                            } catch (e) {
                                console.error(e)
                            }
                        }
                        loadUserProfile(e) {
                            if (!Number.isSafeInteger(e) || e < 0)
                                throw new Error("Profile slot is invalid");
                            try {
                                const t = GD(this, ID, "f").getItem(GD(_D, _D, "f", OD) + e.toString());
                                if (null != t) {
                                    const e = JSON.parse(t);
                                    if ("object" != typeof e)
                                        throw new Error("User profile is not an object");
                                    if ("string" != typeof e.token)
                                        throw new Error("User profile token field has invalid type");
                                    if ("string" != typeof e.nickname)
                                        throw new Error("User profile nickname field has invalid type");
                                    if ("string" != typeof e.carColors)
                                        throw new Error("User profile carColors field has invalid type");
                                    return {
                                        token: e.token,
                                        nickname: e.nickname,
                                        carColors: Iu.deserialize(e.carColors)
                                    }
                                }
                            } catch (e) {
                                console.error(e)
                            }
                            return null
                        }
                        deleteUserProfile(e) {
                            try {
                                GD(this, ID, "f").removeItem(GD(_D, _D, "f", OD) + e.toString())
                            } catch (e) {
                                console.error(e)
                            }
                        }
                        saveSettings(e) {
                            try {
                                const t = [];
                                for (const [n,i] of e.entries())
                                    t.push([Jo[n], i]);
                                GD(this, ID, "f").setItem(GD(_D, _D, "f", FD), JSON.stringify(t))
                            } catch (e) {
                                console.error(e)
                            }
                        }
                        loadSettings() {
                            try {
                                const e = GD(this, ID, "f").getItem(GD(_D, _D, "f", FD));
                                if (null == e)
                                    return null;
                                const t = JSON.parse(e);
                                if (!Array.isArray(t))
                                    return null;
                                const n = [];
                                for (const e of t) {
                                    if (!Array.isArray(e))
                                        continue;
                                    if (2 != e.length)
                                        continue;
                                    if ("string" != typeof e[0])
                                        continue;
                                    const t = e[0];
                                    if (!(t in Jo))
                                        continue;
                                    const i = Jo[t]
                                        , r = e[1];
                                    "string" == typeof e[1] && n.push([i, r])
                                }
                                return n
                            } catch (e) {
                                console.error(e)
                            }
                            return null
                        }
                        saveKeyBindings(e) {
                            try {
                                const t = [];
                                for (const [n,i] of e.entries())
                                    t.push([sx[n], i]);
                                GD(this, ID, "f").setItem(GD(_D, _D, "f", WD), JSON.stringify(t))
                            } catch (e) {
                                console.error(e)
                            }
                        }
                        loadKeyBindings() {
                            try {
                                const e = GD(this, ID, "f").getItem(GD(_D, _D, "f", WD));
                                if (null == e)
                                    return null;
                                const t = JSON.parse(e);
                                if (!Array.isArray(t))
                                    return null;
                                const n = [];
                                for (const e of t) {
                                    if (!Array.isArray(e))
                                        continue;
                                    if (2 != e.length)
                                        continue;
                                    if ("string" != typeof e[0])
                                        continue;
                                    const t = e[0];
                                    if (!(t in sx))
                                        continue;
                                    const i = sx[t]
                                        , r = e[1];
                                    Array.isArray(r) && (2 == r.length && (null !== r[0] && "string" != typeof r[0] || null !== r[1] && "string" != typeof r[1] || n.push([i, r])))
                                }
                                return n
                            } catch (e) {
                                console.error(e)
                            }
                            return null
                        }
                        saveTrackSelectionTab(e) {
                            try {
                                GD(this, ID, "f").setItem(GD(_D, _D, "f", HD), e)
                            } catch (e) {
                                console.error(e)
                            }
                        }
                        loadTrackSelectionTab() {
                            try {
                                const e = GD(this, ID, "f").getItem(GD(_D, _D, "f", HD));
                                if ("official" == e || "community" == e || "custom" == e)
                                    return e
                            } catch (e) {
                                console.error(e)
                            }
                            return "official"
                        }
                    }
                    _D = jD,
                        ID = new WeakMap,
                        CD = new WeakSet,
                        RD = function(e, t, n) {
                            null == this.loadUserProfile(0) && this.saveUserProfile(0, null != e ? e : HR.createToken(), t, n)
                        }
                        ,
                        LD = function(e) {
                            const t = this.loadUserProfile(0);
                            null == t ? this.saveUserProfile(0, HR.createToken(), HR.defaultNickname, e) : this.saveUserProfile(0, t.token, t.nickname, e)
                        }
                        ,
                        DD = function() {
                            try {
                                if (null != GD(this, ID, "f").getItem(GD(_D, _D, "f", ND)))
                                    return "v4";
                                if (null != GD(this, ID, "f").getItem("polytrack_v3_migrated"))
                                    return "v3"
                            } catch (e) {
                                console.error(e)
                            }
                            return null
                        }
                        ,
                        PD = {
                            value: ( () => {
                                    let e = "polytrack_v4_";
                                    return e += "beta_",
                                        e
                                }
                            )()
                        },
                        ND = {
                            value: GD(_D, _D, "f", PD) + "migrated"
                        },
                        BD = {
                            value: GD(_D, _D, "f", PD) + "record" + ru.toString() + "_"
                        },
                        UD = {
                            value: GD(_D, _D, "f", PD) + "track_"
                        },
                        zD = {
                            value: GD(_D, _D, "f", PD) + "user_slot"
                        },
                        OD = {
                            value: GD(_D, _D, "f", PD) + "user_"
                        },
                        FD = {
                            value: GD(_D, _D, "f", PD) + "settings"
                        },
                        WD = {
                            value: GD(_D, _D, "f", PD) + "key_bindings"
                        },
                        HD = {
                            value: GD(_D, _D, "f", PD) + "selected_track_tab"
                        };
                    const QD = jD;
                    var YD, qD, KD, XD, ZD, JD, $D, eB = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, tB = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    class nB {
                        constructor() {
                            YD.add(this),
                                KD.set(this, void 0),
                                XD.set(this, !1),
                                ZD.set(this, null);
                            const e = document.getElementById("ui");
                            if (null == e)
                                throw new Error("Failed to find UI element");
                            eB(this, KD, e, "f"),
                                window.addEventListener("mousemove", ( () => {
                                        document.body.classList.remove("hide-cursor"),
                                        tB(this, XD, "f") && (null != tB(this, ZD, "f") && clearTimeout(tB(this, ZD, "f")),
                                            eB(this, ZD, setTimeout(( () => {
                                                    document.body.classList.add("hide-cursor"),
                                                        eB(this, ZD, null, "f")
                                                }
                                            ), tB(qD, qD, "f", JD)), "f"))
                                    }
                                )),
                                document.addEventListener("gesturestart", (function(e) {
                                        e.preventDefault()
                                    }
                                )),
                                window.addEventListener("resize", ( () => {
                                        tB(this, YD, "m", $D).call(this)
                                    }
                                )),
                                tB(this, YD, "m", $D).call(this)
                        }
                        setCursorHiddenWhenInactive(e) {
                            eB(this, XD, e, "f"),
                                e ? eB(this, ZD, setTimeout(( () => {
                                        document.body.classList.add("hide-cursor"),
                                            eB(this, ZD, null, "f")
                                    }
                                ), tB(qD, qD, "f", JD)), "f") : (document.body.classList.remove("hide-cursor"),
                                null != tB(this, ZD, "f") && (clearTimeout(tB(this, ZD, "f")),
                                    eB(this, ZD, null, "f")))
                        }
                    }
                    qD = nB,
                        KD = new WeakMap,
                        XD = new WeakMap,
                        ZD = new WeakMap,
                        YD = new WeakSet,
                        $D = function() {
                            const e = Math.max(.01, Math.min(window.innerWidth, 1.4375 * window.innerHeight) / 1150);
                            e < 1 ? (tB(this, KD, "f").style.width = "calc(100% / " + e.toString() + ")",
                                tB(this, KD, "f").style.height = "calc(100% / " + e.toString() + ")",
                                tB(this, KD, "f").style.transform = "scale(" + e.toString() + ")") : (tB(this, KD, "f").style.width = "",
                                tB(this, KD, "f").style.height = "",
                                tB(this, KD, "f").style.transform = "")
                        }
                        ,
                        JD = {
                            value: 1e3
                        };
                    const iB = nB;
                    var rB, aB, sB = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    rB = new WeakMap,
                        aB = new WeakMap;
                    const oB = class {
                            constructor() {
                                this.determinismState = gP.Uninitialized,
                                    rB.set(this, 2e4),
                                    aB.set(this, 1e4)
                            }
                            getLeaderboard(e, t, n, i, r) {
                                let a = $d + "leaderboard?version=" + nu + "&trackId=" + t + "&skip=" + n.toString() + "&amount=" + i.toString() + "&onlyVerified=" + r.toString();
                                return this.determinismState == gP.Ok && (a += "&userTokenHash=" + encodeURIComponent(e)),
                                    new Promise(( (t, n) => {
                                            const i = new XMLHttpRequest;
                                            i.timeout = sB(this, rB, "f"),
                                                i.overrideMimeType("text/plain"),
                                                i.onreadystatechange = () => {
                                                    if (i.readyState == XMLHttpRequest.DONE)
                                                        if (200 == i.status)
                                                            try {
                                                                const r = JSON.parse(i.responseText)
                                                                    , a = r.total;
                                                                if ("number" != typeof a)
                                                                    return void n(new Error("Total is not a number"));
                                                                if (!Number.isSafeInteger(a))
                                                                    return void n(new Error("Total is not a safe integer"));
                                                                const s = r.entries;
                                                                if (!Array.isArray(s))
                                                                    return void n(new Error("Entries is not an array"));
                                                                const o = [];
                                                                for (const t of s) {
                                                                    if (null == t)
                                                                        return void n(new Error("Entry is missing"));
                                                                    if (!Object.prototype.hasOwnProperty.call(t, "id"))
                                                                        return void n(new Error('Entry is missing "id" field'));
                                                                    if (!Object.prototype.hasOwnProperty.call(t, "userId"))
                                                                        return void n(new Error('Entry is missing "userId" field'));
                                                                    if (!Object.prototype.hasOwnProperty.call(t, "name"))
                                                                        return void n(new Error('Entry is missing "name" field'));
                                                                    if (!Object.prototype.hasOwnProperty.call(t, "frames"))
                                                                        return void n(new Error('Entry is missing "frames" field'));
                                                                    if (!Object.prototype.hasOwnProperty.call(t, "carColors"))
                                                                        return void n(new Error('Entry is missing "carColors" field'));
                                                                    if (!Object.prototype.hasOwnProperty.call(t, "verifiedState"))
                                                                        return void n(new Error('Entry is missing "verifiedState" field'));
                                                                    if ("number" != typeof t.id)
                                                                        return void n(new Error('"id" field has incorrect type'));
                                                                    if ("string" != typeof t.userId)
                                                                        return void n(new Error('"userId" field has incorrect type'));
                                                                    if ("string" != typeof t.name)
                                                                        return void n(new Error('"name" field has incorrect type'));
                                                                    if ("number" != typeof t.frames)
                                                                        return void n(new Error('"frames" field has incorrect type'));
                                                                    if (!Number.isSafeInteger(t.frames) || t.frames <= 0 || t.frames > cv.maxFrames)
                                                                        return void n(new Error('"frames" field has an invalid value'));
                                                                    if ("string" != typeof t.carColors)
                                                                        return void n(new Error('"carColors" field has incorrect type'));
                                                                    if (!Number.isSafeInteger(t.verifiedState) || t.verifiedState < 0)
                                                                        return void n(new Error('"verifiedState" field has an invalid value'));
                                                                    o.push({
                                                                        id: t.id,
                                                                        name: t.name,
                                                                        time: new xp(t.frames),
                                                                        carColors: Iu.deserialize(t.carColors),
                                                                        verifiedState: t.verifiedState,
                                                                        isSelf: t.userId == e
                                                                    })
                                                                }
                                                                let l = null;
                                                                if (null != r.userEntry) {
                                                                    const e = r.userEntry.position;
                                                                    if ("number" != typeof e)
                                                                        return void n(new Error("User position is not a number"));
                                                                    if (!Number.isSafeInteger(e))
                                                                        return void n(new Error("User position is not a safe integer"));
                                                                    const t = r.userEntry.frames;
                                                                    if ("number" != typeof t)
                                                                        return void n(new Error("User frames is not a number"));
                                                                    if (!Number.isSafeInteger(t))
                                                                        return void n(new Error("User frames is not a safe integer"));
                                                                    const i = new xp(t)
                                                                        , a = r.userEntry.id;
                                                                    if ("number" != typeof a)
                                                                        return void n(new Error("User record id is not a number"));
                                                                    if (!Number.isSafeInteger(a))
                                                                        return void n(new Error("User record id is not a safe integer"));
                                                                    l = {
                                                                        position: e,
                                                                        time: i,
                                                                        id: a
                                                                    }
                                                                }
                                                                t({
                                                                    total: a,
                                                                    entries: o,
                                                                    userEntry: l
                                                                })
                                                            } catch (e) {
                                                                n(new Error("Unknown error: " + String(e)))
                                                            }
                                                        else
                                                            n(new Error("Failed to connect to server, status: " + i.status.toString()))
                                                }
                                                ,
                                                i.open("GET", a, !0),
                                                i.send()
                                        }
                                    ))
                            }
                            getRecordings(e) {
                                const t = $d + "recordings?version=" + nu + "&recordingIds=" + e.join(",");
                                return new Promise(( (e, n) => {
                                        if (this.determinismState != gP.Ok)
                                            n(new Error("Getting recordings not allowed"));
                                        else {
                                            const i = new XMLHttpRequest;
                                            i.timeout = sB(this, rB, "f"),
                                                i.overrideMimeType("text/plain"),
                                                i.onreadystatechange = () => {
                                                    if (i.readyState == XMLHttpRequest.DONE)
                                                        if (200 == i.status)
                                                            try {
                                                                const t = JSON.parse(i.responseText);
                                                                if (!Array.isArray(t))
                                                                    return void n(new Error("Response is not an array"));
                                                                const r = [];
                                                                for (const e of t) {
                                                                    if (null == e) {
                                                                        r.push(null);
                                                                        continue
                                                                    }
                                                                    if ("object" != typeof e || Array.isArray(e))
                                                                        return void n(new Error("JSON item is not an object"));
                                                                    if ("string" != typeof e.recording)
                                                                        return void n(new Error("JSON item recording field has incorrect type"));
                                                                    const t = cv.deserialize(e.recording);
                                                                    if (null == t)
                                                                        return void n(new Error("Failed to deserialize recording"));
                                                                    if ("number" != typeof e.verifiedState)
                                                                        return void n(new Error("JSON item verifiedState field has incorrect type"));
                                                                    const i = e.verifiedState;
                                                                    if (!Number.isSafeInteger(i) || i < 0)
                                                                        return void n(new Error("JSON item verifiedState is not a safe integer"));
                                                                    if ("number" != typeof e.frames)
                                                                        return void n(new Error("JSON item frames field has incorrect type"));
                                                                    const a = e.frames;
                                                                    if (!Number.isSafeInteger(a) || a <= 0 || a > cv.maxFrames)
                                                                        return void n(new Error("JSON item frames is not a safe integer"));
                                                                    const s = new xp(a);
                                                                    if ("string" != typeof e.carColors)
                                                                        return void n(new Error("JSON item carColors field has incorrect type"));
                                                                    const o = Iu.deserialize(e.carColors);
                                                                    r.push({
                                                                        recording: t,
                                                                        time: s,
                                                                        verifiedState: i,
                                                                        carColors: o
                                                                    })
                                                                }
                                                                e(r)
                                                            } catch (e) {
                                                                n(new Error("Unknown error: " + String(e)))
                                                            }
                                                        else
                                                            n(new Error("Failed to connect to server, status: " + i.status.toString()))
                                                }
                                                ,
                                                i.open("GET", t, !0),
                                                i.send()
                                        }
                                    }
                                ))
                            }
                            submitLeaderboard(e, t, n, i, r, a) {
                                return new Promise(( (s, o) => {
                                        if (this.determinismState != gP.Ok)
                                            o(new Error("Submit not allowed"));
                                        else {
                                            const l = a.serialize();
                                            if (l.length >= sB(this, aB, "f"))
                                                o(new Error("Recording is too large"));
                                            else {
                                                const a = $d + "leaderboard"
                                                    , c = "version=" + nu + "&userToken=" + encodeURIComponent(e) + "&name=" + encodeURIComponent(t) + "&carColors=" + n.serialize() + "&trackId=" + i + "&frames=" + r.numberOfFrames.toString() + "&recording=" + l
                                                    , h = new XMLHttpRequest;
                                                h.timeout = sB(this, rB, "f"),
                                                    h.overrideMimeType("text/plain"),
                                                    h.onreadystatechange = () => {
                                                        if (4 == h.readyState)
                                                            if (200 == h.status)
                                                                try {
                                                                    const e = JSON.parse(h.responseText);
                                                                    if (null == e)
                                                                        s({
                                                                            uploadId: null
                                                                        });
                                                                    else {
                                                                        const t = Number.parseInt(e, 10);
                                                                        Number.isSafeInteger(t) ? s({
                                                                            uploadId: t
                                                                        }) : o(new Error("UploadId is not a safe integer"))
                                                                    }
                                                                } catch (e) {
                                                                    o(new Error("Unknown error: " + String(e)))
                                                                }
                                                            else
                                                                o(new Error("Failed to connect to server, status: " + h.status.toString()))
                                                    }
                                                    ,
                                                    h.open("POST", a, !0),
                                                    h.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"),
                                                    h.send(c)
                                            }
                                        }
                                    }
                                ))
                            }
                            submitUserProfile(e, t, n) {
                                return new Promise(( (i, r) => {
                                        const a = $d + "user"
                                            , s = "version=" + nu + "&userToken=" + encodeURIComponent(e) + "&name=" + encodeURIComponent(t) + "&carColors=" + n.serialize()
                                            , o = new XMLHttpRequest;
                                        o.timeout = sB(this, rB, "f"),
                                            o.overrideMimeType("text/plain"),
                                            o.onreadystatechange = () => {
                                                4 == o.readyState && (200 == o.status ? i() : r(new Error("Failed to connect to server, status: " + o.status.toString())))
                                            }
                                            ,
                                            o.open("POST", a, !0),
                                            o.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"),
                                            o.send(s)
                                    }
                                ))
                            }
                            verifyRecordings(e, t, n, i, r) {
                                return new Promise(( (a, s) => {
                                        if (this.determinismState != gP.Ok)
                                            s(new Error("Submit not allowed"));
                                        else {
                                            const o = $d + "verifyRecordings"
                                                , l = "version=" + nu + "&userToken=" + encodeURIComponent(e) + (null != t ? "&trackId=" + t : "") + "&maxFrames=" + n.toString() + "&getEstimatedRemaining=" + i.toString() + "&recordings=" + encodeURIComponent(JSON.stringify(r))
                                                , c = new XMLHttpRequest;
                                            c.timeout = sB(this, rB, "f"),
                                                c.overrideMimeType("text/plain"),
                                                c.onreadystatechange = () => {
                                                    if (4 == c.readyState)
                                                        if (200 == c.status)
                                                            try {
                                                                if ("" == c.responseText)
                                                                    return void a({
                                                                        unverifiedRecordings: [],
                                                                        exhaustive: !0,
                                                                        estimatedRemaining: 0
                                                                    });
                                                                const e = JSON.parse(c.responseText);
                                                                if (!("exhaustive"in e))
                                                                    return void s(new Error('Field "exhaustive" does not exist'));
                                                                const t = 1 == e.exhaustive;
                                                                if (!("estimatedRemaining"in e))
                                                                    return void s(new Error('Field "estimatedRemaining" does not exist'));
                                                                let n;
                                                                if (null == e.estimatedRemaining)
                                                                    n = null;
                                                                else if (n = parseInt(e.estimatedRemaining, 10),
                                                                !Number.isSafeInteger(n) || n < 0)
                                                                    return void s(new Error("Estimated remaining is not a valid integer"));
                                                                if (!("unverifiedRecordings"in e))
                                                                    return void s(new Error('Field "unverifiedRecordings" does not exist'));
                                                                const i = e.unverifiedRecordings;
                                                                if (!Array.isArray(i))
                                                                    return void s(new Error('Field "unverifiedRecordings" is not an array'));
                                                                for (const e of i) {
                                                                    if ("object" != typeof e)
                                                                        return void s(new Error("Recording is not an object"));
                                                                    if ("number" != typeof e.id || !Number.isSafeInteger(e.id))
                                                                        return void s(new Error("Recording id is not a valid integer"));
                                                                    if ("string" != typeof e.recording)
                                                                        return void s(new Error("Recording recording is not a string"));
                                                                    if ("number" != typeof e.frames || !Number.isSafeInteger(e.frames) || e.frames <= 0 || e.frames > cv.maxFrames)
                                                                        return void s(new Error("Recording frames is not a valid integer"))
                                                                }
                                                                a({
                                                                    unverifiedRecordings: i,
                                                                    exhaustive: t,
                                                                    estimatedRemaining: n
                                                                })
                                                            } catch (e) {
                                                                s(new Error("Unknown error: " + String(e)))
                                                            }
                                                        else
                                                            403 == c.status ? s(new Error("User is not a verifier")) : s(new Error("Failed to connect to server, status: " + c.status.toString()))
                                                }
                                                ,
                                                c.open("POST", o, !0),
                                                c.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"),
                                                c.send(l)
                                        }
                                    }
                                ))
                            }
                            getUser(e) {
                                return new Promise(( (t, n) => {
                                        const i = $d + "user?version=" + nu + "&userToken=" + encodeURIComponent(e)
                                            , r = new XMLHttpRequest;
                                        r.timeout = sB(this, rB, "f"),
                                            r.overrideMimeType("text/plain"),
                                            r.onreadystatechange = () => {
                                                if (r.readyState == XMLHttpRequest.DONE)
                                                    if (200 == r.status)
                                                        try {
                                                            const e = JSON.parse(r.responseText);
                                                            if (null == e)
                                                                return void t(null);
                                                            const i = e.name;
                                                            if ("string" != typeof i)
                                                                return void n(new Error("Name is not a string"));
                                                            const a = VR(i);
                                                            if (0 == a || a > 50)
                                                                return void n(new Error("Name as invalid length"));
                                                            const s = e.carColors;
                                                            if ("string" != typeof s)
                                                                return void n(new Error("CarColors data is not a string"));
                                                            const o = Iu.deserialize(s)
                                                                , l = e.isVerifier;
                                                            if ("boolean" != typeof l)
                                                                return void n(new Error("IsVerifier is not a boolean"));
                                                            t({
                                                                name: i,
                                                                carColors: o,
                                                                isVerifier: l
                                                            })
                                                        } catch (e) {
                                                            n(new Error("Unknown error: " + String(e)))
                                                        }
                                                    else
                                                        n(new Error("Failed to connect to server, status: " + r.status.toString()))
                                            }
                                            ,
                                            r.open("GET", i, !0),
                                            r.send()
                                    }
                                ))
                            }
                        }
                    ;
                    var lB, cB, hB, dB, uB, pB = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, fB = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    cB = new WeakMap,
                        hB = new WeakMap,
                        dB = new WeakMap,
                        lB = new WeakSet,
                        uB = function(e) {
                            for (const [t,n] of e) {
                                if (!fB(this, dB, "f").has(t))
                                    throw new Error("Key binding is missing");
                                fB(this, dB, "f").set(t, n)
                            }
                        }
                    ;
                    const mB = class {
                            constructor(e) {
                                lB.add(this),
                                    cB.set(this, void 0),
                                    hB.set(this, this.defaultSettings()),
                                    dB.set(this, this.defaultKeyBindings()),
                                    pB(this, cB, e, "f");
                                const t = e.loadSettings();
                                null != t && this.updateSettings(t);
                                const n = e.loadKeyBindings();
                                null != n && fB(this, lB, "m", uB).call(this, n)
                            }
                            defaultSettings() {
                                return new Map([[Jo.ImperialUnitsEnabled, "false"], [Jo.ResetHintEnabled, "true"], [Jo.GhostCarEnabled, "true"], [Jo.DefaultCameraMode, "false"], [Jo.CockpitCameraToggle, "true"], [Jo.Checkpoints, "bottom"], [Jo.Timer, "bottom"], [Jo.Speedometer, "bottom"], [Jo.Language, "en-US"], [Jo.CarShadowQuality, "2048"], [Jo.TrackShadowEnabled, "true"], [Jo.CloudsEnabled, "true"], [Jo.ParticlesEnabled, "true"], [Jo.SkidmarksEnabled, "true"], [Jo.RenderScale, "1"], [Jo.Antialiasing, "true"], [Jo.SoundEffectVolume, "1"], [Jo.MusicVolume, "1"], [Jo.CheckpointVolume, "1"]])
                            }
                            defaultKeyBindings() {
                                return new Map([[sx.VehicleAccelerate, ["KeyW", "ArrowUp"]], [sx.VehicleTurnRight, ["KeyD", "ArrowRight"]], [sx.VehicleBrake, ["KeyS", "ArrowDown"]], [sx.VehicleTurnLeft, ["KeyA", "ArrowLeft"]], [sx.VehicleCheckpointReset, ["KeyR", "Enter"]], [sx.VehicleStartReset, ["KeyT", "Backspace"]], [sx.VehicleCockpitCamera, ["KeyC", "KeyM"]], [sx.ToggleUI, ["KeyH", null]], [sx.Pause, ["KeyP", "Space"]], [sx.EditorRotatePart, ["KeyR", "Space"]], [sx.EditorHeightModifier, ["ShiftLeft", "ShiftRight"]], [sx.EditorDelete, ["Delete", "KeyX"]], [sx.EditorMoveForwards, ["KeyW", "ArrowUp"]], [sx.EditorMoveRight, ["KeyD", "ArrowRight"]], [sx.EditorMoveBackwards, ["KeyS", "ArrowDown"]], [sx.EditorMoveLeft, ["KeyA", "ArrowLeft"]], [sx.EditorRotateViewLeft, ["KeyQ", null]], [sx.EditorRotateViewRight, ["KeyE", null]], [sx.EditorMoveDown, ["KeyZ", null]], [sx.EditorMoveUp, ["KeyC", null]], [sx.EditorTest, ["KeyT", null]], [sx.EditorPick, ["KeyG", null]], [sx.ToggleFpsCounter, ["Comma", null]], [sx.ToggleSpectatorCamera, ["Period", null]], [sx.SpectatorMoveForwards, ["KeyW", "ArrowUp"]], [sx.SpectatorMoveRight, ["KeyD", "ArrowRight"]], [sx.SpectatorMoveBackwards, ["KeyS", "ArrowDown"]], [sx.SpectatorMoveLeft, ["KeyA", "ArrowLeft"]], [sx.SpectatorSpeedModifier, ["ShiftLeft", "ShiftRight"]]])
                            }
                            getSettings() {
                                return Array.from(fB(this, hB, "f"))
                            }
                            getSetting(e) {
                                const t = fB(this, hB, "f").get(e);
                                if (null == t)
                                    throw new Error("Setting name is missing");
                                return t
                            }
                            getSettingBoolean(e) {
                                return "true" == this.getSetting(e)
                            }
                            getSettingFloat(e) {
                                return parseFloat(this.getSetting(e))
                            }
                            getSettingInteger(e) {
                                return parseInt(this.getSetting(e), 10)
                            }
                            updateSettings(e) {
                                for (const [t,n] of e) {
                                    if (!fB(this, hB, "f").has(t))
                                        throw new Error("Setting name is missing");
                                    fB(this, hB, "f").set(t, n)
                                }
                            }
                            saveSettings() {
                                fB(this, cB, "f").saveSettings(fB(this, hB, "f"))
                            }
                            getKeyBindings(e) {
                                var t;
                                return null !== (t = fB(this, dB, "f").get(e)) && void 0 !== t ? t : [null, null]
                            }
                            setKeyBindings(e) {
                                fB(this, lB, "m", uB).call(this, e),
                                    fB(this, cB, "f").saveKeyBindings(fB(this, dB, "f"))
                            }
                            checkKeyBinding(e, t) {
                                var n;
                                const i = null !== (n = fB(this, dB, "f").get(t)) && void 0 !== n ? n : [];
                                for (const t of i)
                                    if (null != t && e.code == t)
                                        return !0;
                                return !1
                            }
                        }
                    ;
                    var gB;
                    !function(e) {
                        e[e.Init = 0] = "Init",
                            e[e.Verify = 1] = "Verify",
                            e[e.TestDeterminism = 2] = "TestDeterminism",
                            e[e.CreateCar = 3] = "CreateCar",
                            e[e.DeleteCar = 4] = "DeleteCar",
                            e[e.StartCar = 5] = "StartCar",
                            e[e.ControlCar = 6] = "ControlCar",
                            e[e.PauseCar = 7] = "PauseCar",
                            e[e.VerifyResult = 8] = "VerifyResult",
                            e[e.DeterminismResult = 9] = "DeterminismResult",
                            e[e.UpdateResult = 10] = "UpdateResult"
                    }(gB || (gB = {}));
                    const vB = gB;
                    var wB, AB, yB, bB, xB, kB, EB, SB = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, MB = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    AB = new WeakMap,
                        yB = new WeakMap,
                        bB = new WeakMap,
                        xB = new WeakMap,
                        kB = new WeakMap,
                        wB = new WeakSet,
                        EB = function(e, t) {
                            const n = t.getPhysicsParts();
                            MB(this, yB, "f").postMessage({
                                messageType: vB.Init,
                                isRealtime: e,
                                trackParts: n
                            })
                        }
                    ;
                    const TB = class {
                            constructor(e, t, n) {
                                wB.add(this),
                                    AB.set(this, void 0),
                                    yB.set(this, void 0),
                                    bB.set(this, !1),
                                    xB.set(this, 0),
                                    kB.set(this, new Map),
                                    SB(this, yB, new Worker("simulation_worker.bundle.js"), "f"),
                                    null != t && null != n ? (SB(this, AB, t, "f"),
                                        n.hasLoaded() ? MB(this, wB, "m", EB).call(this, e, t) : n.addCompleteListener(( () => {
                                                MB(this, wB, "m", EB).call(this, e, t)
                                            }
                                        ))) : SB(this, AB, null, "f")
                            }
                            dispose() {
                                MB(this, yB, "f").terminate(),
                                    SB(this, bB, !0, "f")
                            }
                            validate(e, t, n) {
                                return new Promise(( (i, r) => {
                                        var a, s;
                                        if (null == MB(this, AB, "f"))
                                            throw new Error("TrackPartManager is not initialized");
                                        if (null == e.getStartTransform())
                                            i(!1);
                                        else {
                                            const o = gI.createMountainVertices(e.getBounds());
                                            if (null == yw.models)
                                                throw new Error("Car collision model not loaded");
                                            const l = (SB(this, xB, (s = MB(this, xB, "f"),
                                                    a = s++,
                                                    s), "f"),
                                                    a)
                                                , c = setInterval(( () => {
                                                        MB(this, bB, "f") && (clearInterval(c),
                                                            r(new Error("Simulation has been disposed")))
                                                    }
                                                ), 10)
                                                , h = e => {
                                                    e.data.messageType == vB.VerifyResult && e.data.carId == l && (clearInterval(c),
                                                        MB(this, yB, "f").removeEventListener("message", h),
                                                        i(e.data.result))
                                                }
                                            ;
                                            MB(this, yB, "f").addEventListener("message", h),
                                                MB(this, yB, "f").postMessage({
                                                    messageType: vB.Verify,
                                                    mountainVertices: o.vertices,
                                                    mountainOffset: {
                                                        x: o.offset.x,
                                                        y: o.offset.y,
                                                        z: o.offset.z
                                                    },
                                                    trackData: e.toSaveString(),
                                                    carId: l,
                                                    carCollisionShapeVertices: yw.models.collisionShapeVertices,
                                                    carMassOffset: yw.massOffset,
                                                    carRecording: t.serialize(),
                                                    targetFrames: n.numberOfFrames
                                                })
                                        }
                                    }
                                ))
                            }
                            testDeterminism() {
                                return new Promise((e => {
                                        const t = n => {
                                                if (n.data.messageType === vB.DeterminismResult)
                                                    MB(this, yB, "f").removeEventListener("message", t),
                                                        e(n.data.isDeterminstic)
                                            }
                                        ;
                                        MB(this, yB, "f").addEventListener("message", t),
                                            MB(this, yB, "f").postMessage({
                                                messageType: vB.TestDeterminism
                                            })
                                    }
                                ))
                            }
                            createCar(e, t, n, i, r, a) {
                                var s, o;
                                if (null == MB(this, AB, "f"))
                                    throw new Error("TrackPartManager is not initialized");
                                if (null == yw.models)
                                    throw new Error("Car collision model not loaded");
                                const l = (SB(this, xB, (o = MB(this, xB, "f"),
                                        s = o++,
                                        o), "f"),
                                        s)
                                    , c = e => {
                                        if (e.data.messageType == vB.UpdateResult) {
                                            const t = e.data.carStates;
                                            for (const e of t)
                                                e.id == l && a(e)
                                        }
                                    }
                                ;
                                MB(this, yB, "f").addEventListener("message", c),
                                    MB(this, kB, "f").set(l, c),
                                    MB(this, yB, "f").postMessage({
                                        messageType: vB.CreateCar,
                                        mountainVertices: t,
                                        mountainOffset: {
                                            x: n.x,
                                            y: n.y,
                                            z: n.z
                                        },
                                        trackData: i.toSaveString(),
                                        carId: l,
                                        carCollisionShapeVertices: yw.models.collisionShapeVertices,
                                        carMassOffset: yw.massOffset,
                                        carRecording: null == r ? void 0 : r.serialize()
                                    });
                                const h = [new An(.627909,.27 - yw.suspensionResetLengthFront,1.3478).applyQuaternion(e.quaternion).add(e.position), new An(-.627909,.27 - yw.suspensionResetLengthFront,1.3478).applyQuaternion(e.quaternion).add(e.position), new An(.720832,.27 - yw.suspensionResetLengthRear,-1.52686).applyQuaternion(e.quaternion).add(e.position), new An(-.720832,.27 - yw.suspensionResetLengthRear,-1.52686).applyQuaternion(e.quaternion).add(e.position)]
                                    , d = [(new wn).setFromEuler((new ai).set(0, Math.PI, 0)).multiply(e.quaternion), (new wn).setFromEuler((new ai).set(0, Math.PI, 0)).multiply(e.quaternion), (new wn).setFromEuler((new ai).set(0, Math.PI, 0)).multiply(e.quaternion), (new wn).setFromEuler((new ai).set(0, Math.PI, 0)).multiply(e.quaternion)];
                                return {
                                    id: l,
                                    frames: 0,
                                    speedKmh: 0,
                                    hasStarted: !1,
                                    finishFrames: null,
                                    nextCheckpointIndex: 0,
                                    hasCheckpointToRespawnAt: !1,
                                    position: {
                                        x: e.position.x,
                                        y: e.position.y,
                                        z: e.position.z
                                    },
                                    quaternion: {
                                        x: e.quaternion.x,
                                        y: e.quaternion.y,
                                        z: e.quaternion.z,
                                        w: e.quaternion.w
                                    },
                                    collisionImpulses: [],
                                    wheelInContact: [!1, !1, !1, !1],
                                    wheelSuspensionLength: [yw.suspensionResetLengthFront, yw.suspensionResetLengthFront, yw.suspensionResetLengthRear, yw.suspensionResetLengthRear],
                                    wheelSuspensionVelocity: [0, 0, 0, 0],
                                    wheelRotation: [0, 0, 0, 0],
                                    wheelDeltaRotation: [0, 0, 0, 0],
                                    wheelSkidInfo: [0, 0, 0, 0],
                                    wheelPosition: h,
                                    wheelQuaternion: d,
                                    brakeLightEnabled: !1,
                                    controls: {
                                        up: !1,
                                        right: !1,
                                        down: !1,
                                        left: !1,
                                        reset: !1
                                    }
                                }
                            }
                            deleteCar(e) {
                                MB(this, yB, "f").postMessage({
                                    messageType: vB.DeleteCar,
                                    carId: e
                                });
                                const t = MB(this, kB, "f").get(e);
                                if (null == t)
                                    throw new Error("Deleting non-existant car");
                                MB(this, yB, "f").removeEventListener("message", t),
                                    MB(this, kB, "f").delete(e)
                            }
                            startCar(e, t) {
                                MB(this, yB, "f").postMessage({
                                    messageType: vB.StartCar,
                                    carId: e,
                                    targetSimulationTimeFrames: null == t ? void 0 : t.numberOfFrames
                                })
                            }
                            controlCar(e, t, n, i, r, a) {
                                MB(this, yB, "f").postMessage({
                                    messageType: vB.ControlCar,
                                    carId: e,
                                    up: t,
                                    right: n,
                                    down: i,
                                    left: r,
                                    reset: a
                                })
                            }
                            pauseCar(e, t) {
                                MB(this, yB, "f").postMessage({
                                    messageType: vB.PauseCar,
                                    carId: e,
                                    isPaused: t
                                })
                            }
                        }
                    ;
                    var CB = n(2796)
                        , _B = {};
                    _B.styleTagTransform = u(),
                        _B.setAttributes = l(),
                        _B.insert = s().bind(null, "head"),
                        _B.domAPI = r(),
                        _B.insertStyleElement = h();
                    t()(CB.A, _B);
                    CB.A && CB.A.locals && CB.A.locals;
                    var IB, PB, RB, LB, NB, DB, BB, UB = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, zB = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    IB = new WeakMap,
                        PB = new WeakMap,
                        RB = new WeakMap,
                        LB = new WeakMap,
                        NB = new WeakMap,
                        DB = new WeakMap,
                        BB = new WeakMap;
                    const OB = class {
                            constructor(e, t, n, i, r, a) {
                                IB.set(this, void 0),
                                    PB.set(this, void 0),
                                    RB.set(this, void 0),
                                    LB.set(this, void 0),
                                    NB.set(this, void 0),
                                    DB.set(this, void 0),
                                    BB.set(this, new Map);
                                const s = document.getElementById("ui");
                                if (null == s)
                                    throw new Error("UI element not found");
                                UB(this, IB, s, "f"),
                                    UB(this, PB, document.createElement("div"), "f"),
                                    zB(this, PB, "f").className = "verifier-ui",
                                    zB(this, IB, "f").appendChild(zB(this, PB, "f")),
                                    UB(this, RB, document.createElement("p"), "f"),
                                    zB(this, PB, "f").appendChild(zB(this, RB, "f"));
                                const o = document.createElement("p");
                                o.textContent = "Number of threads: " + t.toString(),
                                    zB(this, PB, "f").appendChild(o);
                                const l = document.createElement("input");
                                l.type = "range",
                                    l.min = "0",
                                    l.max = t.toString(),
                                    l.value = t.toString(),
                                    l.addEventListener("change", ( () => {
                                            const e = parseInt(l.value, 10);
                                            o.textContent = "Number of threads: " + e.toString(),
                                                r(e)
                                        }
                                    )),
                                    zB(this, PB, "f").appendChild(l);
                                const c = document.createElement("p");
                                c.textContent = "Max time: " + Math.floor(n / 60 / 1e3).toString() + " minutes",
                                    zB(this, PB, "f").appendChild(c);
                                const h = document.createElement("input");
                                h.type = "range",
                                    h.min = 6e4.toString(),
                                    h.max = cv.maxFrames.toString(),
                                    h.value = n.toString(),
                                    h.addEventListener("input", ( () => {
                                            const e = parseInt(h.value, 10);
                                            c.textContent = "Max time: " + Math.floor(e / 60 / 1e3).toString() + " minutes",
                                                a(e)
                                        }
                                    )),
                                    zB(this, PB, "f").appendChild(h);
                                const d = document.createElement("table");
                                zB(this, PB, "f").appendChild(d),
                                    UB(this, LB, d.createTHead(), "f"),
                                    UB(this, NB, d.createTBody(), "f");
                                const u = zB(this, LB, "f").insertRow();
                                for (const e of ["Track", "State", "Verified", "Invalid", "Estimated remaining"]) {
                                    const t = document.createElement("th");
                                    t.textContent = e,
                                        u.appendChild(t)
                                }
                                const p = document.createElement("button");
                                p.className = "button",
                                    p.textContent = "Stop",
                                    p.addEventListener("click", ( () => {
                                            e.playUIClick(),
                                                i()
                                        }
                                    )),
                                    zB(this, PB, "f").appendChild(p),
                                    window.addEventListener("keydown", UB(this, DB, (e => {
                                            "Escape" == e.code && (i(),
                                                e.preventDefault())
                                        }
                                    ), "f"))
                            }
                            dispose() {
                                zB(this, IB, "f").removeChild(zB(this, PB, "f")),
                                    window.removeEventListener("keydown", zB(this, DB, "f"))
                            }
                            setText(e) {
                                zB(this, RB, "f").textContent = e
                            }
                            setTracks(e) {
                                for (const t of e) {
                                    let e = zB(this, BB, "f").get(t.id);
                                    if (null == e) {
                                        e = {
                                            element: zB(this, NB, "f").insertRow(),
                                            name: t.name,
                                            exhausted: t.exhausted,
                                            recordingsVerified: t.recordingsVerified,
                                            invalidRecordings: t.invalidRecordings,
                                            estimatedRemaining: t.estimatedRemaining
                                        },
                                            zB(this, BB, "f").set(t.id, e);
                                        e.element.insertCell().textContent = t.name;
                                        e.element.insertCell().textContent = t.exhausted ? "Empty" : "Processing";
                                        e.element.insertCell().textContent = t.recordingsVerified.toString();
                                        e.element.insertCell().textContent = t.invalidRecordings.toString();
                                        const n = e.element.insertCell();
                                        null != t.estimatedRemaining ? n.textContent = t.estimatedRemaining.toString() : n.textContent = "?"
                                    } else
                                        e.name != t.name && (e.element.cells[0].textContent = t.name,
                                            e.name = t.name),
                                        e.exhausted != t.exhausted && (e.element.cells[1].textContent = t.exhausted ? "Empty" : "Processing",
                                            e.exhausted = t.exhausted),
                                        e.recordingsVerified != t.recordingsVerified && (e.element.cells[2].textContent = t.recordingsVerified.toString(),
                                            e.recordingsVerified = t.recordingsVerified),
                                        e.invalidRecordings != t.invalidRecordings && (e.element.cells[3].textContent = t.invalidRecordings.toString(),
                                            e.invalidRecordings = t.invalidRecordings),
                                        e.estimatedRemaining != t.estimatedRemaining && (null != t.estimatedRemaining ? e.element.cells[4].textContent = t.estimatedRemaining.toString() : e.element.cells[4].textContent = "?",
                                            e.estimatedRemaining = t.estimatedRemaining)
                                }
                            }
                        }
                    ;
                    var FB, WB, HB, VB, GB, jB, QB, YB, qB, KB, XB, ZB, JB, $B, eU, tU, nU, iU, rU, aU, sU, oU, lU, cU, hU, dU, uU, pU, fU, mU, gU, vU, wU, AU = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, yU = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    WB = new WeakMap,
                        HB = new WeakMap,
                        VB = new WeakMap,
                        GB = new WeakMap,
                        jB = new WeakMap,
                        QB = new WeakMap,
                        YB = new WeakMap,
                        qB = new WeakMap,
                        KB = new WeakMap,
                        XB = new WeakMap,
                        ZB = new WeakMap,
                        JB = new WeakMap,
                        $B = new WeakMap,
                        eU = new WeakMap,
                        tU = new WeakMap,
                        nU = new WeakMap,
                        iU = new WeakMap,
                        rU = new WeakMap,
                        aU = new WeakMap,
                        sU = new WeakMap,
                        oU = new WeakMap,
                        lU = new WeakMap,
                        cU = new WeakMap,
                        hU = new WeakMap,
                        dU = new WeakMap,
                        uU = new WeakMap,
                        pU = new WeakMap,
                        fU = new WeakMap,
                        mU = new WeakMap,
                        FB = new WeakSet,
                        gU = function(e) {
                            const t = yU(this, KB, "f").slice();
                            do {
                                const n = Math.floor(Math.random() * t.length)
                                    , i = t.splice(n, 1)[0];
                                if (e > i.timeout)
                                    return i
                            } while (t.length > 0);
                            return null
                        }
                        ,
                        vU = function() {
                            var e;
                            const t = new Date;
                            if (!yU(this, ZB, "f") && yU(this, $B, "f").length < yU(this, cU, "f") && Math.abs(t.getTime() - yU(this, JB, "f").getTime()) >= yU(this, hU, "f")) {
                                AU(this, ZB, !0, "f"),
                                    AU(this, JB, t, "f");
                                const n = yU(this, FB, "m", gU).call(this, t);
                                if (null != n || yU(this, XB, "f").length > 0 && 0 == yU(this, $B, "f").length || yU(this, XB, "f").length > yU(this, lU, "f")) {
                                    const i = yU(this, XB, "f");
                                    AU(this, XB, [], "f");
                                    const r = null != n && (null == n.lastEstimatedRemainingTime || Math.abs(t.getTime() - n.lastEstimatedRemainingTime.getTime()) >= yU(this, dU, "f"));
                                    yU(this, GB, "f").verifyRecordings(yU(this, QB, "f"), null !== (e = null == n ? void 0 : n.id) && void 0 !== e ? e : null, yU(this, uU, "f"), r, i).then(( ({unverifiedRecordings: e, exhaustive: i, estimatedRemaining: r}) => {
                                            null != n && (AU(this, $B, yU(this, $B, "f").concat(e.map(( ({id: e, recording: t, frames: i}) => ({
                                                track: n,
                                                trackData: n.data,
                                                recordingId: e,
                                                recording: cv.deserialize(t),
                                                time: new xp(i)
                                            })))), "f"),
                                            i && (n.timeout = new Date(t.getTime() + Math.floor(432e5 + 12 * Math.random() * 60 * 60 * 1e3))),
                                            null != r && (n.estimatedRemaining = r,
                                                n.lastEstimatedRemainingTime = t))
                                        }
                                    )).catch((e => {
                                            console.error(e),
                                                yU(this, GB, "f").getUser(yU(this, QB, "f")).then((e => {
                                                        (null == e ? void 0 : e.isVerifier) || AU(this, eU, !1, "f")
                                                    }
                                                )).catch((e => {
                                                        console.warn(e)
                                                    }
                                                ))
                                        }
                                    )).finally(( () => {
                                            AU(this, ZB, !1, "f")
                                        }
                                    ))
                                } else
                                    AU(this, ZB, !1, "f")
                            }
                        }
                        ,
                        wU = function() {
                            var e, t, n;
                            if (yU(this, jB, "f").hasLoaded() && yU(this, eU, "f")) {
                                yU(this, FB, "m", vU).call(this);
                                for (const i of yU(this, qB, "f"))
                                    if (!i.isBusy && yU(this, $B, "f").length > 0) {
                                        i.isBusy = !0;
                                        const {track: r, trackData: a, recordingId: s, recording: o, time: l} = yU(this, $B, "f").splice(0, 1)[0];
                                        null == o ? (AU(this, aU, (e = yU(this, aU, "f"),
                                            ++e), "f"),
                                            r.recordingsVerified++,
                                            AU(this, sU, (t = yU(this, sU, "f"),
                                                ++t), "f"),
                                            r.invalidRecordings++,
                                        null != r.estimatedRemaining && (r.estimatedRemaining = Math.max(0, r.estimatedRemaining - 1)),
                                            yU(this, XB, "f").push({
                                                id: s,
                                                verifiedState: vP.Invalid
                                            }),
                                            i.isBusy = !1) : (AU(this, rU, (n = yU(this, rU, "f"),
                                            ++n), "f"),
                                            i.simulation.validate(a, o, l).then((e => {
                                                    var t, n;
                                                    AU(this, aU, (t = yU(this, aU, "f"),
                                                        ++t), "f"),
                                                        r.recordingsVerified++,
                                                    e || (AU(this, sU, (n = yU(this, sU, "f"),
                                                        ++n), "f"),
                                                        r.invalidRecordings++),
                                                    null != r.estimatedRemaining && (r.estimatedRemaining = Math.max(0, r.estimatedRemaining - 1)),
                                                        AU(this, oU, yU(this, oU, "f") + l.numberOfFrames, "f"),
                                                        yU(this, XB, "f").push({
                                                            id: s,
                                                            verifiedState: e ? vP.Verified : vP.Invalid
                                                        })
                                                }
                                            )).catch((e => {
                                                    if (!i.isDisposed)
                                                        throw e
                                                }
                                            )).finally(( () => {
                                                    var e;
                                                    i.isBusy = !1,
                                                        AU(this, rU, (e = yU(this, rU, "f"),
                                                            --e), "f")
                                                }
                                            )))
                                    }
                            }
                        }
                    ;
                    const bU = class {
                        constructor(e, t, n, i, r, a, s, o, l) {
                            FB.add(this),
                                WB.set(this, void 0),
                                HB.set(this, void 0),
                                VB.set(this, void 0),
                                GB.set(this, void 0),
                                jB.set(this, void 0),
                                QB.set(this, void 0),
                                YB.set(this, void 0),
                                qB.set(this, []),
                                KB.set(this, []),
                                XB.set(this, []),
                                ZB.set(this, !1),
                                JB.set(this, new Date),
                                $B.set(this, []),
                                eU.set(this, !0),
                                tU.set(this, void 0),
                                nU.set(this, !1),
                                iU.set(this, new Date),
                                rU.set(this, 0),
                                aU.set(this, 0),
                                sU.set(this, 0),
                                oU.set(this, 0),
                                lU.set(this, 100),
                                cU.set(this, 100),
                                hU.set(this, 1e3),
                                dU.set(this, 36e5),
                                uU.set(this, 6e5),
                                pU.set(this, 4),
                                fU.set(this, void 0),
                                mU.set(this, null),
                                AU(this, WB, e, "f"),
                                AU(this, HB, t, "f"),
                                AU(this, VB, a, "f"),
                                AU(this, GB, n, "f"),
                                AU(this, jB, s, "f"),
                                AU(this, QB, o, "f"),
                            "undefined" != typeof navigator && "hardwareConcurrency"in navigator && navigator.hardwareConcurrency > 0 && AU(this, pU, navigator.hardwareConcurrency, "f"),
                                AU(this, fU, yU(this, pU, "f"), "f"),
                                t.clear(),
                                AU(this, YB, new OB(e,yU(this, pU, "f"),yU(this, uU, "f"),l,(e => {
                                        for (AU(this, fU, e, "f"); yU(this, qB, "f").length < yU(this, fU, "f"); )
                                            yU(this, qB, "f").push({
                                                simulation: new TB(!1,r,s),
                                                isBusy: !1,
                                                isDisposed: !1
                                            });
                                        for (; yU(this, qB, "f").length > yU(this, fU, "f"); ) {
                                            const e = yU(this, qB, "f").pop();
                                            null != e && (e.simulation.dispose(),
                                                e.isDisposed = !0)
                                        }
                                    }
                                ),(e => {
                                        AU(this, uU, e, "f");
                                        for (const e of yU(this, KB, "f"))
                                            e.timeout = new Date,
                                                e.estimatedRemaining = null
                                    }
                                )), "f");
                            for (let e = 0; e < yU(this, fU, "f"); e++)
                                yU(this, qB, "f").push({
                                    simulation: new TB(!1,r,yU(this, jB, "f")),
                                    isBusy: !1,
                                    isDisposed: !1
                                });
                            i.forEachTrack(( (e, t, n) => {
                                    yU(this, KB, "f").push({
                                        id: e,
                                        name: t.name,
                                        data: n,
                                        timeout: new Date,
                                        recordingsVerified: 0,
                                        invalidRecordings: 0,
                                        estimatedRemaining: null,
                                        lastEstimatedRemainingTime: null
                                    })
                                }
                            )),
                                AU(this, tU, setInterval(( () => {
                                        yU(this, FB, "m", wU).call(this)
                                    }
                                ), 10), "f");
                            try {
                                navigator.wakeLock.request("screen").then((e => {
                                        yU(this, nU, "f") ? e.release().catch((e => {
                                                console.error(e)
                                            }
                                        )) : AU(this, mU, e, "f")
                                    }
                                )).catch((e => {
                                        console.warn(e)
                                    }
                                ))
                            } catch (e) {
                                console.error(e)
                            }
                        }
                        dispose() {
                            AU(this, nU, !0, "f"),
                                yU(this, YB, "f").dispose();
                            for (const e of yU(this, qB, "f"))
                                e.simulation.dispose(),
                                    e.isDisposed = !0;
                            yU(this, qB, "f").length = 0,
                                clearInterval(yU(this, tU, "f")),
                            null != yU(this, mU, "f") && yU(this, mU, "f").release().catch((e => {
                                    console.error(e)
                                }
                            ))
                        }
                        update(e) {
                            if (yU(this, jB, "f").hasLoaded()) {
                                const e = new Date
                                    , t = (e.getTime() - yU(this, iU, "f").getTime()) / 1e3;
                                let n = "";
                                yU(this, eU, "f") ? n += "Recordings are being verified...\n" : n += "Error: User is no longer a verifier\n",
                                    n += "\nBacklog: " + yU(this, $B, "f").length.toString(),
                                    n += "\nProcessing: " + yU(this, rU, "f").toString(),
                                    n += "\nRecordings verified: " + yU(this, aU, "f").toString(),
                                    n += "\nInvalid recordings found: " + yU(this, sU, "f").toString(),
                                    n += "\n",
                                    n += "\nVerifications per second: " + (yU(this, aU, "f") / t).toFixed(2),
                                    n += "\nSimulated frames per second: " + Math.floor(yU(this, oU, "f") / t).toString(),
                                    yU(this, YB, "f").setTracks(yU(this, KB, "f").map(( ({id: t, name: n, timeout: i, recordingsVerified: r, invalidRecordings: a, estimatedRemaining: s}) => ({
                                        id: t,
                                        name: n,
                                        exhausted: i > e,
                                        recordingsVerified: r,
                                        invalidRecordings: a,
                                        estimatedRemaining: s
                                    })))),
                                    yU(this, YB, "f").setText(n)
                            }
                            yU(this, WB, "f").update(e, !1, yU(this, HB, "f"), yU(this, VB, "f"))
                        }
                    }
                        , xU = {
                        "Checkpoint order": "  ",
                        Height: "",
                        Exit: "",
                        Random: "",
                        Primary: "",
                        Secondary: "",
                        Frame: "",
                        Rims: "",
                        "Are you sure you want to exit without saving?": "        ",
                        "All changes will be lost!": "   !",
                        "Car saved!": "  !",
                        Test: "",
                        "Starting point is missing!": "  !",
                        Generate: "",
                        "Are you sure you want to generate a new track?\n\nYour current track will be lost!": "        \n\n   !",
                        Load: "",
                        Save: "",
                        "Are you sure you want to load a new track?\n\nYour current track will be lost!": "        \n\n   !",
                        "Track saved!": "  !",
                        "Failed to save!": " !",
                        'Are you sure you want to overwrite "{0}"?': '        "{0}"',
                        Export: "",
                        Help: "",
                        "Are you sure you want to exit the editor?": "        ",
                        "All unsaved data will be lost!": "     !",
                        "Track settings": " ",
                        "Unnamed Track": "  ",
                        "Track name": " ",
                        Author: "",
                        Unknown: " ",
                        Environment: "",
                        Summer: "",
                        Winter: "",
                        Desert: "",
                        "Sun direction": " ",
                        "How to use the editor": "  ",
                        "Camera controls": " ",
                        "The camera can be moved by right clicking and dragging the mouse. Rotate the camera by clicking the middle mouse button (mouse wheel) or holding the control key and right clicking and dragging the mouse. Zoom in and out by scrolling the mouse wheel.": "        .         ( )           .        .",
                        "Alternatively, the camera can also be controlled using the following keyboard keys:": "            :",
                        "Move forwards:": " :",
                        "Move backwards:": " :",
                        "Move left:": " :",
                        "Move right:": " :",
                        "Rotate left:": " :",
                        "Rotate right:": " :",
                        "The edited height can be changed either by using the height selection in the bottom left corner, or holding the shift key and scrolling the mouse wheel. Alternatively, you can use the following keyboard keys:": "                Shift   .         :",
                        "Move up:": " :",
                        "Move down:": " :",
                        Editing: "",
                        "Track parts can be selected in the menu on the right after which they can be placed by left clicking with the mouse.": "                .",
                        "Alternatively, the track part currently hovered by the mouse can be selected with the following keyboard shortcut:": "                 :",
                        "The selected part can then be rotated using the following keyboard shortcut:": "          :",
                        "Track parts can be deleted by using the delete tool in the right side menu or by holding the following key:": "               :",
                        "Starting points, checkpoints and the finish line": "     ",
                        "Starting points, checkpoints and finish lines can all be selected in the uppermost category in the right side menu.": "               .",
                        "Each track must have at least one starting point. If there are multiple starting points, the last placed one will be used.": "          .            .",
                        "Checkpoints should be placed between the starting point and the finish line. When a checkpoint track part is selected there will be a tool in the bottom right to select the order of the checkpoint. This determines the order in which the checkpoints must be passed before driving to the finish line. Notice that it is possible to have multiple checkpoints with the same checkpoint order.": "        .                 .               .              .",
                        "The finish line is where the track ends but will only become active after all checkpoints have been passed. It is also possible to have multiple finish lines.": "                .         .",
                        "Starting point": " ",
                        Checkpoint: " ",
                        "Finish line": " ",
                        "Exporting the track": " ",
                        "When the track is finished, a name for the track can be entered in top left after which the track can be exported using the export button. This will reveal a track code which can be sent to other users so they can import and play the track.": "                   .               .",
                        Close: "",
                        "Not set": " ",
                        or: "",
                        "The camera can be moved by dragging with one finger. Rotate the camera by dragging with two fingers. Zoom in and out by pinching.": "        .         ( )           .        .",
                        "The edited height can be changed by using the height selection in the bottom left corner.": "          .",
                        "Track parts can be selected in the menu on the right after which they can be placed by tapping on the screen.": "               .",
                        "The selected part can then be rotated by tapping the rotate button in the bottom left corner.": "             .",
                        "Track parts can be deleted by using the delete tool in the right side menu.": "          .",
                        Watch: "",
                        "Loading replay": "  ",
                        "Press {0} to return to the last checkpoint": " {0}     ",
                        "Press {0} to start over": " {0}   ",
                        "Reset once to return to the last checkpoint": "        ",
                        "Reset again to start over": "      ",
                        Leaderboard: "",
                        Back: "",
                        "Error: Failed to load leaderboard": ":   ",
                        Pending: " ",
                        Verified: " ",
                        Invalid: " ",
                        Duplicate: "",
                        You: "",
                        "Only verified": " ",
                        Loading: " ",
                        "Failed to load recordings": "  ",
                        "Cannot load recordings due to non-determinism": "      ",
                        Ok: "",
                        "Track is missing starting point": "   ",
                        "Some leaderboard features are disabled.": "    .",
                        "Please try another browser or device.": "     .",
                        "You already have another instance of PolyTrack open.": "     PolyTrack .",
                        "Please switch to that tab or window to continue.": "       .",
                        "Computer determinism check failed.": "   .",
                        "Non-deterministic game assets found.": "      .",
                        "Please try clearing your browser cache.": "      .",
                        Customize: "",
                        Editor: "",
                        Settings: "",
                        Profile: " ",
                        Play: "",
                        Version: "",
                        "You cannot have duplicate user profiles": "      ",
                        "Failed to create user profile": "     ",
                        "This user profile does not exist on the server": "       ",
                        "Failed to download user profile from the server": "       ",
                        "User token is invalid": "   ",
                        "Are you sure you want to display your private key?": "       ",
                        "DO NOT SHARE THIS KEY WITH ANYONE.": "      .",
                        "You need a free user profile slot to import a new user profile": "           ",
                        Quit: "",
                        Fullscreen: " ",
                        Windowed: "",
                        "It seems like you are playing an unofficial version of {0}. For the most up-to-date version please visit the original source:": "       {0}.        :",
                        Nickname: " ",
                        "Choose a nickname to be shown in the leaderboard. Your nickname can be changed at any time.": "     .       .",
                        Cancel: "",
                        Confirm: "",
                        Verifier: "",
                        "User ID": " ",
                        Paused: "",
                        "Switch car": " ",
                        Profiles: "",
                        'Are you sure you would like to delete "{0}"?': '      "{0}"',
                        Empty: "",
                        Reset: " ",
                        Apply: "",
                        Gameplay: " ",
                        Units: "",
                        Metric: "",
                        Imperial: "",
                        "Reset hint": "  ",
                        Disabled: "",
                        Enabled: "",
                        "Ghost car": " ",
                        "Default camera": " ",
                        Default: "",
                        Cockpit: "",
                        "Cockpit camera mode": "   ",
                        Hold: "",
                        Toggle: "",
                        Checkpoints: " ",
                        Timer: "",
                        Speedometer: " ",
                        Bottom: "",
                        Top: "",
                        Language: "",
                        Graphics: "",
                        "Car shadow": " ",
                        "Track shadow": " ",
                        Off: "",
                        On: "",
                        Low: "",
                        Medium: "",
                        High: "",
                        Clouds: "",
                        Particles: "",
                        Skidmarks: " ",
                        "Render scale": " ",
                        "Anti-aliasing (requires restart)": "  (  )",
                        Audio: "",
                        "Sound effect volume": "  ",
                        "Music volume": " ",
                        "Checkpoint volume": "  ",
                        Controls: "",
                        Vehicle: "",
                        Accelerate: "",
                        Brake: "",
                        "Turn left": " ",
                        "Turn right": " ",
                        "Checkpoint reset": "   ",
                        "Start reset": "  ",
                        "Cockpit camera": " ",
                        "Rotate part": " ",
                        "Height modifier": " ",
                        "Delete part": " ",
                        "Move forwards": " ",
                        "Move backwards": " ",
                        "Move left": " ",
                        "Move right": " ",
                        "Rotate view left": "  ",
                        "Rotate view right": "  ",
                        "Move down": " ",
                        "Move up": " ",
                        "Test track": " ",
                        "Pick part": " ",
                        Spectator: "",
                        "Speed modifier": " ",
                        Other: "",
                        "Hide UI": "  ",
                        Pause: " ",
                        "Toggle FPS counter": "    ",
                        "Toggle spectator camera": "  ",
                        "Press any key...\n\nPress [Escape] to cancel.": "   ...\n\n [] .",
                        Clear: "",
                        "New record": "  ",
                        Record: " ",
                        Current: "",
                        Difference: "",
                        Copy: "",
                        Import: "",
                        "Failed to import track": "  ",
                        'The track "{0}" already exists. Do you wish to overwrite it?': ' "{0}"  .     ',
                        Overwrite: " ",
                        "Paste track data here...": "   ...",
                        Rank: "",
                        "Personal best": "  ",
                        Opponents: "",
                        "{0} opponent selected": "{0}  ",
                        "{0} opponents selected": "{0}  ",
                        "Select opponents to race against from the leaderboard on the left": "        ",
                        "No record": "  ",
                        "Official tracks": " ",
                        "Community tracks": " ",
                        "Custom tracks": " ",
                        'Are you sure you want to delete "{0}"?': '       "{0}"',
                        Delete: "",
                        "No community tracks": "   ",
                        "Community tracks are coming soon": "   ",
                        "No custom tracks": "   ",
                        "Create a track using the editor or import a track code": "       ",
                        "Search tracks...": "  ...",
                        "Invalid replay detected!": "    !",
                        "An opponent most likely used cheats": "      "
                    }
                        , kU = {
                        "Checkpoint order": "Kontrollpunktreihenfolge",
                        Height: "Hhe",
                        Exit: "Beenden",
                        Random: "Zufllig",
                        Primary: "Primr",
                        Secondary: "Sekundr",
                        Frame: "Rahmen",
                        Rims: "Felgen",
                        "Are you sure you want to exit without saving?": "Sind Sie sicher, dass Sie ohne Speichern beenden mchten?",
                        "All changes will be lost!": "Alle nderungen gehen verloren!",
                        "Car saved!": "Auto gespeichert!",
                        Test: "Test",
                        "Starting point is missing!": "Startpunkt fehlt!",
                        Generate: "Generieren",
                        "Are you sure you want to generate a new track?\n\nYour current track will be lost!": "Sind Sie sicher, dass Sie eine neue Strecke generieren mchten?\n\nIhre aktuelle Strecke geht verloren!",
                        Load: "Laden",
                        Save: "Speichern",
                        "Are you sure you want to load a new track?\n\nYour current track will be lost!": "Sind Sie sicher, dass Sie eine neue Strecke laden mchten?\n\nIhre aktuelle Strecke geht verloren!",
                        "Track saved!": "Strecke gespeichert!",
                        "Failed to save!": "Speichern fehlgeschlagen!",
                        'Are you sure you want to overwrite "{0}"?': 'Sind Sie sicher, dass Sie "{0}" berschreiben mchten?',
                        Export: "Exportieren",
                        Help: "Hilfe",
                        "Are you sure you want to exit the editor?": "Sind Sie sicher, dass Sie den Editor verlassen mchten?",
                        "All unsaved data will be lost!": "Alle nicht gespeicherten Daten gehen verloren!",
                        "Track settings": "Streckeneinstellungen",
                        "Unnamed Track": "Unbenannte Strecke",
                        "Track name": "Streckenname",
                        Author: "Autor",
                        Unknown: "Unbekannt",
                        Environment: "Umgebung",
                        Summer: "Sommer",
                        Winter: "Winter",
                        Desert: "Wste",
                        "Sun direction": "Sonnenrichtung",
                        "How to use the editor": "Wie man den Editor benutzt",
                        "Camera controls": "Kamerasteuerung",
                        "The camera can be moved by right clicking and dragging the mouse. Rotate the camera by clicking the middle mouse button (mouse wheel) or holding the control key and right clicking and dragging the mouse. Zoom in and out by scrolling the mouse wheel.": "Die Kamera kann durch Rechtsklick und Ziehen der Maus bewegt werden. Drehen Sie die Kamera, indem Sie die mittlere Maustaste (Mausrad) klicken oder die Steuerungstaste gedrckt halten und mit der rechten Maustaste ziehen. Zoomen Sie mit dem Mausrad rein und raus.",
                        "Alternatively, the camera can also be controlled using the following keyboard keys:": "Alternativ kann die Kamera auch mit den folgenden Tasten gesteuert werden:",
                        "Move forwards:": "Nach vorne bewegen:",
                        "Move backwards:": "Nach hinten bewegen:",
                        "Move left:": "Nach links bewegen:",
                        "Move right:": "Nach rechts bewegen:",
                        "Rotate left:": "Nach links drehen:",
                        "Rotate right:": "Nach rechts drehen:",
                        "The edited height can be changed either by using the height selection in the bottom left corner, or holding the shift key and scrolling the mouse wheel. Alternatively, you can use the following keyboard keys:": "Die bearbeitete Hhe kann entweder durch Verwendung der Hhenauswahl in der unteren linken Ecke gendert werden oder indem Sie die Umschalttaste gedrckt halten und das Mausrad scrollen. Alternativ knnen Sie die folgenden Tasten verwenden:",
                        "Move up:": "Nach oben bewegen:",
                        "Move down:": "Nach unten bewegen:",
                        Editing: "Bearbeiten",
                        "Track parts can be selected in the menu on the right after which they can be placed by left clicking with the mouse.": "Streckenteile knnen im Men auf der rechten Seite ausgewhlt werden, danach knnen sie durch Linksklick mit der Maus platziert werden.",
                        "Alternatively, the track part currently hovered by the mouse can be selected with the following keyboard shortcut:": "Alternativ kann das Streckenteil, ber das die Maus gerade schwebt, mit der folgenden Tastenkombination ausgewhlt werden:",
                        "The selected part can then be rotated using the following keyboard shortcut:": "Das ausgewhlte Teil kann dann mit der folgenden Tastenkombination gedreht werden:",
                        "Track parts can be deleted by using the delete tool in the right side menu or by holding the following key:": "Streckenteile knnen mit dem Lschwerkzeug im Men auf der rechten Seite gelscht werden oder indem Sie die folgende Taste gedrckt halten:",
                        "Starting points, checkpoints and the finish line": "Startpunkte, Kontrollpunkte und die Ziellinie",
                        "Starting points, checkpoints and finish lines can all be selected in the uppermost category in the right side menu.": "Startpunkte, Kontrollpunkte und Ziellinien knnen alle in der obersten Kategorie im Men auf der rechten Seite ausgewhlt werden.",
                        "Each track must have at least one starting point. If there are multiple starting points, the last placed one will be used.": "Jede Strecke muss mindestens einen Startpunkt haben. Wenn es mehrere Startpunkte gibt, wird der zuletzt platzierte verwendet.",
                        "Checkpoints should be placed between the starting point and the finish line. When a checkpoint track part is selected there will be a tool in the bottom right to select the order of the checkpoint. This determines the order in which the checkpoints must be passed before driving to the finish line. Notice that it is possible to have multiple checkpoints with the same checkpoint order.": "Kontrollpunkte sollten zwischen dem Startpunkt und der Ziellinie platziert werden. Wenn ein Kontrollpunkt-Streckenteil ausgewhlt ist, gibt es unten rechts ein Werkzeug, um die Reihenfolge des Kontrollpunkts auszuwhlen. Dies bestimmt die Reihenfolge, in der die Kontrollpunkte passiert werden mssen, bevor man zur Ziellinie fhrt. Beachten Sie, dass es mglich ist, mehrere Kontrollpunkte mit derselben Kontrollpunkt-Reihenfolge zu haben.",
                        "The finish line is where the track ends but will only become active after all checkpoints have been passed. It is also possible to have multiple finish lines.": "Die Ziellinie ist der Ort, an dem die Strecke endet, wird aber erst aktiv, nachdem alle Kontrollpunkte passiert wurden. Es ist auch mglich, mehrere Ziellinien zu haben.",
                        "Starting point": "Startpunkt",
                        Checkpoint: "Kontrollpunkt",
                        "Finish line": "Ziellinie",
                        "Exporting the track": "Exportieren der Strecke",
                        "When the track is finished, a name for the track can be entered in top left after which the track can be exported using the export button. This will reveal a track code which can be sent to other users so they can import and play the track.": "Wenn die Strecke fertig ist, kann oben links ein Name fr die Strecke eingegeben werden, danach kann die Strecke mit dem Export-Button exportiert werden. Dadurch wird ein Streckencode angezeigt, der an andere Benutzer gesendet werden kann, damit sie die Strecke importieren und spielen knnen.",
                        Close: "Schlieen",
                        "Not set": "Nicht festgelegt",
                        or: "oder",
                        "The camera can be moved by dragging with one finger. Rotate the camera by dragging with two fingers. Zoom in and out by pinching.": "Die Kamera kann durch Ziehen mit einem Finger bewegt werden. Drehen Sie die Kamera, indem Sie mit zwei Fingern ziehen. Zoomen Sie rein und raus, indem Sie kneifen.",
                        "The edited height can be changed by using the height selection in the bottom left corner.": "Die bearbeitete Hhe kann durch Verwendung der Hhenauswahl in der unteren linken Ecke gendert werden.",
                        "Track parts can be selected in the menu on the right after which they can be placed by tapping on the screen.": "Streckenteile knnen im Men auf der rechten Seite ausgewhlt werden, danach knnen sie durch Antippen des Bildschirms platziert werden.",
                        "The selected part can then be rotated by tapping the rotate button in the bottom left corner.": "Das ausgewhlte Teil kann dann durch Antippen der Drehen-Schaltflche in der unteren linken Ecke gedreht werden.",
                        "Track parts can be deleted by using the delete tool in the right side menu.": "Streckenteile knnen mit dem Lschwerkzeug im Men auf der rechten Seite gelscht werden.",
                        Watch: "Zuschauen",
                        "Loading replay": "Wiederholung laden",
                        "Press {0} to return to the last checkpoint": "Drcken Sie {0}, um zum letzten Kontrollpunkt zurckzukehren",
                        "Press {0} to start over": "Drcken Sie {0}, um von vorne zu beginnen",
                        "Reset once to return to the last checkpoint": "Einmal zurcksetzen, um zum letzten Kontrollpunkt zurckzukehren",
                        "Reset again to start over": "Erneut zurcksetzen, um von vorne zu beginnen",
                        Leaderboard: "Bestenliste",
                        Back: "Zurck",
                        "Error: Failed to load leaderboard": "Fehler: Laden der Bestenliste fehlgeschlagen",
                        Pending: "Ausstehend",
                        Verified: "Verifiziert",
                        Invalid: "Ungltig",
                        Duplicate: "Duplikat",
                        You: "Sie",
                        "Only verified": "Nur verifizierte",
                        Loading: "Laden",
                        "Failed to load recordings": "Aufnahmen konnten nicht geladen werden",
                        "Cannot load recordings due to non-determinism": "Aufgrund von Nicht-Determinismus knnen keine Aufnahmen geladen werden",
                        Ok: "Ok",
                        "Track is missing starting point": "Strecke hat keinen Startpunkt",
                        "Some leaderboard features are disabled.": "Einige Bestenlistenfunktionen sind deaktiviert.",
                        "Please try another browser or device.": "Bitte versuchen Sie einen anderen Browser oder ein anderes Gert.",
                        "You already have another instance of PolyTrack open.": "Sie haben bereits eine andere Instanz von PolyTrack geffnet.",
                        "Please switch to that tab or window to continue.": "Bitte wechseln Sie zu diesem Tab oder Fenster, um fortzufahren.",
                        "Computer determinism check failed.": "Der Computer-Determinismus-Check ist fehlgeschlagen.",
                        "Non-deterministic game assets found.": "Nicht-deterministische Spiel-Assets gefunden.",
                        "Please try clearing your browser cache.": "Bitte versuchen Sie, Ihren Browser-Cache zu lschen.",
                        Customize: "Anpassen",
                        Editor: "Editor",
                        Settings: "Einstellungen",
                        Profile: "Profil",
                        Play: "Spielen",
                        Version: "Version",
                        "You cannot have duplicate user profiles": "Sie knnen keine doppelten Benutzerprofile haben",
                        "Failed to create user profile": "Benutzerprofil konnte nicht erstellt werden",
                        "This user profile does not exist on the server": "Dieses Benutzerprofil existiert nicht auf dem Server",
                        "Failed to download user profile from the server": "Benutzerprofil konnte nicht vom Server heruntergeladen werden",
                        "User token is invalid": "Benutzertoken ist ungltig",
                        "Are you sure you want to display your private key?": "Mchten Sie Ihren privaten Schlssel wirklich anzeigen?",
                        "DO NOT SHARE THIS KEY WITH ANYONE.": "TEILEN SIE DIESEN SCHLSSEL NICHT MIT JEMANDEM.",
                        "You need a free user profile slot to import a new user profile": "Sie bentigen einen freien Benutzerprofil-Slot, um ein neues Benutzerprofil zu importieren",
                        Quit: "Beenden",
                        Fullscreen: "Vollbild",
                        Windowed: "Fenstermodus",
                        "It seems like you are playing an unofficial version of {0}. For the most up-to-date version please visit the original source:": "Es scheint, dass Sie eine inoffizielle Version von {0} spielen. Fr die aktuellste Version besuchen Sie bitte die Originalquelle:",
                        Nickname: "Spitzname",
                        "Choose a nickname to be shown in the leaderboard. Your nickname can be changed at any time.": "Whlen Sie einen Spitznamen, der in der Bestenliste angezeigt wird. Ihr Spitzname kann jederzeit gendert werden.",
                        Cancel: "Abbrechen",
                        Confirm: "Besttigen",
                        Verifier: "Verifizierer",
                        "User ID": "Benutzer-ID",
                        Paused: "Pausiert",
                        "Switch car": "Auto wechseln",
                        Profiles: "Profile",
                        'Are you sure you would like to delete "{0}"?': 'Mchten Sie "{0}" wirklich lschen?',
                        Empty: "Leer",
                        Reset: "Zurcksetzen",
                        Apply: "Anwenden",
                        Gameplay: "Spielablauf",
                        Units: "Einheiten",
                        Metric: "Metrisch",
                        Imperial: "Imperial",
                        "Reset hint": "Hinweis zurcksetzen",
                        Disabled: "Deaktiviert",
                        Enabled: "Aktiviert",
                        "Ghost car": "Geisterauto",
                        "Default camera": "Standardkamera",
                        Default: "Standard",
                        Cockpit: "Cockpit",
                        "Cockpit camera mode": "Cockpit-Kameramodus",
                        Hold: "Halten",
                        Toggle: "Umschalten",
                        Checkpoints: "Kontrollpunkte",
                        Timer: "Timer",
                        Speedometer: "Tachometer",
                        Bottom: "Unten",
                        Top: "Oben",
                        Language: "Sprache",
                        Graphics: "Grafik",
                        "Car shadow": "Auto-Schatten",
                        "Track shadow": "Strecken-Schatten",
                        Off: "Aus",
                        On: "An",
                        Low: "Niedrig",
                        Medium: "Mittel",
                        High: "Hoch",
                        Clouds: "Wolken",
                        Particles: "Partikel",
                        Skidmarks: "Reifenspuren",
                        "Render scale": "Render-Skalierung",
                        "Anti-aliasing (requires restart)": "Antialiasing (erfordert Neustart)",
                        Audio: "Audio",
                        "Sound effect volume": "Lautstrke Soundeffekte",
                        "Music volume": "Lautstrke Musik",
                        "Checkpoint volume": "Lautstrke Kontrollpunkt",
                        Controls: "Steuerung",
                        Vehicle: "Fahrzeug",
                        Accelerate: "Beschleunigen",
                        Brake: "Bremsen",
                        "Turn left": "Nach links lenken",
                        "Turn right": "Nach rechts lenken",
                        "Checkpoint reset": "Kontrollpunkt zurcksetzen",
                        "Start reset": "Start zurcksetzen",
                        "Cockpit camera": "Cockpit-Kamera",
                        "Rotate part": "Teil drehen",
                        "Height modifier": "Hhenmodifikator",
                        "Delete part": "Teil lschen",
                        "Move forwards": "Nach vorne bewegen",
                        "Move backwards": "Nach hinten bewegen",
                        "Move left": "Nach links bewegen",
                        "Move right": "Nach rechts bewegen",
                        "Rotate view left": "Ansicht nach links drehen",
                        "Rotate view right": "Ansicht nach rechts drehen",
                        "Move down": "Nach unten bewegen",
                        "Move up": "Nach oben bewegen",
                        "Test track": "Strecke testen",
                        "Pick part": "Teil auswhlen",
                        Spectator: "Zuschauer",
                        "Speed modifier": "Geschwindigkeitsmodifikator",
                        Other: "Sonstiges",
                        "Hide UI": "UI ausblenden",
                        Pause: "Pause",
                        "Toggle FPS counter": "FPS-Zhler umschalten",
                        "Toggle spectator camera": "Zuschauerkamera umschalten",
                        "Press any key...\n\nPress [Escape] to cancel.": "Drcken Sie eine beliebige Taste...\n\nDrcken Sie [Escape], um abzubrechen.",
                        Clear: "Lschen",
                        "New record": "Neuer Rekord",
                        Record: "Rekord",
                        Current: "Aktuell",
                        Difference: "Differenz",
                        Copy: "Kopieren",
                        Import: "Importieren",
                        "Failed to import track": "Import der Strecke fehlgeschlagen",
                        'The track "{0}" already exists. Do you wish to overwrite it?': 'Die Strecke "{0}" existiert bereits. Mchten Sie sie berschreiben?',
                        Overwrite: "berschreiben",
                        "Paste track data here...": "Streckendaten hier einfgen...",
                        Rank: "Rang",
                        "Personal best": "Persnlicher Rekord",
                        Opponents: "Gegner",
                        "{0} opponent selected": "{0} Gegner ausgewhlt",
                        "{0} opponents selected": "{0} Gegner ausgewhlt",
                        "Select opponents to race against from the leaderboard on the left": "Whlen Sie Gegner aus der Bestenliste links aus, gegen die Sie antreten mchten",
                        "No record": "Kein Rekord",
                        "Official tracks": "Offizielle Strecken",
                        "Community tracks": "Community-Strecken",
                        "Custom tracks": "Benutzerdefinierte Strecken",
                        'Are you sure you want to delete "{0}"?': 'Sind Sie sicher, dass Sie "{0}" lschen mchten?',
                        Delete: "Lschen",
                        "No community tracks": "Keine Community-Strecken",
                        "Community tracks are coming soon": "Community-Strecken kommen bald",
                        "No custom tracks": "Keine benutzerdefinierten Strecken",
                        "Create a track using the editor or import a track code": "Erstellen Sie eine Strecke mit dem Editor oder importieren Sie einen Streckencode",
                        "Search tracks...": "Strecken suchen...",
                        "Invalid replay detected!": "Ungltige Wiederholung erkannt!",
                        "An opponent most likely used cheats": "Ein Gegner hat wahrscheinlich Cheats verwendet"
                    }
                        , EU = {
                        "Checkpoint order": "Checkpoint order",
                        Height: "Height",
                        Exit: "Exit",
                        Random: "Random",
                        Primary: "Primary",
                        Secondary: "Secondary",
                        Frame: "Frame",
                        Rims: "Rims",
                        "Are you sure you want to exit without saving?": "Are you sure you want to exit without saving?",
                        "All changes will be lost!": "All changes will be lost!",
                        "Car saved!": "Car saved!",
                        Test: "Test",
                        "Starting point is missing!": "Starting point is missing!",
                        Generate: "Generate",
                        "Are you sure you want to generate a new track?\n\nYour current track will be lost!": "Are you sure you want to generate a new track?\n\nYour current track will be lost!",
                        Load: "Load",
                        Save: "Save",
                        "Are you sure you want to load a new track?\n\nYour current track will be lost!": "Are you sure you want to load a new track?\n\nYour current track will be lost!",
                        "Track saved!": "Track saved!",
                        "Failed to save!": "Failed to save!",
                        'Are you sure you want to overwrite "{0}"?': 'Are you sure you want to overwrite "{0}"?',
                        Export: "Export",
                        Help: "Help",
                        "Are you sure you want to exit the editor?": "Are you sure you want to exit the editor?",
                        "All unsaved data will be lost!": "All unsaved data will be lost!",
                        "Track settings": "Track settings",
                        "Unnamed Track": "Unnamed Track",
                        "Track name": "Track name",
                        Author: "Author",
                        Unknown: "Unknown",
                        Environment: "Environment",
                        Summer: "Summer",
                        Winter: "Winter",
                        Desert: "Desert",
                        "Sun direction": "Sun direction",
                        "How to use the editor": "How to use the editor",
                        "Camera controls": "Camera controls",
                        "The camera can be moved by right clicking and dragging the mouse. Rotate the camera by clicking the middle mouse button (mouse wheel) or holding the control key and right clicking and dragging the mouse. Zoom in and out by scrolling the mouse wheel.": "The camera can be moved by right clicking and dragging the mouse. Rotate the camera by clicking the middle mouse button (mouse wheel) or holding the control key and right clicking and dragging the mouse. Zoom in and out by scrolling the mouse wheel.",
                        "Alternatively, the camera can also be controlled using the following keyboard keys:": "Alternatively, the camera can also be controlled using the following keyboard keys:",
                        "Move forwards:": "Move forwards:",
                        "Move backwards:": "Move backwards:",
                        "Move left:": "Move left:",
                        "Move right:": "Move right:",
                        "Rotate left:": "Rotate left:",
                        "Rotate right:": "Rotate right:",
                        "The edited height can be changed either by using the height selection in the bottom left corner, or holding the shift key and scrolling the mouse wheel. Alternatively, you can use the following keyboard keys:": "The edited height can be changed either by using the height selection in the bottom left corner, or holding the shift key and scrolling the mouse wheel. Alternatively, you can use the following keyboard keys:",
                        "Move up:": "Move up:",
                        "Move down:": "Move down:",
                        Editing: "Editing",
                        "Track parts can be selected in the menu on the right after which they can be placed by left clicking with the mouse.": "Track parts can be selected in the menu on the right after which they can be placed by left clicking with the mouse.",
                        "Alternatively, the track part currently hovered by the mouse can be selected with the following keyboard shortcut:": "Alternatively, the track part currently hovered by the mouse can be selected with the following keyboard shortcut:",
                        "The selected part can then be rotated using the following keyboard shortcut:": "The selected part can then be rotated using the following keyboard shortcut:",
                        "Track parts can be deleted by using the delete tool in the right side menu or by holding the following key:": "Track parts can be deleted by using the delete tool in the right side menu or by holding the following key:",
                        "Starting points, checkpoints and the finish line": "Starting points, checkpoints and the finish line",
                        "Starting points, checkpoints and finish lines can all be selected in the uppermost category in the right side menu.": "Starting points, checkpoints and finish lines can all be selected in the uppermost category in the right side menu.",
                        "Each track must have at least one starting point. If there are multiple starting points, the last placed one will be used.": "Each track must have at least one starting point. If there are multiple starting points, the last placed one will be used.",
                        "Checkpoints should be placed between the starting point and the finish line. When a checkpoint track part is selected there will be a tool in the bottom right to select the order of the checkpoint. This determines the order in which the checkpoints must be passed before driving to the finish line. Notice that it is possible to have multiple checkpoints with the same checkpoint order.": "Checkpoints should be placed between the starting point and the finish line. When a checkpoint track part is selected there will be a tool in the bottom right to select the order of the checkpoint. This determines the order in which the checkpoints must be passed before driving to the finish line. Notice that it is possible to have multiple checkpoints with the same checkpoint order.",
                        "The finish line is where the track ends but will only become active after all checkpoints have been passed. It is also possible to have multiple finish lines.": "The finish line is where the track ends but will only become active after all checkpoints have been passed. It is also possible to have multiple finish lines.",
                        "Starting point": "Starting point",
                        Checkpoint: "Checkpoint",
                        "Finish line": "Finish line",
                        "Exporting the track": "Exporting the track",
                        "When the track is finished, a name for the track can be entered in top left after which the track can be exported using the export button. This will reveal a track code which can be sent to other users so they can import and play the track.": "When the track is finished, a name for the track can be entered in top left after which the track can be exported using the export button. This will reveal a track code which can be sent to other users so they can import and play the track.",
                        Close: "Close",
                        "Not set": "Not set",
                        or: "or",
                        "The camera can be moved by dragging with one finger. Rotate the camera by dragging with two fingers. Zoom in and out by pinching.": "The camera can be moved by dragging with one finger. Rotate the camera by dragging with two fingers. Zoom in and out by pinching.",
                        "The edited height can be changed by using the height selection in the bottom left corner.": "The edited height can be changed by using the height selection in the bottom left corner.",
                        "Track parts can be selected in the menu on the right after which they can be placed by tapping on the screen.": "Track parts can be selected in the menu on the right after which they can be placed by tapping on the screen.",
                        "The selected part can then be rotated by tapping the rotate button in the bottom left corner.": "The selected part can then be rotated by tapping the rotate button in the bottom left corner.",
                        "Track parts can be deleted by using the delete tool in the right side menu.": "Track parts can be deleted by using the delete tool in the right side menu.",
                        Watch: "Watch",
                        "Loading replay": "Loading replay",
                        "Press {0} to return to the last checkpoint": "Press {0} to return to the last checkpoint",
                        "Press {0} to start over": "Press {0} to start over",
                        "Reset once to return to the last checkpoint": "Reset once to return to the last checkpoint",
                        "Reset again to start over": "Reset again to start over",
                        Leaderboard: "Leaderboard",
                        Back: "Back",
                        "Error: Failed to load leaderboard": "Error: Failed to load leaderboard",
                        Pending: "Pending",
                        Verified: "Verified",
                        Invalid: "Invalid",
                        Duplicate: "Duplicate",
                        You: "You",
                        "Only verified": "Only verified",
                        Loading: "Loading",
                        "Failed to load recordings": "Failed to load recordings",
                        "Cannot load recordings due to non-determinism": "Cannot load recordings due to non-determinism",
                        Ok: "Ok",
                        "Track is missing starting point": "Track is missing starting point",
                        "Some leaderboard features are disabled.": "Some leaderboard features are disabled.",
                        "Please try another browser or device.": "Please try another browser or device.",
                        "You already have another instance of PolyTrack open.": "You already have another instance of PolyTrack open.",
                        "Please switch to that tab or window to continue.": "Please switch to that tab or window to continue.",
                        "Computer determinism check failed.": "Computer determinism check failed.",
                        "Non-deterministic game assets found.": "Non-deterministic game assets found.",
                        "Please try clearing your browser cache.": "Please try clearing your browser cache.",
                        Customize: "Customize",
                        Editor: "Editor",
                        Settings: "Settings",
                        Profile: "Profile",
                        Play: "Play",
                        Version: "Version",
                        "You cannot have duplicate user profiles": "You cannot have duplicate user profiles",
                        "Failed to create user profile": "Failed to create user profile",
                        "This user profile does not exist on the server": "This user profile does not exist on the server",
                        "Failed to download user profile from the server": "Failed to download user profile from the server",
                        "User token is invalid": "User token is invalid",
                        "Are you sure you want to display your private key?": "Are you sure you want to display your private key?",
                        "DO NOT SHARE THIS KEY WITH ANYONE.": "DO NOT SHARE THIS KEY WITH ANYONE.",
                        "You need a free user profile slot to import a new user profile": "You need a free user profile slot to import a new user profile",
                        Quit: "Quit",
                        Fullscreen: "Fullscreen",
                        Windowed: "Windowed",
                        "It seems like you are playing an unofficial version of {0}. For the most up-to-date version please visit the original source:": "It seems like you are playing an unofficial version of {0}. For the most up-to-date version please visit the original source:",
                        Nickname: "Nickname",
                        "Choose a nickname to be shown in the leaderboard. Your nickname can be changed at any time.": "Choose a nickname to be shown in the leaderboard. Your nickname can be changed at any time.",
                        Cancel: "Cancel",
                        Confirm: "Confirm",
                        Verifier: "Verifier",
                        "User ID": "User ID",
                        Paused: "Paused",
                        "Switch car": "Switch car",
                        Profiles: "Profiles",
                        'Are you sure you would like to delete "{0}"?': 'Are you sure you would like to delete "{0}"?',
                        Empty: "Empty",
                        Reset: "Reset",
                        Apply: "Apply",
                        Gameplay: "Gameplay",
                        Units: "Units",
                        Metric: "Metric",
                        Imperial: "Imperial",
                        "Reset hint": "Reset hint",
                        Disabled: "Disabled",
                        Enabled: "Enabled",
                        "Ghost car": "Ghost car",
                        "Default camera": "Default camera",
                        Default: "Default",
                        Cockpit: "Cockpit",
                        "Cockpit camera mode": "Cockpit camera mode",
                        Hold: "Hold",
                        Toggle: "Toggle",
                        Checkpoints: "Checkpoints",
                        Timer: "Timer",
                        Speedometer: "Speedometer",
                        Bottom: "Bottom",
                        Top: "Top",
                        Language: "Language",
                        Graphics: "Graphics",
                        "Car shadow": "Car shadow",
                        "Track shadow": "Track shadow",
                        Off: "Off",
                        On: "On",
                        Low: "Low",
                        Medium: "Medium",
                        High: "High",
                        Clouds: "Clouds",
                        Particles: "Particles",
                        Skidmarks: "Skidmarks",
                        "Render scale": "Render scale",
                        "Anti-aliasing (requires restart)": "Anti-aliasing (requires restart)",
                        Audio: "Audio",
                        "Sound effect volume": "Sound effect volume",
                        "Music volume": "Music volume",
                        "Checkpoint volume": "Checkpoint volume",
                        Controls: "Controls",
                        Vehicle: "Vehicle",
                        Accelerate: "Accelerate",
                        Brake: "Brake",
                        "Turn left": "Turn left",
                        "Turn right": "Turn right",
                        "Checkpoint reset": "Checkpoint reset",
                        "Start reset": "Start reset",
                        "Cockpit camera": "Cockpit camera",
                        "Rotate part": "Rotate part",
                        "Height modifier": "Height modifier",
                        "Delete part": "Delete part",
                        "Move forwards": "Move forwards",
                        "Move backwards": "Move backwards",
                        "Move left": "Move left",
                        "Move right": "Move right",
                        "Rotate view left": "Rotate view left",
                        "Rotate view right": "Rotate view right",
                        "Move down": "Move down",
                        "Move up": "Move up",
                        "Test track": "Test track",
                        "Pick part": "Pick part",
                        Spectator: "Spectator",
                        "Speed modifier": "Speed modifier",
                        Other: "Other",
                        "Hide UI": "Hide UI",
                        Pause: "Pause",
                        "Toggle FPS counter": "Toggle FPS counter",
                        "Toggle spectator camera": "Toggle spectator camera",
                        "Press any key...\n\nPress [Escape] to cancel.": "Press any key...\n\nPress [Escape] to cancel.",
                        Clear: "Clear",
                        "New record": "New record",
                        Record: "Record",
                        Current: "Current",
                        Difference: "Difference",
                        Copy: "Copy",
                        Import: "Import",
                        "Failed to import track": "Failed to import track",
                        'The track "{0}" already exists. Do you wish to overwrite it?': 'The track "{0}" already exists. Do you wish to overwrite it?',
                        Overwrite: "Overwrite",
                        "Paste track data here...": "Paste track data here...",
                        Rank: "Rank",
                        "Personal best": "Personal best",
                        Opponents: "Opponents",
                        "{0} opponent selected": "{0} opponent selected",
                        "{0} opponents selected": "{0} opponents selected",
                        "Select opponents to race against from the leaderboard on the left": "Select opponents to race against from the leaderboard on the left",
                        "No record": "No record",
                        "Official tracks": "Official tracks",
                        "Community tracks": "Community tracks",
                        "Custom tracks": "Custom tracks",
                        'Are you sure you want to delete "{0}"?': 'Are you sure you want to delete "{0}"?',
                        Delete: "Delete",
                        "No community tracks": "No community tracks",
                        "Community tracks are coming soon": "Community tracks are coming soon",
                        "No custom tracks": "No custom tracks",
                        "Create a track using the editor or import a track code": "Create a track using the editor or import a track code",
                        "Search tracks...": "Search tracks...",
                        "Invalid replay detected!": "Invalid replay detected!",
                        "An opponent most likely used cheats": "An opponent most likely used cheats"
                    }
                        , SU = {
                        "Checkpoint order": "Orden de puntos de control",
                        Height: "Altura",
                        Exit: "Salir",
                        Random: "Aleatorio",
                        Primary: "Primario",
                        Secondary: "Secundario",
                        Frame: "Marco",
                        Rims: "Llantas",
                        "Are you sure you want to exit without saving?": "Ests seguro de que deseas salir sin guardar?",
                        "All changes will be lost!": "Todos los cambios se perdern!",
                        "Car saved!": "Coche guardado!",
                        Test: "Prueba",
                        "Starting point is missing!": "Falta el punto de inicio!",
                        Generate: "Generar",
                        "Are you sure you want to generate a new track?\n\nYour current track will be lost!": "Ests seguro de que deseas generar una nueva pista?\n\nTu pista actual se perder!",
                        Load: "Cargar",
                        Save: "Guardar",
                        "Are you sure you want to load a new track?\n\nYour current track will be lost!": "Ests seguro de que deseas cargar una nueva pista?\n\nTu pista actual se perder!",
                        "Track saved!": "Pista guardada!",
                        "Failed to save!": "Error al guardar!",
                        'Are you sure you want to overwrite "{0}"?': 'Ests seguro de que deseas sobrescribir "{0}"?',
                        Export: "Exportar",
                        Help: "Ayuda",
                        "Are you sure you want to exit the editor?": "Ests seguro de que deseas salir del editor?",
                        "All unsaved data will be lost!": "Se perdern todos los datos no guardados!",
                        "Track settings": "Configuracin de la pista",
                        "Unnamed Track": "Pista sin nombre",
                        "Track name": "Nombre de la pista",
                        Author: "Autor",
                        Unknown: "Desconocido",
                        Environment: "Entorno",
                        Summer: "Verano",
                        Winter: "Invierno",
                        Desert: "Desierto",
                        "Sun direction": "Direccin del sol",
                        "How to use the editor": "Cmo usar el editor",
                        "Camera controls": "Controles de la cmara",
                        "The camera can be moved by right clicking and dragging the mouse. Rotate the camera by clicking the middle mouse button (mouse wheel) or holding the control key and right clicking and dragging the mouse. Zoom in and out by scrolling the mouse wheel.": "La cmara se puede mover haciendo clic derecho y arrastrando el ratn. Gira la cmara haciendo clic con el botn central del ratn (rueda del ratn) o manteniendo presionada la tecla de control y haciendo clic derecho y arrastrando el ratn. Acrcate y aljate desplazando la rueda del ratn.",
                        "Alternatively, the camera can also be controlled using the following keyboard keys:": "Alternativamente, la cmara tambin se puede controlar usando las siguientes teclas del teclado:",
                        "Move forwards:": "Mover hacia adelante:",
                        "Move backwards:": "Mover hacia atrs:",
                        "Move left:": "Mover a la izquierda:",
                        "Move right:": "Mover a la derecha:",
                        "Rotate left:": "Girar a la izquierda:",
                        "Rotate right:": "Girar a la derecha:",
                        "The edited height can be changed either by using the height selection in the bottom left corner, or holding the shift key and scrolling the mouse wheel. Alternatively, you can use the following keyboard keys:": "La altura editada se puede cambiar ya sea usando la seleccin de altura en la esquina inferior izquierda, o manteniendo presionada la tecla de maysculas y desplazando la rueda del ratn. Alternativamente, puedes usar las siguientes teclas del teclado:",
                        "Move up:": "Mover hacia arriba:",
                        "Move down:": "Mover hacia abajo:",
                        Editing: "Edicin",
                        "Track parts can be selected in the menu on the right after which they can be placed by left clicking with the mouse.": "Las partes de la pista se pueden seleccionar en el men de la derecha, despus de lo cual se pueden colocar haciendo clic izquierdo con el ratn.",
                        "Alternatively, the track part currently hovered by the mouse can be selected with the following keyboard shortcut:": "Alternativamente, la parte de la pista actualmente sobrevolada por el ratn se puede seleccionar con el siguiente atajo de teclado:",
                        "The selected part can then be rotated using the following keyboard shortcut:": "La parte seleccionada se puede girar usando el siguiente atajo de teclado:",
                        "Track parts can be deleted by using the delete tool in the right side menu or by holding the following key:": "Las partes de la pista se pueden eliminar usando la herramienta de eliminacin en el men del lado derecho o manteniendo presionada la siguiente tecla:",
                        "Starting points, checkpoints and the finish line": "Puntos de inicio, puntos de control y la lnea de meta",
                        "Starting points, checkpoints and finish lines can all be selected in the uppermost category in the right side menu.": "Los puntos de inicio, puntos de control y lneas de meta se pueden seleccionar en la categora superior del men del lado derecho.",
                        "Each track must have at least one starting point. If there are multiple starting points, the last placed one will be used.": "Cada pista debe tener al menos un punto de inicio. Si hay varios puntos de inicio, se usar el ltimo colocado.",
                        "Checkpoints should be placed between the starting point and the finish line. When a checkpoint track part is selected there will be a tool in the bottom right to select the order of the checkpoint. This determines the order in which the checkpoints must be passed before driving to the finish line. Notice that it is possible to have multiple checkpoints with the same checkpoint order.": "Los puntos de control deben colocarse entre el punto de inicio y la lnea de meta. Cuando se selecciona una parte de la pista de punto de control, habr una herramienta en la parte inferior derecha para seleccionar el orden del punto de control. Esto determina el orden en que se deben pasar los puntos de control antes de conducir hacia la lnea de meta. Ten en cuenta que es posible tener varios puntos de control con el mismo orden de punto de control.",
                        "The finish line is where the track ends but will only become active after all checkpoints have been passed. It is also possible to have multiple finish lines.": "La lnea de meta es donde termina la pista, pero solo se activar despus de que se hayan pasado todos los puntos de control. Tambin es posible tener varias lneas de meta.",
                        "Starting point": "Punto de inicio",
                        Checkpoint: "Punto de control",
                        "Finish line": "Lnea de meta",
                        "Exporting the track": "Exportando la pista",
                        "When the track is finished, a name for the track can be entered in top left after which the track can be exported using the export button. This will reveal a track code which can be sent to other users so they can import and play the track.": "Cuando la pista est terminada, se puede ingresar un nombre para la pista en la parte superior izquierda, despus de lo cual se puede exportar la pista usando el botn de exportacin. Esto revelar un cdigo de pista que se puede enviar a otros usuarios para que puedan importar y jugar la pista.",
                        Close: "Cerrar",
                        "Not set": "No establecido",
                        or: "o",
                        "The camera can be moved by dragging with one finger. Rotate the camera by dragging with two fingers. Zoom in and out by pinching.": "La cmara se puede mover arrastrando con un dedo. Gira la cmara arrastrando con dos dedos. Acrcate y aljate pellizcando.",
                        "The edited height can be changed by using the height selection in the bottom left corner.": "La altura editada se puede cambiar usando la seleccin de altura en la esquina inferior izquierda.",
                        "Track parts can be selected in the menu on the right after which they can be placed by tapping on the screen.": "Las partes de la pista se pueden seleccionar en el men de la derecha, despus de lo cual se pueden colocar tocando la pantalla.",
                        "The selected part can then be rotated by tapping the rotate button in the bottom left corner.": "La parte seleccionada se puede girar tocando el botn de rotacin en la esquina inferior izquierda.",
                        "Track parts can be deleted by using the delete tool in the right side menu.": "Las partes de la pista se pueden eliminar usando la herramienta de eliminacin en el men del lado derecho.",
                        Watch: "Ver",
                        "Loading replay": "Cargando repeticin",
                        "Press {0} to return to the last checkpoint": "Presiona {0} para volver al ltimo punto de control",
                        "Press {0} to start over": "Presiona {0} para empezar de nuevo",
                        "Reset once to return to the last checkpoint": "Restablecer una vez para volver al ltimo punto de control",
                        "Reset again to start over": "Restablecer de nuevo para empezar de nuevo",
                        Leaderboard: "Tabla de clasificacin",
                        Back: "Volver",
                        "Error: Failed to load leaderboard": "Error: No se pudo cargar la tabla de clasificacin",
                        Pending: "Pendiente",
                        Verified: "Verificado",
                        Invalid: "Invlido",
                        Duplicate: "Duplicado",
                        You: "T",
                        "Only verified": "Solo verificados",
                        Loading: "Cargando",
                        "Failed to load recordings": "Error al cargar las grabaciones",
                        "Cannot load recordings due to non-determinism": "No se pueden cargar las grabaciones debido a la no determinismo",
                        Ok: "Aceptar",
                        "Track is missing starting point": "Falta el punto de inicio en la pista",
                        "Some leaderboard features are disabled.": "Algunas funciones de la tabla de clasificacin estn desactivadas.",
                        "Please try another browser or device.": "Por favor, prueba otro navegador o dispositivo.",
                        "You already have another instance of PolyTrack open.": "Ya tienes otra instancia de PolyTrack abierta.",
                        "Please switch to that tab or window to continue.": "Por favor, cambia a esa pestaa o ventana para continuar.",
                        "Computer determinism check failed.": "Fall la comprobacin de determinismo del ordenador.",
                        "Non-deterministic game assets found.": "Se encontraron activos de juego no deterministas.",
                        "Please try clearing your browser cache.": "Por favor, intenta borrar la cach de tu navegador.",
                        Customize: "Personalizar",
                        Editor: "Editor",
                        Settings: "Configuracin",
                        Profile: "Perfil",
                        Play: "Jugar",
                        Version: "Versin",
                        "You cannot have duplicate user profiles": "No puedes tener perfiles de usuario duplicados",
                        "Failed to create user profile": "No se pudo crear el perfil de usuario",
                        "This user profile does not exist on the server": "Este perfil de usuario no existe en el servidor",
                        "Failed to download user profile from the server": "No se pudo descargar el perfil de usuario desde el servidor",
                        "User token is invalid": "El token de usuario no es vlido",
                        "Are you sure you want to display your private key?": "Ests seguro de que quieres mostrar tu clave privada?",
                        "DO NOT SHARE THIS KEY WITH ANYONE.": "NO COMPARTAS ESTA CLAVE CON NADIE.",
                        "You need a free user profile slot to import a new user profile": "Necesitas un espacio libre de perfil de usuario para importar un nuevo perfil de usuario",
                        Quit: "Salir",
                        Fullscreen: "Pantalla completa",
                        Windowed: "Ventana",
                        "It seems like you are playing an unofficial version of {0}. For the most up-to-date version please visit the original source:": "Parece que ests jugando una versin no oficial de {0}. Para la versin ms actualizada, visita la fuente original:",
                        Nickname: "Apodo",
                        "Choose a nickname to be shown in the leaderboard. Your nickname can be changed at any time.": "Elige un apodo para que aparezca en la tabla de clasificacin. Puedes cambiar tu apodo en cualquier momento.",
                        Cancel: "Cancelar",
                        Confirm: "Confirmar",
                        Verifier: "Verificador",
                        "User ID": "ID de usuario",
                        Paused: "Pausado",
                        "Switch car": "Cambiar coche",
                        Profiles: "Perfiles",
                        'Are you sure you would like to delete "{0}"?': 'Ests seguro de que quieres eliminar "{0}"?',
                        Empty: "Vaco",
                        Reset: "Restablecer",
                        Apply: "Aplicar",
                        Gameplay: "Jugabilidad",
                        Units: "Unidades",
                        Metric: "Mtrico",
                        Imperial: "Imperial",
                        "Reset hint": "Restablecer pista",
                        Disabled: "Desactivado",
                        Enabled: "Activado",
                        "Ghost car": "Coche fantasma",
                        "Default camera": "Cmara predeterminada",
                        Default: "Predeterminado",
                        Cockpit: "Cabina",
                        "Cockpit camera mode": "Modo de cmara en la cabina",
                        Hold: "Mantener",
                        Toggle: "Alternar",
                        Checkpoints: "Puntos de control",
                        Timer: "Temporizador",
                        Speedometer: "Velocmetro",
                        Bottom: "Inferior",
                        Top: "Superior",
                        Language: "Idioma",
                        Graphics: "Grficos",
                        "Car shadow": "Sombra del coche",
                        "Track shadow": "Sombra de la pista",
                        Off: "Apagar",
                        On: "Encender",
                        Low: "Bajo",
                        Medium: "Medio",
                        High: "Alto",
                        Clouds: "Nubes",
                        Particles: "Partculas",
                        Skidmarks: "Marcas de derrape",
                        "Render scale": "Escala de renderizado",
                        "Anti-aliasing (requires restart)": "Anti-aliasing (requiere reinicio)",
                        Audio: "Audio",
                        "Sound effect volume": "Volumen de efectos de sonido",
                        "Music volume": "Volumen de msica",
                        "Checkpoint volume": "Volumen de puntos de control",
                        Controls: "Controles",
                        Vehicle: "Vehculo",
                        Accelerate: "Acelerar",
                        Brake: "Frenar",
                        "Turn left": "Girar a la izquierda",
                        "Turn right": "Girar a la derecha",
                        "Checkpoint reset": "Restablecer punto de control",
                        "Start reset": "Restablecer inicio",
                        "Cockpit camera": "Cmara en la cabina",
                        "Rotate part": "Girar parte",
                        "Height modifier": "Modificador de altura",
                        "Delete part": "Eliminar parte",
                        "Move forwards": "Mover hacia adelante",
                        "Move backwards": "Mover hacia atrs",
                        "Move left": "Mover a la izquierda",
                        "Move right": "Mover a la derecha",
                        "Rotate view left": "Girar vista a la izquierda",
                        "Rotate view right": "Girar vista a la derecha",
                        "Move down": "Mover hacia abajo",
                        "Move up": "Mover hacia arriba",
                        "Test track": "Probar pista",
                        "Pick part": "Seleccionar parte",
                        Spectator: "Espectador",
                        "Speed modifier": "Modificador de velocidad",
                        Other: "Otro",
                        "Hide UI": "Ocultar IU",
                        Pause: "Pausa",
                        "Toggle FPS counter": "Alternar contador de FPS",
                        "Toggle spectator camera": "Alternar cmara de espectador",
                        "Press any key...\n\nPress [Escape] to cancel.": "Presiona cualquier tecla...\n\nPresiona [Escape] para cancelar.",
                        Clear: "Borrar",
                        "New record": "Nuevo rcord",
                        Record: "Rcord",
                        Current: "Actual",
                        Difference: "Diferencia",
                        Copy: "Copiar",
                        Import: "Importar",
                        "Failed to import track": "Error al importar la pista",
                        'The track "{0}" already exists. Do you wish to overwrite it?': 'La pista "{0}" ya existe. Deseas sobrescribirla?',
                        Overwrite: "Sobrescribir",
                        "Paste track data here...": "Pegar datos de la pista aqu...",
                        Rank: "Rango",
                        "Personal best": "Mejor marca personal",
                        Opponents: "Oponentes",
                        "{0} opponent selected": "{0} oponente seleccionado",
                        "{0} opponents selected": "{0} oponente seleccionado",
                        "Select opponents to race against from the leaderboard on the left": "Selecciona oponentes con los que competir en la tabla de clasificacin de la izquierda",
                        "No record": "Sin rcord",
                        "Official tracks": "Pistas oficiales",
                        "Community tracks": "Pistas de la comunidad",
                        "Custom tracks": "Pistas personalizadas",
                        'Are you sure you want to delete "{0}"?': 'Ests seguro de que deseas eliminar "{0}"?',
                        Delete: "Eliminar",
                        "No community tracks": "No hay pistas de la comunidad",
                        "Community tracks are coming soon": "Las pistas de la comunidad llegarn pronto",
                        "No custom tracks": "No hay pistas personalizadas",
                        "Create a track using the editor or import a track code": "Crea una pista usando el editor o importa un cdigo de pista",
                        "Search tracks...": "Buscar pistas...",
                        "Invalid replay detected!": "Se detect una repeticin no vlida!",
                        "An opponent most likely used cheats": "Un oponente probablemente us trucos"
                    }
                        , MU = {
                        "Checkpoint order": "Ordre des points de contrle",
                        Height: "Hauteur",
                        Exit: "Quitter",
                        Random: "Alatoire",
                        Primary: "Principal",
                        Secondary: "Secondaire",
                        Frame: "Cadre",
                        Rims: "Jantes",
                        "Are you sure you want to exit without saving?": "tes-vous sr de vouloir quitter sans sauvegarder ?",
                        "All changes will be lost!": "Tous les changements seront perdus !",
                        "Car saved!": "Voiture sauvegarde !",
                        Test: "Test",
                        "Starting point is missing!": "Point de dpart manquant !",
                        Generate: "Gnrer",
                        "Are you sure you want to generate a new track?\n\nYour current track will be lost!": "tes-vous sr de vouloir gnrer une nouvelle piste ?\n\nVotre piste actuelle sera perdue !",
                        Load: "Charger",
                        Save: "Enregistrer",
                        "Are you sure you want to load a new track?\n\nYour current track will be lost!": "tes-vous sr de vouloir charger une nouvelle piste ?\n\nVotre piste actuelle sera perdue !",
                        "Track saved!": "Piste enregistre !",
                        "Failed to save!": "chec de l'enregistrement !",
                        'Are you sure you want to overwrite "{0}"?': 'tes-vous sr de vouloir craser "{0}" ?',
                        Export: "Exporter",
                        Help: "Aide",
                        "Are you sure you want to exit the editor?": "tes-vous sr de vouloir quitter l'diteur ?",
                        "All unsaved data will be lost!": "Toutes les donnes non sauvegardes seront perdues !",
                        "Track settings": "Paramtres de la piste",
                        "Unnamed Track": "Piste sans nom",
                        "Track name": "Nom de la piste",
                        Author: "Auteur",
                        Unknown: "Inconnu",
                        Environment: "Environnement",
                        Summer: "t",
                        Winter: "Hiver",
                        Desert: "Dsert",
                        "Sun direction": "Direction du soleil",
                        "How to use the editor": "Comment utiliser l'diteur",
                        "Camera controls": "Contrles de la camra",
                        "The camera can be moved by right clicking and dragging the mouse. Rotate the camera by clicking the middle mouse button (mouse wheel) or holding the control key and right clicking and dragging the mouse. Zoom in and out by scrolling the mouse wheel.": "La camra peut tre dplace en cliquant avec le bouton droit et en faisant glisser la souris. Faites pivoter la camra en cliquant sur le bouton central de la souris (molette) ou en maintenant la touche de contrle enfonce et en cliquant avec le bouton droit et en faisant glisser la souris. Zoomez en avant et en arrire en faisant dfiler la molette de la souris.",
                        "Alternatively, the camera can also be controlled using the following keyboard keys:": "Alternativement, la camra peut galement tre contrle en utilisant les touches de clavier suivantes :",
                        "Move forwards:": "Avancer :",
                        "Move backwards:": "Reculer :",
                        "Move left:": "Dplacer  gauche :",
                        "Move right:": "Dplacer  droite :",
                        "Rotate left:": "Pivoter  gauche :",
                        "Rotate right:": "Pivoter  droite :",
                        "The edited height can be changed either by using the height selection in the bottom left corner, or holding the shift key and scrolling the mouse wheel. Alternatively, you can use the following keyboard keys:": "La hauteur modifie peut tre change en utilisant la slection de hauteur dans le coin infrieur gauche, ou en maintenant la touche Maj enfonce et en faisant dfiler la molette de la souris. Alternativement, vous pouvez utiliser les touches de clavier suivantes :",
                        "Move up:": "Monter :",
                        "Move down:": "Descendre :",
                        Editing: "dition",
                        "Track parts can be selected in the menu on the right after which they can be placed by left clicking with the mouse.": "Les parties de la piste peuvent tre slectionnes dans le menu de droite, aprs quoi elles peuvent tre places en cliquant avec le bouton gauche de la souris.",
                        "Alternatively, the track part currently hovered by the mouse can be selected with the following keyboard shortcut:": "Alternativement, la partie de la piste actuellement survole par la souris peut tre slectionne avec le raccourci clavier suivant :",
                        "The selected part can then be rotated using the following keyboard shortcut:": "La partie slectionne peut ensuite tre pivote en utilisant le raccourci clavier suivant :",
                        "Track parts can be deleted by using the delete tool in the right side menu or by holding the following key:": "Les parties de la piste peuvent tre supprimes en utilisant l'outil de suppression dans le menu de droite ou en maintenant la touche suivante enfonce :",
                        "Starting points, checkpoints and the finish line": "Points de dpart, points de contrle et ligne d'arrive",
                        "Starting points, checkpoints and finish lines can all be selected in the uppermost category in the right side menu.": "Les points de dpart, les points de contrle et les lignes d'arrive peuvent tous tre slectionns dans la catgorie la plus haute du menu de droite.",
                        "Each track must have at least one starting point. If there are multiple starting points, the last placed one will be used.": "Chaque piste doit avoir au moins un point de dpart. S'il y a plusieurs points de dpart, le dernier plac sera utilis.",
                        "Checkpoints should be placed between the starting point and the finish line. When a checkpoint track part is selected there will be a tool in the bottom right to select the order of the checkpoint. This determines the order in which the checkpoints must be passed before driving to the finish line. Notice that it is possible to have multiple checkpoints with the same checkpoint order.": "Les points de contrle doivent tre placs entre le point de dpart et la ligne d'arrive. Lorsqu'une partie de la piste de point de contrle est slectionne, il y aura un outil en bas  droite pour slectionner l'ordre du point de contrle. Cela dtermine l'ordre dans lequel les points de contrle doivent tre passs avant de conduire jusqu' la ligne d'arrive. Notez qu'il est possible d'avoir plusieurs points de contrle avec le mme ordre de point de contrle.",
                        "The finish line is where the track ends but will only become active after all checkpoints have been passed. It is also possible to have multiple finish lines.": "La ligne d'arrive est l'endroit o la piste se termine mais ne deviendra active qu'aprs que tous les points de contrle aient t passs. Il est galement possible d'avoir plusieurs lignes d'arrive.",
                        "Starting point": "Point de dpart",
                        Checkpoint: "Point de contrle",
                        "Finish line": "Ligne d'arrive",
                        "Exporting the track": "Exportation de la piste",
                        "When the track is finished, a name for the track can be entered in top left after which the track can be exported using the export button. This will reveal a track code which can be sent to other users so they can import and play the track.": "Lorsque la piste est termine, un nom pour la piste peut tre entr en haut  gauche, aprs quoi la piste peut tre exporte en utilisant le bouton d'exportation. Cela rvlera un code de piste qui peut tre envoy  d'autres utilisateurs afin qu'ils puissent importer et jouer la piste.",
                        Close: "Fermer",
                        "Not set": "Non dfini",
                        or: "ou",
                        "The camera can be moved by dragging with one finger. Rotate the camera by dragging with two fingers. Zoom in and out by pinching.": "La camra peut tre dplace en faisant glisser un doigt. Faites pivoter la camra en faisant glisser deux doigts. Zoomez avant et arrire en pinant.",
                        "The edited height can be changed by using the height selection in the bottom left corner.": "La hauteur modifie peut tre change en utilisant la slection de hauteur dans le coin infrieur gauche.",
                        "Track parts can be selected in the menu on the right after which they can be placed by tapping on the screen.": "Les parties de la piste peuvent tre slectionnes dans le menu de droite, aprs quoi elles peuvent tre places en tapant sur l'cran.",
                        "The selected part can then be rotated by tapping the rotate button in the bottom left corner.": "La partie slectionne peut ensuite tre pivote en tapant sur le bouton de rotation dans le coin infrieur gauche.",
                        "Track parts can be deleted by using the delete tool in the right side menu.": "Les parties de la piste peuvent tre supprimes en utilisant l'outil de suppression dans le menu de droite.",
                        Watch: "Regarder",
                        "Loading replay": "Chargement de l'enregistrement",
                        "Press {0} to return to the last checkpoint": "Appuyez sur {0} pour retourner au dernier point de contrle",
                        "Press {0} to start over": "Appuyez sur {0} pour recommencer",
                        "Reset once to return to the last checkpoint": "Rinitialisez une fois pour retourner au dernier point de contrle",
                        "Reset again to start over": "Rinitialisez  nouveau pour recommencer",
                        Leaderboard: "Classement",
                        Back: "Retour",
                        "Error: Failed to load leaderboard": "Erreur : chec du chargement du classement",
                        Pending: "En attente",
                        Verified: "Vrifi",
                        Invalid: "Invalide",
                        Duplicate: "Doublon",
                        You: "Vous",
                        "Only verified": "Uniquement vrifis",
                        Loading: "Chargement",
                        "Failed to load recordings": "chec du chargement des enregistrements",
                        "Cannot load recordings due to non-determinism": "Impossible de charger les enregistrements en raison du non-dterminisme",
                        Ok: "OK",
                        "Track is missing starting point": "La piste n'a pas de point de dpart",
                        "Some leaderboard features are disabled.": "Certaines fonctionnalits du classement sont dsactives.",
                        "Please try another browser or device.": "Veuillez essayer un autre navigateur ou appareil.",
                        "You already have another instance of PolyTrack open.": "Vous avez dj une autre instance de PolyTrack ouverte.",
                        "Please switch to that tab or window to continue.": "Veuillez basculer vers cet onglet ou cette fentre pour continuer.",
                        "Computer determinism check failed.": "chec de la vrification du dterminisme de l'ordinateur.",
                        "Non-deterministic game assets found.": "Actifs de jeu non dterministes trouvs.",
                        "Please try clearing your browser cache.": "Veuillez essayer de vider le cache de votre navigateur.",
                        Customize: "Personnaliser",
                        Editor: "diteur",
                        Settings: "Paramtres",
                        Profile: "Profil",
                        Play: "Jouer",
                        Version: "Version",
                        "You cannot have duplicate user profiles": "Vous ne pouvez pas avoir de profils d'utilisateur en double",
                        "Failed to create user profile": "chec de la cration du profil utilisateur",
                        "This user profile does not exist on the server": "Ce profil utilisateur n'existe pas sur le serveur",
                        "Failed to download user profile from the server": "chec du tlchargement du profil utilisateur depuis le serveur",
                        "User token is invalid": "Le jeton utilisateur n'est pas valide",
                        "Are you sure you want to display your private key?": "tes-vous sr de vouloir afficher votre cl prive ?",
                        "DO NOT SHARE THIS KEY WITH ANYONE.": "NE PARTAGEZ PAS CETTE CL AVEC PERSONNE.",
                        "You need a free user profile slot to import a new user profile": "Vous avez besoin d'un emplacement de profil utilisateur libre pour importer un nouveau profil utilisateur",
                        Quit: "Quitter",
                        Fullscreen: "Plein cran",
                        Windowed: "Fentr",
                        "It seems like you are playing an unofficial version of {0}. For the most up-to-date version please visit the original source:": "Il semble que vous jouiez  une version non officielle de {0}. Pour la version la plus rcente, veuillez visiter la source originale :",
                        Nickname: "Pseudonyme",
                        "Choose a nickname to be shown in the leaderboard. Your nickname can be changed at any time.": "Choisissez un pseudonyme  afficher dans le classement. Vous pouvez changer votre pseudonyme  tout moment.",
                        Cancel: "Annuler",
                        Confirm: "Confirmer",
                        Verifier: "Vrificateur",
                        "User ID": "ID utilisateur",
                        Paused: "En pause",
                        "Switch car": "Changer de voiture",
                        Profiles: "Profils",
                        'Are you sure you would like to delete "{0}"?': 'tes-vous sr de vouloir supprimer "{0}"?',
                        Empty: "Vide",
                        Reset: "Rinitialiser",
                        Apply: "Appliquer",
                        Gameplay: "Jouabilit",
                        Units: "Units",
                        Metric: "Mtrique",
                        Imperial: "Imprial",
                        "Reset hint": "Rinitialiser l'astuce",
                        Disabled: "Dsactiv",
                        Enabled: "Activ",
                        "Ghost car": "Voiture fantme",
                        "Default camera": "Camra par dfaut",
                        Default: "Dfaut",
                        Cockpit: "Cockpit",
                        "Cockpit camera mode": "Mode camra cockpit",
                        Hold: "Maintenir",
                        Toggle: "Basculer",
                        Checkpoints: "Points de contrle",
                        Timer: "Minuteur",
                        Speedometer: "Compteur de vitesse",
                        Bottom: "Bas",
                        Top: "Haut",
                        Language: "Langue",
                        Graphics: "Graphismes",
                        "Car shadow": "Ombre de la voiture",
                        "Track shadow": "Ombre de la piste",
                        Off: "Dsactiv",
                        On: "Activ",
                        Low: "Faible",
                        Medium: "Moyen",
                        High: "lev",
                        Clouds: "Nuages",
                        Particles: "Particules",
                        Skidmarks: "Marques de drapage",
                        "Render scale": "chelle de rendu",
                        "Anti-aliasing (requires restart)": "Anticrnelage (ncessite un redmarrage)",
                        Audio: "Audio",
                        "Sound effect volume": "Volume des effets sonores",
                        "Music volume": "Volume de la musique",
                        "Checkpoint volume": "Volume des points de contrle",
                        Controls: "Commandes",
                        Vehicle: "Vhicule",
                        Accelerate: "Acclrer",
                        Brake: "Freiner",
                        "Turn left": "Tourner  gauche",
                        "Turn right": "Tourner  droite",
                        "Checkpoint reset": "Rinitialisation du point de contrle",
                        "Start reset": "Rinitialisation du dpart",
                        "Cockpit camera": "Camra cockpit",
                        "Rotate part": "Pivoter la partie",
                        "Height modifier": "Modificateur de hauteur",
                        "Delete part": "Supprimer la partie",
                        "Move forwards": "Avancer",
                        "Move backwards": "Reculer",
                        "Move left": "Dplacer  gauche",
                        "Move right": "Dplacer  droite",
                        "Rotate view left": "Pivoter la vue  gauche",
                        "Rotate view right": "Pivoter la vue  droite",
                        "Move down": "Descendre",
                        "Move up": "Monter",
                        "Test track": "Tester la piste",
                        "Pick part": "Choisir la partie",
                        Spectator: "Spectateur",
                        "Speed modifier": "Modificateur de vitesse",
                        Other: "Autre",
                        "Hide UI": "Masquer l'interface utilisateur",
                        Pause: "Pause",
                        "Toggle FPS counter": "Basculer le compteur FPS",
                        "Toggle spectator camera": "Basculer la camra spectateur",
                        "Press any key...\n\nPress [Escape] to cancel.": "Appuyez sur n'importe quelle touche...\n\nAppuyez sur [chap] pour annuler.",
                        Clear: "Effacer",
                        "New record": "Nouveau record",
                        Record: "Record",
                        Current: "Actuel",
                        Difference: "Diffrence",
                        Copy: "Copier",
                        Import: "Importer",
                        "Failed to import track": "chec de l'importation de la piste",
                        'The track "{0}" already exists. Do you wish to overwrite it?': 'La piste "{0}" existe dj. Souhaitez-vous l\'craser ?',
                        Overwrite: "craser",
                        "Paste track data here...": "Collez les donnes de la piste ici...",
                        Rank: "Classement",
                        "Personal best": "Meilleur temps personnel",
                        Opponents: "Adversaires",
                        "{0} opponent selected": "{0} adversaire slectionn",
                        "{0} opponents selected": "{0} adversaires slectionns",
                        "Select opponents to race against from the leaderboard on the left": "Slectionnez des adversaires contre lesquels courir dans le classement sur la gauche",
                        "No record": "Pas de record",
                        "Official tracks": "Pistes officielles",
                        "Community tracks": "Pistes communautaires",
                        "Custom tracks": "Pistes personnalises",
                        'Are you sure you want to delete "{0}"?': 'tes-vous sr de vouloir supprimer "{0}" ?',
                        Delete: "Supprimer",
                        "No community tracks": "Pas de pistes communautaires",
                        "Community tracks are coming soon": "Les pistes communautaires arrivent bientt",
                        "No custom tracks": "Pas de pistes personnalises",
                        "Create a track using the editor or import a track code": "Crez une piste en utilisant l'diteur ou importez un code de piste",
                        "Search tracks...": "Rechercher des pistes...",
                        "Invalid replay detected!": "Rejouer invalide dtect!",
                        "An opponent most likely used cheats": "Un adversaire a probablement utilis des triches"
                    }
                        , TU = {
                        "Checkpoint order": "Ordine dei checkpoint",
                        Height: "Altezza",
                        Exit: "Esci",
                        Random: "Casuale",
                        Primary: "Primario",
                        Secondary: "Secondario",
                        Frame: "Telaio",
                        Rims: "Cerchioni",
                        "Are you sure you want to exit without saving?": "Sei sicuro di voler uscire senza salvare?",
                        "All changes will be lost!": "Tutte le modifiche andranno perse!",
                        "Car saved!": "Auto salvata!",
                        Test: "Test",
                        "Starting point is missing!": "Punto di partenza mancante!",
                        Generate: "Genera",
                        "Are you sure you want to generate a new track?\n\nYour current track will be lost!": "Sei sicuro di voler generare un nuovo percorso?\n\nIl tuo percorso attuale verr perso!",
                        Load: "Carica",
                        Save: "Salva",
                        "Are you sure you want to load a new track?\n\nYour current track will be lost!": "Sei sicuro di voler caricare un nuovo percorso?\n\nIl tuo percorso attuale verr perso!",
                        "Track saved!": "Percorso salvato!",
                        "Failed to save!": "Salvataggio non riuscito!",
                        'Are you sure you want to overwrite "{0}"?': 'Sei sicuro di voler sovrascrivere "{0}"?',
                        Export: "Esporta",
                        Help: "Aiuto",
                        "Are you sure you want to exit the editor?": "Sei sicuro di voler uscire dall'editor?",
                        "All unsaved data will be lost!": "Tutti i dati non salvati andranno persi!",
                        "Track settings": "Impostazioni del percorso",
                        "Unnamed Track": "Percorso senza nome",
                        "Track name": "Nome del percorso",
                        Author: "Autore",
                        Unknown: "Sconosciuto",
                        Environment: "Ambiente",
                        Summer: "Estate",
                        Winter: "Inverno",
                        Desert: "Deserto",
                        "Sun direction": "Direzione del sole",
                        "How to use the editor": "Come usare l'editor",
                        "Camera controls": "Controlli della telecamera",
                        "The camera can be moved by right clicking and dragging the mouse. Rotate the camera by clicking the middle mouse button (mouse wheel) or holding the control key and right clicking and dragging the mouse. Zoom in and out by scrolling the mouse wheel.": "La telecamera pu essere spostata facendo clic con il tasto destro del mouse e trascinando. Ruota la telecamera facendo clic con il pulsante centrale del mouse (rotella) o tenendo premuto il tasto di controllo e facendo clic con il tasto destro del mouse e trascinando. Zoom avanti e indietro scorrendo la rotella del mouse.",
                        "Alternatively, the camera can also be controlled using the following keyboard keys:": "In alternativa, la telecamera pu essere controllata utilizzando i seguenti tasti della tastiera:",
                        "Move forwards:": "Muovi avanti:",
                        "Move backwards:": "Muovi indietro:",
                        "Move left:": "Muovi a sinistra:",
                        "Move right:": "Muovi a destra:",
                        "Rotate left:": "Ruota a sinistra:",
                        "Rotate right:": "Ruota a destra:",
                        "The edited height can be changed either by using the height selection in the bottom left corner, or holding the shift key and scrolling the mouse wheel. Alternatively, you can use the following keyboard keys:": "L'altezza modificata pu essere cambiata utilizzando la selezione dell'altezza nell'angolo in basso a sinistra, o tenendo premuto il tasto shift e scorrendo la rotella del mouse. In alternativa, puoi utilizzare i seguenti tasti della tastiera:",
                        "Move up:": "Muovi su:",
                        "Move down:": "Muovi gi:",
                        Editing: "Modifica",
                        "Track parts can be selected in the menu on the right after which they can be placed by left clicking with the mouse.": "Le parti del percorso possono essere selezionate nel menu a destra, dopodich possono essere posizionate facendo clic con il tasto sinistro del mouse.",
                        "Alternatively, the track part currently hovered by the mouse can be selected with the following keyboard shortcut:": "In alternativa, la parte del percorso attualmente sotto il cursore del mouse pu essere selezionata con la seguente scorciatoia da tastiera:",
                        "The selected part can then be rotated using the following keyboard shortcut:": "La parte selezionata pu quindi essere ruotata utilizzando la seguente scorciatoia da tastiera:",
                        "Track parts can be deleted by using the delete tool in the right side menu or by holding the following key:": "Le parti del percorso possono essere eliminate utilizzando lo strumento di eliminazione nel menu a destra o tenendo premuto il seguente tasto:",
                        "Starting points, checkpoints and the finish line": "Punti di partenza, checkpoint e linea di arrivo",
                        "Starting points, checkpoints and finish lines can all be selected in the uppermost category in the right side menu.": "I punti di partenza, i checkpoint e le linee di arrivo possono essere selezionati nella categoria pi alta nel menu a destra.",
                        "Each track must have at least one starting point. If there are multiple starting points, the last placed one will be used.": "Ogni percorso deve avere almeno un punto di partenza. Se ci sono pi punti di partenza, verr utilizzato l'ultimo posizionato.",
                        "Checkpoints should be placed between the starting point and the finish line. When a checkpoint track part is selected there will be a tool in the bottom right to select the order of the checkpoint. This determines the order in which the checkpoints must be passed before driving to the finish line. Notice that it is possible to have multiple checkpoints with the same checkpoint order.": "I checkpoint devono essere posizionati tra il punto di partenza e la linea di arrivo. Quando viene selezionata una parte del percorso checkpoint, ci sar uno strumento in basso a destra per selezionare l'ordine del checkpoint. Questo determina l'ordine in cui i checkpoint devono essere superati prima di arrivare alla linea di arrivo. Nota che  possibile avere pi checkpoint con lo stesso ordine di checkpoint.",
                        "The finish line is where the track ends but will only become active after all checkpoints have been passed. It is also possible to have multiple finish lines.": "La linea di arrivo  dove finisce il percorso, ma diventer attiva solo dopo che tutti i checkpoint sono stati superati.  anche possibile avere pi linee di arrivo.",
                        "Starting point": "Punto di partenza",
                        Checkpoint: "Checkpoint",
                        "Finish line": "Linea di arrivo",
                        "Exporting the track": "Esportazione del percorso",
                        "When the track is finished, a name for the track can be entered in top left after which the track can be exported using the export button. This will reveal a track code which can be sent to other users so they can import and play the track.": "Quando il percorso  terminato,  possibile inserire un nome per il percorso in alto a sinistra, dopodich il percorso pu essere esportato utilizzando il pulsante di esportazione. Questo riveler un codice del percorso che pu essere inviato ad altri utenti in modo che possano importare e giocare il percorso.",
                        Close: "Chiudi",
                        "Not set": "Non impostato",
                        or: "o",
                        "The camera can be moved by dragging with one finger. Rotate the camera by dragging with two fingers. Zoom in and out by pinching.": "La telecamera pu essere spostata trascinando con un dito. Ruota la telecamera trascinando con due dita. Zoom avanti e indietro pizzicando.",
                        "The edited height can be changed by using the height selection in the bottom left corner.": "L'altezza modificata pu essere cambiata utilizzando la selezione dell'altezza nell'angolo in basso a sinistra.",
                        "Track parts can be selected in the menu on the right after which they can be placed by tapping on the screen.": "Le parti del percorso possono essere selezionate nel menu a destra, dopodich possono essere posizionate toccando lo schermo.",
                        "The selected part can then be rotated by tapping the rotate button in the bottom left corner.": "La parte selezionata pu quindi essere ruotata toccando il pulsante di rotazione nell'angolo in basso a sinistra.",
                        "Track parts can be deleted by using the delete tool in the right side menu.": "Le parti del percorso possono essere eliminate utilizzando lo strumento di eliminazione nel menu a destra.",
                        Watch: "Guarda",
                        "Loading replay": "Caricamento riproduzione",
                        "Press {0} to return to the last checkpoint": "Premi {0} per tornare all'ultimo checkpoint",
                        "Press {0} to start over": "Premi {0} per ricominciare",
                        "Reset once to return to the last checkpoint": "Resetta una volta per tornare all'ultimo checkpoint",
                        "Reset again to start over": "Resetta di nuovo per ricominciare",
                        Leaderboard: "Classifica",
                        Back: "Indietro",
                        "Error: Failed to load leaderboard": "Errore: impossibile caricare la classifica",
                        Pending: "In sospeso",
                        Verified: "Verificato",
                        Invalid: "Non valido",
                        Duplicate: "Duplicato",
                        You: "Tu",
                        "Only verified": "Solo verificati",
                        Loading: "Caricamento",
                        "Failed to load recordings": "Impossibile caricare le registrazioni",
                        "Cannot load recordings due to non-determinism": "Impossibile caricare le registrazioni a causa del non determinismo",
                        Ok: "Ok",
                        "Track is missing starting point": "Il percorso non ha un punto di partenza",
                        "Some leaderboard features are disabled.": "Alcune funzionalit della classifica sono disabilitate.",
                        "Please try another browser or device.": "Si prega di provare un altro browser o dispositivo.",
                        "You already have another instance of PolyTrack open.": "Hai gi un'altra istanza di PolyTrack aperta.",
                        "Please switch to that tab or window to continue.": "Si prega di passare a quella scheda o finestra per continuare.",
                        "Computer determinism check failed.": "Verifica del determinismo del computer fallita.",
                        "Non-deterministic game assets found.": "Asset di gioco non deterministici trovati.",
                        "Please try clearing your browser cache.": "Si prega di provare a cancellare la cache del browser.",
                        Customize: "Personalizza",
                        Editor: "Editor",
                        Settings: "Impostazioni",
                        Profile: "Profilo",
                        Play: "Gioca",
                        Version: "Versione",
                        "You cannot have duplicate user profiles": "Non  possibile avere profili utente duplicati",
                        "Failed to create user profile": "Impossibile creare il profilo utente",
                        "This user profile does not exist on the server": "Questo profilo utente non esiste sul server",
                        "Failed to download user profile from the server": "Impossibile scaricare il profilo utente dal server",
                        "User token is invalid": "Token utente non valido",
                        "Are you sure you want to display your private key?": "Sei sicuro di voler mostrare la tua chiave privata?",
                        "DO NOT SHARE THIS KEY WITH ANYONE.": "NON CONDIVIDERE QUESTA CHIAVE CON NESSUNO.",
                        "You need a free user profile slot to import a new user profile": "Hai bisogno di uno slot di profilo utente libero per importare un nuovo profilo utente",
                        Quit: "Esci",
                        Fullscreen: "Schermo intero",
                        Windowed: "Finestra",
                        "It seems like you are playing an unofficial version of {0}. For the most up-to-date version please visit the original source:": "Sembra che tu stia giocando a una versione non ufficiale di {0}. Per la versione pi aggiornata visita la fonte originale:",
                        Nickname: "Nickname",
                        "Choose a nickname to be shown in the leaderboard. Your nickname can be changed at any time.": "Scegli un nickname da mostrare nella classifica. Puoi cambiarlo in qualsiasi momento.",
                        Cancel: "Annulla",
                        Confirm: "Conferma",
                        Verifier: "Verificatore",
                        "User ID": "ID Utente",
                        Paused: "In pausa",
                        "Switch car": "Cambia auto",
                        Profiles: "Profili",
                        'Are you sure you would like to delete "{0}"?': 'Sei sicuro di voler eliminare "{0}"?',
                        Empty: "Vuoto",
                        Reset: "Resetta",
                        Apply: "Applica",
                        Gameplay: "Modalit di gioco",
                        Units: "Unit",
                        Metric: "Metrico",
                        Imperial: "Imperiale",
                        "Reset hint": "Resetta suggerimento",
                        Disabled: "Disattivato",
                        Enabled: "Attivato",
                        "Ghost car": "Auto fantasma",
                        "Default camera": "Telecamera predefinita",
                        Default: "Predefinita",
                        Cockpit: "Cabina",
                        "Cockpit camera mode": "Modalit telecamera cabina",
                        Hold: "Tieni",
                        Toggle: "Attiva/Disattiva",
                        Checkpoints: "Checkpoint",
                        Timer: "Timer",
                        Speedometer: "Contachilometri",
                        Bottom: "In basso",
                        Top: "In alto",
                        Language: "Lingua",
                        Graphics: "Grafica",
                        "Car shadow": "Ombra dell'auto",
                        "Track shadow": "Ombra del percorso",
                        Off: "Disattivato",
                        On: "Attivato",
                        Low: "Basso",
                        Medium: "Medio",
                        High: "Alto",
                        Clouds: "Nuvole",
                        Particles: "Particelle",
                        Skidmarks: "Segni di frenata",
                        "Render scale": "Scala di rendering",
                        "Anti-aliasing (requires restart)": "Anti-aliasing (richiede riavvio)",
                        Audio: "Audio",
                        "Sound effect volume": "Volume degli effetti sonori",
                        "Music volume": "Volume della musica",
                        "Checkpoint volume": "Volume dei checkpoint",
                        Controls: "Controlli",
                        Vehicle: "Veicolo",
                        Accelerate: "Accelerare",
                        Brake: "Frenare",
                        "Turn left": "Svolta a sinistra",
                        "Turn right": "Svolta a destra",
                        "Checkpoint reset": "Reset checkpoint",
                        "Start reset": "Reset partenza",
                        "Cockpit camera": "Telecamera cabina",
                        "Rotate part": "Ruota parte",
                        "Height modifier": "Modificatore altezza",
                        "Delete part": "Elimina parte",
                        "Move forwards": "Muovi avanti",
                        "Move backwards": "Muovi indietro",
                        "Move left": "Muovi a sinistra",
                        "Move right": "Muovi a destra",
                        "Rotate view left": "Ruota vista a sinistra",
                        "Rotate view right": "Ruota vista a destra",
                        "Move down": "Muovi gi",
                        "Move up": "Muovi su",
                        "Test track": "Test percorso",
                        "Pick part": "Seleziona parte",
                        Spectator: "Spettatore",
                        "Speed modifier": "Modificatore velocit",
                        Other: "Altro",
                        "Hide UI": "Nascondi UI",
                        Pause: "Pausa",
                        "Toggle FPS counter": "Attiva/Disattiva contatore FPS",
                        "Toggle spectator camera": "Attiva/Disattiva telecamera spettatore",
                        "Press any key...\n\nPress [Escape] to cancel.": "Premi un tasto qualsiasi...\n\nPremi [Esc] per annullare.",
                        Clear: "Cancella",
                        "New record": "Nuovo record",
                        Record: "Record",
                        Current: "Attuale",
                        Difference: "Differenza",
                        Copy: "Copia",
                        Import: "Importa",
                        "Failed to import track": "Importazione percorso non riuscita",
                        'The track "{0}" already exists. Do you wish to overwrite it?': 'Il percorso "{0}" esiste gi. Vuoi sovrascriverlo?',
                        Overwrite: "Sovrascrivi",
                        "Paste track data here...": "Incolla dati del percorso qui...",
                        Rank: "Posizione",
                        "Personal best": "Miglior tempo personale",
                        Opponents: "Avversari",
                        "{0} opponent selected": "{0} avversario selezionato",
                        "{0} opponents selected": "{0} avversari selezionati",
                        "Select opponents to race against from the leaderboard on the left": "Seleziona gli avversari con cui gareggiare dalla classifica a sinistra",
                        "No record": "Nessun record",
                        "Official tracks": "Percorsi ufficiali",
                        "Community tracks": "Percorsi della community",
                        "Custom tracks": "Percorsi personalizzati",
                        'Are you sure you want to delete "{0}"?': 'Sei sicuro di voler eliminare "{0}"?',
                        Delete: "Elimina",
                        "No community tracks": "Nessun percorso della community",
                        "Community tracks are coming soon": "I percorsi della community arriveranno presto",
                        "No custom tracks": "Nessun percorso personalizzato",
                        "Create a track using the editor or import a track code": "Crea un percorso utilizzando l'editor o importa un codice percorso",
                        "Search tracks...": "Cerca percorso...",
                        "Invalid replay detected!": "Riproduzione non valida rilevata!",
                        "An opponent most likely used cheats": "Un avversario ha probabilmente usato trucchi"
                    }
                        , CU = {
                        "Checkpoint order": "",
                        Height: "",
                        Exit: "",
                        Random: "",
                        Primary: "",
                        Secondary: "",
                        Frame: "",
                        Rims: "",
                        "Are you sure you want to exit without saving?": "",
                        "All changes will be lost!": "",
                        "Car saved!": "",
                        Test: "",
                        "Starting point is missing!": "",
                        Generate: "",
                        "Are you sure you want to generate a new track?\n\nYour current track will be lost!": "\n\n",
                        Load: "",
                        Save: "",
                        "Are you sure you want to load a new track?\n\nYour current track will be lost!": "\n\n",
                        "Track saved!": "",
                        "Failed to save!": "",
                        'Are you sure you want to overwrite "{0}"?': '"{0}" ',
                        Export: "",
                        Help: "",
                        "Are you sure you want to exit the editor?": "",
                        "All unsaved data will be lost!": "",
                        "Track settings": "",
                        "Unnamed Track": "",
                        "Track name": "",
                        Author: "",
                        Unknown: "",
                        Environment: "",
                        Summer: "",
                        Winter: "",
                        Desert: "",
                        "Sun direction": "",
                        "How to use the editor": "",
                        "Camera controls": "",
                        "The camera can be moved by right clicking and dragging the mouse. Rotate the camera by clicking the middle mouse button (mouse wheel) or holding the control key and right clicking and dragging the mouse. Zoom in and out by scrolling the mouse wheel.": "",
                        "Alternatively, the camera can also be controlled using the following keyboard keys:": ":",
                        "Move forwards:": ":",
                        "Move backwards:": ":",
                        "Move left:": ":",
                        "Move right:": ":",
                        "Rotate left:": ":",
                        "Rotate right:": ":",
                        "The edited height can be changed either by using the height selection in the bottom left corner, or holding the shift key and scrolling the mouse wheel. Alternatively, you can use the following keyboard keys:": "Shift:",
                        "Move up:": ":",
                        "Move down:": ":",
                        Editing: "",
                        "Track parts can be selected in the menu on the right after which they can be placed by left clicking with the mouse.": "",
                        "Alternatively, the track part currently hovered by the mouse can be selected with the following keyboard shortcut:": ":",
                        "The selected part can then be rotated using the following keyboard shortcut:": ":",
                        "Track parts can be deleted by using the delete tool in the right side menu or by holding the following key:": ":",
                        "Starting points, checkpoints and the finish line": "",
                        "Starting points, checkpoints and finish lines can all be selected in the uppermost category in the right side menu.": "",
                        "Each track must have at least one starting point. If there are multiple starting points, the last placed one will be used.": "1",
                        "Checkpoints should be placed between the starting point and the finish line. When a checkpoint track part is selected there will be a tool in the bottom right to select the order of the checkpoint. This determines the order in which the checkpoints must be passed before driving to the finish line. Notice that it is possible to have multiple checkpoints with the same checkpoint order.": "",
                        "The finish line is where the track ends but will only become active after all checkpoints have been passed. It is also possible to have multiple finish lines.": "",
                        "Starting point": "",
                        Checkpoint: "",
                        "Finish line": "",
                        "Exporting the track": "",
                        "When the track is finished, a name for the track can be entered in top left after which the track can be exported using the export button. This will reveal a track code which can be sent to other users so they can import and play the track.": "",
                        Close: "",
                        "Not set": "",
                        or: "",
                        "The camera can be moved by dragging with one finger. Rotate the camera by dragging with two fingers. Zoom in and out by pinching.": "12",
                        "The edited height can be changed by using the height selection in the bottom left corner.": "",
                        "Track parts can be selected in the menu on the right after which they can be placed by tapping on the screen.": "",
                        "The selected part can then be rotated by tapping the rotate button in the bottom left corner.": "",
                        "Track parts can be deleted by using the delete tool in the right side menu.": "",
                        Watch: "",
                        "Loading replay": "",
                        "Press {0} to return to the last checkpoint": " {0} ",
                        "Press {0} to start over": " {0} ",
                        "Reset once to return to the last checkpoint": "1",
                        "Reset again to start over": "",
                        Leaderboard: "",
                        Back: "",
                        "Error: Failed to load leaderboard": "",
                        Pending: "",
                        Verified: "",
                        Invalid: "",
                        Duplicate: "",
                        You: "",
                        "Only verified": "",
                        Loading: "",
                        "Failed to load recordings": "",
                        "Cannot load recordings due to non-determinism": "",
                        Ok: "OK",
                        "Track is missing starting point": "",
                        "Some leaderboard features are disabled.": "",
                        "Please try another browser or device.": "",
                        "You already have another instance of PolyTrack open.": "PolyTrack",
                        "Please switch to that tab or window to continue.": "",
                        "Computer determinism check failed.": "",
                        "Non-deterministic game assets found.": "",
                        "Please try clearing your browser cache.": "",
                        Customize: "",
                        Editor: "",
                        Settings: "",
                        Profile: "",
                        Play: "",
                        Version: "",
                        "You cannot have duplicate user profiles": "",
                        "Failed to create user profile": "",
                        "This user profile does not exist on the server": "",
                        "Failed to download user profile from the server": "",
                        "User token is invalid": "",
                        "Are you sure you want to display your private key?": "",
                        "DO NOT SHARE THIS KEY WITH ANYONE.": "",
                        "You need a free user profile slot to import a new user profile": "",
                        Quit: "",
                        Fullscreen: "",
                        Windowed: "",
                        "It seems like you are playing an unofficial version of {0}. For the most up-to-date version please visit the original source:": "{0} :",
                        Nickname: "",
                        "Choose a nickname to be shown in the leaderboard. Your nickname can be changed at any time.": "",
                        Cancel: "",
                        Confirm: "",
                        Verifier: "",
                        "User ID": "ID",
                        Paused: "",
                        "Switch car": "",
                        Profiles: "",
                        'Are you sure you would like to delete "{0}"?': '"{0}"',
                        Empty: "",
                        Reset: "",
                        Apply: "",
                        Gameplay: "",
                        Units: "",
                        Metric: "",
                        Imperial: "",
                        "Reset hint": "",
                        Disabled: "",
                        Enabled: "",
                        "Ghost car": "",
                        "Default camera": "",
                        Default: "",
                        Cockpit: "",
                        "Cockpit camera mode": "",
                        Hold: "",
                        Toggle: "",
                        Checkpoints: "",
                        Timer: "",
                        Speedometer: "",
                        Bottom: "",
                        Top: "",
                        Language: "",
                        Graphics: "",
                        "Car shadow": "",
                        "Track shadow": "",
                        Off: "",
                        On: "",
                        Low: "",
                        Medium: "",
                        High: "",
                        Clouds: "",
                        Particles: "",
                        Skidmarks: "",
                        "Render scale": "",
                        "Anti-aliasing (requires restart)": "",
                        Audio: "",
                        "Sound effect volume": "",
                        "Music volume": "",
                        "Checkpoint volume": "",
                        Controls: "",
                        Vehicle: "",
                        Accelerate: "",
                        Brake: "",
                        "Turn left": "",
                        "Turn right": "",
                        "Checkpoint reset": "",
                        "Start reset": "",
                        "Cockpit camera": "",
                        "Rotate part": "",
                        "Height modifier": "",
                        "Delete part": "",
                        "Move forwards": "",
                        "Move backwards": "",
                        "Move left": "",
                        "Move right": "",
                        "Rotate view left": "",
                        "Rotate view right": "",
                        "Move down": "",
                        "Move up": "",
                        "Test track": "",
                        "Pick part": "",
                        Spectator: "",
                        "Speed modifier": "",
                        Other: "",
                        "Hide UI": "UI",
                        Pause: "",
                        "Toggle FPS counter": "FPS",
                        "Toggle spectator camera": "",
                        "Press any key...\n\nPress [Escape] to cancel.": "...\n\n[Escape] ",
                        Clear: "",
                        "New record": "",
                        Record: "",
                        Current: "",
                        Difference: "",
                        Copy: "",
                        Import: "",
                        "Failed to import track": "",
                        'The track "{0}" already exists. Do you wish to overwrite it?': "{0}",
                        Overwrite: "",
                        "Paste track data here...": "...",
                        Rank: "",
                        "Personal best": "",
                        Opponents: "",
                        "{0} opponent selected": "{0} ",
                        "{0} opponents selected": "{0} ",
                        "Select opponents to race against from the leaderboard on the left": "",
                        "No record": "",
                        "Official tracks": "",
                        "Community tracks": "",
                        "Custom tracks": "",
                        'Are you sure you want to delete "{0}"?': '"{0}" ',
                        Delete: "",
                        "No community tracks": "",
                        "Community tracks are coming soon": "",
                        "No custom tracks": "",
                        "Create a track using the editor or import a track code": "",
                        "Search tracks...": "...",
                        "Invalid replay detected!": "",
                        "An opponent most likely used cheats": ""
                    }
                        , _U = {
                        "Checkpoint order": " ",
                        Height: "",
                        Exit: "",
                        Random: "",
                        Primary: "",
                        Secondary: "",
                        Frame: "",
                        Rims: "",
                        "Are you sure you want to exit without saving?": "  ?",
                        "All changes will be lost!": "   !",
                        "Car saved!": " !",
                        Test: "",
                        "Starting point is missing!": "  !",
                        Generate: "",
                        "Are you sure you want to generate a new track?\n\nYour current track will be lost!": "  ?\n\n  !",
                        Load: "",
                        Save: "",
                        "Are you sure you want to load a new track?\n\nYour current track will be lost!": "  ?\n\n  !",
                        "Track saved!": " !",
                        "Failed to save!": " !",
                        'Are you sure you want to overwrite "{0}"?': '"{0}"() ?',
                        Export: "",
                        Help: "",
                        "Are you sure you want to exit the editor?": " ?",
                        "All unsaved data will be lost!": "    !",
                        "Track settings": " ",
                        "Unnamed Track": "  ",
                        "Track name": " ",
                        Author: "",
                        Unknown: "  ",
                        Environment: "",
                        Summer: "",
                        Winter: "",
                        Desert: "",
                        "Sun direction": " ",
                        "How to use the editor": "  ",
                        "Camera controls": " ",
                        "The camera can be moved by right clicking and dragging the mouse. Rotate the camera by clicking the middle mouse button (mouse wheel) or holding the control key and right clicking and dragging the mouse. Zoom in and out by scrolling the mouse wheel.": "        .     ()           .        .",
                        "Alternatively, the camera can also be controlled using the following keyboard keys:": "        .",
                        "Move forwards:": " :",
                        "Move backwards:": " :",
                        "Move left:": " :",
                        "Move right:": " :",
                        "Rotate left:": " :",
                        "Rotate right:": " :",
                        "The edited height can be changed either by using the height selection in the bottom left corner, or holding the shift key and scrolling the mouse wheel. Alternatively, you can use the following keyboard keys:": "        Shift         .       .",
                        "Move up:": " :",
                        "Move down:": " :",
                        Editing: "",
                        "Track parts can be selected in the menu on the right after which they can be placed by left clicking with the mouse.": "           .",
                        "Alternatively, the track part currently hovered by the mouse can be selected with the following keyboard shortcut:": "            .",
                        "The selected part can then be rotated using the following keyboard shortcut:": "        .",
                        "Track parts can be deleted by using the delete tool in the right side menu or by holding the following key:": "             .",
                        "Starting points, checkpoints and the finish line": " ,    ",
                        "Starting points, checkpoints and finish lines can all be selected in the uppermost category in the right side menu.": " ,             .",
                        "Each track must have at least one starting point. If there are multiple starting points, the last placed one will be used.": "       .          .",
                        "Checkpoints should be placed between the starting point and the finish line. When a checkpoint track part is selected there will be a tool in the bottom right to select the order of the checkpoint. This determines the order in which the checkpoints must be passed before driving to the finish line. Notice that it is possible to have multiple checkpoints with the same checkpoint order.": "       .             .          .            .",
                        "The finish line is where the track ends but will only become active after all checkpoints have been passed. It is also possible to have multiple finish lines.": "         .       .",
                        "Starting point": " ",
                        Checkpoint: "",
                        "Finish line": " ",
                        "Exporting the track": " ",
                        "When the track is finished, a name for the track can be entered in top left after which the track can be exported using the export button. This will reveal a track code which can be sent to other users so they can import and play the track.": "              .            .",
                        Close: "",
                        "Not set": " ",
                        or: "",
                        "The camera can be moved by dragging with one finger. Rotate the camera by dragging with two fingers. Zoom in and out by pinching.": "      .       .      .",
                        "The edited height can be changed by using the height selection in the bottom left corner.": "         .",
                        "Track parts can be selected in the menu on the right after which they can be placed by tapping on the screen.": "          .",
                        "The selected part can then be rotated by tapping the rotate button in the bottom left corner.": "         .",
                        "Track parts can be deleted by using the delete tool in the right side menu.": "         .",
                        Watch: "",
                        "Loading replay": " ",
                        "Press {0} to return to the last checkpoint": "   {0}() ",
                        "Press {0} to start over": "  {0}() ",
                        "Reset once to return to the last checkpoint": "     ",
                        "Reset again to start over": "   ",
                        Leaderboard: "",
                        Back: "",
                        "Error: Failed to load leaderboard": ":   ",
                        Pending: " ",
                        Verified: "",
                        Invalid: " ",
                        Duplicate: "",
                        You: "",
                        "Only verified": " ",
                        Loading: " ",
                        "Failed to load recordings": "  ",
                        "Cannot load recordings due to non-determinism": "     ",
                        Ok: "",
                        "Track is missing starting point": "   ",
                        "Some leaderboard features are disabled.": "   .",
                        "Please try another browser or device.": "   .",
                        "You already have another instance of PolyTrack open.": "  PolyTrack   .",
                        "Please switch to that tab or window to continue.": "    .",
                        "Computer determinism check failed.": "   .",
                        "Non-deterministic game assets found.": "    .",
                        "Please try clearing your browser cache.": "    .",
                        Customize: " ",
                        Editor: "",
                        Settings: "",
                        Profile: "",
                        Play: "",
                        Version: "",
                        "You cannot have duplicate user profiles": "     ",
                        "Failed to create user profile": "   ",
                        "This user profile does not exist on the server": "     ",
                        "Failed to download user profile from the server": "    ",
                        "User token is invalid": "   ",
                        "Are you sure you want to display your private key?": "  ?",
                        "DO NOT SHARE THIS KEY WITH ANYONE.": "    .",
                        "You need a free user profile slot to import a new user profile": "        ",
                        Quit: "",
                        Fullscreen: " ",
                        Windowed: " ",
                        "It seems like you are playing an unofficial version of {0}. For the most up-to-date version please visit the original source:": "{0}      .     :",
                        Nickname: "",
                        "Choose a nickname to be shown in the leaderboard. Your nickname can be changed at any time.": "   .     .",
                        Cancel: "",
                        Confirm: "",
                        Verifier: "",
                        "User ID": " ID",
                        Paused: " ",
                        "Switch car": " ",
                        Profiles: "",
                        'Are you sure you would like to delete "{0}"?': '"{0}" ?',
                        Empty: " ",
                        Reset: "",
                        Apply: "",
                        Gameplay: " ",
                        Units: "",
                        Metric: "",
                        Imperial: "/ ",
                        "Reset hint": " ",
                        Disabled: "",
                        Enabled: "",
                        "Ghost car": " ",
                        "Default camera": " ",
                        Default: "",
                        Cockpit: "",
                        "Cockpit camera mode": "  ",
                        Hold: "",
                        Toggle: "",
                        Checkpoints: "",
                        Timer: "",
                        Speedometer: "",
                        Bottom: "",
                        Top: "",
                        Language: "",
                        Graphics: "",
                        "Car shadow": " ",
                        "Track shadow": " ",
                        Off: "",
                        On: "",
                        Low: "",
                        Medium: "",
                        High: "",
                        Clouds: "",
                        Particles: "",
                        Skidmarks: " ",
                        "Render scale": " ",
                        "Anti-aliasing (requires restart)": "  ( )",
                        Audio: "",
                        "Sound effect volume": "  ",
                        "Music volume": " ",
                        "Checkpoint volume": " ",
                        Controls: "",
                        Vehicle: "",
                        Accelerate: "",
                        Brake: "",
                        "Turn left": " ",
                        "Turn right": " ",
                        "Checkpoint reset": " ",
                        "Start reset": " ",
                        "Cockpit camera": " ",
                        "Rotate part": " ",
                        "Height modifier": " ",
                        "Delete part": " ",
                        "Move forwards": " ",
                        "Move backwards": " ",
                        "Move left": " ",
                        "Move right": " ",
                        "Rotate view left": "  ",
                        "Rotate view right": "  ",
                        "Move down": " ",
                        "Move up": " ",
                        "Test track": " ",
                        "Pick part": " ",
                        Spectator: "",
                        "Speed modifier": " ",
                        Other: "",
                        "Hide UI": "UI ",
                        Pause: " ",
                        "Toggle FPS counter": "FPS  ",
                        "Toggle spectator camera": "  ",
                        "Press any key...\n\nPress [Escape] to cancel.": "  ...\n\n[Escape]  .",
                        Clear: "",
                        "New record": " ",
                        Record: "",
                        Current: "",
                        Difference: "",
                        Copy: "",
                        Import: "",
                        "Failed to import track": "  ",
                        'The track "{0}" already exists. Do you wish to overwrite it?': '"{0}"   . ?',
                        Overwrite: "",
                        "Paste track data here...": "   ...",
                        Rank: "",
                        "Personal best": "  ",
                        Opponents: "",
                        "{0} opponent selected": "{0}  ",
                        "{0} opponents selected": "{0}  ",
                        "Select opponents to race against from the leaderboard on the left": "    ",
                        "No record": " ",
                        "Official tracks": " ",
                        "Community tracks": " ",
                        "Custom tracks": "  ",
                        'Are you sure you want to delete "{0}"?': '"{0}"() ?',
                        Delete: "",
                        "No community tracks": "  ",
                        "Community tracks are coming soon": "   ",
                        "No custom tracks": "   ",
                        "Create a track using the editor or import a track code": "        ",
                        "Search tracks...": " ...",
                        "Invalid replay detected!": "   !",
                        "An opponent most likely used cheats": "   "
                    }
                        , IU = {
                        "Checkpoint order": "Kolejno punktw kontrolnych",
                        Height: "Wysoko",
                        Exit: "Wyjcie",
                        Random: "Losowe",
                        Primary: "Gwny",
                        Secondary: "Dodatkowy",
                        Frame: "Rama",
                        Rims: "Obrcze",
                        "Are you sure you want to exit without saving?": "Czy na pewno chcesz wyj bez zapisywania?",
                        "All changes will be lost!": "Wszystkie zmiany zostan utracone!",
                        "Car saved!": "Samochd zapisany!",
                        Test: "Test",
                        "Starting point is missing!": "Brak punktu startowego!",
                        Generate: "Generuj",
                        "Are you sure you want to generate a new track?\n\nYour current track will be lost!": "Czy na pewno chcesz wygenerowa now tras?\n\nTwoja obecna trasa zostanie utracona!",
                        Load: "Wczytaj",
                        Save: "Zapisz",
                        "Are you sure you want to load a new track?\n\nYour current track will be lost!": "Czy na pewno chcesz wczyta now tras?\n\nTwoja obecna trasa zostanie utracona!",
                        "Track saved!": "Trasa zostaa zapisana!",
                        "Failed to save!": "Nie udao si zapisa!",
                        'Are you sure you want to overwrite "{0}"?': "Czy na pewno chcesz nadpisa {0}?",
                        Export: "Eksportuj",
                        Help: "Pomoc",
                        "Are you sure you want to exit the editor?": "Czy na pewno chcesz wyj z edytora?",
                        "All unsaved data will be lost!": "Wszystkie niezapisane dane zostan utracone!",
                        "Track settings": "Ustawienia trasy",
                        "Unnamed Track": "Bez nazwy",
                        "Track name": "Nazwa trasy",
                        Author: "Autor",
                        Unknown: "Nieznany",
                        Environment: "rodowisko",
                        Summer: "Lato",
                        Winter: "Zima",
                        Desert: "Pustynia",
                        "Sun direction": "Kierunek soca",
                        "How to use the editor": "Jak korzysta z edytora",
                        "Camera controls": "Sterowanie kamer",
                        "The camera can be moved by right clicking and dragging the mouse. Rotate the camera by clicking the middle mouse button (mouse wheel) or holding the control key and right clicking and dragging the mouse. Zoom in and out by scrolling the mouse wheel.": "Kamer mona przesuwa, klikajc prawym przyciskiem myszy i przecigajc. Obr kamer, klikajc rodkowy przycisk myszy (koo myszy) lub przytrzymujc klawisz Ctrl i klikajc prawym przyciskiem myszy i przecigajc. Przybli i oddal obraz, przewijajc kko myszy.",
                        "Alternatively, the camera can also be controlled using the following keyboard keys:": "Alternatywnie, kamer mona rwnie sterowa za pomoc nastpujcych klawiszy na klawiaturze:",
                        "Move forwards:": "Poruszaj si do przodu:",
                        "Move backwards:": "Poruszaj si do tyu:",
                        "Move left:": "Poruszaj si w lewo:",
                        "Move right:": "Poruszaj si w prawo:",
                        "Rotate left:": "Obr w lewo:",
                        "Rotate right:": "Obr w prawo:",
                        "The edited height can be changed either by using the height selection in the bottom left corner, or holding the shift key and scrolling the mouse wheel. Alternatively, you can use the following keyboard keys:": "Edytowan wysoko mona zmieni, korzystajc z wyboru wysokoci w lewym dolnym rogu lub przytrzymujc klawisz Shift i przewijajc kko myszy. Alternatywnie mona uy nastpujcych klawiszy na klawiaturze:",
                        "Move up:": "Przesu w gr:",
                        "Move down:": "Przesu w d:",
                        Editing: "Edycja",
                        "Track parts can be selected in the menu on the right after which they can be placed by left clicking with the mouse.": "Czci toru mona wybra w menu po prawej stronie, a nastpnie mona je umieci, klikajc lewym przyciskiem myszy.",
                        "Alternatively, the track part currently hovered by the mouse can be selected with the following keyboard shortcut:": "Alternatywnie, aktualnie zaznaczon cz toru mona wybra za pomoc nastpujcego skrtu klawiaturowego:",
                        "The selected part can then be rotated using the following keyboard shortcut:": "Wybran cz mona nastpnie obrci za pomoc nastpujcego skrtu klawiaturowego:",
                        "Track parts can be deleted by using the delete tool in the right side menu or by holding the following key:": "Czci toru mona usun, korzystajc z narzdzia usuwania w menu po prawej stronie lub przytrzymujc nastpujcy klawisz:",
                        "Starting points, checkpoints and the finish line": "Punkty startowe, punkty kontrolne i linia mety",
                        "Starting points, checkpoints and finish lines can all be selected in the uppermost category in the right side menu.": "Punkty startowe, punkty kontrolne i linie mety mona wybra we wszystkich kategoriach w menu po prawej stronie.",
                        "Each track must have at least one starting point. If there are multiple starting points, the last placed one will be used.": "Kada trasa musi mie co najmniej jeden punkt startowy. Jeli istnieje wiele punktw startowych, zostanie uyty ostatnio umieszczony.",
                        "Checkpoints should be placed between the starting point and the finish line. When a checkpoint track part is selected there will be a tool in the bottom right to select the order of the checkpoint. This determines the order in which the checkpoints must be passed before driving to the finish line. Notice that it is possible to have multiple checkpoints with the same checkpoint order.": "Punkty kontrolne powinny by umieszczone midzy punktem startowym a lini mety. Po wybraniu czci toru punktu kontrolnego pojawi si narzdzie w prawym dolnym rogu, ktre pozwoli wybra kolejno punktu kontrolnego. Okrela to kolejno, w jakiej punkty kontrolne musz by przechodzone przed dojazdem do linii mety. Zauwa, e moliwe jest posiadanie wielu punktw kontrolnych o tej samej kolejnoci.",
                        "The finish line is where the track ends but will only become active after all checkpoints have been passed. It is also possible to have multiple finish lines.": "Linia mety to miejsce, gdzie koczy si tor, ale staje si aktywna dopiero po przejciu wszystkich punktw kontrolnych. Moliwe jest rwnie posiadanie wielu linii mety.",
                        "Starting point": "Punkt startowy",
                        Checkpoint: "Punkt kontrolny",
                        "Finish line": "Linia mety",
                        "Exporting the track": "Eksportowanie trasy",
                        "When the track is finished, a name for the track can be entered in top left after which the track can be exported using the export button. This will reveal a track code which can be sent to other users so they can import and play the track.": "Po zakoczeniu trasy mona wprowadzi jej nazw w lewym grnym rogu, a nastpnie mona j wyeksportowa, korzystajc z przycisku eksportu. To ujawni kod trasy, ktry mona przesa innym uytkownikom, aby mogli zaimportowa i odtworzy tras.",
                        Close: "Zamknij",
                        "Not set": "Nie ustawiono",
                        or: "lub",
                        "The camera can be moved by dragging with one finger. Rotate the camera by dragging with two fingers. Zoom in and out by pinching.": "Kamer mona przesuwa, przecigajc jednym palcem. Obr kamer, przecigajc dwoma palcami. Przybli i oddal obraz, ciskajc palcami.",
                        "The edited height can be changed by using the height selection in the bottom left corner.": "Edytowan wysoko mona zmieni, korzystajc z wyboru wysokoci w lewym dolnym rogu.",
                        "Track parts can be selected in the menu on the right after which they can be placed by tapping on the screen.": "Czci toru mona wybra w menu po prawej stronie, a nastpnie mona je umieci, dotykajc ekranu.",
                        "The selected part can then be rotated by tapping the rotate button in the bottom left corner.": "Wybran cz mona nastpnie obrci, dotykajc przycisku obracania w lewym dolnym rogu.",
                        "Track parts can be deleted by using the delete tool in the right side menu.": "Czci toru mona usun, korzystajc z narzdzia usuwania w menu po prawej stronie.",
                        Watch: "Ogldaj",
                        "Loading replay": "Wczytywanie nagrania",
                        "Press {0} to return to the last checkpoint": "Nacinij {0}, aby wrci do ostatniego punktu kontrolnego",
                        "Press {0} to start over": "Nacinij {0}, aby zacz od nowa",
                        "Reset once to return to the last checkpoint": "Resetuj raz, aby wrci do ostatniego punktu kontrolnego",
                        "Reset again to start over": "Resetuj ponownie, aby zacz od nowa",
                        Leaderboard: "Tabela wynikw",
                        Back: "Powrt",
                        "Error: Failed to load leaderboard": "Bd: Nie mona wczyta tabeli wynikw",
                        Pending: "Oczekujcy",
                        Verified: "Zweryfikowany",
                        Invalid: "Nieprawidowy",
                        Duplicate: "Duplikat",
                        You: "Ty",
                        "Only verified": "Tylko zweryfikowane",
                        Loading: "adowanie",
                        "Failed to load recordings": "Nie udao si wczyta nagra",
                        "Cannot load recordings due to non-determinism": "Nie mona wczyta nagra z powodu nieterminizmu",
                        Ok: "Ok",
                        "Track is missing starting point": "Brak punktu startowego na trasie",
                        "Some leaderboard features are disabled.": "Niektre funkcje tabeli wynikw s wyczone.",
                        "Please try another browser or device.": "Prosz sprbowa inn przegldark lub urzdzenie.",
                        "You already have another instance of PolyTrack open.": "Masz ju otwart inn instancj PolyTrack.",
                        "Please switch to that tab or window to continue.": "Prosz przeczy si na ten kart lub okno, aby kontynuowa.",
                        "Computer determinism check failed.": "Nie udao si sprawdzi determinizmu komputera.",
                        "Non-deterministic game assets found.": "Znaleziono nieterministyczne zasoby gry.",
                        "Please try clearing your browser cache.": "Prosz sprbowa wyczyci pami podrczn przegldarki.",
                        Customize: "Dostosuj",
                        Editor: "Edytor",
                        Settings: "Ustawienia",
                        Profile: "Profil",
                        Play: "Graj",
                        Version: "Wersja",
                        "You cannot have duplicate user profiles": "Nie moesz mie zduplikowanych profili uytkownika",
                        "Failed to create user profile": "Nie udao si utworzy profilu uytkownika",
                        "This user profile does not exist on the server": "Ten profil uytkownika nie istnieje na serwerze",
                        "Failed to download user profile from the server": "Nie udao si pobra profilu uytkownika z serwera",
                        "User token is invalid": "Token uytkownika jest nieprawidowy",
                        "Are you sure you want to display your private key?": "Czy na pewno chcesz wywietli swj klucz prywatny?",
                        "DO NOT SHARE THIS KEY WITH ANYONE.": "NIE UDOSTPNIAJ TEGO KLUCZA NIKOMU.",
                        "You need a free user profile slot to import a new user profile": "Potrzebujesz wolnego miejsca na profil uytkownika, aby zaimportowa nowy profil uytkownika",
                        Quit: "Wyjd",
                        Fullscreen: "Peny ekran",
                        Windowed: "Okno",
                        "It seems like you are playing an unofficial version of {0}. For the most up-to-date version please visit the original source:": "Wyglda na to, e grasz w nieoficjaln wersj {0}. Aby uzyska najnowsz wersj, odwied oryginalne rdo:",
                        Nickname: "Pseudonim",
                        "Choose a nickname to be shown in the leaderboard. Your nickname can be changed at any time.": "Wybierz pseudonim, ktry bdzie wywietlany w tabeli wynikw. Moesz go zmienia w dowolnym momencie.",
                        Cancel: "Anuluj",
                        Confirm: "Potwierd",
                        Verifier: "Weryfikator",
                        "User ID": "ID uytkownika",
                        Paused: "Wstrzymano",
                        "Switch car": "Zmie samochd",
                        Profiles: "Profile",
                        'Are you sure you would like to delete "{0}"?': 'Czy na pewno chcesz usun "{0}"?',
                        Empty: "Puste",
                        Reset: "Resetuj",
                        Apply: "Zastosuj",
                        Gameplay: "Rozgrywka",
                        Units: "Jednostki",
                        Metric: "Metryczne",
                        Imperial: "Imperialne",
                        "Reset hint": "Resetuj wskazwk",
                        Disabled: "Wyczone",
                        Enabled: "Wczone",
                        "Ghost car": "Duch samochodu",
                        "Default camera": "Domylna kamera",
                        Default: "Domylny",
                        Cockpit: "Kokpit",
                        "Cockpit camera mode": "Tryb kamery kokpitu",
                        Hold: "Przytrzymaj",
                        Toggle: "Przecz",
                        Checkpoints: "Punkty kontrolne",
                        Timer: "Stoper",
                        Speedometer: "Prdkociomierz",
                        Bottom: "D",
                        Top: "Gra",
                        Language: "Jzyk",
                        Graphics: "Grafika",
                        "Car shadow": "Cie samochodu",
                        "Track shadow": "Cie trasy",
                        Off: "Wycz",
                        On: "Wcz",
                        Low: "Niska",
                        Medium: "rednia",
                        High: "Wysoka",
                        Clouds: "Chmury",
                        Particles: "Czsteczki",
                        Skidmarks: "lady opon",
                        "Render scale": "Skala renderowania",
                        "Anti-aliasing (requires restart)": "Anti-aliasing (wymaga restartu)",
                        Audio: "Dwik",
                        "Sound effect volume": "Gono efektw dwikowych",
                        "Music volume": "Gono muzyki",
                        "Checkpoint volume": "Gono punktw kontrolnych",
                        Controls: "Sterowanie",
                        Vehicle: "Pojazd",
                        Accelerate: "Przyspiesz",
                        Brake: "Hamuj",
                        "Turn left": "Skr w lewo",
                        "Turn right": "Skr w prawo",
                        "Checkpoint reset": "Reset punktu kontrolnego",
                        "Start reset": "Reset startu",
                        "Cockpit camera": "Kamera kokpitu",
                        "Rotate part": "Obr cz",
                        "Height modifier": "Modyfikator wysokoci",
                        "Delete part": "Usu cz",
                        "Move forwards": "Poruszaj si do przodu",
                        "Move backwards": "Poruszaj si do tyu",
                        "Move left": "Poruszaj si w lewo",
                        "Move right": "Poruszaj si w prawo",
                        "Rotate view left": "Obr widok w lewo",
                        "Rotate view right": "Obr widok w prawo",
                        "Move down": "Przesu w d",
                        "Move up": "Przesu w gr",
                        "Test track": "Testuj tras",
                        "Pick part": "Wybierz cz",
                        Spectator: "Widz",
                        "Speed modifier": "Modyfikator prdkoci",
                        Other: "Inne",
                        "Hide UI": "Ukryj UI",
                        Pause: "Pauza",
                        "Toggle FPS counter": "Przecz licznik FPS",
                        "Toggle spectator camera": "Przecz kamer widza",
                        "Press any key...\n\nPress [Escape] to cancel.": "Nacinij dowolny klawisz...\n\nNacinij [Escape], aby anulowa.",
                        Clear: "Wyczy",
                        "New record": "Nowy rekord",
                        Record: "Rekord",
                        Current: "Aktualny",
                        Difference: "Rnica",
                        Copy: "Kopiuj",
                        Import: "Importuj",
                        "Failed to import track": "Import trasy nie powid si",
                        'The track "{0}" already exists. Do you wish to overwrite it?': "Trasa {0} ju istnieje. Czy chcesz j nadpisa?",
                        Overwrite: "Nadpisz",
                        "Paste track data here...": "Wklej dane trasy tutaj...",
                        Rank: "Ranking",
                        "Personal best": "Najlepszy wynik",
                        Opponents: "Przeciwnicy",
                        "{0} opponent selected": "{0} przeciwnik wybrany",
                        "{0} opponents selected": "{0} przeciwnikw wybranych",
                        "Select opponents to race against from the leaderboard on the left": "Wybierz przeciwnikw, przeciwko ktrym chcesz ciga si z tabeli wynikw po lewej stronie",
                        "No record": "Brak rekordu",
                        "Official tracks": "Oficjalne trasy",
                        "Community tracks": "Trasy spoecznoci",
                        "Custom tracks": "Niestandardowe trasy",
                        'Are you sure you want to delete "{0}"?': "Czy na pewno chcesz usun {0}?",
                        Delete: "Usu",
                        "No community tracks": "Brak tras spoecznoci",
                        "Community tracks are coming soon": "Trasy spoecznoci wkrtce",
                        "No custom tracks": "Brak niestandardowych tras",
                        "Create a track using the editor or import a track code": "Utwrz tras za pomoc edytora lub zaimportuj kod trasy",
                        "Search tracks...": "Szukaj tras...",
                        "Invalid replay detected!": "Wykryto nieprawidowe nagranie!",
                        "An opponent most likely used cheats": "Przeciwnik najprawdopodobniej uy oszustw"
                    }
                        , PU = {
                        "Checkpoint order": "Ordem dos Pontos de Verificao",
                        Height: "Altura",
                        Exit: "Sair",
                        Random: "Aleatrio",
                        Primary: "Principal",
                        Secondary: "Secundrio",
                        Frame: "Estrutura",
                        Rims: "Aros",
                        "Are you sure you want to exit without saving?": "Tem certeza de que deseja sair sem salvar?",
                        "All changes will be lost!": "Todas as alteraes sero perdidas!",
                        "Car saved!": "Carro salvo!",
                        Test: "Testar",
                        "Starting point is missing!": "Ponto de partida est faltando!",
                        Generate: "Gerar",
                        "Are you sure you want to generate a new track?\n\nYour current track will be lost!": "Tem certeza de que deseja gerar uma nova pista?\n\nSua pista atual ser perdida!",
                        Load: "Carregar",
                        Save: "Salvar",
                        "Are you sure you want to load a new track?\n\nYour current track will be lost!": "Tem certeza de que deseja carregar uma nova pista?\n\nSua pista atual ser perdida!",
                        "Track saved!": "Pista salva!",
                        "Failed to save!": "Falha ao salvar!",
                        'Are you sure you want to overwrite "{0}"?': 'Tem certeza de que deseja sobrescrever "{0}"?',
                        Export: "Exportar",
                        Help: "Ajuda",
                        "Are you sure you want to exit the editor?": "Tem certeza de que deseja sair do editor?",
                        "All unsaved data will be lost!": "Todos os dados no salvos sero perdidos!",
                        "Track settings": "Configuraes da pista",
                        "Unnamed Track": "Pista sem nome",
                        "Track name": "Nome da pista",
                        Author: "Autor",
                        Unknown: "Desconhecido",
                        Environment: "Ambiente",
                        Summer: "Vero",
                        Winter: "Inverno",
                        Desert: "Deserto",
                        "Sun direction": "Direo do sol",
                        "How to use the editor": "Como usar o editor",
                        "Camera controls": "Controles da cmera",
                        "The camera can be moved by right clicking and dragging the mouse. Rotate the camera by clicking the middle mouse button (mouse wheel) or holding the control key and right clicking and dragging the mouse. Zoom in and out by scrolling the mouse wheel.": "A cmera pode ser movida clicando com o boto direito do mouse e arrastando. Gire a cmera clicando no boto do meio do mouse (roda do mouse) ou segurando a tecla de controle e clicando com o boto direito do mouse e arrastando. Amplie e reduza o zoom rolando a roda do mouse.",
                        "Alternatively, the camera can also be controlled using the following keyboard keys:": "Alternativamente, a cmera tambm pode ser controlada usando as seguintes teclas do teclado:",
                        "Move forwards:": "Mover para frente:",
                        "Move backwards:": "Mover para trs:",
                        "Move left:": "Mover para a esquerda:",
                        "Move right:": "Mover para a direita:",
                        "Rotate left:": "Girar para a esquerda:",
                        "Rotate right:": "Girar para a direita:",
                        "The edited height can be changed either by using the height selection in the bottom left corner, or holding the shift key and scrolling the mouse wheel. Alternatively, you can use the following keyboard keys:": "A altura editada pode ser alterada usando a seleo de altura no canto inferior esquerdo ou segurando a tecla shift e rolando a roda do mouse. Alternativamente, voc pode usar as seguintes teclas do teclado:",
                        "Move up:": "Mover para cima:",
                        "Move down:": "Mover para baixo:",
                        Editing: "Edio",
                        "Track parts can be selected in the menu on the right after which they can be placed by left clicking with the mouse.": "As partes da pista podem ser selecionadas no menu  direita e, em seguida, podem ser colocadas clicando com o boto esquerdo do mouse.",
                        "Alternatively, the track part currently hovered by the mouse can be selected with the following keyboard shortcut:": "Alternativamente, a parte da pista atualmente destacada pelo mouse pode ser selecionada com o seguinte atalho de teclado:",
                        "The selected part can then be rotated using the following keyboard shortcut:": "A parte selecionada pode ento ser girada usando o seguinte atalho de teclado:",
                        "Track parts can be deleted by using the delete tool in the right side menu or by holding the following key:": "As partes da pista podem ser excludas usando a ferramenta de excluso no menu lateral direito ou segurando a seguinte tecla:",
                        "Starting points, checkpoints and the finish line": "Pontos de partida, checkpoints e linha de chegada",
                        "Starting points, checkpoints and finish lines can all be selected in the uppermost category in the right side menu.": "Pontos de partida, checkpoints e linhas de chegada podem ser selecionados na categoria mais alta do menu lateral direito.",
                        "Each track must have at least one starting point. If there are multiple starting points, the last placed one will be used.": "Cada pista deve ter pelo menos um ponto de partida. Se houver vrios pontos de partida, o ltimo colocado ser usado.",
                        "Checkpoints should be placed between the starting point and the finish line. When a checkpoint track part is selected there will be a tool in the bottom right to select the order of the checkpoint. This determines the order in which the checkpoints must be passed before driving to the finish line. Notice that it is possible to have multiple checkpoints with the same checkpoint order.": "Os checkpoints devem ser colocados entre o ponto de partida e a linha de chegada. Quando uma parte da pista de checkpoint  selecionada, haver uma ferramenta no canto inferior direito para selecionar a ordem do checkpoint. Isso determina a ordem em que os checkpoints devem ser passados antes de dirigir at a linha de chegada. Observe que  possvel ter vrios checkpoints com a mesma ordem de checkpoint.",
                        "The finish line is where the track ends but will only become active after all checkpoints have been passed. It is also possible to have multiple finish lines.": "A linha de chegada  onde a pista termina, mas s se tornar ativa depois que todos os checkpoints forem passados. Tambm  possvel ter vrias linhas de chegada.",
                        "Starting point": "Ponto de partida",
                        Checkpoint: "Checkpoint",
                        "Finish line": "Linha de chegada",
                        "Exporting the track": "Exportando a pista",
                        "When the track is finished, a name for the track can be entered in top left after which the track can be exported using the export button. This will reveal a track code which can be sent to other users so they can import and play the track.": "Quando a pista estiver pronta, um nome para a pista pode ser inserido no canto superior esquerdo e, em seguida, a pista pode ser exportada usando o boto de exportao. Isso revelar um cdigo de pista que pode ser enviado para outros usurios para que eles possam importar e jogar a pista.",
                        Close: "Fechar",
                        "Not set": "No definido",
                        or: "ou",
                        "The camera can be moved by dragging with one finger. Rotate the camera by dragging with two fingers. Zoom in and out by pinching.": "A cmera pode ser movida arrastando com um dedo. Gire a cmera arrastando com dois dedos. Amplie e reduza o zoom beliscando.",
                        "The edited height can be changed by using the height selection in the bottom left corner.": "A altura editada pode ser alterada usando a seleo de altura no canto inferior esquerdo.",
                        "Track parts can be selected in the menu on the right after which they can be placed by tapping on the screen.": "As partes da pista podem ser selecionadas no menu  direita e, em seguida, podem ser colocadas tocando na tela.",
                        "The selected part can then be rotated by tapping the rotate button in the bottom left corner.": "A parte selecionada pode ento ser girada tocando no boto de rotao no canto inferior esquerdo.",
                        "Track parts can be deleted by using the delete tool in the right side menu.": "As partes da pista podem ser excludas usando a ferramenta de excluso no menu lateral direito.",
                        Watch: "Assistir",
                        "Loading replay": "Carregando replay",
                        "Press {0} to return to the last checkpoint": "Pressione {0} para retornar ao ltimo checkpoint",
                        "Press {0} to start over": "Pressione {0} para comear de novo",
                        "Reset once to return to the last checkpoint": "Redefinir uma vez para retornar ao ltimo checkpoint",
                        "Reset again to start over": "Redefinir novamente para comear de novo",
                        Leaderboard: "Quadro de Lderes",
                        Back: "Voltar",
                        "Error: Failed to load leaderboard": "Erro: Falha ao carregar o quadro de lderes",
                        Pending: "Pendente",
                        Verified: "Verificado",
                        Invalid: "Invlido",
                        Duplicate: "Duplicado",
                        You: "Voc",
                        "Only verified": "Apenas verificados",
                        Loading: "Carregando",
                        "Failed to load recordings": "Falha ao carregar gravaes",
                        "Cannot load recordings due to non-determinism": "No  possvel carregar gravaes devido a no determinismo",
                        Ok: "Ok",
                        "Track is missing starting point": "Pista est sem ponto de partida",
                        "Some leaderboard features are disabled.": "Alguns recursos do quadro de lderes esto desativados.",
                        "Please try another browser or device.": "Por favor, tente outro navegador ou dispositivo.",
                        "You already have another instance of PolyTrack open.": "Voc j tem outra instncia do PolyTrack aberta.",
                        "Please switch to that tab or window to continue.": "Por favor, mude para aquela guia ou janela para continuar.",
                        "Computer determinism check failed.": "Falha na verificao de determinismo do computador.",
                        "Non-deterministic game assets found.": "Assets de jogo no determinsticos encontrados.",
                        "Please try clearing your browser cache.": "Por favor, tente limpar o cache do seu navegador.",
                        Customize: "Personalizar",
                        Editor: "Editor",
                        Settings: "Configuraes",
                        Profile: "Perfil",
                        Play: "Jogar",
                        Version: "Verso",
                        "You cannot have duplicate user profiles": "Voc no pode ter perfis de usurio duplicados",
                        "Failed to create user profile": "Falha ao criar perfil de usurio",
                        "This user profile does not exist on the server": "Este perfil de usurio no existe no servidor",
                        "Failed to download user profile from the server": "Falha ao baixar perfil de usurio do servidor",
                        "User token is invalid": "Token de usurio invlido",
                        "Are you sure you want to display your private key?": "Tem certeza de que deseja exibir sua chave privada?",
                        "DO NOT SHARE THIS KEY WITH ANYONE.": "NO COMPARTILHE ESTA CHAVE COM NINGUM.",
                        "You need a free user profile slot to import a new user profile": "Voc precisa de um slot de perfil de usurio livre para importar um novo perfil de usurio",
                        Quit: "Sair",
                        Fullscreen: "Tela Cheia",
                        Windowed: "Janela",
                        "It seems like you are playing an unofficial version of {0}. For the most up-to-date version please visit the original source:": "Parece que voc est jogando uma verso no oficial de {0}. Para a verso mais atualizada, visite a fonte original:",
                        Nickname: "Apelido",
                        "Choose a nickname to be shown in the leaderboard. Your nickname can be changed at any time.": "Escolha um apelido para ser exibido no quadro de lderes. Seu apelido pode ser alterado a qualquer momento.",
                        Cancel: "Cancelar",
                        Confirm: "Confirmar",
                        Verifier: "Verificador",
                        "User ID": "ID de Usurio",
                        Paused: "Pausado",
                        "Switch car": "Trocar carro",
                        Profiles: "Perfis",
                        'Are you sure you would like to delete "{0}"?': 'Tem certeza de que deseja excluir "{0}"?',
                        Empty: "Vazio",
                        Reset: "Redefinir",
                        Apply: "Aplicar",
                        Gameplay: "Jogabilidade",
                        Units: "Unidades",
                        Metric: "Mtrico",
                        Imperial: "Imperial",
                        "Reset hint": "Redefinir dica",
                        Disabled: "Desativado",
                        Enabled: "Ativado",
                        "Ghost car": "Carro Fantasma",
                        "Default camera": "Cmera Padro",
                        Default: "Padro",
                        Cockpit: "Cockpit",
                        "Cockpit camera mode": "Modo de cmera do cockpit",
                        Hold: "Manter",
                        Toggle: "Alternar",
                        Checkpoints: "Pontos de Verificao",
                        Timer: "Temporizador",
                        Speedometer: "Velocmetro",
                        Bottom: "Inferior",
                        Top: "Superior",
                        Language: "Idioma",
                        Graphics: "Grficos",
                        "Car shadow": "Sombra do Carro",
                        "Track shadow": "Sombra da Pista",
                        Off: "Desligado",
                        On: "Ligado",
                        Low: "Baixo",
                        Medium: "Mdio",
                        High: "Alto",
                        Clouds: "Nuvens",
                        Particles: "Partculas",
                        Skidmarks: "Marcas de Derrapagem",
                        "Render scale": "Escala de Renderizao",
                        "Anti-aliasing (requires restart)": "Anti-aliasing (requer reincio)",
                        Audio: "udio",
                        "Sound effect volume": "Volume de Efeitos Sonoros",
                        "Music volume": "Volume de Msica",
                        "Checkpoint volume": "Volume dos Pontos de Verificao",
                        Controls: "Controles",
                        Vehicle: "Veculo",
                        Accelerate: "Acelerar",
                        Brake: "Freio",
                        "Turn left": "Virar  Esquerda",
                        "Turn right": "Virar  Direita",
                        "Checkpoint reset": "Redefinir Ponto de Verificao",
                        "Start reset": "Redefinir Incio",
                        "Cockpit camera": "Cmera do Cockpit",
                        "Rotate part": "Girar Parte",
                        "Height modifier": "Modificador de Altura",
                        "Delete part": "Excluir Parte",
                        "Move forwards": "Mover para Frente",
                        "Move backwards": "Mover para Trs",
                        "Move left": "Mover para a Esquerda",
                        "Move right": "Mover para a Direita",
                        "Rotate view left": "Girar Viso para a Esquerda",
                        "Rotate view right": "Girar Viso para a Direita",
                        "Move down": "Mover para Baixo",
                        "Move up": "Mover para Cima",
                        "Test track": "Testar Pista",
                        "Pick part": "Escolher Parte",
                        Spectator: "Espectador",
                        "Speed modifier": "Modificador de Velocidade",
                        Other: "Outro",
                        "Hide UI": "Ocultar UI",
                        Pause: "Pausar",
                        "Toggle FPS counter": "Alternar Contador de FPS",
                        "Toggle spectator camera": "Alternar Cmera de Espectador",
                        "Press any key...\n\nPress [Escape] to cancel.": "Pressione qualquer tecla...\n\nPressione [Escape] para cancelar.",
                        Clear: "Limpar",
                        "New record": "Novo recorde",
                        Record: "Recorde",
                        Current: "Atual",
                        Difference: "Diferena",
                        Copy: "Copiar",
                        Import: "Importar",
                        "Failed to import track": "Falha ao importar a pista",
                        'The track "{0}" already exists. Do you wish to overwrite it?': 'A pista "{0}" j existe. Deseja sobrescrev-la?',
                        Overwrite: "Sobrescrever",
                        "Paste track data here...": "Cole os dados da pista aqui...",
                        Rank: "Classificao",
                        "Personal best": "Melhor pessoal",
                        Opponents: "Oponentes",
                        "{0} opponent selected": "{0} oponente selecionado",
                        "{0} opponents selected": "{0} oponentes selecionados",
                        "Select opponents to race against from the leaderboard on the left": "Selecione os oponentes para competir no quadro de lderes  esquerda",
                        "No record": "Sem recorde",
                        "Official tracks": "Pistas Oficiais",
                        "Community tracks": "Pistas Comunitrias",
                        "Custom tracks": "Pistas Personalizadas",
                        'Are you sure you want to delete "{0}"?': 'Tem certeza de que deseja excluir "{0}"?',
                        Delete: "Excluir",
                        "No community tracks": "Sem pistas comunitrias",
                        "Community tracks are coming soon": "Pistas comunitrias em breve",
                        "No custom tracks": "Sem pistas personalizadas",
                        "Create a track using the editor or import a track code": "Crie uma pista usando o editor ou importe um cdigo de pista",
                        "Search tracks...": "Pesquisar pistas...",
                        "Invalid replay detected!": "Replay invlido detectado!",
                        "An opponent most likely used cheats": "Um oponente provavelmente usou trapaas"
                    }
                        , RU = {
                        "Checkpoint order": "Ordem dos Pontos de Verificao",
                        Height: "Altura",
                        Exit: "Sair",
                        Random: "Aleatrio",
                        Primary: "Primrio",
                        Secondary: "Secundrio",
                        Frame: "Estrutura",
                        Rims: "Aros",
                        "Are you sure you want to exit without saving?": "Tem a certeza de que deseja sair sem guardar?",
                        "All changes will be lost!": "Todas as alteraes sero perdidas!",
                        "Car saved!": "Carro guardado!",
                        Test: "Testar",
                        "Starting point is missing!": "Ponto de partida em falta!",
                        Generate: "Gerar",
                        "Are you sure you want to generate a new track?\n\nYour current track will be lost!": "Tem a certeza de que deseja gerar uma nova pista?\n\nA pista atual ser perdida!",
                        Load: "Carregar",
                        Save: "Guardar",
                        "Are you sure you want to load a new track?\n\nYour current track will be lost!": "Tem a certeza de que deseja carregar uma nova pista?\n\nA pista atual ser perdida!",
                        "Track saved!": "Pista guardada!",
                        "Failed to save!": "Falha ao guardar!",
                        'Are you sure you want to overwrite "{0}"?': 'Tem a certeza de que deseja substituir "{0}"?',
                        Export: "Exportar",
                        Help: "Ajuda",
                        "Are you sure you want to exit the editor?": "Tem a certeza de que deseja sair do editor?",
                        "All unsaved data will be lost!": "Todos os dados no guardados sero perdidos!",
                        "Track settings": "Definies da pista",
                        "Unnamed Track": "Pista sem nome",
                        "Track name": "Nome da pista",
                        Author: "Autor",
                        Unknown: "Desconhecido",
                        Environment: "Ambiente",
                        Summer: "Vero",
                        Winter: "Inverno",
                        Desert: "Deserto",
                        "Sun direction": "Direo do sol",
                        "How to use the editor": "Como usar o editor",
                        "Camera controls": "Controlos da cmera",
                        "The camera can be moved by right clicking and dragging the mouse. Rotate the camera by clicking the middle mouse button (mouse wheel) or holding the control key and right clicking and dragging the mouse. Zoom in and out by scrolling the mouse wheel.": "A cmera pode ser movida clicando com o boto direito do mouse e arrastando. Rode a cmera clicando no boto do meio do mouse (roda do mouse) ou segurando a tecla de controle e clicando com o boto direito do mouse e arrastando. Aproxime e afaste o zoom rolando a roda do mouse.",
                        "Alternatively, the camera can also be controlled using the following keyboard keys:": "Alternativamente, a cmera tambm pode ser controlada usando as seguintes teclas do teclado:",
                        "Move forwards:": "Mover para a frente:",
                        "Move backwards:": "Mover para trs:",
                        "Move left:": "Mover para a esquerda:",
                        "Move right:": "Mover para a direita:",
                        "Rotate left:": "Rodar para a esquerda:",
                        "Rotate right:": "Rodar para a direita:",
                        "The edited height can be changed either by using the height selection in the bottom left corner, or holding the shift key and scrolling the mouse wheel. Alternatively, you can use the following keyboard keys:": "A altura editada pode ser alterada usando a seleo de altura no canto inferior esquerdo ou segurando a tecla shift e rolando a roda do mouse. Alternativamente, voc pode usar as seguintes teclas do teclado:",
                        "Move up:": "Mover para cima:",
                        "Move down:": "Mover para baixo:",
                        Editing: "Edio",
                        "Track parts can be selected in the menu on the right after which they can be placed by left clicking with the mouse.": "As partes da pista podem ser selecionadas no menu  direita e depois podem ser colocadas clicando com o boto esquerdo do mouse.",
                        "Alternatively, the track part currently hovered by the mouse can be selected with the following keyboard shortcut:": "Alternativamente, a parte da pista atualmente destacada pelo mouse pode ser selecionada com o seguinte atalho de teclado:",
                        "The selected part can then be rotated using the following keyboard shortcut:": "A parte selecionada pode ento ser girada usando o seguinte atalho de teclado:",
                        "Track parts can be deleted by using the delete tool in the right side menu or by holding the following key:": "As partes da pista podem ser excludas usando a ferramenta de excluso no menu lateral direito ou segurando a seguinte tecla:",
                        "Starting points, checkpoints and the finish line": "Pontos de partida, checkpoints e linha de chegada",
                        "Starting points, checkpoints and finish lines can all be selected in the uppermost category in the right side menu.": "Pontos de partida, checkpoints e linhas de chegada podem ser selecionados na categoria mais alta do menu lateral direito.",
                        "Each track must have at least one starting point. If there are multiple starting points, the last placed one will be used.": "Cada pista deve ter pelo menos um ponto de partida. Se houver vrios pontos de partida, o ltimo colocado ser usado.",
                        "Checkpoints should be placed between the starting point and the finish line. When a checkpoint track part is selected there will be a tool in the bottom right to select the order of the checkpoint. This determines the order in which the checkpoints must be passed before driving to the finish line. Notice that it is possible to have multiple checkpoints with the same checkpoint order.": "Os checkpoints devem ser colocados entre o ponto de partida e a linha de chegada. Quando uma parte da pista de checkpoint  selecionada, haver uma ferramenta no canto inferior direito para selecionar a ordem do checkpoint. Isso determina a ordem em que os checkpoints devem ser passados antes de dirigir at a linha de chegada. Observe que  possvel ter vrios checkpoints com a mesma ordem de checkpoint.",
                        "The finish line is where the track ends but will only become active after all checkpoints have been passed. It is also possible to have multiple finish lines.": "A linha de chegada  onde a pista termina, mas s se tornar ativa depois que todos os checkpoints forem passados. Tambm  possvel ter vrias linhas de chegada.",
                        "Starting point": "Ponto de partida",
                        Checkpoint: "Checkpoint",
                        "Finish line": "Linha de chegada",
                        "Exporting the track": "Exportando a pista",
                        "When the track is finished, a name for the track can be entered in top left after which the track can be exported using the export button. This will reveal a track code which can be sent to other users so they can import and play the track.": "Quando a pista estiver pronta, um nome para a pista pode ser inserido no canto superior esquerdo, aps o qual a pista pode ser exportada usando o boto de exportao. Isso revelar um cdigo de pista que pode ser enviado para outros usurios para que eles possam importar e jogar a pista.",
                        Close: "Fechar",
                        "Not set": "No definido",
                        or: "ou",
                        "The camera can be moved by dragging with one finger. Rotate the camera by dragging with two fingers. Zoom in and out by pinching.": "A cmera pode ser movida arrastando com um dedo. Rode a cmera arrastando com dois dedos. Aproxime e afaste o zoom beliscando.",
                        "The edited height can be changed by using the height selection in the bottom left corner.": "A altura editada pode ser alterada usando a seleo de altura no canto inferior esquerdo.",
                        "Track parts can be selected in the menu on the right after which they can be placed by tapping on the screen.": "As partes da pista podem ser selecionadas no menu  direita e depois podem ser colocadas tocando na tela.",
                        "The selected part can then be rotated by tapping the rotate button in the bottom left corner.": "A parte selecionada pode ento ser girada tocando no boto de rotao no canto inferior esquerdo.",
                        "Track parts can be deleted by using the delete tool in the right side menu.": "As partes da pista podem ser excludas usando a ferramenta de excluso no menu lateral direito.",
                        Watch: "Ver",
                        "Loading replay": "A carregar replay",
                        "Press {0} to return to the last checkpoint": "Pressione {0} para voltar ao ltimo checkpoint",
                        "Press {0} to start over": "Pressione {0} para comear de novo",
                        "Reset once to return to the last checkpoint": "Repor uma vez para voltar ao ltimo checkpoint",
                        "Reset again to start over": "Repor novamente para comear de novo",
                        Leaderboard: "Tabela de Classificao",
                        Back: "Voltar",
                        "Error: Failed to load leaderboard": "Erro: Falha ao carregar a tabela de classificao",
                        Pending: "Pendente",
                        Verified: "Verificado",
                        Invalid: "Invlido",
                        Duplicate: "Duplicado",
                        You: "Voc",
                        "Only verified": "Apenas verificados",
                        Loading: "A Carregar",
                        "Failed to load recordings": "Falha ao carregar as gravaes",
                        "Cannot load recordings due to non-determinism": "No  possvel carregar as gravaes devido ao no determinismo",
                        Ok: "Ok",
                        "Track is missing starting point": "A pista no tem ponto de partida",
                        "Some leaderboard features are disabled.": "Algumas funcionalidades da tabela de classificao esto desativadas.",
                        "Please try another browser or device.": "Por favor, tente outro navegador ou dispositivo.",
                        "You already have another instance of PolyTrack open.": "J tem outra instncia do PolyTrack aberta.",
                        "Please switch to that tab or window to continue.": "Por favor, mude para essa aba ou janela para continuar.",
                        "Computer determinism check failed.": "Falha na verificao de determinismo do computador.",
                        "Non-deterministic game assets found.": "Ativos de jogo no determinsticos encontrados.",
                        "Please try clearing your browser cache.": "Por favor, tente limpar o cache do seu navegador.",
                        Customize: "Personalizar",
                        Editor: "Editor",
                        Settings: "Definies",
                        Profile: "Perfil",
                        Play: "Jogar",
                        Version: "Verso",
                        "You cannot have duplicate user profiles": "No pode ter perfis de utilizador duplicados",
                        "Failed to create user profile": "Falha ao criar o perfil de utilizador",
                        "This user profile does not exist on the server": "Este perfil de utilizador no existe no servidor",
                        "Failed to download user profile from the server": "Falha ao descarregar o perfil de utilizador do servidor",
                        "User token is invalid": "Token de utilizador invlido",
                        "Are you sure you want to display your private key?": "Tem a certeza de que pretende mostrar a sua chave privada?",
                        "DO NOT SHARE THIS KEY WITH ANYONE.": "NO PARTILHE ESTA CHAVE COM NINGUM.",
                        "You need a free user profile slot to import a new user profile": "Necessita de um slot de perfil de utilizador livre para importar um novo perfil de utilizador",
                        Quit: "Sair",
                        Fullscreen: "Ecr Inteiro",
                        Windowed: "Janela",
                        "It seems like you are playing an unofficial version of {0}. For the most up-to-date version please visit the original source:": "Parece que est a jogar uma verso no oficial de {0}. Para a verso mais atualizada, visite a fonte original:",
                        Nickname: "Alcunha",
                        "Choose a nickname to be shown in the leaderboard. Your nickname can be changed at any time.": "Escolha uma alcunha para ser exibida na tabela de classificao. A sua alcunha pode ser alterada a qualquer momento.",
                        Cancel: "Cancelar",
                        Confirm: "Confirmar",
                        Verifier: "Verificador",
                        "User ID": "ID de Utilizador",
                        Paused: "Pausado",
                        "Switch car": "Mudar de carro",
                        Profiles: "Perfis",
                        'Are you sure you would like to delete "{0}"?': 'Tem a certeza de que pretende eliminar "{0}"?',
                        Empty: "Vazio",
                        Reset: "Repor",
                        Apply: "Aplicar",
                        Gameplay: "Jogabilidade",
                        Units: "Unidades",
                        Metric: "Mtrico",
                        Imperial: "Imperial",
                        "Reset hint": "Repor dica",
                        Disabled: "Desativado",
                        Enabled: "Ativado",
                        "Ghost car": "Carro Fantasma",
                        "Default camera": "Cmera Padro",
                        Default: "Padro",
                        Cockpit: "Cabine",
                        "Cockpit camera mode": "Modo da cmera de cabine",
                        Hold: "Manter",
                        Toggle: "Alternar",
                        Checkpoints: "Pontos de Verificao",
                        Timer: "Temporizador",
                        Speedometer: "Velocmetro",
                        Bottom: "Inferior",
                        Top: "Superior",
                        Language: "Idioma",
                        Graphics: "Grficos",
                        "Car shadow": "Sombra do Carro",
                        "Track shadow": "Sombra da Pista",
                        Off: "Desligado",
                        On: "Ligado",
                        Low: "Baixo",
                        Medium: "Mdio",
                        High: "Alto",
                        Clouds: "Nuvens",
                        Particles: "Partculas",
                        Skidmarks: "Marcas de Derrapagem",
                        "Render scale": "Escala de Renderizao",
                        "Anti-aliasing (requires restart)": "Anti-aliasing (necessita de reiniciar)",
                        Audio: "udio",
                        "Sound effect volume": "Volume dos Efeitos Sonoros",
                        "Music volume": "Volume da Msica",
                        "Checkpoint volume": "Volume dos Pontos de Verificao",
                        Controls: "Controlos",
                        Vehicle: "Veculo",
                        Accelerate: "Acelerar",
                        Brake: "Travar",
                        "Turn left": "Virar  Esquerda",
                        "Turn right": "Virar  Direita",
                        "Checkpoint reset": "Repor o Ponto de Verificao",
                        "Start reset": "Repor o Incio",
                        "Cockpit camera": "Cmera de Cabine",
                        "Rotate part": "Rodar Parte",
                        "Height modifier": "Modificador de Altura",
                        "Delete part": "Eliminar Parte",
                        "Move forwards": "Mover para a frente",
                        "Move backwards": "Mover para trs",
                        "Move left": "Mover para a esquerda",
                        "Move right": "Mover para a direita",
                        "Rotate view left": "Rodar a vista para a esquerda",
                        "Rotate view right": "Rodar a vista para a direita",
                        "Move down": "Mover para baixo",
                        "Move up": "Mover para cima",
                        "Test track": "Testar Pista",
                        "Pick part": "Escolher Parte",
                        Spectator: "Espectador",
                        "Speed modifier": "Modificador de Velocidade",
                        Other: "Outro",
                        "Hide UI": "Esconder UI",
                        Pause: "Pausa",
                        "Toggle FPS counter": "Alternar Contador de FPS",
                        "Toggle spectator camera": "Alternar Cmara de Espectador",
                        "Press any key...\n\nPress [Escape] to cancel.": "Pressione qualquer tecla...\n\nPressione [Escape] para cancelar.",
                        Clear: "Limpar",
                        "New record": "Novo Recorde",
                        Record: "Recorde",
                        Current: "Atual",
                        Difference: "Diferena",
                        Copy: "Copiar",
                        Import: "Importar",
                        "Failed to import track": "Falha ao importar a pista",
                        'The track "{0}" already exists. Do you wish to overwrite it?': 'A pista "{0}" j existe. Deseja substitu-la?',
                        Overwrite: "Substituir",
                        "Paste track data here...": "Cole os dados da pista aqui...",
                        Rank: "Classificao",
                        "Personal best": "Melhor Pessoal",
                        Opponents: "Oponentes",
                        "{0} opponent selected": "{0} oponente selecionado",
                        "{0} opponents selected": "{0} oponentes selecionados",
                        "Select opponents to race against from the leaderboard on the left": "Selecione os oponentes para competir na tabela de classificao  esquerda",
                        "No record": "Sem Registo",
                        "Official tracks": "Pistas Oficiais",
                        "Community tracks": "Pistas da Comunidade",
                        "Custom tracks": "Pistas Personalizadas",
                        'Are you sure you want to delete "{0}"?': 'Tem a certeza de que deseja eliminar "{0}"?',
                        Delete: "Eliminar",
                        "No community tracks": "Sem pistas da comunidade",
                        "Community tracks are coming soon": "Pistas da comunidade em breve",
                        "No custom tracks": "Sem pistas personalizadas",
                        "Create a track using the editor or import a track code": "Crie uma pista usando o editor ou importe um cdigo de pista",
                        "Search tracks...": "Procurar pistas...",
                        "Invalid replay detected!": "Replay invlido detetado!",
                        "An opponent most likely used cheats": "Um oponente provavelmente usou cheats"
                    }
                        , LU = {
                        "Checkpoint order": "  ",
                        Height: "",
                        Exit: "",
                        Random: "",
                        Primary: "",
                        Secondary: "",
                        Frame: "",
                        Rims: "",
                        "Are you sure you want to exit without saving?": " ,     ?",
                        "All changes will be lost!": "   !",
                        "Car saved!": " !",
                        Test: "",
                        "Starting point is missing!": "  !",
                        Generate: "",
                        "Are you sure you want to generate a new track?\n\nYour current track will be lost!": " ,     ?\n\n    !",
                        Load: "",
                        Save: "",
                        "Are you sure you want to load a new track?\n\nYour current track will be lost!": " ,     ?\n\n    !",
                        "Track saved!": " !",
                        "Failed to save!": "  !",
                        'Are you sure you want to overwrite "{0}"?': ' ,    "{0}"?',
                        Export: "",
                        Help: "",
                        "Are you sure you want to exit the editor?": " ,     ?",
                        "All unsaved data will be lost!": "    !",
                        "Track settings": " ",
                        "Unnamed Track": " ",
                        "Track name": " ",
                        Author: "",
                        Unknown: "",
                        Environment: "",
                        Summer: "",
                        Winter: "",
                        Desert: "",
                        "Sun direction": " ",
                        "How to use the editor": "  ",
                        "Camera controls": " ",
                        "The camera can be moved by right clicking and dragging the mouse. Rotate the camera by clicking the middle mouse button (mouse wheel) or holding the control key and right clicking and dragging the mouse. Zoom in and out by scrolling the mouse wheel.": "  ,       .  ,     ()    Ctrl        .    ,   .",
                        "Alternatively, the camera can also be controlled using the following keyboard keys:": " ,        :",
                        "Move forwards:": " :",
                        "Move backwards:": " :",
                        "Move left:": " :",
                        "Move right:": " :",
                        "Rotate left:": " :",
                        "Rotate right:": " :",
                        "The edited height can be changed either by using the height selection in the bottom left corner, or holding the shift key and scrolling the mouse wheel. Alternatively, you can use the following keyboard keys:": "                Shift    .  ,     :",
                        "Move up:": " :",
                        "Move down:": " :",
                        Editing: "",
                        "Track parts can be selected in the menu on the right after which they can be placed by left clicking with the mouse.": "      ,     ,    .",
                        "Alternatively, the track part currently hovered by the mouse can be selected with the following keyboard shortcut:": " ,   ,    ,       :",
                        "The selected part can then be rotated using the following keyboard shortcut:": "        :",
                        "Track parts can be deleted by using the delete tool in the right side menu or by holding the following key:": "              :",
                        "Starting points, checkpoints and the finish line": " ,     ",
                        "Starting points, checkpoints and finish lines can all be selected in the uppermost category in the right side menu.": " ,            .",
                        "Each track must have at least one starting point. If there are multiple starting points, the last placed one will be used.": "        .     ,    .",
                        "Checkpoints should be placed between the starting point and the finish line. When a checkpoint track part is selected there will be a tool in the bottom right to select the order of the checkpoint. This determines the order in which the checkpoints must be passed before driving to the finish line. Notice that it is possible to have multiple checkpoints with the same checkpoint order.": "         .                 .   ,            .  ,              .",
                        "The finish line is where the track ends but will only become active after all checkpoints have been passed. It is also possible to have multiple finish lines.": "  -  ,   ,          .      .",
                        "Starting point": " ",
                        Checkpoint: " ",
                        "Finish line": " ",
                        "Exporting the track": " ",
                        "When the track is finished, a name for the track can be entered in top left after which the track can be exported using the export button. This will reveal a track code which can be sent to other users so they can import and play the track.": "  ,        ,         .     ,     ,        .",
                        Close: "",
                        "Not set": " ",
                        or: "",
                        "The camera can be moved by dragging with one finger. Rotate the camera by dragging with two fingers. Zoom in and out by pinching.": "  ,   .  ,   .    ,    .",
                        "The edited height can be changed by using the height selection in the bottom left corner.": "            .",
                        "Track parts can be selected in the menu on the right after which they can be placed by tapping on the screen.": "      ,     ,  .",
                        "The selected part can then be rotated by tapping the rotate button in the bottom left corner.": "   ,       .",
                        "Track parts can be deleted by using the delete tool in the right side menu.": "          .",
                        Watch: "",
                        "Loading replay": " ",
                        "Press {0} to return to the last checkpoint": " {0},      ",
                        "Press {0} to start over": " {0},   ",
                        "Reset once to return to the last checkpoint": "  ,      ",
                        "Reset again to start over": "  ,   ",
                        Leaderboard: " ",
                        Back: "",
                        "Error: Failed to load leaderboard": ":     ",
                        Pending: " ",
                        Verified: "",
                        Invalid: "",
                        Duplicate: "",
                        You: "",
                        "Only verified": " ",
                        Loading: "",
                        "Failed to load recordings": "   ",
                        "Cannot load recordings due to non-determinism": "   - ",
                        Ok: "",
                        "Track is missing starting point": "    ",
                        "Some leaderboard features are disabled.": "    .",
                        "Please try another browser or device.": ",     .",
                        "You already have another instance of PolyTrack open.": "      PolyTrack.",
                        "Please switch to that tab or window to continue.": ",      ,  .",
                        "Computer determinism check failed.": "    .",
                        "Non-deterministic game assets found.": "   .",
                        "Please try clearing your browser cache.": ",    .",
                        Customize: "",
                        Editor: "",
                        Settings: "",
                        Profile: "",
                        Play: "",
                        Version: "",
                        "You cannot have duplicate user profiles": "    ",
                        "Failed to create user profile": "    ",
                        "This user profile does not exist on the server": "      ",
                        "Failed to download user profile from the server": "      ",
                        "User token is invalid": "  ",
                        "Are you sure you want to display your private key?": " ,      ?",
                        "DO NOT SHARE THIS KEY WITH ANYONE.": "      .",
                        "You need a free user profile slot to import a new user profile": "          ",
                        Quit: "",
                        Fullscreen: "",
                        Windowed: "",
                        "It seems like you are playing an unofficial version of {0}. For the most up-to-date version please visit the original source:": ",      {0}.       :",
                        Nickname: "",
                        "Choose a nickname to be shown in the leaderboard. Your nickname can be changed at any time.": " ,      .       .",
                        Cancel: "",
                        Confirm: "",
                        Verifier: "",
                        "User ID": " ",
                        Paused: "",
                        "Switch car": " ",
                        Profiles: "",
                        'Are you sure you would like to delete "{0}"?': ' ,    "{0}"?',
                        Empty: "",
                        Reset: "",
                        Apply: "",
                        Gameplay: " ",
                        Units: " ",
                        Metric: "",
                        Imperial: "",
                        "Reset hint": " ",
                        Disabled: "",
                        Enabled: "",
                        "Ghost car": " ",
                        "Default camera": "  ",
                        Default: " ",
                        Cockpit: "",
                        "Cockpit camera mode": " ",
                        Hold: "",
                        Toggle: "",
                        Checkpoints: " ",
                        Timer: "",
                        Speedometer: "",
                        Bottom: "",
                        Top: "",
                        Language: "",
                        Graphics: "",
                        "Car shadow": " ",
                        "Track shadow": " ",
                        Off: "",
                        On: "",
                        Low: "",
                        Medium: "",
                        High: "",
                        Clouds: "",
                        Particles: "",
                        Skidmarks: "  ",
                        "Render scale": " ",
                        "Anti-aliasing (requires restart)": " ( )",
                        Audio: "",
                        "Sound effect volume": "  ",
                        "Music volume": " ",
                        "Checkpoint volume": "  ",
                        Controls: "",
                        Vehicle: "",
                        Accelerate: "",
                        Brake: "",
                        "Turn left": " ",
                        "Turn right": " ",
                        "Checkpoint reset": "  ",
                        "Start reset": " ",
                        "Cockpit camera": " ",
                        "Rotate part": " ",
                        "Height modifier": " ",
                        "Delete part": " ",
                        "Move forwards": " ",
                        "Move backwards": " ",
                        "Move left": " ",
                        "Move right": " ",
                        "Rotate view left": "  ",
                        "Rotate view right": "  ",
                        "Move down": " ",
                        "Move up": " ",
                        "Test track": " ",
                        "Pick part": " ",
                        Spectator: "",
                        "Speed modifier": " ",
                        Other: "",
                        "Hide UI": " ",
                        Pause: "",
                        "Toggle FPS counter": "  FPS",
                        "Toggle spectator camera": "  ",
                        "Press any key...\n\nPress [Escape] to cancel.": "  ...\n\n [Escape],  .",
                        Clear: "",
                        "New record": " ",
                        Record: "",
                        Current: "",
                        Difference: "",
                        Copy: "",
                        Import: "",
                        "Failed to import track": "   ",
                        'The track "{0}" already exists. Do you wish to overwrite it?': ' "{0}"  .   ?',
                        Overwrite: "",
                        "Paste track data here...": "   ...",
                        Rank: "",
                        "Personal best": " ",
                        Opponents: "",
                        "{0} opponent selected": "{0}  ",
                        "{0} opponents selected": "{0}  ",
                        "Select opponents to race against from the leaderboard on the left": "       ",
                        "No record": " ",
                        "Official tracks": " ",
                        "Community tracks": " ",
                        "Custom tracks": " ",
                        'Are you sure you want to delete "{0}"?': ' ,    "{0}"?',
                        Delete: "",
                        "No community tracks": "  ",
                        "Community tracks are coming soon": "   ",
                        "No custom tracks": "  ",
                        "Create a track using the editor or import a track code": "        ",
                        "Search tracks...": " ...",
                        "Invalid replay detected!": "  !",
                        "An opponent most likely used cheats": ",  ,  "
                    }
                        , NU = {
                        "Checkpoint order": "Kontrol noktas sras",
                        Height: "Ykseklik",
                        Exit: "k",
                        Random: "Rastgele",
                        Primary: "Birincil",
                        Secondary: "kincil",
                        Frame: "ereve",
                        Rims: "Jantlar",
                        "Are you sure you want to exit without saving?": "Kaydetmeden kmak istediinizden emin misiniz?",
                        "All changes will be lost!": "Tm deiiklikler kaybolacak!",
                        "Car saved!": "Araba kaydedildi!",
                        Test: "Test",
                        "Starting point is missing!": "Balang noktas eksik!",
                        Generate: "Olutur",
                        "Are you sure you want to generate a new track?\n\nYour current track will be lost!": "Yeni bir rota oluturmak istediinizden emin misiniz?\n\nMevcut rotanz kaybolacak!",
                        Load: "Ykle",
                        Save: "Kaydet",
                        "Are you sure you want to load a new track?\n\nYour current track will be lost!": "Yeni bir rota yklemek istediinizden emin misiniz?\n\nMevcut rotanz kaybolacak!",
                        "Track saved!": "Rota kaydedildi!",
                        "Failed to save!": "Kaydetme baarsz!",
                        'Are you sure you want to overwrite "{0}"?': '"{0}" zerine yazmak istediinizden emin misiniz?',
                        Export: "Da Aktar",
                        Help: "Yardm",
                        "Are you sure you want to exit the editor?": "Editrden kmak istediinizden emin misiniz?",
                        "All unsaved data will be lost!": "Tm kaydedilmemi veriler kaybolacak!",
                        "Track settings": "Rota ayarlar",
                        "Unnamed Track": "Adsz Rota",
                        "Track name": "Rota ad",
                        Author: "Yazar",
                        Unknown: "Bilinmiyor",
                        Environment: "evre",
                        Summer: "Yaz",
                        Winter: "K",
                        Desert: "l",
                        "Sun direction": "Gne yn",
                        "How to use the editor": "Editr nasl kullanlr",
                        "Camera controls": "Kamera kontrolleri",
                        "The camera can be moved by right clicking and dragging the mouse. Rotate the camera by clicking the middle mouse button (mouse wheel) or holding the control key and right clicking and dragging the mouse. Zoom in and out by scrolling the mouse wheel.": "Kameray sa tklayarak ve fareyi srkleyerek hareket ettirebilirsiniz. Kameray orta fare dmesine (fare tekerlei) tklayarak veya kontrol tuunu basl tutarak sa tklayarak ve fareyi srkleyerek dndrebilirsiniz. Fare tekerlei ile yaknlatrma ve uzaklatrma yapabilirsiniz.",
                        "Alternatively, the camera can also be controlled using the following keyboard keys:": "Alternatif olarak, kamera aadaki klavye tular kullanlarak da kontrol edilebilir:",
                        "Move forwards:": "leri hareket et:",
                        "Move backwards:": "Geri hareket et:",
                        "Move left:": "Sola hareket et:",
                        "Move right:": "Saa hareket et:",
                        "Rotate left:": "Sola dndr:",
                        "Rotate right:": "Saa dndr:",
                        "The edited height can be changed either by using the height selection in the bottom left corner, or holding the shift key and scrolling the mouse wheel. Alternatively, you can use the following keyboard keys:": "Dzenlenen ykseklik, sol alt kedeki ykseklik seimini kullanarak veya Shift tuunu basl tutarak ve fare tekerleini kaydrarak deitirilebilir. Alternatif olarak, aadaki klavye tularn kullanabilirsiniz:",
                        "Move up:": "Yukar hareket et:",
                        "Move down:": "Aa hareket et:",
                        Editing: "Dzenleme",
                        "Track parts can be selected in the menu on the right after which they can be placed by left clicking with the mouse.": "Paralar, fareyle sol tklayarak yerletirilebilecekleri sa taraftaki menden seilebilir.",
                        "Alternatively, the track part currently hovered by the mouse can be selected with the following keyboard shortcut:": "Alternatif olarak, fare tarafndan zerine gelinen rota paras aadaki klavye ksayoluyla seilebilir:",
                        "The selected part can then be rotated using the following keyboard shortcut:": "Seilen para aadaki klavye ksayoluyla dndrlebilir:",
                        "Track parts can be deleted by using the delete tool in the right side menu or by holding the following key:": "Rota paralar, sa taraftaki mendeki silme arac kullanlarak veya aadaki tua basl tutarak silinebilir:",
                        "Starting points, checkpoints and the finish line": "Balang noktalar, kontrol noktalar ve biti izgisi",
                        "Starting points, checkpoints and finish lines can all be selected in the uppermost category in the right side menu.": "Balang noktalar, kontrol noktalar ve biti izgileri, sa taraftaki mennn en st kategorisinde seilebilir.",
                        "Each track must have at least one starting point. If there are multiple starting points, the last placed one will be used.": "Her rota en az bir balang noktasna sahip olmaldr. Birden fazla balang noktas varsa, en son yerletirilen kullanlacaktr.",
                        "Checkpoints should be placed between the starting point and the finish line. When a checkpoint track part is selected there will be a tool in the bottom right to select the order of the checkpoint. This determines the order in which the checkpoints must be passed before driving to the finish line. Notice that it is possible to have multiple checkpoints with the same checkpoint order.": "Kontrol noktalar, balang noktas ile biti izgisi arasna yerletirilmelidir. Bir kontrol noktas rota paras seildiinde, kontrol noktasnn srasn semek iin sa alt kede bir ara bulunur. Bu, kontrol noktalarnn biti izgisine gitmeden nce geilmesi gereken sray belirler. Ayn kontrol noktas srasna sahip birden fazla kontrol noktas olabileceine dikkat edin.",
                        "The finish line is where the track ends but will only become active after all checkpoints have been passed. It is also possible to have multiple finish lines.": "Biti izgisi, rotann bittii yerdir, ancak tm kontrol noktalar geildikten sonra aktif hale gelir. Birden fazla biti izgisi de olabilir.",
                        "Starting point": "Balang noktas",
                        Checkpoint: "Kontrol noktas",
                        "Finish line": "Biti izgisi",
                        "Exporting the track": "Rotann da aktarlmas",
                        "When the track is finished, a name for the track can be entered in top left after which the track can be exported using the export button. This will reveal a track code which can be sent to other users so they can import and play the track.": "Rota tamamlandnda, rota iin bir ad girilebilir ve ardndan rota dmesini kullanarak rota da aktarlabilir. Bu, dier kullanclara gnderilebilecek bir rota kodunu ortaya karr, bylece rota ie aktarlabilir ve oynanabilir.",
                        Close: "Kapat",
                        "Not set": "Ayarlanmad",
                        or: "veya",
                        "The camera can be moved by dragging with one finger. Rotate the camera by dragging with two fingers. Zoom in and out by pinching.": "Kameray bir parmakla srkleyerek hareket ettirebilirsiniz. Kameray iki parmakla srkleyerek dndrebilirsiniz. Yaknlatrmak ve uzaklatrmak iin sktrabilirsiniz.",
                        "The edited height can be changed by using the height selection in the bottom left corner.": "Dzenlenen ykseklik, sol alt kedeki ykseklik seimi kullanlarak deitirilebilir.",
                        "Track parts can be selected in the menu on the right after which they can be placed by tapping on the screen.": "Paralar, ekrana dokunarak yerletirilebilecekleri sa taraftaki menden seilebilir.",
                        "The selected part can then be rotated by tapping the rotate button in the bottom left corner.": "Seilen para, sol alt kedeki dndr dmesine dokunarak dndrlebilir.",
                        "Track parts can be deleted by using the delete tool in the right side menu.": "Paralar, sa taraftaki mendeki silme arac kullanlarak silinebilir.",
                        Watch: "zle",
                        "Loading replay": "Tekrar ykleniyor",
                        "Press {0} to return to the last checkpoint": "Son kontrol noktasna dnmek iin {0} tuuna basn",
                        "Press {0} to start over": "Batan balamak iin {0} tuuna basn",
                        "Reset once to return to the last checkpoint": "Son kontrol noktasna dnmek iin bir kez sfrlayn",
                        "Reset again to start over": "Batan balamak iin tekrar sfrlayn",
                        Leaderboard: "Liderlik Tablosu",
                        Back: "Geri",
                        "Error: Failed to load leaderboard": "Hata: Liderlik tablosu yklenemedi",
                        Pending: "Beklemede",
                        Verified: "Doruland",
                        Invalid: "Geersiz",
                        Duplicate: "ift",
                        You: "Sen",
                        "Only verified": "Sadece dorulanm",
                        Loading: "Ykleniyor",
                        "Failed to load recordings": "Kaytlar yklenemedi",
                        "Cannot load recordings due to non-determinism": "Belirlenim dlktan dolay kaytlar yklenemiyor",
                        Ok: "Tamam",
                        "Track is missing starting point": "Rota balang noktas eksik",
                        "Some leaderboard features are disabled.": "Baz liderlik tablosu zellikleri devre d brakld.",
                        "Please try another browser or device.": "Ltfen baka bir tarayc veya cihaz deneyin.",
                        "You already have another instance of PolyTrack open.": "Zaten PolyTrack'in baka bir rneini atnz.",
                        "Please switch to that tab or window to continue.": "Devam etmek iin ltfen o sekmeye veya pencereye gein.",
                        "Computer determinism check failed.": "Bilgisayar belirlenim kontrol baarsz oldu.",
                        "Non-deterministic game assets found.": "Belirlenim d oyun varlklar bulundu.",
                        "Please try clearing your browser cache.": "Ltfen tarayc nbelleinizi temizlemeyi deneyin.",
                        Customize: "zelletir",
                        Editor: "Editr",
                        Settings: "Ayarlar",
                        Profile: "Profil",
                        Play: "Oyna",
                        Version: "Srm",
                        "You cannot have duplicate user profiles": "ift kullanc profili oluturamazsnz",
                        "Failed to create user profile": "Kullanc profili oluturulamad",
                        "This user profile does not exist on the server": "Bu kullanc profili sunucuda mevcut deil",
                        "Failed to download user profile from the server": "Kullanc profili sunucudan indirilemedi",
                        "User token is invalid": "Kullanc belirteci geersiz",
                        "Are you sure you want to display your private key?": "Gizli anahtarnz gstermek istediinizden emin misiniz?",
                        "DO NOT SHARE THIS KEY WITH ANYONE.": "BU ANAHTARI KMSEYLE PAYLAMAYIN.",
                        "You need a free user profile slot to import a new user profile": "Yeni bir kullanc profili eklemek iin bo bir kullanc profili yuvasna ihtiyacnz var",
                        Quit: "k",
                        Fullscreen: "Tam Ekran",
                        Windowed: "Pencere Modu",
                        "It seems like you are playing an unofficial version of {0}. For the most up-to-date version please visit the original source:": "{0} adl resmi olmayan bir srm oynuyor gibi grnyorsunuz. En gncel srm iin ltfen orijinal kayna ziyaret edin:",
                        Nickname: "Kullanc Ad",
                        "Choose a nickname to be shown in the leaderboard. Your nickname can be changed at any time.": "Liderlik tablosunda gsterilecek bir kullanc ad sein. Kullanc adnz istediiniz zaman deitirebilirsiniz.",
                        Cancel: "ptal",
                        Confirm: "Onayla",
                        Verifier: "Dorulayc",
                        "User ID": "Kullanc Kimlii",
                        Paused: "Duraklatld",
                        "Switch car": "Araba deitir",
                        Profiles: "Profiller",
                        'Are you sure you would like to delete "{0}"?': '"{0}" silmek istediinizden emin misiniz?',
                        Empty: "Bo",
                        Reset: "Sfrla",
                        Apply: "Uygula",
                        Gameplay: "Oynan",
                        Units: "Birimler",
                        Metric: "Metrik",
                        Imperial: "ngiliz",
                        "Reset hint": "pucunu sfrla",
                        Disabled: "Devre D",
                        Enabled: "Etkin",
                        "Ghost car": "Hayalet araba",
                        "Default camera": "Varsaylan kamera",
                        Default: "Varsaylan",
                        Cockpit: "Kokpit",
                        "Cockpit camera mode": "Kokpit kamera modu",
                        Hold: "Basl Tut",
                        Toggle: "Deitir",
                        Checkpoints: "Kontrol Noktalar",
                        Timer: "Zamanlayc",
                        Speedometer: "Hzler",
                        Bottom: "Alt",
                        Top: "st",
                        Language: "Dil",
                        Graphics: "Grafikler",
                        "Car shadow": "Araba glgesi",
                        "Track shadow": "Rota glgesi",
                        Off: "Kapal",
                        On: "Ak",
                        Low: "Dk",
                        Medium: "Orta",
                        High: "Yksek",
                        Clouds: "Bulutlar",
                        Particles: "Partikller",
                        Skidmarks: "Lastik izleri",
                        "Render scale": "Grnt lei",
                        "Anti-aliasing (requires restart)": "Kenar yumuatma (yeniden balatma gerektirir)",
                        Audio: "Ses",
                        "Sound effect volume": "Ses efekti ses seviyesi",
                        "Music volume": "Mzik ses seviyesi",
                        "Checkpoint volume": "Kontrol noktas ses seviyesi",
                        Controls: "Kontroller",
                        Vehicle: "Ara",
                        Accelerate: "Hzlan",
                        Brake: "Fren",
                        "Turn left": "Sola dn",
                        "Turn right": "Saa dn",
                        "Checkpoint reset": "Kontrol noktas sfrla",
                        "Start reset": "Balang sfrla",
                        "Cockpit camera": "Kokpit kamera",
                        "Rotate part": "Paray dndr",
                        "Height modifier": "Ykseklik deitir",
                        "Delete part": "Paray sil",
                        "Move forwards": "leri git",
                        "Move backwards": "Geri git",
                        "Move left": "Sola git",
                        "Move right": "Saa git",
                        "Rotate view left": "Grnm sola dndr",
                        "Rotate view right": "Grnm saa dndr",
                        "Move down": "Aa git",
                        "Move up": "Yukar git",
                        "Test track": "Rota test et",
                        "Pick part": "Para se",
                        Spectator: "Seyirci",
                        "Speed modifier": "Hz deitir",
                        Other: "Dier",
                        "Hide UI": "UI'yi gizle",
                        Pause: "Duraklat",
                        "Toggle FPS counter": "FPS sayacn deitir",
                        "Toggle spectator camera": "Seyirci kamerasn deitir",
                        "Press any key...\n\nPress [Escape] to cancel.": "Herhangi bir tua basn...\n\nptal etmek iin [Escape] tuuna basn",
                        Clear: "Temizle",
                        "New record": "Yeni kayt",
                        Record: "Kayt",
                        Current: "Mevcut",
                        Difference: "Fark",
                        Copy: "Kopyala",
                        Import: "e Aktar",
                        "Failed to import track": "Rota ie aktarma baarsz oldu",
                        'The track "{0}" already exists. Do you wish to overwrite it?': '"{0}" rota zaten var. zerine yazmak istiyor musunuz?',
                        Overwrite: "zerine yaz",
                        "Paste track data here...": "Rota verilerini buraya yaptr...",
                        Rank: "Sra",
                        "Personal best": "Kiisel en iyi",
                        Opponents: "Rakipler",
                        "{0} opponent selected": "{0} rakip seildi",
                        "{0} opponents selected": "{0} rakip seildi",
                        "Select opponents to race against from the leaderboard on the left": "Soldaki liderlik tablosundan yarmak iin rakipleri sein",
                        "No record": "Kayt yok",
                        "Official tracks": "Resmi rotalar",
                        "Community tracks": "Topluluk rotalar",
                        "Custom tracks": "zel rotalar",
                        'Are you sure you want to delete "{0}"?': '"{0}" silmek istediinizden emin misiniz?',
                        Delete: "Sil",
                        "No community tracks": "Topluluk rotas yok",
                        "Community tracks are coming soon": "Topluluk rotalar yaknda gelecek",
                        "No custom tracks": "zel rotalar yok",
                        "Create a track using the editor or import a track code": "Editr kullanarak bir rota oluturun veya bir rota kodu ie aktarn",
                        "Search tracks...": "Rotay ara...",
                        "Invalid replay detected!": "Geersiz tekrar algland!",
                        "An opponent most likely used cheats": "Bir rakibin muhtemelen hile kulland"
                    }
                        , DU = {
                        "Checkpoint order": "  ",
                        Height: "",
                        Exit: "",
                        Random: "",
                        Primary: "",
                        Secondary: "",
                        Frame: "",
                        Rims: "",
                        "Are you sure you want to exit without saving?": " ,     ?",
                        "All changes will be lost!": "   !",
                        "Car saved!": " !",
                        Test: "",
                        "Starting point is missing!": "  !",
                        Generate: "",
                        "Are you sure you want to generate a new track?\n\nYour current track will be lost!": " ,     ?\n\n    !",
                        Load: "",
                        Save: "",
                        "Are you sure you want to load a new track?\n\nYour current track will be lost!": " ,     ?\n\n    !",
                        "Track saved!": " !",
                        "Failed to save!": "  !",
                        'Are you sure you want to overwrite "{0}"?': ' ,    "{0}"?',
                        Export: "",
                        Help: "",
                        "Are you sure you want to exit the editor?": " ,     ?",
                        "All unsaved data will be lost!": "     !",
                        "Track settings": " ",
                        "Unnamed Track": " ",
                        "Track name": " ",
                        Author: "",
                        Unknown: "",
                        Environment: "",
                        Summer: "",
                        Winter: "",
                        Desert: "",
                        "Sun direction": " ",
                        "How to use the editor": "  ",
                        "Camera controls": " ",
                        "The camera can be moved by right clicking and dragging the mouse. Rotate the camera by clicking the middle mouse button (mouse wheel) or holding the control key and right clicking and dragging the mouse. Zoom in and out by scrolling the mouse wheel.": "  ,       .  ,     ( )    Control        .    ,   .",
                        "Alternatively, the camera can also be controlled using the following keyboard keys:": "         :",
                        "Move forwards:": " :",
                        "Move backwards:": " :",
                        "Move left:": " :",
                        "Move right:": " :",
                        "Rotate left:": " :",
                        "Rotate right:": " :",
                        "The edited height can be changed either by using the height selection in the bottom left corner, or holding the shift key and scrolling the mouse wheel. Alternatively, you can use the following keyboard keys:": "   ,           Shift    . ,       :",
                        "Move up:": " :",
                        "Move down:": " :",
                        Editing: "",
                        "Track parts can be selected in the menu on the right after which they can be placed by left clicking with the mouse.": "      ,     ,    .",
                        "Alternatively, the track part currently hovered by the mouse can be selected with the following keyboard shortcut:": ",  ,      ,         :",
                        "The selected part can then be rotated using the following keyboard shortcut:": "          :",
                        "Track parts can be deleted by using the delete tool in the right side menu or by holding the following key:": "   ,           :",
                        "Starting points, checkpoints and the finish line": " ,     ",
                        "Starting points, checkpoints and finish lines can all be selected in the uppermost category in the right side menu.": " ,               .",
                        "Each track must have at least one starting point. If there are multiple starting points, the last placed one will be used.": "       .     ,    .",
                        "Checkpoints should be placed between the starting point and the finish line. When a checkpoint track part is selected there will be a tool in the bottom right to select the order of the checkpoint. This determines the order in which the checkpoints must be passed before driving to the finish line. Notice that it is possible to have multiple checkpoints with the same checkpoint order.": "         .      ,   '      .   ,            .  ,           .",
                        "The finish line is where the track ends but will only become active after all checkpoints have been passed. It is also possible to have multiple finish lines.": "  -  ,   ,          .      .",
                        "Starting point": " ",
                        Checkpoint: " ",
                        "Finish line": " ",
                        "Exporting the track": " ",
                        "When the track is finished, a name for the track can be entered in top left after which the track can be exported using the export button. This will reveal a track code which can be sent to other users so they can import and play the track.": "  ,      ,     ,   .    ,     ,       .",
                        Close: "",
                        "Not set": " ",
                        or: "",
                        "The camera can be moved by dragging with one finger. Rotate the camera by dragging with two fingers. Zoom in and out by pinching.": "  ,   .  ,   .    ,  .",
                        "The edited height can be changed by using the height selection in the bottom left corner.": "   ,       .",
                        "Track parts can be selected in the menu on the right after which they can be placed by tapping on the screen.": "      ,     ,   .",
                        "The selected part can then be rotated by tapping the rotate button in the bottom left corner.": "   ,       .",
                        "Track parts can be deleted by using the delete tool in the right side menu.": "   ,       .",
                        Watch: "",
                        "Loading replay": " ",
                        "Press {0} to return to the last checkpoint": " {0},      ",
                        "Press {0} to start over": " {0},   ",
                        "Reset once to return to the last checkpoint": "  ,      ",
                        "Reset again to start over": "  ,   ",
                        Leaderboard: " ",
                        Back: "",
                        "Error: Failed to load leaderboard": ":     ",
                        Pending: "  ",
                        Verified: "",
                        Invalid: "",
                        Duplicate: "",
                        You: "",
                        "Only verified": " ",
                        Loading: "",
                        "Failed to load recordings": "   ",
                        "Cannot load recordings due to non-determinism": "     ",
                        Ok: "",
                        "Track is missing starting point": "    ",
                        "Some leaderboard features are disabled.": "    .",
                        "Please try another browser or device.": " ,     .",
                        "You already have another instance of PolyTrack open.": "      PolyTrack .",
                        "Please switch to that tab or window to continue.": " ,      ,  .",
                        "Computer determinism check failed.": "  '  .",
                        "Non-deterministic game assets found.": "   .",
                        "Please try clearing your browser cache.": "   .",
                        Customize: "",
                        Editor: "",
                        Settings: "",
                        Profile: "",
                        Play: "",
                        Version: "",
                        "You cannot have duplicate user profiles": "      ",
                        "Failed to create user profile": "    ",
                        "This user profile does not exist on the server": "      ",
                        "Failed to download user profile from the server": "      ",
                        "User token is invalid": "  ",
                        "Are you sure you want to display your private key?": " ,      ?",
                        "DO NOT SHARE THIS KEY WITH ANYONE.": "     .",
                        "You need a free user profile slot to import a new user profile": "          ",
                        Quit: "",
                        Fullscreen: "",
                        Windowed: " ",
                        "It seems like you are playing an unofficial version of {0}. For the most up-to-date version please visit the original source:": ",      {0}.      :",
                        Nickname: "",
                        "Choose a nickname to be shown in the leaderboard. Your nickname can be changed at any time.": "      .      - .",
                        Cancel: "",
                        Confirm: "",
                        Verifier: "",
                        "User ID": "ID ",
                        Paused: "",
                        "Switch car": " ",
                        Profiles: "",
                        'Are you sure you would like to delete "{0}"?': ' ,    "{0}"?',
                        Empty: "",
                        Reset: "",
                        Apply: "",
                        Gameplay: " ",
                        Units: " ",
                        Metric: "",
                        Imperial: "",
                        "Reset hint": " ",
                        Disabled: "",
                        Enabled: "",
                        "Ghost car": " ",
                        "Default camera": "  ",
                        Default: " ",
                        Cockpit: " ",
                        "Cockpit camera mode": "  ",
                        Hold: "",
                        Toggle: "",
                        Checkpoints: " ",
                        Timer: "",
                        Speedometer: "",
                        Bottom: "",
                        Top: "",
                        Language: "",
                        Graphics: "",
                        "Car shadow": " ",
                        "Track shadow": " ",
                        Off: "",
                        On: "",
                        Low: "",
                        Medium: "",
                        High: "",
                        Clouds: "",
                        Particles: "",
                        Skidmarks: "",
                        "Render scale": " ",
                        "Anti-aliasing (requires restart)": " ( )",
                        Audio: "",
                        "Sound effect volume": "  ",
                        "Music volume": " ",
                        "Checkpoint volume": "  ",
                        Controls: "",
                        Vehicle: " ",
                        Accelerate: "",
                        Brake: "",
                        "Turn left": " ",
                        "Turn right": " ",
                        "Checkpoint reset": "  ",
                        "Start reset": " ",
                        "Cockpit camera": "  ",
                        "Rotate part": " ",
                        "Height modifier": " ",
                        "Delete part": " ",
                        "Move forwards": " ",
                        "Move backwards": " ",
                        "Move left": " ",
                        "Move right": " ",
                        "Rotate view left": "  ",
                        "Rotate view right": "  ",
                        "Move down": " ",
                        "Move up": " ",
                        "Test track": " ",
                        "Pick part": " ",
                        Spectator: "",
                        "Speed modifier": " ",
                        Other: "",
                        "Hide UI": " ",
                        Pause: "",
                        "Toggle FPS counter": "  FPS",
                        "Toggle spectator camera": "  ",
                        "Press any key...\n\nPress [Escape] to cancel.": " - ...\n\n [Escape],  .",
                        Clear: "",
                        "New record": " ",
                        Record: "",
                        Current: "",
                        Difference: "",
                        Copy: "",
                        Import: "",
                        "Failed to import track": "   ",
                        'The track "{0}" already exists. Do you wish to overwrite it?': ' "{0}"  .   ?',
                        Overwrite: "",
                        "Paste track data here...": "   ...",
                        Rank: "",
                        "Personal best": " ",
                        Opponents: "",
                        "{0} opponent selected": "{0}  ",
                        "{0} opponents selected": "{0}  ",
                        "Select opponents to race against from the leaderboard on the left": "       ",
                        "No record": " ",
                        "Official tracks": " ",
                        "Community tracks": " ",
                        "Custom tracks": " ",
                        'Are you sure you want to delete "{0}"?': ' ,    "{0}"?',
                        Delete: "",
                        "No community tracks": "  ",
                        "Community tracks are coming soon": "  ",
                        "No custom tracks": "  ",
                        "Create a track using the editor or import a track code": "        ",
                        "Search tracks...": " ...",
                        "Invalid replay detected!": "  !",
                        "An opponent most likely used cheats": ", ,  "
                    }
                        , BU = {
                        "Checkpoint order": "",
                        Height: "",
                        Exit: "",
                        Random: "",
                        Primary: "",
                        Secondary: "",
                        Frame: "",
                        Rims: "",
                        "Are you sure you want to exit without saving?": "",
                        "All changes will be lost!": "",
                        "Car saved!": "",
                        Test: "",
                        "Starting point is missing!": "",
                        Generate: "",
                        "Are you sure you want to generate a new track?\n\nYour current track will be lost!": "\n\n",
                        Load: "",
                        Save: "",
                        "Are you sure you want to load a new track?\n\nYour current track will be lost!": "\n\n",
                        "Track saved!": "",
                        "Failed to save!": "",
                        'Are you sure you want to overwrite "{0}"?': ' "{0}" ',
                        Export: "",
                        Help: "",
                        "Are you sure you want to exit the editor?": "",
                        "All unsaved data will be lost!": "",
                        "Track settings": "",
                        "Unnamed Track": "",
                        "Track name": "",
                        Author: "",
                        Unknown: "",
                        Environment: "",
                        Summer: "",
                        Winter: "",
                        Desert: "",
                        "Sun direction": "",
                        "How to use the editor": "",
                        "Camera controls": "",
                        "The camera can be moved by right clicking and dragging the mouse. Rotate the camera by clicking the middle mouse button (mouse wheel) or holding the control key and right clicking and dragging the mouse. Zoom in and out by scrolling the mouse wheel.": "Ctrl",
                        "Alternatively, the camera can also be controlled using the following keyboard keys:": "",
                        "Move forwards:": "",
                        "Move backwards:": "",
                        "Move left:": "",
                        "Move right:": "",
                        "Rotate left:": "",
                        "Rotate right:": "",
                        "The edited height can be changed either by using the height selection in the bottom left corner, or holding the shift key and scrolling the mouse wheel. Alternatively, you can use the following keyboard keys:": "Shift",
                        "Move up:": "",
                        "Move down:": "",
                        Editing: "",
                        "Track parts can be selected in the menu on the right after which they can be placed by left clicking with the mouse.": "",
                        "Alternatively, the track part currently hovered by the mouse can be selected with the following keyboard shortcut:": "",
                        "The selected part can then be rotated using the following keyboard shortcut:": "",
                        "Track parts can be deleted by using the delete tool in the right side menu or by holding the following key:": "",
                        "Starting points, checkpoints and the finish line": "",
                        "Starting points, checkpoints and finish lines can all be selected in the uppermost category in the right side menu.": "",
                        "Each track must have at least one starting point. If there are multiple starting points, the last placed one will be used.": "",
                        "Checkpoints should be placed between the starting point and the finish line. When a checkpoint track part is selected there will be a tool in the bottom right to select the order of the checkpoint. This determines the order in which the checkpoints must be passed before driving to the finish line. Notice that it is possible to have multiple checkpoints with the same checkpoint order.": "",
                        "The finish line is where the track ends but will only become active after all checkpoints have been passed. It is also possible to have multiple finish lines.": "",
                        "Starting point": "",
                        Checkpoint: "",
                        "Finish line": "",
                        "Exporting the track": "",
                        "When the track is finished, a name for the track can be entered in top left after which the track can be exported using the export button. This will reveal a track code which can be sent to other users so they can import and play the track.": "",
                        Close: "",
                        "Not set": "",
                        or: "",
                        "The camera can be moved by dragging with one finger. Rotate the camera by dragging with two fingers. Zoom in and out by pinching.": "",
                        "The edited height can be changed by using the height selection in the bottom left corner.": "",
                        "Track parts can be selected in the menu on the right after which they can be placed by tapping on the screen.": "",
                        "The selected part can then be rotated by tapping the rotate button in the bottom left corner.": "",
                        "Track parts can be deleted by using the delete tool in the right side menu.": "",
                        Watch: "",
                        "Loading replay": "",
                        "Press {0} to return to the last checkpoint": " {0} ",
                        "Press {0} to start over": " {0} ",
                        "Reset once to return to the last checkpoint": "",
                        "Reset again to start over": "",
                        Leaderboard: "",
                        Back: "",
                        "Error: Failed to load leaderboard": "",
                        Pending: "",
                        Verified: "",
                        Invalid: "",
                        Duplicate: "",
                        You: "",
                        "Only verified": "",
                        Loading: "",
                        "Failed to load recordings": "",
                        "Cannot load recordings due to non-determinism": "",
                        Ok: "",
                        "Track is missing starting point": "",
                        "Some leaderboard features are disabled.": "",
                        "Please try another browser or device.": "",
                        "You already have another instance of PolyTrack open.": "PolyTrack",
                        "Please switch to that tab or window to continue.": "",
                        "Computer determinism check failed.": "",
                        "Non-deterministic game assets found.": "",
                        "Please try clearing your browser cache.": "",
                        Customize: "",
                        Editor: "",
                        Settings: "",
                        Profile: "",
                        Play: "",
                        Version: "",
                        "You cannot have duplicate user profiles": "",
                        "Failed to create user profile": "",
                        "This user profile does not exist on the server": "",
                        "Failed to download user profile from the server": "",
                        "User token is invalid": "",
                        "Are you sure you want to display your private key?": "",
                        "DO NOT SHARE THIS KEY WITH ANYONE.": "",
                        "You need a free user profile slot to import a new user profile": "",
                        Quit: "",
                        Fullscreen: "",
                        Windowed: "",
                        "It seems like you are playing an unofficial version of {0}. For the most up-to-date version please visit the original source:": " {0} ",
                        Nickname: "",
                        "Choose a nickname to be shown in the leaderboard. Your nickname can be changed at any time.": "",
                        Cancel: "",
                        Confirm: "",
                        Verifier: "",
                        "User ID": "ID",
                        Paused: "",
                        "Switch car": "",
                        Profiles: "",
                        'Are you sure you would like to delete "{0}"?': ' "{0}" ',
                        Empty: "",
                        Reset: "",
                        Apply: "",
                        Gameplay: "",
                        Units: "",
                        Metric: "",
                        Imperial: "",
                        "Reset hint": "",
                        Disabled: "",
                        Enabled: "",
                        "Ghost car": "",
                        "Default camera": "",
                        Default: "",
                        Cockpit: "",
                        "Cockpit camera mode": "",
                        Hold: "",
                        Toggle: "",
                        Checkpoints: "",
                        Timer: "",
                        Speedometer: "",
                        Bottom: "",
                        Top: "",
                        Language: "",
                        Graphics: "",
                        "Car shadow": "",
                        "Track shadow": "",
                        Off: "",
                        On: "",
                        Low: "",
                        Medium: "",
                        High: "",
                        Clouds: "",
                        Particles: "",
                        Skidmarks: "",
                        "Render scale": "",
                        "Anti-aliasing (requires restart)": "",
                        Audio: "",
                        "Sound effect volume": "",
                        "Music volume": "",
                        "Checkpoint volume": "",
                        Controls: "",
                        Vehicle: "",
                        Accelerate: "",
                        Brake: "",
                        "Turn left": "",
                        "Turn right": "",
                        "Checkpoint reset": "",
                        "Start reset": "",
                        "Cockpit camera": "",
                        "Rotate part": "",
                        "Height modifier": "",
                        "Delete part": "",
                        "Move forwards": "",
                        "Move backwards": "",
                        "Move left": "",
                        "Move right": "",
                        "Rotate view left": "",
                        "Rotate view right": "",
                        "Move down": "",
                        "Move up": "",
                        "Test track": "",
                        "Pick part": "",
                        Spectator: "",
                        "Speed modifier": "",
                        Other: "",
                        "Hide UI": "UI",
                        Pause: "",
                        "Toggle FPS counter": "FPS",
                        "Toggle spectator camera": "",
                        "Press any key...\n\nPress [Escape] to cancel.": "...\n\n [Escape] ",
                        Clear: "",
                        "New record": "",
                        Record: "",
                        Current: "",
                        Difference: "",
                        Copy: "",
                        Import: "",
                        "Failed to import track": "",
                        'The track "{0}" already exists. Do you wish to overwrite it?': ' "{0}" ',
                        Overwrite: "",
                        "Paste track data here...": "...",
                        Rank: "",
                        "Personal best": "",
                        Opponents: "",
                        "{0} opponent selected": "{0} ",
                        "{0} opponents selected": "{0} ",
                        "Select opponents to race against from the leaderboard on the left": "",
                        "No record": "",
                        "Official tracks": "",
                        "Community tracks": "",
                        "Custom tracks": "",
                        'Are you sure you want to delete "{0}"?': ' "{0}" ',
                        Delete: "",
                        "No community tracks": "",
                        "Community tracks are coming soon": "",
                        "No custom tracks": "",
                        "Create a track using the editor or import a track code": "",
                        "Search tracks...": "...",
                        "Invalid replay detected!": "",
                        "An opponent most likely used cheats": ""
                    }
                        , UU = {
                        "Checkpoint order": "",
                        Height: "",
                        Exit: "",
                        Random: "",
                        Primary: "",
                        Secondary: "",
                        Frame: "",
                        Rims: "",
                        "Are you sure you want to exit without saving?": "",
                        "All changes will be lost!": "",
                        "Car saved!": "",
                        Test: "",
                        "Starting point is missing!": "",
                        Generate: "",
                        "Are you sure you want to generate a new track?\n\nYour current track will be lost!": "\n\n",
                        Load: "",
                        Save: "",
                        "Are you sure you want to load a new track?\n\nYour current track will be lost!": "\n\n",
                        "Track saved!": "",
                        "Failed to save!": "",
                        'Are you sure you want to overwrite "{0}"?': ' "{0}" ',
                        Export: "",
                        Help: "",
                        "Are you sure you want to exit the editor?": "",
                        "All unsaved data will be lost!": "",
                        "Track settings": "",
                        "Unnamed Track": "",
                        "Track name": "",
                        Author: "",
                        Unknown: "",
                        Environment: "",
                        Summer: "",
                        Winter: "",
                        Desert: "",
                        "Sun direction": "",
                        "How to use the editor": "",
                        "Camera controls": "",
                        "The camera can be moved by right clicking and dragging the mouse. Rotate the camera by clicking the middle mouse button (mouse wheel) or holding the control key and right clicking and dragging the mouse. Zoom in and out by scrolling the mouse wheel.": "Ctrl",
                        "Alternatively, the camera can also be controlled using the following keyboard keys:": "",
                        "Move forwards:": "",
                        "Move backwards:": "",
                        "Move left:": "",
                        "Move right:": "",
                        "Rotate left:": "",
                        "Rotate right:": "",
                        "The edited height can be changed either by using the height selection in the bottom left corner, or holding the shift key and scrolling the mouse wheel. Alternatively, you can use the following keyboard keys:": "Shift",
                        "Move up:": "",
                        "Move down:": "",
                        Editing: "",
                        "Track parts can be selected in the menu on the right after which they can be placed by left clicking with the mouse.": "",
                        "Alternatively, the track part currently hovered by the mouse can be selected with the following keyboard shortcut:": "",
                        "The selected part can then be rotated using the following keyboard shortcut:": "",
                        "Track parts can be deleted by using the delete tool in the right side menu or by holding the following key:": "",
                        "Starting points, checkpoints and the finish line": "",
                        "Starting points, checkpoints and finish lines can all be selected in the uppermost category in the right side menu.": "",
                        "Each track must have at least one starting point. If there are multiple starting points, the last placed one will be used.": "",
                        "Checkpoints should be placed between the starting point and the finish line. When a checkpoint track part is selected there will be a tool in the bottom right to select the order of the checkpoint. This determines the order in which the checkpoints must be passed before driving to the finish line. Notice that it is possible to have multiple checkpoints with the same checkpoint order.": "",
                        "The finish line is where the track ends but will only become active after all checkpoints have been passed. It is also possible to have multiple finish lines.": "",
                        "Starting point": "",
                        Checkpoint: "",
                        "Finish line": "",
                        "Exporting the track": "",
                        "When the track is finished, a name for the track can be entered in top left after which the track can be exported using the export button. This will reveal a track code which can be sent to other users so they can import and play the track.": "",
                        Close: "",
                        "Not set": "",
                        or: "",
                        "The camera can be moved by dragging with one finger. Rotate the camera by dragging with two fingers. Zoom in and out by pinching.": "",
                        "The edited height can be changed by using the height selection in the bottom left corner.": "",
                        "Track parts can be selected in the menu on the right after which they can be placed by tapping on the screen.": "",
                        "The selected part can then be rotated by tapping the rotate button in the bottom left corner.": "",
                        "Track parts can be deleted by using the delete tool in the right side menu.": "",
                        Watch: "",
                        "Loading replay": "",
                        "Press {0} to return to the last checkpoint": " {0} ",
                        "Press {0} to start over": " {0} ",
                        "Reset once to return to the last checkpoint": "",
                        "Reset again to start over": "",
                        Leaderboard: "",
                        Back: "",
                        "Error: Failed to load leaderboard": "",
                        Pending: "",
                        Verified: "",
                        Invalid: "",
                        Duplicate: "",
                        You: "",
                        "Only verified": "",
                        Loading: "",
                        "Failed to load recordings": "",
                        "Cannot load recordings due to non-determinism": "",
                        Ok: "",
                        "Track is missing starting point": "",
                        "Some leaderboard features are disabled.": "",
                        "Please try another browser or device.": "",
                        "You already have another instance of PolyTrack open.": " PolyTrack ",
                        "Please switch to that tab or window to continue.": "",
                        "Computer determinism check failed.": "",
                        "Non-deterministic game assets found.": "",
                        "Please try clearing your browser cache.": "",
                        Customize: "",
                        Editor: "",
                        Settings: "",
                        Profile: "",
                        Play: "",
                        Version: "",
                        "You cannot have duplicate user profiles": "",
                        "Failed to create user profile": "",
                        "This user profile does not exist on the server": "",
                        "Failed to download user profile from the server": "",
                        "User token is invalid": "",
                        "Are you sure you want to display your private key?": "",
                        "DO NOT SHARE THIS KEY WITH ANYONE.": "",
                        "You need a free user profile slot to import a new user profile": "",
                        Quit: "",
                        Fullscreen: "",
                        Windowed: "",
                        "It seems like you are playing an unofficial version of {0}. For the most up-to-date version please visit the original source:": " {0}",
                        Nickname: "",
                        "Choose a nickname to be shown in the leaderboard. Your nickname can be changed at any time.": "",
                        Cancel: "",
                        Confirm: "",
                        Verifier: "",
                        "User ID": " ID",
                        Paused: "",
                        "Switch car": "",
                        Profiles: "",
                        'Are you sure you would like to delete "{0}"?': ' "{0}" ',
                        Empty: "",
                        Reset: "",
                        Apply: "",
                        Gameplay: "",
                        Units: "",
                        Metric: "",
                        Imperial: "",
                        "Reset hint": "",
                        Disabled: "",
                        Enabled: "",
                        "Ghost car": "",
                        "Default camera": "",
                        Default: "",
                        Cockpit: "",
                        "Cockpit camera mode": "",
                        Hold: "",
                        Toggle: "",
                        Checkpoints: "",
                        Timer: "",
                        Speedometer: "",
                        Bottom: "",
                        Top: "",
                        Language: "",
                        Graphics: "",
                        "Car shadow": "",
                        "Track shadow": "",
                        Off: "",
                        On: "",
                        Low: "",
                        Medium: "",
                        High: "",
                        Clouds: "",
                        Particles: "",
                        Skidmarks: "",
                        "Render scale": "",
                        "Anti-aliasing (requires restart)": " ()",
                        Audio: "",
                        "Sound effect volume": "",
                        "Music volume": "",
                        "Checkpoint volume": "",
                        Controls: "",
                        Vehicle: "",
                        Accelerate: "",
                        Brake: "",
                        "Turn left": "",
                        "Turn right": "",
                        "Checkpoint reset": "",
                        "Start reset": "",
                        "Cockpit camera": "",
                        "Rotate part": "",
                        "Height modifier": "",
                        "Delete part": "",
                        "Move forwards": "",
                        "Move backwards": "",
                        "Move left": "",
                        "Move right": "",
                        "Rotate view left": "",
                        "Rotate view right": "",
                        "Move down": "",
                        "Move up": "",
                        "Test track": "",
                        "Pick part": "",
                        Spectator: "",
                        "Speed modifier": "",
                        Other: "",
                        "Hide UI": " UI",
                        Pause: "",
                        "Toggle FPS counter": " FPS ",
                        "Toggle spectator camera": "",
                        "Press any key...\n\nPress [Escape] to cancel.": "...\n\n [Escape] ",
                        Clear: "",
                        "New record": "",
                        Record: "",
                        Current: "",
                        Difference: "",
                        Copy: "",
                        Import: "",
                        "Failed to import track": "",
                        'The track "{0}" already exists. Do you wish to overwrite it?': ' "{0}" ',
                        Overwrite: "",
                        "Paste track data here...": "...",
                        Rank: "",
                        "Personal best": "",
                        Opponents: "",
                        "{0} opponent selected": "{0} ",
                        "{0} opponents selected": "{0} ",
                        "Select opponents to race against from the leaderboard on the left": "",
                        "No record": "",
                        "Official tracks": "",
                        "Community tracks": "",
                        "Custom tracks": "",
                        'Are you sure you want to delete "{0}"?': ' "{0}" ',
                        Delete: "",
                        "No community tracks": "",
                        "Community tracks are coming soon": "",
                        "No custom tracks": "",
                        "Create a track using the editor or import a track code": "",
                        "Search tracks...": "...",
                        "Invalid replay detected!": "",
                        "An opponent most likely used cheats": ""
                    };
                    var zU, OU, FU, WU, HU = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    }, VU = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    };
                    OU = new WeakMap,
                        FU = new WeakMap,
                        zU = new WeakSet,
                        WU = function(e) {
                            const t = HU(this, FU, "f").get(e);
                            return null != t ? t : EU
                        }
                    ;
                    const GU = class {
                            constructor(e) {
                                zU.add(this),
                                    OU.set(this, void 0),
                                    FU.set(this, new Map([["ar", xU], ["de-DE", kU], ["es-ES", SU], ["fr-FR", MU], ["it-IT", TU], ["ja-JP", CU], ["ko-KR", _U], ["pl-PL", IU], ["pt-BR", PU], ["pt-PT", RU], ["ru-RU", LU], ["tr-TR", NU], ["uk-UA", DU], ["zh-CN", BU], ["zh-TW", UU]])),
                                    VU(this, OU, HU(this, zU, "m", WU).call(this, e), "f")
                            }
                            set language(e) {
                                VU(this, OU, HU(this, zU, "m", WU).call(this, e), "f")
                            }
                            get(e, t) {
                                let n;
                                if (n = e in HU(this, OU, "f") ? HU(this, OU, "f")[e] : e,
                                null != t)
                                    for (const [e,i] of t.entries())
                                        n = n.replace(new RegExp("\\{" + e.toString() + "\\}","g"), i);
                                return n
                            }
                        }
                    ;
                    var jU = n(1465)
                        , QU = {};
                    QU.styleTagTransform = u(),
                        QU.setAttributes = l(),
                        QU.insert = s().bind(null, "head"),
                        QU.domAPI = r(),
                        QU.insertStyleElement = h();
                    t()(jU.A, QU);
                    jU.A && jU.A.locals && jU.A.locals;
                    var YU, qU, KU, XU, ZU, JU, $U = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, ez = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    YU = new WeakMap,
                        qU = new WeakMap,
                        KU = new WeakMap,
                        XU = new WeakMap,
                        ZU = new WeakMap,
                        JU = new WeakMap;
                    const tz = class {
                            constructor() {
                                YU.set(this, void 0),
                                    qU.set(this, void 0),
                                    KU.set(this, void 0),
                                    XU.set(this, void 0),
                                    ZU.set(this, void 0),
                                    JU.set(this, void 0);
                                const e = document.getElementById("ui");
                                if (null == e)
                                    throw new Error("UI element not found");
                                $U(this, YU, e, "f"),
                                    $U(this, qU, document.createElement("div"), "f"),
                                    ez(this, qU, "f").className = "input-visualizer",
                                    ez(this, YU, "f").appendChild(ez(this, qU, "f")),
                                    $U(this, KU, document.createElement("div"), "f"),
                                    ez(this, KU, "f").className = "arrow-up",
                                    ez(this, KU, "f").innerHTML = '<img src="images/arrow_up.svg">',
                                    ez(this, qU, "f").appendChild(ez(this, KU, "f")),
                                    $U(this, XU, document.createElement("div"), "f"),
                                    ez(this, XU, "f").className = "arrow-right",
                                    ez(this, XU, "f").innerHTML = '<img src="images/arrow_right.svg">',
                                    ez(this, qU, "f").appendChild(ez(this, XU, "f")),
                                    $U(this, ZU, document.createElement("div"), "f"),
                                    ez(this, ZU, "f").className = "arrow-down",
                                    ez(this, ZU, "f").innerHTML = '<img src="images/arrow_down.svg">',
                                    ez(this, qU, "f").appendChild(ez(this, ZU, "f")),
                                    $U(this, JU, document.createElement("div"), "f"),
                                    ez(this, JU, "f").className = "arrow-left",
                                    ez(this, JU, "f").innerHTML = '<img src="images/arrow_left.svg">',
                                    ez(this, qU, "f").appendChild(ez(this, JU, "f"))
                            }
                            dispose() {
                                ez(this, YU, "f").removeChild(ez(this, qU, "f"))
                            }
                            update(e) {
                                ez(this, KU, "f").className = e.up ? "active arrow-up" : "arrow-up",
                                    ez(this, XU, "f").className = e.right ? "active arrow-right" : "arrow-right",
                                    ez(this, ZU, "f").className = e.down ? "active arrow-down" : "arrow-down",
                                    ez(this, JU, "f").className = e.left ? "active arrow-left" : "arrow-left"
                            }
                        }
                    ;
                    var nz = n(4543)
                        , iz = {};
                    iz.styleTagTransform = u(),
                        iz.setAttributes = l(),
                        iz.insert = s().bind(null, "head"),
                        iz.domAPI = r(),
                        iz.insertStyleElement = h();
                    t()(nz.A, iz);
                    nz.A && nz.A.locals && nz.A.locals;
                    var rz, az, sz, oz, lz, cz, hz, dz, uz, pz, fz, mz, gz, vz, wz, Az, yz, bz, xz = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, kz = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    az = new WeakMap,
                        sz = new WeakMap,
                        oz = new WeakMap,
                        lz = new WeakMap,
                        cz = new WeakMap,
                        hz = new WeakMap,
                        dz = new WeakMap,
                        uz = new WeakMap,
                        pz = new WeakMap,
                        fz = new WeakMap,
                        mz = new WeakMap,
                        gz = new WeakMap,
                        vz = new WeakMap,
                        wz = new WeakMap,
                        rz = new WeakSet,
                        Az = function(e) {
                            const t = kz(this, cz, "f").getBoundingClientRect()
                                , n = (e.clientX - t.left) / (t.width - 8)
                                , i = new xp(Math.max(0, Math.min(kz(this, mz, "f").numberOfFrames, Math.floor(n * kz(this, mz, "f").numberOfFrames))));
                            kz(this, sz, "f").call(this, i)
                        }
                        ,
                        yz = function() {
                            kz(this, fz, "f") ? kz(this, lz, "f").innerHTML = '<img src="images/reset.svg">' : kz(this, pz, "f") ? kz(this, lz, "f").innerHTML = '<img src="images/play.svg">' : kz(this, lz, "f").innerHTML = '<img src="images/pause.svg">'
                        }
                        ,
                        bz = function() {
                            if (kz(this, uz, "f").innerHTML = "",
                            kz(this, mz, "f").time < 1e4) {
                                let e, t;
                                kz(this, mz, "f").time > 2e3 ? (e = 60,
                                    t = 600) : kz(this, mz, "f").time > 200 ? (e = 10,
                                    t = 60) : (e = 1,
                                    t = 10);
                                for (let n = e; n < kz(this, mz, "f").time; n += e) {
                                    const e = document.createElement("div");
                                    e.className = n % t == 0 ? "dash long" : "dash",
                                        e.style.left = "calc(" + (n / kz(this, mz, "f").time * 100).toString() + "% - 1px)",
                                        kz(this, uz, "f").appendChild(e)
                                }
                            }
                        }
                    ;
                    const Ez = class {
                            constructor(e, t, n, i) {
                                rz.add(this),
                                    az.set(this, void 0),
                                    sz.set(this, void 0),
                                    oz.set(this, void 0),
                                    lz.set(this, void 0),
                                    cz.set(this, void 0),
                                    hz.set(this, void 0),
                                    dz.set(this, void 0),
                                    uz.set(this, void 0),
                                    pz.set(this, void 0),
                                    fz.set(this, !1),
                                    mz.set(this, void 0),
                                    gz.set(this, !1),
                                    vz.set(this, void 0),
                                    wz.set(this, void 0),
                                    xz(this, pz, i, "f");
                                const r = document.getElementById("ui");
                                if (null == r)
                                    throw new Error("UI element not found");
                                xz(this, az, r, "f"),
                                    xz(this, sz, n, "f"),
                                    xz(this, mz, t, "f"),
                                    xz(this, oz, document.createElement("div"), "f"),
                                    kz(this, oz, "f").className = "time-bar",
                                    kz(this, az, "f").appendChild(kz(this, oz, "f")),
                                    xz(this, lz, document.createElement("button"), "f"),
                                    kz(this, lz, "f").className = "button",
                                    kz(this, lz, "f").addEventListener("click", ( () => {
                                            e.playUIClick(),
                                                kz(this, fz, "f") ? (kz(this, sz, "f").call(this, new xp(0)),
                                                    this.isPaused = !1) : this.isPaused = !this.isPaused
                                        }
                                    )),
                                    kz(this, oz, "f").appendChild(kz(this, lz, "f")),
                                    kz(this, rz, "m", yz).call(this),
                                    xz(this, cz, document.createElement("div"), "f"),
                                    kz(this, cz, "f").className = "bar",
                                    kz(this, cz, "f").addEventListener("pointerdown", (e => {
                                            xz(this, gz, !0, "f"),
                                                kz(this, rz, "m", Az).call(this, e)
                                        }
                                    )),
                                    window.addEventListener("pointermove", xz(this, vz, (e => {
                                            kz(this, gz, "f") && kz(this, rz, "m", Az).call(this, e)
                                        }
                                    ), "f")),
                                    window.addEventListener("pointerup", xz(this, wz, (e => {
                                            kz(this, gz, "f") && (xz(this, gz, !1, "f"),
                                                kz(this, rz, "m", Az).call(this, e))
                                        }
                                    ), "f")),
                                    kz(this, oz, "f").appendChild(kz(this, cz, "f"));
                                const a = document.createElement("div");
                                kz(this, cz, "f").appendChild(a),
                                    xz(this, hz, document.createElement("div"), "f"),
                                    kz(this, hz, "f").className = "unloaded-fill",
                                    a.appendChild(kz(this, hz, "f")),
                                    xz(this, dz, document.createElement("div"), "f"),
                                    kz(this, dz, "f").className = "fill",
                                    a.appendChild(kz(this, dz, "f")),
                                    xz(this, uz, document.createElement("div"), "f"),
                                    kz(this, uz, "f").className = "dash-container",
                                    a.appendChild(kz(this, uz, "f")),
                                    kz(this, rz, "m", bz).call(this)
                            }
                            dispose() {
                                kz(this, az, "f").removeChild(kz(this, oz, "f")),
                                    window.removeEventListener("pointermove", kz(this, vz, "f")),
                                    window.removeEventListener("pointerup", kz(this, wz, "f"))
                            }
                            get isDragging() {
                                return kz(this, gz, "f")
                            }
                            get isPaused() {
                                return kz(this, pz, "f")
                            }
                            set isPaused(e) {
                                xz(this, pz, e, "f"),
                                    kz(this, rz, "m", yz).call(this)
                            }
                            set time(e) {
                                const t = e.numberOfFrames >= kz(this, mz, "f").numberOfFrames;
                                kz(this, dz, "f").style.width = "calc(8px + " + (e.numberOfFrames / kz(this, mz, "f").numberOfFrames * 100).toString() + "%)",
                                    0 == e.numberOfFrames ? kz(this, dz, "f").style.visibility = "hidden" : kz(this, dz, "f").style.visibility = "visible",
                                kz(this, fz, "f") != t && (xz(this, fz, t, "f"),
                                    kz(this, rz, "m", yz).call(this))
                            }
                            set loadedTime(e) {
                                kz(this, hz, "f").style.width = "calc(8px + " + (100 * (1 - e.numberOfFrames / kz(this, mz, "f").numberOfFrames)).toString() + "%)",
                                    e.numberOfFrames >= kz(this, mz, "f").numberOfFrames ? kz(this, hz, "f").style.visibility = "hidden" : kz(this, hz, "f").style.visibility = "visible"
                            }
                            set totalTime(e) {
                                kz(this, mz, "f").equals(e) || (xz(this, mz, e.clone(), "f"),
                                    kz(this, rz, "m", bz).call(this))
                            }
                        }
                    ;
                    var Sz = n(8768)
                        , Mz = {};
                    Mz.styleTagTransform = u(),
                        Mz.setAttributes = l(),
                        Mz.insert = s().bind(null, "head"),
                        Mz.domAPI = r(),
                        Mz.insertStyleElement = h();
                    t()(Sz.A, Mz);
                    Sz.A && Sz.A.locals && Sz.A.locals;
                    var Tz, Cz, _z = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, Iz = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    Tz = new WeakMap,
                        Cz = new WeakMap;
                    const Pz = class {
                            constructor(e, t, n, i) {
                                Tz.set(this, void 0),
                                    Cz.set(this, void 0);
                                const r = document.getElementById("ui");
                                if (null == r)
                                    throw new Error("UI element not found");
                                _z(this, Tz, r, "f"),
                                    _z(this, Cz, document.createElement("div"), "f"),
                                    Iz(this, Cz, "f").className = "preview-toolbar";
                                const a = document.createElement("button");
                                if (a.className = "button",
                                    a.innerHTML = '<img class="button-icon" src="images/back.svg"> ',
                                    a.append(document.createTextNode(t.get("Back"))),
                                    a.addEventListener("click", ( () => {
                                            e.playUIClick(),
                                                n()
                                        }
                                    )),
                                    Iz(this, Cz, "f").appendChild(a),
                                null != i) {
                                    const n = document.createElement("button");
                                    n.className = "button",
                                        n.innerHTML = '<img class="button-icon" src="images/customize.svg"> ',
                                        n.append(document.createTextNode(t.get("Switch car"))),
                                        n.addEventListener("click", ( () => {
                                                e.playUIClick(),
                                                    i()
                                            }
                                        )),
                                        Iz(this, Cz, "f").appendChild(n)
                                }
                                Iz(this, Tz, "f").appendChild(Iz(this, Cz, "f"))
                            }
                            dispose() {
                                Iz(this, Tz, "f").removeChild(Iz(this, Cz, "f"))
                            }
                        }
                    ;
                    var Rz, Lz, Nz, Dz, Bz, Uz, zz, Oz, Fz, Wz, Hz, Vz, Gz, jz, Qz, Yz, qz, Kz, Xz, Zz, Jz, $z, eO, tO, nO, iO, rO, aO, sO, oO, lO, cO = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    }, hO = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    };
                    Lz = new WeakMap,
                        Nz = new WeakMap,
                        Dz = new WeakMap,
                        Bz = new WeakMap,
                        Uz = new WeakMap,
                        zz = new WeakMap,
                        Oz = new WeakMap,
                        Fz = new WeakMap,
                        Wz = new WeakMap,
                        Hz = new WeakMap,
                        Vz = new WeakMap,
                        Gz = new WeakMap,
                        jz = new WeakMap,
                        Qz = new WeakMap,
                        Yz = new WeakMap,
                        qz = new WeakMap,
                        Kz = new WeakMap,
                        Xz = new WeakMap,
                        Zz = new WeakMap,
                        Jz = new WeakMap,
                        $z = new WeakMap,
                        eO = new WeakMap,
                        tO = new WeakMap,
                        nO = new WeakMap,
                        iO = new WeakMap,
                        rO = new WeakMap,
                        aO = new WeakMap,
                        sO = new WeakMap,
                        Rz = new WeakSet,
                        oO = function(e) {
                            var t, n, i, r, a;
                            if (e) {
                                const e = hO(this, Qz, "f")[hO(this, jz, "f")].settings.time;
                                let t;
                                cO(this, Jz, new Ez(hO(this, Wz, "f"),e,(e => {
                                        var t, n, i;
                                        cO(this, qz, Math.max(0, Math.min(hO(this, Kz, "f"), e.time)), "f");
                                        const r = Math.round(1e3 * hO(this, qz, "f"));
                                        hO(this, Rz, "m", lO).call(this, r);
                                        for (const e of hO(this, Qz, "f"))
                                            e.car.update(0);
                                        const a = hO(this, Qz, "f")[hO(this, jz, "f")].car;
                                        null != hO(this, Jz, "f") && (hO(this, Jz, "f").time = new xp(r)),
                                        null === (t = hO(this, eO, "f")) || void 0 === t || t.update(a.getControls()),
                                        null === (n = hO(this, tO, "f")) || void 0 === n || n.update(a),
                                        null === (i = hO(this, nO, "f")) || void 0 === i || i.update(a)
                                    }
                                ),hO(this, Yz, "f")), "f"),
                                    t = hO(this, Qz, "f").length > 1 ? () => {
                                            cO(this, jz, (hO(this, jz, "f") + 1) % hO(this, Qz, "f").length, "f");
                                            for (let e = 0; e < hO(this, Qz, "f").length; e++)
                                                hO(this, Qz, "f")[e].car.notificationAudioEnabled = e == hO(this, jz, "f");
                                            hO(this, Xz, "f").isEnabled || (hO(this, Vz, "f").getSettingBoolean(Jo.DefaultCameraMode) ? hO(this, Fz, "f").setCamera(hO(this, Qz, "f")[hO(this, jz, "f")].car.cameraCockpit) : hO(this, Fz, "f").setCamera(hO(this, Qz, "f")[hO(this, jz, "f")].car.cameraOrbit)),
                                            null != hO(this, Jz, "f") && (hO(this, Jz, "f").totalTime = hO(this, Qz, "f")[hO(this, jz, "f")].settings.time),
                                            null != hO(this, nO, "f") && (hO(this, nO, "f").nickname = hO(this, Qz, "f")[hO(this, jz, "f")].settings.name)
                                        }
                                        : null,
                                    cO(this, $z, new Pz(hO(this, Wz, "f"),hO(this, Hz, "f"),( () => {
                                            hO(this, Gz, "f").call(this, hO(this, Dz, "f"), hO(this, Bz, "f"), hO(this, Uz, "f"), hO(this, Qz, "f").map((e => e.settings)))
                                        }
                                    ),t), "f"),
                                    cO(this, eO, new tz, "f"),
                                    cO(this, tO, new eT(hO(this, Vz, "f")), "f"),
                                    hO(this, tO, "f").setOverridePosition(!1),
                                    cO(this, nO, new Vx(hO(this, Hz, "f"),hO(this, Vz, "f"),!0), "f"),
                                    hO(this, nO, "f").nickname = hO(this, Qz, "f")[hO(this, jz, "f")].settings.name,
                                    hO(this, nO, "f").setOverridePosition(!1)
                            } else
                                null === (t = hO(this, Jz, "f")) || void 0 === t || t.dispose(),
                                    cO(this, Jz, null, "f"),
                                null === (n = hO(this, $z, "f")) || void 0 === n || n.dispose(),
                                    cO(this, $z, null, "f"),
                                null === (i = hO(this, eO, "f")) || void 0 === i || i.dispose(),
                                    cO(this, eO, null, "f"),
                                null === (r = hO(this, tO, "f")) || void 0 === r || r.dispose(),
                                    cO(this, tO, null, "f"),
                                null === (a = hO(this, nO, "f")) || void 0 === a || a.dispose(),
                                    cO(this, nO, null, "f")
                        }
                        ,
                        lO = function(e) {
                            for (const t of hO(this, Qz, "f"))
                                if (t.car.getTime().numberOfFrames != e) {
                                    const n = t.replay.getFrame(e);
                                    null != n && t.car.setCarState(n)
                                }
                        }
                    ;
                    const dO = class {
                            constructor(e, t, n, i, r, a, s, o, l, c, h, d, u) {
                                Rz.add(this),
                                    Lz.set(this, void 0),
                                    Nz.set(this, void 0),
                                    Dz.set(this, void 0),
                                    Bz.set(this, void 0),
                                    Uz.set(this, void 0),
                                    zz.set(this, void 0),
                                    Oz.set(this, void 0),
                                    Fz.set(this, void 0),
                                    Wz.set(this, void 0),
                                    Hz.set(this, void 0),
                                    Vz.set(this, void 0),
                                    Gz.set(this, void 0),
                                    jz.set(this, 0),
                                    Qz.set(this, void 0),
                                    Yz.set(this, !1),
                                    qz.set(this, 0),
                                    Kz.set(this, 0),
                                    Xz.set(this, void 0),
                                    Zz.set(this, !0),
                                    Jz.set(this, null),
                                    $z.set(this, null),
                                    eO.set(this, null),
                                    tO.set(this, null),
                                    nO.set(this, null),
                                    iO.set(this, null),
                                    rO.set(this, void 0),
                                    aO.set(this, void 0),
                                    sO.set(this, 1e4),
                                    cO(this, Lz, e, "f"),
                                    cO(this, Nz, t, "f"),
                                    cO(this, Dz, n, "f"),
                                    cO(this, Bz, i, "f"),
                                    cO(this, Uz, r, "f"),
                                    cO(this, zz, a, "f"),
                                    cO(this, Oz, s, "f"),
                                    cO(this, Fz, o, "f"),
                                    cO(this, Wz, l, "f"),
                                    cO(this, Hz, c, "f"),
                                    cO(this, Vz, h, "f"),
                                    cO(this, Gz, u, "f"),
                                    t.loadTrackData(i),
                                    t.generateMeshes(),
                                    a.generateMountains(t.getBounds());
                                const p = t.getStartTransform();
                                if (null == p)
                                    throw new Error("Track has no starting point");
                                const f = new xp(d.reduce(( (e, t) => Math.max(e, t.time.numberOfFrames + hO(this, sO, "f"))), 0));
                                cO(this, Kz, f.time, "f"),
                                    cO(this, Qz, d.map(( (n, i) => {
                                            const r = new yw(null,p,n.recording,null,o,l,a,t,h);
                                            r.notificationAudioEnabled = hO(this, jz, "f") == i,
                                                r.setColors(n.carColors);
                                            const s = {
                                                replay: new tC,
                                                carId: null,
                                                car: r,
                                                settings: n
                                            }
                                                , c = e.createCar(p, a.getMountainVertices(), a.getMountainOffset(), t.getTrackData(), n.recording, (t => {
                                                    s.replay.push(t),
                                                    null != s.carId && t.frames >= f.numberOfFrames && (e.deleteCar(s.carId),
                                                        s.carId = null)
                                                }
                                            ));
                                            return s.replay.push(c),
                                                e.startCar(c.id, f.clone()),
                                                s.carId = c.id,
                                                s
                                        }
                                    )), "f"),
                                    h.getSettingBoolean(Jo.DefaultCameraMode) ? o.setCamera(hO(this, Qz, "f")[hO(this, jz, "f")].car.cameraCockpit) : o.setCamera(hO(this, Qz, "f")[hO(this, jz, "f")].car.cameraOrbit),
                                    cO(this, Xz, new LT(o,h), "f"),
                                    hO(this, Xz, "f").addToggleListener((e => {
                                            e ? o.setCamera(hO(this, Xz, "f").camera) : hO(this, Vz, "f").getSettingBoolean(Jo.DefaultCameraMode) ? hO(this, Fz, "f").setCamera(hO(this, Qz, "f")[hO(this, jz, "f")].car.cameraCockpit) : hO(this, Fz, "f").setCamera(hO(this, Qz, "f")[hO(this, jz, "f")].car.cameraOrbit)
                                        }
                                    )),
                                    hO(this, Rz, "m", oO).call(this, !0),
                                    window.addEventListener("keydown", cO(this, rO, (e => {
                                            if (hO(this, Xz, "f").isEnabled)
                                                "Escape" == e.code && (hO(this, Xz, "f").isEnabled = !1,
                                                    e.preventDefault());
                                            else if ("Escape" == e.code)
                                                u(n, i, r, hO(this, Qz, "f").map((e => e.settings))),
                                                    e.preventDefault();
                                            else if (h.checkKeyBinding(e, sx.VehicleCheckpointReset) || h.checkKeyBinding(e, sx.VehicleStartReset))
                                                e.repeat || cO(this, qz, 0, "f"),
                                                    e.preventDefault();
                                            else if (hO(this, Vz, "f").checkKeyBinding(e, sx.VehicleCockpitCamera)) {
                                                if (!e.repeat) {
                                                    const e = hO(this, Qz, "f")[hO(this, jz, "f")].car;
                                                    e.hasFinished() || (hO(this, Vz, "f").getSettingBoolean(Jo.CockpitCameraToggle) ? hO(this, Fz, "f").camera == e.cameraOrbit ? hO(this, Fz, "f").setCamera(e.cameraCockpit) : hO(this, Fz, "f").setCamera(e.cameraOrbit) : hO(this, Vz, "f").getSettingBoolean(Jo.DefaultCameraMode) ? hO(this, Fz, "f").setCamera(e.cameraOrbit) : hO(this, Fz, "f").setCamera(e.cameraCockpit))
                                                }
                                                e.preventDefault()
                                            }
                                            if (h.checkKeyBinding(e, sx.ToggleUI) && (cO(this, Zz, !hO(this, Zz, "f"), "f"),
                                                hO(this, Rz, "m", oO).call(this, hO(this, Zz, "f")),
                                                e.preventDefault()),
                                                h.checkKeyBinding(e, sx.ToggleSpectatorCamera)) {
                                                hO(this, Xz, "f").camera.position.copy(hO(this, Fz, "f").camera.position);
                                                const t = new ai(0,0,0,"YXZ").setFromQuaternion(hO(this, Fz, "f").camera.quaternion);
                                                t.z = 0,
                                                    hO(this, Xz, "f").camera.quaternion.setFromEuler(t),
                                                    hO(this, Xz, "f").toggle(),
                                                    e.preventDefault()
                                            }
                                            "Space" == e.code && (cO(this, Yz, !hO(this, Yz, "f"), "f"),
                                            null != hO(this, Jz, "f") && (hO(this, Jz, "f").isPaused = hO(this, Yz, "f")),
                                                e.preventDefault())
                                        }
                                    ), "f")),
                                    window.addEventListener("keyup", cO(this, aO, (e => {
                                            if (!hO(this, Xz, "f").isEnabled && hO(this, Vz, "f").checkKeyBinding(e, sx.VehicleCockpitCamera)) {
                                                const e = hO(this, Qz, "f")[hO(this, jz, "f")].car;
                                                e.hasFinished() || hO(this, Vz, "f").getSettingBoolean(Jo.CockpitCameraToggle) || (hO(this, Vz, "f").getSettingBoolean(Jo.DefaultCameraMode) ? hO(this, Fz, "f").setCamera(e.cameraCockpit) : hO(this, Fz, "f").setCamera(e.cameraOrbit))
                                            }
                                        }
                                    ), "f"))
                            }
                            dispose() {
                                var e;
                                hO(this, Nz, "f").clear(),
                                    hO(this, zz, "f").clearMountains();
                                for (const e of hO(this, Qz, "f"))
                                    null != e.carId && (hO(this, Lz, "f").deleteCar(e.carId),
                                        e.carId = null),
                                        e.car.dispose();
                                hO(this, Xz, "f").dispose(),
                                    hO(this, Rz, "m", oO).call(this, !1),
                                    window.removeEventListener("keydown", hO(this, rO, "f")),
                                    window.removeEventListener("keyup", hO(this, aO, "f")),
                                null === (e = hO(this, iO, "f")) || void 0 === e || e.dispose()
                            }
                            update(e) {
                                var t, n, i, r, a, s;
                                null != hO(this, Jz, "f") && cO(this, Yz, hO(this, Jz, "f").isPaused, "f");
                                let o = 1 / 0;
                                for (const e of hO(this, Qz, "f"))
                                    o = Math.min(o, e.replay.getLastFrame().numberOfFrames);
                                const l = new xp(o);
                                let c;
                                if (hO(this, Yz, "f") || (null === (t = hO(this, Jz, "f")) || void 0 === t ? void 0 : t.isDragging)) {
                                    c = 0;
                                    for (const e of hO(this, Qz, "f"))
                                        e.car.audioVolume = 0
                                } else {
                                    const t = Math.min(hO(this, Kz, "f"), hO(this, qz, "f") + e);
                                    if (l.time >= t) {
                                        cO(this, qz, t, "f"),
                                        hO(this, qz, "f") == hO(this, Kz, "f") && (null != hO(this, Jz, "f") && (hO(this, Jz, "f").isPaused = !0),
                                            cO(this, Yz, !0, "f")),
                                            c = e;
                                        for (const e of hO(this, Qz, "f"))
                                            e.car.audioVolume = 1
                                    } else {
                                        c = 0;
                                        for (const e of hO(this, Qz, "f"))
                                            e.car.audioVolume = 0
                                    }
                                }
                                const h = Math.round(1e3 * hO(this, qz, "f"))
                                    , d = Math.min(h, l.numberOfFrames);
                                if ((null === (n = hO(this, Jz, "f")) || void 0 === n ? void 0 : n.isDragging) || d < hO(this, Qz, "f")[hO(this, jz, "f")].car.getTime().numberOfFrames || d > hO(this, Qz, "f")[hO(this, jz, "f")].car.getTime().numberOfFrames + 1e3)
                                    hO(this, Rz, "m", lO).call(this, d);
                                else {
                                    for (let e = hO(this, Qz, "f")[hO(this, jz, "f")].car.getTime().numberOfFrames + 1; e <= d; e++)
                                        hO(this, Rz, "m", lO).call(this, e)
                                }
                                null != hO(this, Jz, "f") && (hO(this, Jz, "f").time = hO(this, Qz, "f")[hO(this, jz, "f")].car.getTime(),
                                    hO(this, Jz, "f").loadedTime = l),
                                null === (i = hO(this, eO, "f")) || void 0 === i || i.update(hO(this, Qz, "f")[hO(this, jz, "f")].car.getControls()),
                                null === (r = hO(this, tO, "f")) || void 0 === r || r.update(hO(this, Qz, "f")[hO(this, jz, "f")].car),
                                null === (a = hO(this, nO, "f")) || void 0 === a || a.update(hO(this, Qz, "f")[hO(this, jz, "f")].car);
                                for (const e of hO(this, Qz, "f"))
                                    e.car.update(c);
                                null === (s = hO(this, iO, "f")) || void 0 === s || s.updateCar(hO(this, Qz, "f")[hO(this, jz, "f")].car),
                                    hO(this, Xz, "f").update(e),
                                    hO(this, zz, "f").update(hO(this, Nz, "f")),
                                    hO(this, Oz, "f").update(c, hO(this, Fz, "f").camera, hO(this, Nz, "f").sunDirection),
                                    hO(this, Wz, "f").update(e, !1, hO(this, Fz, "f"), hO(this, Vz, "f")),
                                    hO(this, Fz, "f").update(hO(this, Qz, "f")[hO(this, jz, "f")].car.getPosition(), hO(this, Nz, "f").sunDirection)
                            }
                        }
                    ;
                    var uO, pO, fO = function(e, t, n, i) {
                        if ("a" === n && !i)
                            throw new TypeError("Private accessor was defined without a getter");
                        if ("function" == typeof t ? e !== t || !i : !t.has(e))
                            throw new TypeError("Cannot read private member from an object whose class did not declare it");
                        return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
                    }, mO = function(e, t, n, i, r) {
                        if ("m" === i)
                            throw new TypeError("Private method is not writable");
                        if ("a" === i && !r)
                            throw new TypeError("Private accessor was defined without a setter");
                        if ("function" == typeof t ? e !== t || !r : !t.has(e))
                            throw new TypeError("Cannot write private member to an object whose class did not declare it");
                        return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                            n
                    };
                    uO = new WeakMap,
                        pO = new WeakMap;
                    const gO = class {
                            constructor() {
                                uO.set(this, !1),
                                    pO.set(this, []),
                                    window.addEventListener("touchstart", ( () => {
                                            if (!fO(this, uO, "f")) {
                                                mO(this, uO, !0, "f");
                                                for (const e of fO(this, pO, "f"))
                                                    e(fO(this, uO, "f"))
                                            }
                                        }
                                    )),
                                    window.addEventListener("keydown", ( () => {
                                            if (fO(this, uO, "f")) {
                                                mO(this, uO, !1, "f");
                                                for (const e of fO(this, pO, "f"))
                                                    e(fO(this, uO, "f"))
                                            }
                                        }
                                    ))
                            }
                            get touchEnabled() {
                                return fO(this, uO, "f")
                            }
                            addChangeListener(e) {
                                fO(this, pO, "f").push(e),
                                    e(fO(this, uO, "f"))
                            }
                            removeChangeListener(e) {
                                const t = fO(this, pO, "f").indexOf(e);
                                t >= 0 && fO(this, pO, "f").splice(t, 1)
                            }
                        }
                    ;
                    /**
                     * @license
                     * Copyright 2025 Kodub.com
                     */
                    nn.enabled = !1,
                        function() {
                            const e = new IN;
                            e.addResource(),
                                bC().then(( () => {
                                        e.loadedResource()
                                    }
                                )).catch((e => {
                                        console.error(e)
                                    }
                                )),
                                e.addCompleteListener(( () => {
                                        MC()
                                    }
                                ));
                            const t = n(7780);
                            for (const n of t.keys())
                                e.preloadImage("images/" + n.substring(2));
                            const i = new yD
                                , r = new iB
                                , a = new dl(e);
                            a.load("music", ["audio/music.mp3", "audio/music.flac"]),
                                a.load("click", ["audio/click.flac"]),
                                a.load("engine", ["audio/engine.flac"]),
                                a.load("suspension", ["audio/suspension.flac"]),
                                a.load("tires", ["audio/tires.flac"]),
                                a.load("collision", ["audio/collision.flac"]),
                                a.load("skidding", ["audio/skidding.flac"]),
                                a.load("editor_edit", ["audio/editor_edit.flac"]),
                                a.load("checkpoint", ["audio/checkpoint.flac"]),
                                a.load("finish", ["audio/checkpoint.flac"]),
                                $u.initResources(e);
                            const s = yw.initResources();
                            _b.initResources(e);
                            const o = new pD
                                , l = o.init(e)
                                , c = new QD;
                            c.migrate();
                            const h = new TB(!0,o,e)
                                , d = new TB(!1,o,e)
                                , u = h.testDeterminism();
                            e.addResource(),
                                e.addResource(),
                                e.addResource(),
                                s.then((t => {
                                        e.loadedResource(),
                                            l.then((n => {
                                                    e.loadedResource(),
                                                        u.then((i => {
                                                                e.loadedResource(),
                                                                    g.determinismState = i ? n && t ? gP.Ok : gP.AssetsFailed : gP.TestFailed
                                                            }
                                                        )).catch((e => {
                                                                console.error(e)
                                                            }
                                                        ))
                                                }
                                            )).catch((e => {
                                                    console.error(e)
                                                }
                                            ))
                                    }
                                )).catch((e => {
                                        console.error(e)
                                    }
                                ));
                            const p = new mB(c)
                                , f = new GU(p.getSetting(Jo.Language))
                                , m = new HR(c)
                                , g = new oB;
                            m.syncUserProfile(g);
                            const v = new HN(c,g,m)
                                , w = document.getElementById("screen")
                                , A = new yu(w,p)
                                , y = new TD(A,p,e)
                                , b = new gI(A)
                                , x = new yb(A,p,o)
                                , k = new nD(e,c)
                                , E = new ty
                                , S = new kN(a)
                                , M = new gO
                                , T = t => {
                                    i.trigger(( () => {
                                            kC(),
                                                EC(),
                                                L.dispose(),
                                                L = new lN(h,x,b,y,k,f,S,m,v,A,a,c,p,g,e,t,C,_,I,R),
                                                SC()
                                        }
                                    ))
                                }
                                , C = () => {
                                    i.trigger(( () => {
                                            kC(),
                                                EC(),
                                                L.dispose(),
                                                L = new VA(f,x,b,y,A,a,m,p,g,S,( () => {
                                                        T(!1)
                                                    }
                                                )),
                                                SC()
                                        }
                                    ))
                                }
                                , _ = () => {
                                    i.trigger(( () => {
                                            EC(),
                                                L.dispose();
                                            const t = L = new pM(x,o,c,b,y,f,a,A,p,i,m,v,k,S,M,( () => {
                                                    kC(),
                                                        EC(),
                                                        L.dispose(),
                                                        L = new lN(h,x,b,y,k,f,S,m,v,A,a,c,p,g,e,!1,C,_,I,R),
                                                        SC()
                                                }
                                            ),( (e, n, i) => {
                                                    const s = L = new Y_(h,d,x,b,y,f,A,a,m,p,r,S,M,e,n,"custom",[],null,( () => {}
                                                    ),( () => {
                                                            xC(),
                                                                s.dispose(!1),
                                                                L = t,
                                                                i()
                                                        }
                                                    ),null)
                                                }
                                            ));
                                            return SC(),
                                                t.isPaused = !0,
                                                TC(( () => {
                                                        a.mute()
                                                    }
                                                ), "start-editor").finally(( () => {
                                                        xC(),
                                                            a.unmute(),
                                                            t.isPaused = !1
                                                    }
                                                ))
                                        }
                                    ))
                                }
                                , I = (e, t, n, s) => {
                                    i.trigger(( () => {
                                            EC(),
                                                L.dispose();
                                            const i = m.profileSlot
                                                , o = v.getRecordTime(i, t.getId())
                                                , l = L = new Y_(h,d,x,b,y,f,A,a,m,p,r,S,M,e,t,n,s,o,( (e, t, n) => {
                                                    if (null != e) {
                                                        const r = v.getRecordTime(i, e);
                                                        (null == r || n.lessThan(r)) && v.setRecord(i, e, n, t)
                                                    }
                                                }
                                            ),( () => {
                                                    T(!0)
                                                }
                                            ),P);
                                            return SC(),
                                                l.isPaused = !0,
                                                TC(( () => {
                                                        a.mute()
                                                    }
                                                ), "start-game").finally(( () => {
                                                        a.unmute(),
                                                            l.isPaused = !1
                                                    }
                                                ))
                                        }
                                    ))
                                }
                                , P = (e, t, n, r) => {
                                    i.trigger(( () => {
                                            EC(),
                                                L.dispose(),
                                                L = new dO(d,x,e,t,n,b,y,A,a,f,p,r,I),
                                                SC(),
                                                xC()
                                        }
                                    ))
                                }
                                , R = t => {
                                    i.trigger(( () => {
                                            EC(),
                                                L.dispose(),
                                                L = new bU(a,A,g,k,o,p,e,t,( () => {
                                                        T(!1)
                                                    }
                                                )),
                                                SC(),
                                                xC()
                                        }
                                    ))
                                }
                            ;
                            let L = new lN(h,x,b,y,k,f,S,m,v,A,a,c,p,g,e,!1,C,_,I,R)
                                , N = 0;
                            A.setAnimationLoop((function(e) {
                                    const t = Math.max(e - N, 0) / 1e3;
                                    N = e,
                                        L.update(t),
                                        E.update(t)
                                }
                            )),
                                window.addEventListener("keyup", (e => {
                                        p.checkKeyBinding(e, sx.ToggleFpsCounter) && E.toggle()
                                    }
                                ))
                        }()
                }
            )()
    }
)();
